"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// ../../node_modules/is-buffer/index.js
var require_is_buffer = __commonJS({
  "../../node_modules/is-buffer/index.js"(exports, module2) {
    module2.exports = function isBuffer2(obj) {
      return obj != null && obj.constructor != null && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
    };
  }
});

// ../../node_modules/extend/index.js
var require_extend = __commonJS({
  "../../node_modules/extend/index.js"(exports, module2) {
    "use strict";
    var hasOwn = Object.prototype.hasOwnProperty;
    var toStr = Object.prototype.toString;
    var defineProperty = Object.defineProperty;
    var gOPD = Object.getOwnPropertyDescriptor;
    var isArray = function isArray2(arr) {
      if (typeof Array.isArray === "function") {
        return Array.isArray(arr);
      }
      return toStr.call(arr) === "[object Array]";
    };
    var isPlainObject2 = function isPlainObject3(obj) {
      if (!obj || toStr.call(obj) !== "[object Object]") {
        return false;
      }
      var hasOwnConstructor = hasOwn.call(obj, "constructor");
      var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, "isPrototypeOf");
      if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
        return false;
      }
      var key;
      for (key in obj) {
      }
      return typeof key === "undefined" || hasOwn.call(obj, key);
    };
    var setProperty = function setProperty2(target, options) {
      if (defineProperty && options.name === "__proto__") {
        defineProperty(target, options.name, {
          enumerable: true,
          configurable: true,
          value: options.newValue,
          writable: true
        });
      } else {
        target[options.name] = options.newValue;
      }
    };
    var getProperty = function getProperty2(obj, name) {
      if (name === "__proto__") {
        if (!hasOwn.call(obj, name)) {
          return void 0;
        } else if (gOPD) {
          return gOPD(obj, name).value;
        }
      }
      return obj[name];
    };
    module2.exports = function extend2() {
      var options, name, src, copy, copyIsArray, clone2;
      var target = arguments[0];
      var i = 1;
      var length = arguments.length;
      var deep = false;
      if (typeof target === "boolean") {
        deep = target;
        target = arguments[1] || {};
        i = 2;
      }
      if (target == null || typeof target !== "object" && typeof target !== "function") {
        target = {};
      }
      for (; i < length; ++i) {
        options = arguments[i];
        if (options != null) {
          for (name in options) {
            src = getProperty(target, name);
            copy = getProperty(options, name);
            if (target !== copy) {
              if (deep && copy && (isPlainObject2(copy) || (copyIsArray = isArray(copy)))) {
                if (copyIsArray) {
                  copyIsArray = false;
                  clone2 = src && isArray(src) ? src : [];
                } else {
                  clone2 = src && isPlainObject2(src) ? src : {};
                }
                setProperty(target, { name, newValue: extend2(deep, clone2, copy) });
              } else if (typeof copy !== "undefined") {
                setProperty(target, { name, newValue: copy });
              }
            }
          }
        }
      }
      return target;
    };
  }
});

// index.ts
var unified_latex_util_parse_exports = {};
__export(unified_latex_util_parse_exports, {
  getParser: () => getParser,
  parse: () => parse5,
  parseMath: () => parseMath,
  parseMathMinimal: () => parseMathMinimal,
  parseMinimal: () => parseMinimal,
  unifiedLatexAstComplier: () => unifiedLatexAstComplier,
  unifiedLatexFromString: () => unifiedLatexFromString,
  unifiedLatexFromStringMinimal: () => unifiedLatexFromStringMinimal
});
module.exports = __toCommonJS(unified_latex_util_parse_exports);

// libs/compiler-ast.ts
var unifiedLatexAstComplier = function unifiedLatexAstComplier2() {
  Object.assign(this, { Compiler: (x) => x });
};

// ../../node_modules/bail/index.js
function bail(error) {
  if (error) {
    throw error;
  }
}

// ../../node_modules/unified/lib/index.js
var import_is_buffer2 = __toESM(require_is_buffer(), 1);
var import_extend = __toESM(require_extend(), 1);

// ../../node_modules/unified/node_modules/is-plain-obj/index.js
function isPlainObject(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
}

// ../../node_modules/trough/index.js
function trough() {
  const fns = [];
  const pipeline = { run, use };
  return pipeline;
  function run(...values) {
    let middlewareIndex = -1;
    const callback = values.pop();
    if (typeof callback !== "function") {
      throw new TypeError("Expected function as last argument, not " + callback);
    }
    next(null, ...values);
    function next(error, ...output) {
      const fn = fns[++middlewareIndex];
      let index2 = -1;
      if (error) {
        callback(error);
        return;
      }
      while (++index2 < values.length) {
        if (output[index2] === null || output[index2] === void 0) {
          output[index2] = values[index2];
        }
      }
      values = output;
      if (fn) {
        wrap(fn, next)(...output);
      } else {
        callback(null, ...output);
      }
    }
  }
  function use(middelware) {
    if (typeof middelware !== "function") {
      throw new TypeError(
        "Expected `middelware` to be a function, not " + middelware
      );
    }
    fns.push(middelware);
    return pipeline;
  }
}
function wrap(middleware, callback) {
  let called;
  return wrapped;
  function wrapped(...parameters) {
    const fnExpectsCallback = middleware.length > parameters.length;
    let result;
    if (fnExpectsCallback) {
      parameters.push(done);
    }
    try {
      result = middleware.apply(this, parameters);
    } catch (error) {
      const exception = (
        /** @type {Error} */
        error
      );
      if (fnExpectsCallback && called) {
        throw exception;
      }
      return done(exception);
    }
    if (!fnExpectsCallback) {
      if (result instanceof Promise) {
        result.then(then, done);
      } else if (result instanceof Error) {
        done(result);
      } else {
        then(result);
      }
    }
  }
  function done(error, ...output) {
    if (!called) {
      called = true;
      callback(error, ...output);
    }
  }
  function then(value) {
    done(null, value);
  }
}

// ../../node_modules/vfile/lib/index.js
var import_is_buffer = __toESM(require_is_buffer(), 1);

// ../../node_modules/unist-util-stringify-position/lib/index.js
function stringifyPosition(value) {
  if (!value || typeof value !== "object") {
    return "";
  }
  if ("position" in value || "type" in value) {
    return position(value.position);
  }
  if ("start" in value || "end" in value) {
    return position(value);
  }
  if ("line" in value || "column" in value) {
    return point(value);
  }
  return "";
}
function point(point2) {
  return index(point2 && point2.line) + ":" + index(point2 && point2.column);
}
function position(pos) {
  return point(pos && pos.start) + "-" + point(pos && pos.end);
}
function index(value) {
  return value && typeof value === "number" ? value : 1;
}

// ../../node_modules/vfile-message/index.js
var VFileMessage = class extends Error {
  /**
   * Create a message for `reason` at `place` from `origin`.
   *
   * When an error is passed in as `reason`, the `stack` is copied.
   *
   * @param {string|Error|VFileMessage} reason
   *   Reason for message.
   *   Uses the stack and message of the error if given.
   * @param {Node|NodeLike|Position|Point} [place]
   *   Place at which the message occurred in a file.
   * @param {string} [origin]
   *   Place in code the message originates from (example `'my-package:my-rule-name'`)
   */
  constructor(reason, place, origin) {
    const parts = [null, null];
    let position2 = {
      // @ts-expect-error: we always follows the structure of `position`.
      start: { line: null, column: null },
      // @ts-expect-error: "
      end: { line: null, column: null }
    };
    super();
    if (typeof place === "string") {
      origin = place;
      place = void 0;
    }
    if (typeof origin === "string") {
      const index2 = origin.indexOf(":");
      if (index2 === -1) {
        parts[1] = origin;
      } else {
        parts[0] = origin.slice(0, index2);
        parts[1] = origin.slice(index2 + 1);
      }
    }
    if (place) {
      if ("type" in place || "position" in place) {
        if (place.position) {
          position2 = place.position;
        }
      } else if ("start" in place || "end" in place) {
        position2 = place;
      } else if ("line" in place || "column" in place) {
        position2.start = place;
      }
    }
    this.name = stringifyPosition(place) || "1:1";
    this.message = typeof reason === "object" ? reason.message : reason;
    this.stack = "";
    if (typeof reason === "object" && reason.stack) {
      this.stack = reason.stack;
    }
    this.reason = this.message;
    this.fatal;
    this.line = position2.start.line;
    this.column = position2.start.column;
    this.position = position2;
    this.source = parts[0];
    this.ruleId = parts[1];
    this.file;
    this.actual;
    this.expected;
    this.url;
    this.note;
  }
};
VFileMessage.prototype.file = "";
VFileMessage.prototype.name = "";
VFileMessage.prototype.reason = "";
VFileMessage.prototype.message = "";
VFileMessage.prototype.stack = "";
VFileMessage.prototype.fatal = null;
VFileMessage.prototype.column = null;
VFileMessage.prototype.line = null;
VFileMessage.prototype.source = null;
VFileMessage.prototype.ruleId = null;
VFileMessage.prototype.position = null;

// ../../node_modules/vfile/lib/minpath.browser.js
var path = { basename, dirname, extname, join, sep: "/" };
function basename(path2, ext) {
  if (ext !== void 0 && typeof ext !== "string") {
    throw new TypeError('"ext" argument must be a string');
  }
  assertPath(path2);
  let start = 0;
  let end = -1;
  let index2 = path2.length;
  let seenNonSlash;
  if (ext === void 0 || ext.length === 0 || ext.length > path2.length) {
    while (index2--) {
      if (path2.charCodeAt(index2) === 47) {
        if (seenNonSlash) {
          start = index2 + 1;
          break;
        }
      } else if (end < 0) {
        seenNonSlash = true;
        end = index2 + 1;
      }
    }
    return end < 0 ? "" : path2.slice(start, end);
  }
  if (ext === path2) {
    return "";
  }
  let firstNonSlashEnd = -1;
  let extIndex = ext.length - 1;
  while (index2--) {
    if (path2.charCodeAt(index2) === 47) {
      if (seenNonSlash) {
        start = index2 + 1;
        break;
      }
    } else {
      if (firstNonSlashEnd < 0) {
        seenNonSlash = true;
        firstNonSlashEnd = index2 + 1;
      }
      if (extIndex > -1) {
        if (path2.charCodeAt(index2) === ext.charCodeAt(extIndex--)) {
          if (extIndex < 0) {
            end = index2;
          }
        } else {
          extIndex = -1;
          end = firstNonSlashEnd;
        }
      }
    }
  }
  if (start === end) {
    end = firstNonSlashEnd;
  } else if (end < 0) {
    end = path2.length;
  }
  return path2.slice(start, end);
}
function dirname(path2) {
  assertPath(path2);
  if (path2.length === 0) {
    return ".";
  }
  let end = -1;
  let index2 = path2.length;
  let unmatchedSlash;
  while (--index2) {
    if (path2.charCodeAt(index2) === 47) {
      if (unmatchedSlash) {
        end = index2;
        break;
      }
    } else if (!unmatchedSlash) {
      unmatchedSlash = true;
    }
  }
  return end < 0 ? path2.charCodeAt(0) === 47 ? "/" : "." : end === 1 && path2.charCodeAt(0) === 47 ? "//" : path2.slice(0, end);
}
function extname(path2) {
  assertPath(path2);
  let index2 = path2.length;
  let end = -1;
  let startPart = 0;
  let startDot = -1;
  let preDotState = 0;
  let unmatchedSlash;
  while (index2--) {
    const code = path2.charCodeAt(index2);
    if (code === 47) {
      if (unmatchedSlash) {
        startPart = index2 + 1;
        break;
      }
      continue;
    }
    if (end < 0) {
      unmatchedSlash = true;
      end = index2 + 1;
    }
    if (code === 46) {
      if (startDot < 0) {
        startDot = index2;
      } else if (preDotState !== 1) {
        preDotState = 1;
      }
    } else if (startDot > -1) {
      preDotState = -1;
    }
  }
  if (startDot < 0 || end < 0 || // We saw a non-dot character immediately before the dot.
  preDotState === 0 || // The (right-most) trimmed path component is exactly `..`.
  preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return "";
  }
  return path2.slice(startDot, end);
}
function join(...segments) {
  let index2 = -1;
  let joined;
  while (++index2 < segments.length) {
    assertPath(segments[index2]);
    if (segments[index2]) {
      joined = joined === void 0 ? segments[index2] : joined + "/" + segments[index2];
    }
  }
  return joined === void 0 ? "." : normalize(joined);
}
function normalize(path2) {
  assertPath(path2);
  const absolute = path2.charCodeAt(0) === 47;
  let value = normalizeString(path2, !absolute);
  if (value.length === 0 && !absolute) {
    value = ".";
  }
  if (value.length > 0 && path2.charCodeAt(path2.length - 1) === 47) {
    value += "/";
  }
  return absolute ? "/" + value : value;
}
function normalizeString(path2, allowAboveRoot) {
  let result = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let index2 = -1;
  let code;
  let lastSlashIndex;
  while (++index2 <= path2.length) {
    if (index2 < path2.length) {
      code = path2.charCodeAt(index2);
    } else if (code === 47) {
      break;
    } else {
      code = 47;
    }
    if (code === 47) {
      if (lastSlash === index2 - 1 || dots === 1) {
      } else if (lastSlash !== index2 - 1 && dots === 2) {
        if (result.length < 2 || lastSegmentLength !== 2 || result.charCodeAt(result.length - 1) !== 46 || result.charCodeAt(result.length - 2) !== 46) {
          if (result.length > 2) {
            lastSlashIndex = result.lastIndexOf("/");
            if (lastSlashIndex !== result.length - 1) {
              if (lastSlashIndex < 0) {
                result = "";
                lastSegmentLength = 0;
              } else {
                result = result.slice(0, lastSlashIndex);
                lastSegmentLength = result.length - 1 - result.lastIndexOf("/");
              }
              lastSlash = index2;
              dots = 0;
              continue;
            }
          } else if (result.length > 0) {
            result = "";
            lastSegmentLength = 0;
            lastSlash = index2;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          result = result.length > 0 ? result + "/.." : "..";
          lastSegmentLength = 2;
        }
      } else {
        if (result.length > 0) {
          result += "/" + path2.slice(lastSlash + 1, index2);
        } else {
          result = path2.slice(lastSlash + 1, index2);
        }
        lastSegmentLength = index2 - lastSlash - 1;
      }
      lastSlash = index2;
      dots = 0;
    } else if (code === 46 && dots > -1) {
      dots++;
    } else {
      dots = -1;
    }
  }
  return result;
}
function assertPath(path2) {
  if (typeof path2 !== "string") {
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(path2)
    );
  }
}

// ../../node_modules/vfile/lib/minproc.browser.js
var proc = { cwd };
function cwd() {
  return "/";
}

// ../../node_modules/vfile/lib/minurl.shared.js
function isUrl(fileURLOrPath) {
  return fileURLOrPath !== null && typeof fileURLOrPath === "object" && // @ts-expect-error: indexable.
  fileURLOrPath.href && // @ts-expect-error: indexable.
  fileURLOrPath.origin;
}

// ../../node_modules/vfile/lib/minurl.browser.js
function urlToPath(path2) {
  if (typeof path2 === "string") {
    path2 = new URL(path2);
  } else if (!isUrl(path2)) {
    const error = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + path2 + "`"
    );
    error.code = "ERR_INVALID_ARG_TYPE";
    throw error;
  }
  if (path2.protocol !== "file:") {
    const error = new TypeError("The URL must be of scheme file");
    error.code = "ERR_INVALID_URL_SCHEME";
    throw error;
  }
  return getPathFromURLPosix(path2);
}
function getPathFromURLPosix(url) {
  if (url.hostname !== "") {
    const error = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    error.code = "ERR_INVALID_FILE_URL_HOST";
    throw error;
  }
  const pathname = url.pathname;
  let index2 = -1;
  while (++index2 < pathname.length) {
    if (pathname.charCodeAt(index2) === 37 && pathname.charCodeAt(index2 + 1) === 50) {
      const third = pathname.charCodeAt(index2 + 2);
      if (third === 70 || third === 102) {
        const error = new TypeError(
          "File URL path must not include encoded / characters"
        );
        error.code = "ERR_INVALID_FILE_URL_PATH";
        throw error;
      }
    }
  }
  return decodeURIComponent(pathname);
}

// ../../node_modules/vfile/lib/index.js
var order = ["history", "path", "basename", "stem", "extname", "dirname"];
var VFile = class {
  /**
   * Create a new virtual file.
   *
   * If `options` is `string` or `Buffer`, it’s treated as `{value: options}`.
   * If `options` is a `URL`, it’s treated as `{path: options}`.
   * If `options` is a `VFile`, shallow copies its data over to the new file.
   * All fields in `options` are set on the newly created `VFile`.
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * It’s not possible to set either `dirname` or `extname` without setting
   * either `history`, `path`, `basename`, or `stem` as well.
   *
   * @param {Compatible} [value]
   */
  constructor(value) {
    let options;
    if (!value) {
      options = {};
    } else if (typeof value === "string" || (0, import_is_buffer.default)(value)) {
      options = { value };
    } else if (isUrl(value)) {
      options = { path: value };
    } else {
      options = value;
    }
    this.data = {};
    this.messages = [];
    this.history = [];
    this.cwd = proc.cwd();
    this.value;
    this.stored;
    this.result;
    this.map;
    let index2 = -1;
    while (++index2 < order.length) {
      const prop2 = order[index2];
      if (prop2 in options && options[prop2] !== void 0) {
        this[prop2] = prop2 === "history" ? [...options[prop2]] : options[prop2];
      }
    }
    let prop;
    for (prop in options) {
      if (!order.includes(prop))
        this[prop] = options[prop];
    }
  }
  /**
   * Get the full path (example: `'~/index.min.js'`).
   * @returns {string}
   */
  get path() {
    return this.history[this.history.length - 1];
  }
  /**
   * Set the full path (example: `'~/index.min.js'`).
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   * @param {string|URL} path
   */
  set path(path2) {
    if (isUrl(path2)) {
      path2 = urlToPath(path2);
    }
    assertNonEmpty(path2, "path");
    if (this.path !== path2) {
      this.history.push(path2);
    }
  }
  /**
   * Get the parent path (example: `'~'`).
   */
  get dirname() {
    return typeof this.path === "string" ? path.dirname(this.path) : void 0;
  }
  /**
   * Set the parent path (example: `'~'`).
   * Cannot be set if there’s no `path` yet.
   */
  set dirname(dirname2) {
    assertPath2(this.basename, "dirname");
    this.path = path.join(dirname2 || "", this.basename);
  }
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   */
  get basename() {
    return typeof this.path === "string" ? path.basename(this.path) : void 0;
  }
  /**
   * Set basename (including extname) (`'index.min.js'`).
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   */
  set basename(basename2) {
    assertNonEmpty(basename2, "basename");
    assertPart(basename2, "basename");
    this.path = path.join(this.dirname || "", basename2);
  }
  /**
   * Get the extname (including dot) (example: `'.js'`).
   */
  get extname() {
    return typeof this.path === "string" ? path.extname(this.path) : void 0;
  }
  /**
   * Set the extname (including dot) (example: `'.js'`).
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if there’s no `path` yet.
   */
  set extname(extname2) {
    assertPart(extname2, "extname");
    assertPath2(this.dirname, "extname");
    if (extname2) {
      if (extname2.charCodeAt(0) !== 46) {
        throw new Error("`extname` must start with `.`");
      }
      if (extname2.includes(".", 1)) {
        throw new Error("`extname` cannot contain multiple dots");
      }
    }
    this.path = path.join(this.dirname, this.stem + (extname2 || ""));
  }
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   */
  get stem() {
    return typeof this.path === "string" ? path.basename(this.path, this.extname) : void 0;
  }
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   */
  set stem(stem) {
    assertNonEmpty(stem, "stem");
    assertPart(stem, "stem");
    this.path = path.join(this.dirname || "", stem + (this.extname || ""));
  }
  /**
   * Serialize the file.
   *
   * @param {BufferEncoding} [encoding='utf8']
   *   When `value` is a `Buffer`, `encoding` is a character encoding to
   *   understand it as (default: `'utf8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(encoding) {
    return (this.value || "").toString(encoding);
  }
  /**
   * Constructs a new `VFileMessage`, where `fatal` is set to `false`, and
   * associates it with the file by adding it to `vfile.messages` and setting
   * `message.file` to the current filepath.
   *
   * @param {string|Error|VFileMessage} reason
   *   Human readable reason for the message, uses the stack and message of the error if given.
   * @param {Node|NodeLike|Position|Point} [place]
   *   Place where the message occurred in the file.
   * @param {string} [origin]
   *   Computer readable reason for the message
   * @returns {VFileMessage}
   *   Message.
   */
  message(reason, place, origin) {
    const message = new VFileMessage(reason, place, origin);
    if (this.path) {
      message.name = this.path + ":" + message.name;
      message.file = this.path;
    }
    message.fatal = false;
    this.messages.push(message);
    return message;
  }
  /**
   * Like `VFile#message()`, but associates an informational message where
   * `fatal` is set to `null`.
   *
   * @param {string|Error|VFileMessage} reason
   *   Human readable reason for the message, uses the stack and message of the error if given.
   * @param {Node|NodeLike|Position|Point} [place]
   *   Place where the message occurred in the file.
   * @param {string} [origin]
   *   Computer readable reason for the message
   * @returns {VFileMessage}
   *   Message.
   */
  info(reason, place, origin) {
    const message = this.message(reason, place, origin);
    message.fatal = null;
    return message;
  }
  /**
   * Like `VFile#message()`, but associates a fatal message where `fatal` is
   * set to `true`, and then immediately throws it.
   *
   * > 👉 **Note**: a fatal error means that a file is no longer processable.
   *
   * @param {string|Error|VFileMessage} reason
   *   Human readable reason for the message, uses the stack and message of the error if given.
   * @param {Node|NodeLike|Position|Point} [place]
   *   Place where the message occurred in the file.
   * @param {string} [origin]
   *   Computer readable reason for the message
   * @returns {never}
   *   Message.
   */
  fail(reason, place, origin) {
    const message = this.message(reason, place, origin);
    message.fatal = true;
    throw message;
  }
};
function assertPart(part, name) {
  if (part && part.includes(path.sep)) {
    throw new Error(
      "`" + name + "` cannot be a path: did not expect `" + path.sep + "`"
    );
  }
}
function assertNonEmpty(part, name) {
  if (!part) {
    throw new Error("`" + name + "` cannot be empty");
  }
}
function assertPath2(path2, name) {
  if (!path2) {
    throw new Error("Setting `" + name + "` requires `path` to be set too");
  }
}

// ../../node_modules/unified/lib/index.js
var unified = base().freeze();
var own = {}.hasOwnProperty;
function base() {
  const transformers = trough();
  const attachers = [];
  let namespace = {};
  let frozen;
  let freezeIndex = -1;
  processor.data = data;
  processor.Parser = void 0;
  processor.Compiler = void 0;
  processor.freeze = freeze;
  processor.attachers = attachers;
  processor.use = use;
  processor.parse = parse6;
  processor.stringify = stringify;
  processor.run = run;
  processor.runSync = runSync;
  processor.process = process;
  processor.processSync = processSync;
  return processor;
  function processor() {
    const destination = base();
    let index2 = -1;
    while (++index2 < attachers.length) {
      destination.use(...attachers[index2]);
    }
    destination.data((0, import_extend.default)(true, {}, namespace));
    return destination;
  }
  function data(key, value) {
    if (typeof key === "string") {
      if (arguments.length === 2) {
        assertUnfrozen("data", frozen);
        namespace[key] = value;
        return processor;
      }
      return own.call(namespace, key) && namespace[key] || null;
    }
    if (key) {
      assertUnfrozen("data", frozen);
      namespace = key;
      return processor;
    }
    return namespace;
  }
  function freeze() {
    if (frozen) {
      return processor;
    }
    while (++freezeIndex < attachers.length) {
      const [attacher, ...options] = attachers[freezeIndex];
      if (options[0] === false) {
        continue;
      }
      if (options[0] === true) {
        options[0] = void 0;
      }
      const transformer = attacher.call(processor, ...options);
      if (typeof transformer === "function") {
        transformers.use(transformer);
      }
    }
    frozen = true;
    freezeIndex = Number.POSITIVE_INFINITY;
    return processor;
  }
  function use(value, ...options) {
    let settings;
    assertUnfrozen("use", frozen);
    if (value === null || value === void 0) {
    } else if (typeof value === "function") {
      addPlugin(value, ...options);
    } else if (typeof value === "object") {
      if (Array.isArray(value)) {
        addList(value);
      } else {
        addPreset(value);
      }
    } else {
      throw new TypeError("Expected usable value, not `" + value + "`");
    }
    if (settings) {
      namespace.settings = Object.assign(namespace.settings || {}, settings);
    }
    return processor;
    function add(value2) {
      if (typeof value2 === "function") {
        addPlugin(value2);
      } else if (typeof value2 === "object") {
        if (Array.isArray(value2)) {
          const [plugin, ...options2] = value2;
          addPlugin(plugin, ...options2);
        } else {
          addPreset(value2);
        }
      } else {
        throw new TypeError("Expected usable value, not `" + value2 + "`");
      }
    }
    function addPreset(result) {
      addList(result.plugins);
      if (result.settings) {
        settings = Object.assign(settings || {}, result.settings);
      }
    }
    function addList(plugins) {
      let index2 = -1;
      if (plugins === null || plugins === void 0) {
      } else if (Array.isArray(plugins)) {
        while (++index2 < plugins.length) {
          const thing = plugins[index2];
          add(thing);
        }
      } else {
        throw new TypeError("Expected a list of plugins, not `" + plugins + "`");
      }
    }
    function addPlugin(plugin, value2) {
      let index2 = -1;
      let entry;
      while (++index2 < attachers.length) {
        if (attachers[index2][0] === plugin) {
          entry = attachers[index2];
          break;
        }
      }
      if (entry) {
        if (isPlainObject(entry[1]) && isPlainObject(value2)) {
          value2 = (0, import_extend.default)(true, entry[1], value2);
        }
        entry[1] = value2;
      } else {
        attachers.push([...arguments]);
      }
    }
  }
  function parse6(doc) {
    processor.freeze();
    const file = vfile(doc);
    const Parser2 = processor.Parser;
    assertParser("parse", Parser2);
    if (newable(Parser2, "parse")) {
      return new Parser2(String(file), file).parse();
    }
    return Parser2(String(file), file);
  }
  function stringify(node, doc) {
    processor.freeze();
    const file = vfile(doc);
    const Compiler = processor.Compiler;
    assertCompiler("stringify", Compiler);
    assertNode(node);
    if (newable(Compiler, "compile")) {
      return new Compiler(node, file).compile();
    }
    return Compiler(node, file);
  }
  function run(node, doc, callback) {
    assertNode(node);
    processor.freeze();
    if (!callback && typeof doc === "function") {
      callback = doc;
      doc = void 0;
    }
    if (!callback) {
      return new Promise(executor);
    }
    executor(null, callback);
    function executor(resolve, reject) {
      transformers.run(node, vfile(doc), done);
      function done(error, tree, file) {
        tree = tree || node;
        if (error) {
          reject(error);
        } else if (resolve) {
          resolve(tree);
        } else {
          callback(null, tree, file);
        }
      }
    }
  }
  function runSync(node, file) {
    let result;
    let complete;
    processor.run(node, file, done);
    assertDone("runSync", "run", complete);
    return result;
    function done(error, tree) {
      bail(error);
      result = tree;
      complete = true;
    }
  }
  function process(doc, callback) {
    processor.freeze();
    assertParser("process", processor.Parser);
    assertCompiler("process", processor.Compiler);
    if (!callback) {
      return new Promise(executor);
    }
    executor(null, callback);
    function executor(resolve, reject) {
      const file = vfile(doc);
      processor.run(processor.parse(file), file, (error, tree, file2) => {
        if (error || !tree || !file2) {
          done(error);
        } else {
          const result = processor.stringify(tree, file2);
          if (result === void 0 || result === null) {
          } else if (looksLikeAVFileValue(result)) {
            file2.value = result;
          } else {
            file2.result = result;
          }
          done(error, file2);
        }
      });
      function done(error, file2) {
        if (error || !file2) {
          reject(error);
        } else if (resolve) {
          resolve(file2);
        } else {
          callback(null, file2);
        }
      }
    }
  }
  function processSync(doc) {
    let complete;
    processor.freeze();
    assertParser("processSync", processor.Parser);
    assertCompiler("processSync", processor.Compiler);
    const file = vfile(doc);
    processor.process(file, done);
    assertDone("processSync", "process", complete);
    return file;
    function done(error) {
      complete = true;
      bail(error);
    }
  }
}
function newable(value, name) {
  return typeof value === "function" && // Prototypes do exist.
  // type-coverage:ignore-next-line
  value.prototype && // A function with keys in its prototype is probably a constructor.
  // Classes’ prototype methods are not enumerable, so we check if some value
  // exists in the prototype.
  // type-coverage:ignore-next-line
  (keys(value.prototype) || name in value.prototype);
}
function keys(value) {
  let key;
  for (key in value) {
    if (own.call(value, key)) {
      return true;
    }
  }
  return false;
}
function assertParser(name, value) {
  if (typeof value !== "function") {
    throw new TypeError("Cannot `" + name + "` without `Parser`");
  }
}
function assertCompiler(name, value) {
  if (typeof value !== "function") {
    throw new TypeError("Cannot `" + name + "` without `Compiler`");
  }
}
function assertUnfrozen(name, frozen) {
  if (frozen) {
    throw new Error(
      "Cannot call `" + name + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
  }
}
function assertNode(node) {
  if (!isPlainObject(node) || typeof node.type !== "string") {
    throw new TypeError("Expected node, got `" + node + "`");
  }
}
function assertDone(name, asyncName, complete) {
  if (!complete) {
    throw new Error(
      "`" + name + "` finished async. Use `" + asyncName + "` instead"
    );
  }
}
function vfile(value) {
  return looksLikeAVFile(value) ? value : new VFile(value);
}
function looksLikeAVFile(value) {
  return Boolean(
    value && typeof value === "object" && "message" in value && "messages" in value
  );
}
function looksLikeAVFileValue(value) {
  return typeof value === "string" || (0, import_is_buffer2.default)(value);
}

// ../unified-latex-ctan/dist/index.js
var __create2 = Object.create;
var __defProp2 = Object.defineProperty;
var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames2 = Object.getOwnPropertyNames;
var __getProtoOf2 = Object.getPrototypeOf;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __commonJS2 = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames2(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps2 = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames2(from))
      if (!__hasOwnProp2.call(to, key) && key !== except)
        __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps2(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var require_color_name = __commonJS2({
  "../../node_modules/color-name/index.js"(exports, module2) {
    "use strict";
    module2.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});
var require_is_arrayish = __commonJS2({
  "../../node_modules/simple-swizzle/node_modules/is-arrayish/index.js"(exports, module2) {
    module2.exports = function isArrayish(obj) {
      if (!obj || typeof obj === "string") {
        return false;
      }
      return obj instanceof Array || Array.isArray(obj) || obj.length >= 0 && (obj.splice instanceof Function || Object.getOwnPropertyDescriptor(obj, obj.length - 1) && obj.constructor.name !== "String");
    };
  }
});
var require_simple_swizzle = __commonJS2({
  "../../node_modules/simple-swizzle/index.js"(exports, module2) {
    "use strict";
    var isArrayish = require_is_arrayish();
    var concat = Array.prototype.concat;
    var slice = Array.prototype.slice;
    var swizzle = module2.exports = function swizzle2(args) {
      var results = [];
      for (var i = 0, len = args.length; i < len; i++) {
        var arg32 = args[i];
        if (isArrayish(arg32)) {
          results = concat.call(results, slice.call(arg32));
        } else {
          results.push(arg32);
        }
      }
      return results;
    };
    swizzle.wrap = function(fn) {
      return function() {
        return fn(swizzle(arguments));
      };
    };
  }
});
var require_color_string = __commonJS2({
  "../../node_modules/color-string/index.js"(exports, module2) {
    var colorNames = require_color_name();
    var swizzle = require_simple_swizzle();
    var hasOwnProperty = Object.hasOwnProperty;
    var reverseNames = /* @__PURE__ */ Object.create(null);
    for (name in colorNames) {
      if (hasOwnProperty.call(colorNames, name)) {
        reverseNames[colorNames[name]] = name;
      }
    }
    var name;
    var cs = module2.exports = {
      to: {},
      get: {}
    };
    cs.get = function(string132) {
      var prefix = string132.substring(0, 3).toLowerCase();
      var val;
      var model;
      switch (prefix) {
        case "hsl":
          val = cs.get.hsl(string132);
          model = "hsl";
          break;
        case "hwb":
          val = cs.get.hwb(string132);
          model = "hwb";
          break;
        default:
          val = cs.get.rgb(string132);
          model = "rgb";
          break;
      }
      if (!val) {
        return null;
      }
      return { model, value: val };
    };
    cs.get.rgb = function(string132) {
      if (!string132) {
        return null;
      }
      var abbr = /^#([a-f0-9]{3,4})$/i;
      var hex = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
      var rgba = /^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
      var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
      var keyword = /^(\w+)$/;
      var rgb = [0, 0, 0, 1];
      var match132;
      var i;
      var hexAlpha;
      if (match132 = string132.match(hex)) {
        hexAlpha = match132[2];
        match132 = match132[1];
        for (i = 0; i < 3; i++) {
          var i2 = i * 2;
          rgb[i] = parseInt(match132.slice(i2, i2 + 2), 16);
        }
        if (hexAlpha) {
          rgb[3] = parseInt(hexAlpha, 16) / 255;
        }
      } else if (match132 = string132.match(abbr)) {
        match132 = match132[1];
        hexAlpha = match132[3];
        for (i = 0; i < 3; i++) {
          rgb[i] = parseInt(match132[i] + match132[i], 16);
        }
        if (hexAlpha) {
          rgb[3] = parseInt(hexAlpha + hexAlpha, 16) / 255;
        }
      } else if (match132 = string132.match(rgba)) {
        for (i = 0; i < 3; i++) {
          rgb[i] = parseInt(match132[i + 1], 0);
        }
        if (match132[4]) {
          if (match132[5]) {
            rgb[3] = parseFloat(match132[4]) * 0.01;
          } else {
            rgb[3] = parseFloat(match132[4]);
          }
        }
      } else if (match132 = string132.match(per)) {
        for (i = 0; i < 3; i++) {
          rgb[i] = Math.round(parseFloat(match132[i + 1]) * 2.55);
        }
        if (match132[4]) {
          if (match132[5]) {
            rgb[3] = parseFloat(match132[4]) * 0.01;
          } else {
            rgb[3] = parseFloat(match132[4]);
          }
        }
      } else if (match132 = string132.match(keyword)) {
        if (match132[1] === "transparent") {
          return [0, 0, 0, 0];
        }
        if (!hasOwnProperty.call(colorNames, match132[1])) {
          return null;
        }
        rgb = colorNames[match132[1]];
        rgb[3] = 1;
        return rgb;
      } else {
        return null;
      }
      for (i = 0; i < 3; i++) {
        rgb[i] = clamp(rgb[i], 0, 255);
      }
      rgb[3] = clamp(rgb[3], 0, 1);
      return rgb;
    };
    cs.get.hsl = function(string132) {
      if (!string132) {
        return null;
      }
      var hsl = /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
      var match132 = string132.match(hsl);
      if (match132) {
        var alpha = parseFloat(match132[4]);
        var h = (parseFloat(match132[1]) % 360 + 360) % 360;
        var s32 = clamp(parseFloat(match132[2]), 0, 100);
        var l = clamp(parseFloat(match132[3]), 0, 100);
        var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
        return [h, s32, l, a];
      }
      return null;
    };
    cs.get.hwb = function(string132) {
      if (!string132) {
        return null;
      }
      var hwb = /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
      var match132 = string132.match(hwb);
      if (match132) {
        var alpha = parseFloat(match132[4]);
        var h = (parseFloat(match132[1]) % 360 + 360) % 360;
        var w = clamp(parseFloat(match132[2]), 0, 100);
        var b = clamp(parseFloat(match132[3]), 0, 100);
        var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
        return [h, w, b, a];
      }
      return null;
    };
    cs.to.hex = function() {
      var rgba = swizzle(arguments);
      return "#" + hexDouble(rgba[0]) + hexDouble(rgba[1]) + hexDouble(rgba[2]) + (rgba[3] < 1 ? hexDouble(Math.round(rgba[3] * 255)) : "");
    };
    cs.to.rgb = function() {
      var rgba = swizzle(arguments);
      return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ")" : "rgba(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ", " + rgba[3] + ")";
    };
    cs.to.rgb.percent = function() {
      var rgba = swizzle(arguments);
      var r = Math.round(rgba[0] / 255 * 100);
      var g = Math.round(rgba[1] / 255 * 100);
      var b = Math.round(rgba[2] / 255 * 100);
      return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + r + "%, " + g + "%, " + b + "%)" : "rgba(" + r + "%, " + g + "%, " + b + "%, " + rgba[3] + ")";
    };
    cs.to.hsl = function() {
      var hsla = swizzle(arguments);
      return hsla.length < 4 || hsla[3] === 1 ? "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)" : "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, " + hsla[3] + ")";
    };
    cs.to.hwb = function() {
      var hwba = swizzle(arguments);
      var a = "";
      if (hwba.length >= 4 && hwba[3] !== 1) {
        a = ", " + hwba[3];
      }
      return "hwb(" + hwba[0] + ", " + hwba[1] + "%, " + hwba[2] + "%" + a + ")";
    };
    cs.to.keyword = function(rgb) {
      return reverseNames[rgb.slice(0, 3)];
    };
    function clamp(num, min, max) {
      return Math.min(Math.max(min, num), max);
    }
    function hexDouble(num) {
      var str = Math.round(num).toString(16).toUpperCase();
      return str.length < 2 ? "0" + str : str;
    }
  }
});
var require_conversions = __commonJS2({
  "../../node_modules/color-convert/conversions.js"(exports, module2) {
    var cssKeywords = require_color_name();
    var reverseKeywords = {};
    for (const key of Object.keys(cssKeywords)) {
      reverseKeywords[cssKeywords[key]] = key;
    }
    var convert = {
      rgb: { channels: 3, labels: "rgb" },
      hsl: { channels: 3, labels: "hsl" },
      hsv: { channels: 3, labels: "hsv" },
      hwb: { channels: 3, labels: "hwb" },
      cmyk: { channels: 4, labels: "cmyk" },
      xyz: { channels: 3, labels: "xyz" },
      lab: { channels: 3, labels: "lab" },
      lch: { channels: 3, labels: "lch" },
      hex: { channels: 1, labels: ["hex"] },
      keyword: { channels: 1, labels: ["keyword"] },
      ansi16: { channels: 1, labels: ["ansi16"] },
      ansi256: { channels: 1, labels: ["ansi256"] },
      hcg: { channels: 3, labels: ["h", "c", "g"] },
      apple: { channels: 3, labels: ["r16", "g16", "b16"] },
      gray: { channels: 1, labels: ["gray"] }
    };
    module2.exports = convert;
    for (const model of Object.keys(convert)) {
      if (!("channels" in convert[model])) {
        throw new Error("missing channels property: " + model);
      }
      if (!("labels" in convert[model])) {
        throw new Error("missing channel labels property: " + model);
      }
      if (convert[model].labels.length !== convert[model].channels) {
        throw new Error("channel and label counts mismatch: " + model);
      }
      const { channels, labels } = convert[model];
      delete convert[model].channels;
      delete convert[model].labels;
      Object.defineProperty(convert[model], "channels", { value: channels });
      Object.defineProperty(convert[model], "labels", { value: labels });
    }
    convert.rgb.hsl = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const min = Math.min(r, g, b);
      const max = Math.max(r, g, b);
      const delta = max - min;
      let h;
      let s32;
      if (max === min) {
        h = 0;
      } else if (r === max) {
        h = (g - b) / delta;
      } else if (g === max) {
        h = 2 + (b - r) / delta;
      } else if (b === max) {
        h = 4 + (r - g) / delta;
      }
      h = Math.min(h * 60, 360);
      if (h < 0) {
        h += 360;
      }
      const l = (min + max) / 2;
      if (max === min) {
        s32 = 0;
      } else if (l <= 0.5) {
        s32 = delta / (max + min);
      } else {
        s32 = delta / (2 - max - min);
      }
      return [h, s32 * 100, l * 100];
    };
    convert.rgb.hsv = function(rgb) {
      let rdif;
      let gdif;
      let bdif;
      let h;
      let s32;
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const v = Math.max(r, g, b);
      const diff = v - Math.min(r, g, b);
      const diffc = function(c) {
        return (v - c) / 6 / diff + 1 / 2;
      };
      if (diff === 0) {
        h = 0;
        s32 = 0;
      } else {
        s32 = diff / v;
        rdif = diffc(r);
        gdif = diffc(g);
        bdif = diffc(b);
        if (r === v) {
          h = bdif - gdif;
        } else if (g === v) {
          h = 1 / 3 + rdif - bdif;
        } else if (b === v) {
          h = 2 / 3 + gdif - rdif;
        }
        if (h < 0) {
          h += 1;
        } else if (h > 1) {
          h -= 1;
        }
      }
      return [
        h * 360,
        s32 * 100,
        v * 100
      ];
    };
    convert.rgb.hwb = function(rgb) {
      const r = rgb[0];
      const g = rgb[1];
      let b = rgb[2];
      const h = convert.rgb.hsl(rgb)[0];
      const w = 1 / 255 * Math.min(r, Math.min(g, b));
      b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
      return [h, w * 100, b * 100];
    };
    convert.rgb.cmyk = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const k = Math.min(1 - r, 1 - g, 1 - b);
      const c = (1 - r - k) / (1 - k) || 0;
      const m = (1 - g - k) / (1 - k) || 0;
      const y = (1 - b - k) / (1 - k) || 0;
      return [c * 100, m * 100, y * 100, k * 100];
    };
    function comparativeDistance(x, y) {
      return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
    }
    convert.rgb.keyword = function(rgb) {
      const reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      let currentClosestDistance = Infinity;
      let currentClosestKeyword;
      for (const keyword of Object.keys(cssKeywords)) {
        const value = cssKeywords[keyword];
        const distance = comparativeDistance(rgb, value);
        if (distance < currentClosestDistance) {
          currentClosestDistance = distance;
          currentClosestKeyword = keyword;
        }
      }
      return currentClosestKeyword;
    };
    convert.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert.rgb.xyz = function(rgb) {
      let r = rgb[0] / 255;
      let g = rgb[1] / 255;
      let b = rgb[2] / 255;
      r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
      g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
      b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
      const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x * 100, y * 100, z * 100];
    };
    convert.rgb.lab = function(rgb) {
      const xyz = convert.rgb.xyz(rgb);
      let x = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y - 16;
      const a = 500 * (x - y);
      const b = 200 * (y - z);
      return [l, a, b];
    };
    convert.hsl.rgb = function(hsl) {
      const h = hsl[0] / 360;
      const s32 = hsl[1] / 100;
      const l = hsl[2] / 100;
      let t2;
      let t3;
      let val;
      if (s32 === 0) {
        val = l * 255;
        return [val, val, val];
      }
      if (l < 0.5) {
        t2 = l * (1 + s32);
      } else {
        t2 = l + s32 - l * s32;
      }
      const t1 = 2 * l - t2;
      const rgb = [0, 0, 0];
      for (let i = 0; i < 3; i++) {
        t3 = h + 1 / 3 * -(i - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }
        rgb[i] = val * 255;
      }
      return rgb;
    };
    convert.hsl.hsv = function(hsl) {
      const h = hsl[0];
      let s32 = hsl[1] / 100;
      let l = hsl[2] / 100;
      let smin = s32;
      const lmin = Math.max(l, 0.01);
      l *= 2;
      s32 *= l <= 1 ? l : 2 - l;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      const v = (l + s32) / 2;
      const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s32 / (l + s32);
      return [h, sv * 100, v * 100];
    };
    convert.hsv.rgb = function(hsv) {
      const h = hsv[0] / 60;
      const s32 = hsv[1] / 100;
      let v = hsv[2] / 100;
      const hi = Math.floor(h) % 6;
      const f = h - Math.floor(h);
      const p = 255 * v * (1 - s32);
      const q = 255 * v * (1 - s32 * f);
      const t = 255 * v * (1 - s32 * (1 - f));
      v *= 255;
      switch (hi) {
        case 0:
          return [v, t, p];
        case 1:
          return [q, v, p];
        case 2:
          return [p, v, t];
        case 3:
          return [p, q, v];
        case 4:
          return [t, p, v];
        case 5:
          return [v, p, q];
      }
    };
    convert.hsv.hsl = function(hsv) {
      const h = hsv[0];
      const s32 = hsv[1] / 100;
      const v = hsv[2] / 100;
      const vmin = Math.max(v, 0.01);
      let sl;
      let l;
      l = (2 - s32) * v;
      const lmin = (2 - s32) * vmin;
      sl = s32 * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l /= 2;
      return [h, sl * 100, l * 100];
    };
    convert.hwb.rgb = function(hwb) {
      const h = hwb[0] / 360;
      let wh = hwb[1] / 100;
      let bl = hwb[2] / 100;
      const ratio = wh + bl;
      let f;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      const i = Math.floor(6 * h);
      const v = 1 - bl;
      f = 6 * h - i;
      if ((i & 1) !== 0) {
        f = 1 - f;
      }
      const n = wh + f * (v - wh);
      let r;
      let g;
      let b;
      switch (i) {
        default:
        case 6:
        case 0:
          r = v;
          g = n;
          b = wh;
          break;
        case 1:
          r = n;
          g = v;
          b = wh;
          break;
        case 2:
          r = wh;
          g = v;
          b = n;
          break;
        case 3:
          r = wh;
          g = n;
          b = v;
          break;
        case 4:
          r = n;
          g = wh;
          b = v;
          break;
        case 5:
          r = v;
          g = wh;
          b = n;
          break;
      }
      return [r * 255, g * 255, b * 255];
    };
    convert.cmyk.rgb = function(cmyk) {
      const c = cmyk[0] / 100;
      const m = cmyk[1] / 100;
      const y = cmyk[2] / 100;
      const k = cmyk[3] / 100;
      const r = 1 - Math.min(1, c * (1 - k) + k);
      const g = 1 - Math.min(1, m * (1 - k) + k);
      const b = 1 - Math.min(1, y * (1 - k) + k);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.rgb = function(xyz) {
      const x = xyz[0] / 100;
      const y = xyz[1] / 100;
      const z = xyz[2] / 100;
      let r;
      let g;
      let b;
      r = x * 3.2406 + y * -1.5372 + z * -0.4986;
      g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      b = x * 0.0557 + y * -0.204 + z * 1.057;
      r = r > 31308e-7 ? 1.055 * r ** (1 / 2.4) - 0.055 : r * 12.92;
      g = g > 31308e-7 ? 1.055 * g ** (1 / 2.4) - 0.055 : g * 12.92;
      b = b > 31308e-7 ? 1.055 * b ** (1 / 2.4) - 0.055 : b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.lab = function(xyz) {
      let x = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y - 16;
      const a = 500 * (x - y);
      const b = 200 * (y - z);
      return [l, a, b];
    };
    convert.lab.xyz = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let x;
      let y;
      let z;
      y = (l + 16) / 116;
      x = a / 500 + y;
      z = y - b / 200;
      const y2 = y ** 3;
      const x2 = x ** 3;
      const z2 = z ** 3;
      y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
      x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
      z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
      x *= 95.047;
      y *= 100;
      z *= 108.883;
      return [x, y, z];
    };
    convert.lab.lch = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let h;
      const hr = Math.atan2(b, a);
      h = hr * 360 / 2 / Math.PI;
      if (h < 0) {
        h += 360;
      }
      const c = Math.sqrt(a * a + b * b);
      return [l, c, h];
    };
    convert.lch.lab = function(lch) {
      const l = lch[0];
      const c = lch[1];
      const h = lch[2];
      const hr = h / 360 * 2 * Math.PI;
      const a = c * Math.cos(hr);
      const b = c * Math.sin(hr);
      return [l, a, b];
    };
    convert.rgb.ansi16 = function(args, saturation = null) {
      const [r, g, b] = args;
      let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation;
      value = Math.round(value / 50);
      if (value === 0) {
        return 30;
      }
      let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
      if (value === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert.hsv.ansi16 = function(args) {
      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
    };
    convert.rgb.ansi256 = function(args) {
      const r = args[0];
      const g = args[1];
      const b = args[2];
      if (r === g && g === b) {
        if (r < 8) {
          return 16;
        }
        if (r > 248) {
          return 231;
        }
        return Math.round((r - 8) / 247 * 24) + 232;
      }
      const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
      return ansi;
    };
    convert.ansi16.rgb = function(args) {
      let color = args % 10;
      if (color === 0 || color === 7) {
        if (args > 50) {
          color += 3.5;
        }
        color = color / 10.5 * 255;
        return [color, color, color];
      }
      const mult = (~~(args > 50) + 1) * 0.5;
      const r = (color & 1) * mult * 255;
      const g = (color >> 1 & 1) * mult * 255;
      const b = (color >> 2 & 1) * mult * 255;
      return [r, g, b];
    };
    convert.ansi256.rgb = function(args) {
      if (args >= 232) {
        const c = (args - 232) * 10 + 8;
        return [c, c, c];
      }
      args -= 16;
      let rem;
      const r = Math.floor(args / 36) / 5 * 255;
      const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
      const b = rem % 6 / 5 * 255;
      return [r, g, b];
    };
    convert.rgb.hex = function(args) {
      const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      const string132 = integer.toString(16).toUpperCase();
      return "000000".substring(string132.length) + string132;
    };
    convert.hex.rgb = function(args) {
      const match132 = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match132) {
        return [0, 0, 0];
      }
      let colorString = match132[0];
      if (match132[0].length === 3) {
        colorString = colorString.split("").map((char) => {
          return char + char;
        }).join("");
      }
      const integer = parseInt(colorString, 16);
      const r = integer >> 16 & 255;
      const g = integer >> 8 & 255;
      const b = integer & 255;
      return [r, g, b];
    };
    convert.rgb.hcg = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const max = Math.max(Math.max(r, g), b);
      const min = Math.min(Math.min(r, g), b);
      const chroma = max - min;
      let grayscale;
      let hue;
      if (chroma < 1) {
        grayscale = min / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max === r) {
        hue = (g - b) / chroma % 6;
      } else if (max === g) {
        hue = 2 + (b - r) / chroma;
      } else {
        hue = 4 + (r - g) / chroma;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert.hsl.hcg = function(hsl) {
      const s32 = hsl[1] / 100;
      const l = hsl[2] / 100;
      const c = l < 0.5 ? 2 * s32 * l : 2 * s32 * (1 - l);
      let f = 0;
      if (c < 1) {
        f = (l - 0.5 * c) / (1 - c);
      }
      return [hsl[0], c * 100, f * 100];
    };
    convert.hsv.hcg = function(hsv) {
      const s32 = hsv[1] / 100;
      const v = hsv[2] / 100;
      const c = s32 * v;
      let f = 0;
      if (c < 1) {
        f = (v - c) / (1 - c);
      }
      return [hsv[0], c * 100, f * 100];
    };
    convert.hcg.rgb = function(hcg) {
      const h = hcg[0] / 360;
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      if (c === 0) {
        return [g * 255, g * 255, g * 255];
      }
      const pure = [0, 0, 0];
      const hi = h % 1 * 6;
      const v = hi % 1;
      const w = 1 - v;
      let mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w;
      }
      mg = (1 - c) * g;
      return [
        (c * pure[0] + mg) * 255,
        (c * pure[1] + mg) * 255,
        (c * pure[2] + mg) * 255
      ];
    };
    convert.hcg.hsv = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c + g * (1 - c);
      let f = 0;
      if (v > 0) {
        f = c / v;
      }
      return [hcg[0], f * 100, v * 100];
    };
    convert.hcg.hsl = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const l = g * (1 - c) + 0.5 * c;
      let s32 = 0;
      if (l > 0 && l < 0.5) {
        s32 = c / (2 * l);
      } else if (l >= 0.5 && l < 1) {
        s32 = c / (2 * (1 - l));
      }
      return [hcg[0], s32 * 100, l * 100];
    };
    convert.hcg.hwb = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c + g * (1 - c);
      return [hcg[0], (v - c) * 100, (1 - v) * 100];
    };
    convert.hwb.hcg = function(hwb) {
      const w = hwb[1] / 100;
      const b = hwb[2] / 100;
      const v = 1 - b;
      const c = v - w;
      let g = 0;
      if (c < 1) {
        g = (v - c) / (1 - c);
      }
      return [hwb[0], c * 100, g * 100];
    };
    convert.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert.rgb.apple = function(rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };
    convert.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert.gray.hsl = function(args) {
      return [0, 0, args[0]];
    };
    convert.gray.hsv = convert.gray.hsl;
    convert.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    };
    convert.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    };
    convert.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    };
    convert.gray.hex = function(gray) {
      const val = Math.round(gray[0] / 100 * 255) & 255;
      const integer = (val << 16) + (val << 8) + val;
      const string132 = integer.toString(16).toUpperCase();
      return "000000".substring(string132.length) + string132;
    };
    convert.rgb.gray = function(rgb) {
      const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
  }
});
var require_route = __commonJS2({
  "../../node_modules/color-convert/route.js"(exports, module2) {
    var conversions = require_conversions();
    function buildGraph() {
      const graph = {};
      const models = Object.keys(conversions);
      for (let len = models.length, i = 0; i < len; i++) {
        graph[models[i]] = {
          // http://jsperf.com/1-vs-infinity
          // micro-opt, but this is simple.
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      const graph = buildGraph();
      const queue = [fromModel];
      graph[fromModel].distance = 0;
      while (queue.length) {
        const current = queue.pop();
        const adjacents = Object.keys(conversions[current]);
        for (let len = adjacents.length, i = 0; i < len; i++) {
          const adjacent = adjacents[i];
          const node = graph[adjacent];
          if (node.distance === -1) {
            node.distance = graph[current].distance + 1;
            node.parent = current;
            queue.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link(from, to) {
      return function(args) {
        return to(from(args));
      };
    }
    function wrapConversion(toModel, graph) {
      const path2 = [graph[toModel].parent, toModel];
      let fn = conversions[graph[toModel].parent][toModel];
      let cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path2.unshift(graph[cur].parent);
        fn = link(conversions[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }
      fn.conversion = path2;
      return fn;
    }
    module2.exports = function(fromModel) {
      const graph = deriveBFS(fromModel);
      const conversion = {};
      const models = Object.keys(graph);
      for (let len = models.length, i = 0; i < len; i++) {
        const toModel = models[i];
        const node = graph[toModel];
        if (node.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
  }
});
var require_color_convert = __commonJS2({
  "../../node_modules/color-convert/index.js"(exports, module2) {
    var conversions = require_conversions();
    var route = require_route();
    var convert = {};
    var models = Object.keys(conversions);
    function wrapRaw(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        return fn(args);
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        const result = fn(args);
        if (typeof result === "object") {
          for (let len = result.length, i = 0; i < len; i++) {
            result[i] = Math.round(result[i]);
          }
        }
        return result;
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    models.forEach((fromModel) => {
      convert[fromModel] = {};
      Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
      Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
      const routes = route(fromModel);
      const routeModels = Object.keys(routes);
      routeModels.forEach((toModel) => {
        const fn = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn);
        convert[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    module2.exports = convert;
  }
});
var require_color = __commonJS2({
  "../../node_modules/color/index.js"(exports, module2) {
    var colorString = require_color_string();
    var convert = require_color_convert();
    var skippedModels = [
      // To be honest, I don't really feel like keyword belongs in color convert, but eh.
      "keyword",
      // Gray conflicts with some method names, and has its own method defined.
      "gray",
      // Shouldn't really be in color-convert either...
      "hex"
    ];
    var hashedModelKeys = {};
    for (const model of Object.keys(convert)) {
      hashedModelKeys[[...convert[model].labels].sort().join("")] = model;
    }
    var limiters = {};
    function Color3(object, model) {
      if (!(this instanceof Color3)) {
        return new Color3(object, model);
      }
      if (model && model in skippedModels) {
        model = null;
      }
      if (model && !(model in convert)) {
        throw new Error("Unknown model: " + model);
      }
      let i;
      let channels;
      if (object == null) {
        this.model = "rgb";
        this.color = [0, 0, 0];
        this.valpha = 1;
      } else if (object instanceof Color3) {
        this.model = object.model;
        this.color = [...object.color];
        this.valpha = object.valpha;
      } else if (typeof object === "string") {
        const result = colorString.get(object);
        if (result === null) {
          throw new Error("Unable to parse color from string: " + object);
        }
        this.model = result.model;
        channels = convert[this.model].channels;
        this.color = result.value.slice(0, channels);
        this.valpha = typeof result.value[channels] === "number" ? result.value[channels] : 1;
      } else if (object.length > 0) {
        this.model = model || "rgb";
        channels = convert[this.model].channels;
        const newArray = Array.prototype.slice.call(object, 0, channels);
        this.color = zeroArray(newArray, channels);
        this.valpha = typeof object[channels] === "number" ? object[channels] : 1;
      } else if (typeof object === "number") {
        this.model = "rgb";
        this.color = [
          object >> 16 & 255,
          object >> 8 & 255,
          object & 255
        ];
        this.valpha = 1;
      } else {
        this.valpha = 1;
        const keys2 = Object.keys(object);
        if ("alpha" in object) {
          keys2.splice(keys2.indexOf("alpha"), 1);
          this.valpha = typeof object.alpha === "number" ? object.alpha : 0;
        }
        const hashedKeys = keys2.sort().join("");
        if (!(hashedKeys in hashedModelKeys)) {
          throw new Error("Unable to parse color from object: " + JSON.stringify(object));
        }
        this.model = hashedModelKeys[hashedKeys];
        const { labels } = convert[this.model];
        const color = [];
        for (i = 0; i < labels.length; i++) {
          color.push(object[labels[i]]);
        }
        this.color = zeroArray(color);
      }
      if (limiters[this.model]) {
        channels = convert[this.model].channels;
        for (i = 0; i < channels; i++) {
          const limit = limiters[this.model][i];
          if (limit) {
            this.color[i] = limit(this.color[i]);
          }
        }
      }
      this.valpha = Math.max(0, Math.min(1, this.valpha));
      if (Object.freeze) {
        Object.freeze(this);
      }
    }
    Color3.prototype = {
      toString() {
        return this.string();
      },
      toJSON() {
        return this[this.model]();
      },
      string(places) {
        let self = this.model in colorString.to ? this : this.rgb();
        self = self.round(typeof places === "number" ? places : 1);
        const args = self.valpha === 1 ? self.color : [...self.color, this.valpha];
        return colorString.to[self.model](args);
      },
      percentString(places) {
        const self = this.rgb().round(typeof places === "number" ? places : 1);
        const args = self.valpha === 1 ? self.color : [...self.color, this.valpha];
        return colorString.to.rgb.percent(args);
      },
      array() {
        return this.valpha === 1 ? [...this.color] : [...this.color, this.valpha];
      },
      object() {
        const result = {};
        const { channels } = convert[this.model];
        const { labels } = convert[this.model];
        for (let i = 0; i < channels; i++) {
          result[labels[i]] = this.color[i];
        }
        if (this.valpha !== 1) {
          result.alpha = this.valpha;
        }
        return result;
      },
      unitArray() {
        const rgb = this.rgb().color;
        rgb[0] /= 255;
        rgb[1] /= 255;
        rgb[2] /= 255;
        if (this.valpha !== 1) {
          rgb.push(this.valpha);
        }
        return rgb;
      },
      unitObject() {
        const rgb = this.rgb().object();
        rgb.r /= 255;
        rgb.g /= 255;
        rgb.b /= 255;
        if (this.valpha !== 1) {
          rgb.alpha = this.valpha;
        }
        return rgb;
      },
      round(places) {
        places = Math.max(places || 0, 0);
        return new Color3([...this.color.map(roundToPlace(places)), this.valpha], this.model);
      },
      alpha(value) {
        if (value !== void 0) {
          return new Color3([...this.color, Math.max(0, Math.min(1, value))], this.model);
        }
        return this.valpha;
      },
      // Rgb
      red: getset("rgb", 0, maxfn(255)),
      green: getset("rgb", 1, maxfn(255)),
      blue: getset("rgb", 2, maxfn(255)),
      hue: getset(["hsl", "hsv", "hsl", "hwb", "hcg"], 0, (value) => (value % 360 + 360) % 360),
      saturationl: getset("hsl", 1, maxfn(100)),
      lightness: getset("hsl", 2, maxfn(100)),
      saturationv: getset("hsv", 1, maxfn(100)),
      value: getset("hsv", 2, maxfn(100)),
      chroma: getset("hcg", 1, maxfn(100)),
      gray: getset("hcg", 2, maxfn(100)),
      white: getset("hwb", 1, maxfn(100)),
      wblack: getset("hwb", 2, maxfn(100)),
      cyan: getset("cmyk", 0, maxfn(100)),
      magenta: getset("cmyk", 1, maxfn(100)),
      yellow: getset("cmyk", 2, maxfn(100)),
      black: getset("cmyk", 3, maxfn(100)),
      x: getset("xyz", 0, maxfn(95.047)),
      y: getset("xyz", 1, maxfn(100)),
      z: getset("xyz", 2, maxfn(108.833)),
      l: getset("lab", 0, maxfn(100)),
      a: getset("lab", 1),
      b: getset("lab", 2),
      keyword(value) {
        if (value !== void 0) {
          return new Color3(value);
        }
        return convert[this.model].keyword(this.color);
      },
      hex(value) {
        if (value !== void 0) {
          return new Color3(value);
        }
        return colorString.to.hex(this.rgb().round().color);
      },
      hexa(value) {
        if (value !== void 0) {
          return new Color3(value);
        }
        const rgbArray = this.rgb().round().color;
        let alphaHex = Math.round(this.valpha * 255).toString(16).toUpperCase();
        if (alphaHex.length === 1) {
          alphaHex = "0" + alphaHex;
        }
        return colorString.to.hex(rgbArray) + alphaHex;
      },
      rgbNumber() {
        const rgb = this.rgb().color;
        return (rgb[0] & 255) << 16 | (rgb[1] & 255) << 8 | rgb[2] & 255;
      },
      luminosity() {
        const rgb = this.rgb().color;
        const lum = [];
        for (const [i, element] of rgb.entries()) {
          const chan = element / 255;
          lum[i] = chan <= 0.04045 ? chan / 12.92 : ((chan + 0.055) / 1.055) ** 2.4;
        }
        return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
      },
      contrast(color2) {
        const lum1 = this.luminosity();
        const lum2 = color2.luminosity();
        if (lum1 > lum2) {
          return (lum1 + 0.05) / (lum2 + 0.05);
        }
        return (lum2 + 0.05) / (lum1 + 0.05);
      },
      level(color2) {
        const contrastRatio = this.contrast(color2);
        if (contrastRatio >= 7) {
          return "AAA";
        }
        return contrastRatio >= 4.5 ? "AA" : "";
      },
      isDark() {
        const rgb = this.rgb().color;
        const yiq = (rgb[0] * 2126 + rgb[1] * 7152 + rgb[2] * 722) / 1e4;
        return yiq < 128;
      },
      isLight() {
        return !this.isDark();
      },
      negate() {
        const rgb = this.rgb();
        for (let i = 0; i < 3; i++) {
          rgb.color[i] = 255 - rgb.color[i];
        }
        return rgb;
      },
      lighten(ratio) {
        const hsl = this.hsl();
        hsl.color[2] += hsl.color[2] * ratio;
        return hsl;
      },
      darken(ratio) {
        const hsl = this.hsl();
        hsl.color[2] -= hsl.color[2] * ratio;
        return hsl;
      },
      saturate(ratio) {
        const hsl = this.hsl();
        hsl.color[1] += hsl.color[1] * ratio;
        return hsl;
      },
      desaturate(ratio) {
        const hsl = this.hsl();
        hsl.color[1] -= hsl.color[1] * ratio;
        return hsl;
      },
      whiten(ratio) {
        const hwb = this.hwb();
        hwb.color[1] += hwb.color[1] * ratio;
        return hwb;
      },
      blacken(ratio) {
        const hwb = this.hwb();
        hwb.color[2] += hwb.color[2] * ratio;
        return hwb;
      },
      grayscale() {
        const rgb = this.rgb().color;
        const value = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
        return Color3.rgb(value, value, value);
      },
      fade(ratio) {
        return this.alpha(this.valpha - this.valpha * ratio);
      },
      opaquer(ratio) {
        return this.alpha(this.valpha + this.valpha * ratio);
      },
      rotate(degrees) {
        const hsl = this.hsl();
        let hue = hsl.color[0];
        hue = (hue + degrees) % 360;
        hue = hue < 0 ? 360 + hue : hue;
        hsl.color[0] = hue;
        return hsl;
      },
      mix(mixinColor, weight) {
        if (!mixinColor || !mixinColor.rgb) {
          throw new Error('Argument to "mix" was not a Color instance, but rather an instance of ' + typeof mixinColor);
        }
        const color1 = mixinColor.rgb();
        const color2 = this.rgb();
        const p = weight === void 0 ? 0.5 : weight;
        const w = 2 * p - 1;
        const a = color1.alpha() - color2.alpha();
        const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
        const w2 = 1 - w1;
        return Color3.rgb(
          w1 * color1.red() + w2 * color2.red(),
          w1 * color1.green() + w2 * color2.green(),
          w1 * color1.blue() + w2 * color2.blue(),
          color1.alpha() * p + color2.alpha() * (1 - p)
        );
      }
    };
    for (const model of Object.keys(convert)) {
      if (skippedModels.includes(model)) {
        continue;
      }
      const { channels } = convert[model];
      Color3.prototype[model] = function(...args) {
        if (this.model === model) {
          return new Color3(this);
        }
        if (args.length > 0) {
          return new Color3(args, model);
        }
        return new Color3([...assertArray(convert[this.model][model].raw(this.color)), this.valpha], model);
      };
      Color3[model] = function(...args) {
        let color = args[0];
        if (typeof color === "number") {
          color = zeroArray(args, channels);
        }
        return new Color3(color, model);
      };
    }
    function roundTo(number, places) {
      return Number(number.toFixed(places));
    }
    function roundToPlace(places) {
      return function(number) {
        return roundTo(number, places);
      };
    }
    function getset(model, channel, modifier) {
      model = Array.isArray(model) ? model : [model];
      for (const m of model) {
        (limiters[m] || (limiters[m] = []))[channel] = modifier;
      }
      model = model[0];
      return function(value) {
        let result;
        if (value !== void 0) {
          if (modifier) {
            value = modifier(value);
          }
          result = this[model]();
          result.color[channel] = value;
          return result;
        }
        result = this[model]().color[channel];
        if (modifier) {
          result = modifier(result);
        }
        return result;
      };
    }
    function maxfn(max) {
      return function(v) {
        return Math.max(0, Math.min(max, v));
      };
    }
    function assertArray(value) {
      return Array.isArray(value) ? value : [value];
    }
    function zeroArray(array, length) {
      for (let i = 0; i < length; i++) {
        if (typeof array[i] !== "number") {
          array[i] = 0;
        }
      }
      return array;
    }
    module2.exports = Color3;
  }
});
var macros = {
  cref: { signature: "s m" },
  Cref: { signature: "s m" },
  crefrange: { signature: "s m m" },
  Crefrange: { signature: "s m m" },
  cpageref: { signature: "s m" },
  Cpageref: { signature: "s m" },
  ref: { signature: "m" },
  pageref: { signature: "m" },
  namecref: { signature: "m" },
  nameCref: { signature: "m" },
  lcnamecref: { signature: "m" },
  namecrefs: { signature: "m" },
  nameCrefs: { signature: "m" },
  lcnamecrefs: { signature: "m" },
  labelcref: { signature: "m" },
  labelcpageref: { signature: "m" },
  crefalias: { signature: "m m" },
  crefname: { signature: "m m m" },
  // XXX there are many more obscure commands to add here
  // https://ctan.org/pkg/cleveref
  crefdefaultlabelformat: { signature: "m" },
  crefrangeconjunction: { signature: "m" }
};
var environments = {};
var BRACES_MAP = {
  "*": { openMark: "", closeMark: "" },
  "{": { openMark: "{", closeMark: "}" },
  "[": { openMark: "[", closeMark: "]" },
  "(": { openMark: "(", closeMark: ")" },
  "<": { openMark: "<", closeMark: ">" }
};
var CLOSE_BRACES = new Set(
  Object.values(BRACES_MAP).map((x) => x.closeMark).filter((x) => x)
);
function bracesToOpenAndCloseMarks(braces) {
  const ret = [];
  for (const char of braces.split("")) {
    if (CLOSE_BRACES.has(char)) {
      continue;
    }
    const braces2 = BRACES_MAP[char];
    if (braces2 == null) {
      throw new Error(`Unknown open/close mark type "${char}"`);
    }
    braces2;
    ret.push(braces2);
  }
  return ret;
}
function arg(args2, special) {
  if (args2 == null) {
    return { type: "argument", content: [], openMark: "", closeMark: "" };
  }
  if (typeof args2 === "string") {
    args2 = s(args2);
  }
  if (!Array.isArray(args2) && args2.type === "argument") {
    return args2;
  }
  let openMark = (special == null ? void 0 : special.openMark) ?? "{";
  let closeMark = (special == null ? void 0 : special.closeMark) ?? "}";
  if (special == null ? void 0 : special.braces) {
    const braces = bracesToOpenAndCloseMarks(special.braces);
    if (braces[0]) {
      openMark = braces[0].openMark;
      closeMark = braces[0].closeMark;
    }
  }
  if (!Array.isArray(args2)) {
    args2 = [args2];
  }
  return { type: "argument", content: args2, openMark, closeMark };
}
function s(value) {
  if (typeof value === "string") {
    return { type: "string", content: value };
  }
  return value;
}
var linebreak = Symbol("linebreak");
var ESCAPE = "\\";
function _printRaw(node) {
  if (typeof node === "string") {
    return [node];
  }
  if (Array.isArray(node)) {
    return [].concat(
      ...node.map((n) => _printRaw(n))
    );
  }
  let argsString, escape;
  switch (node.type) {
    case "root":
      return _printRaw(node.content);
    case "argument":
      return [node.openMark, ..._printRaw(node.content), node.closeMark];
    case "comment":
      var suffix = node.suffixParbreak ? "" : linebreak;
      var leadingWhitespace = "";
      if (node.sameline && node.leadingWhitespace) {
        leadingWhitespace = " ";
      }
      if (node.sameline) {
        return [
          leadingWhitespace,
          "%",
          ..._printRaw(node.content),
          suffix
        ];
      }
      return [linebreak, "%", ..._printRaw(node.content), suffix];
    case "environment":
    case "mathenv":
    case "verbatim":
      var env = _printRaw(node.env);
      var envStart = [ESCAPE + "begin{", ...env, "}"];
      var envEnd = [ESCAPE + "end{", ...env, "}"];
      argsString = node.args == null ? [] : _printRaw(node.args);
      return [
        ...envStart,
        ...argsString,
        ..._printRaw(node.content),
        ...envEnd
      ];
    case "displaymath":
      return [ESCAPE + "[", ..._printRaw(node.content), ESCAPE + "]"];
    case "group":
      return ["{", ..._printRaw(node.content), "}"];
    case "inlinemath":
      return ["$", ..._printRaw(node.content), "$"];
    case "macro":
      argsString = node.args == null ? [] : _printRaw(node.args);
      escape = node.escapeToken == null ? ESCAPE : node.escapeToken;
      return [escape, ..._printRaw(node.content), ...argsString];
    case "parbreak":
      return [linebreak, linebreak];
    case "string":
      return [node.content];
    case "verb":
      return [
        ESCAPE,
        node.env,
        node.escape,
        ..._printRaw(node.content),
        node.escape
      ];
    case "whitespace":
      return [" "];
    default:
      console.warn(
        "Cannot find render for node ",
        node,
        `(of type ${typeof node})`
      );
      return ["" + node];
  }
}
function printRaw(node, options) {
  const asArray = options != null ? options.asArray : false;
  const printedTokens = _printRaw(node);
  if (asArray) {
    return printedTokens;
  }
  return printedTokens.map((x) => x === linebreak ? "\n" : x).join("");
}
function createMacroMatcher(macros15) {
  const macrosHash = Array.isArray(macros15) ? macros15.length > 0 ? typeof macros15[0] === "string" ? Object.fromEntries(
    macros15.map((macro262) => {
      if (typeof macro262 !== "string") {
        throw new Error("Wrong branch of map function");
      }
      return [macro262, {}];
    })
  ) : Object.fromEntries(
    macros15.map((macro262) => {
      if (typeof macro262 === "string") {
        throw new Error("Wrong branch of map function");
      }
      if (macro262.escapeToken != null) {
        return [
          macro262.content,
          { escapeToken: macro262.escapeToken }
        ];
      }
      return [macro262.content, {}];
    })
  ) : {} : macros15;
  return function matchAgainstMacros(node) {
    if (node == null || node.type !== "macro") {
      return false;
    }
    const spec = macrosHash[node.content];
    if (!spec) {
      return false;
    }
    if (typeof spec === "object" && "escapeToken" in spec) {
      return spec.escapeToken == null || spec.escapeToken === node.escapeToken;
    }
    return true;
  };
}
function createEnvironmentMatcher(macros15) {
  const environmentsHash = Array.isArray(macros15) ? Object.fromEntries(
    macros15.map((str) => {
      return [str, {}];
    })
  ) : macros15;
  return function matchAgainstEnvironments(node) {
    if (!match.anyEnvironment(node)) {
      return false;
    }
    const envName = printRaw(node.env);
    const spec = environmentsHash[envName];
    if (!spec) {
      return false;
    }
    return true;
  };
}
var match = {
  macro(node, macroName) {
    if (node == null) {
      return false;
    }
    return node.type === "macro" && (macroName == null || node.content === macroName);
  },
  anyMacro(node) {
    return match.macro(node);
  },
  environment(node, envName) {
    if (node == null) {
      return false;
    }
    return (node.type === "environment" || node.type === "mathenv") && (envName == null || printRaw(node.env) === envName);
  },
  anyEnvironment(node) {
    return match.environment(node);
  },
  comment(node) {
    if (node == null) {
      return false;
    }
    return node.type === "comment";
  },
  parbreak(node) {
    if (node == null) {
      return false;
    }
    return node.type === "parbreak";
  },
  whitespace(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace";
  },
  /**
   * Matches whitespace or a comment with leading whitespace.
   */
  whitespaceLike(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace" || node.type === "whitespace" && node.leadingWhitespace === true;
  },
  string(node, value) {
    if (node == null) {
      return false;
    }
    return node.type === "string" && (value == null || node.content === value);
  },
  anyString(node) {
    return match.string(node);
  },
  group(node) {
    if (node == null) {
      return false;
    }
    return node.type === "group";
  },
  argument(node) {
    if (node == null) {
      return false;
    }
    return node.type === "argument";
  },
  blankArgument(node) {
    if (!match.argument(node)) {
      return false;
    }
    return node.openMark === "" && node.closeMark === "" && node.content.length === 0;
  },
  math(node) {
    if (node == null) {
      return false;
    }
    return node.type === "displaymath" || node.type === "inlinemath";
  },
  createMacroMatcher,
  createEnvironmentMatcher
};
var {
  anyEnvironment,
  anyMacro,
  anyString,
  argument,
  blankArgument,
  comment,
  environment,
  group,
  macro,
  math,
  parbreak,
  string,
  whitespace
} = match;
var linebreak2 = Symbol("linebreak");
var ESCAPE2 = "\\";
function _printRaw2(node) {
  if (typeof node === "string") {
    return [node];
  }
  if (Array.isArray(node)) {
    return [].concat(
      ...node.map((n) => _printRaw2(n))
    );
  }
  let argsString, escape;
  switch (node.type) {
    case "root":
      return _printRaw2(node.content);
    case "argument":
      return [node.openMark, ..._printRaw2(node.content), node.closeMark];
    case "comment":
      var suffix = node.suffixParbreak ? "" : linebreak2;
      var leadingWhitespace = "";
      if (node.sameline && node.leadingWhitespace) {
        leadingWhitespace = " ";
      }
      if (node.sameline) {
        return [
          leadingWhitespace,
          "%",
          ..._printRaw2(node.content),
          suffix
        ];
      }
      return [linebreak2, "%", ..._printRaw2(node.content), suffix];
    case "environment":
    case "mathenv":
    case "verbatim":
      var env = _printRaw2(node.env);
      var envStart = [ESCAPE2 + "begin{", ...env, "}"];
      var envEnd = [ESCAPE2 + "end{", ...env, "}"];
      argsString = node.args == null ? [] : _printRaw2(node.args);
      return [
        ...envStart,
        ...argsString,
        ..._printRaw2(node.content),
        ...envEnd
      ];
    case "displaymath":
      return [ESCAPE2 + "[", ..._printRaw2(node.content), ESCAPE2 + "]"];
    case "group":
      return ["{", ..._printRaw2(node.content), "}"];
    case "inlinemath":
      return ["$", ..._printRaw2(node.content), "$"];
    case "macro":
      argsString = node.args == null ? [] : _printRaw2(node.args);
      escape = node.escapeToken == null ? ESCAPE2 : node.escapeToken;
      return [escape, ..._printRaw2(node.content), ...argsString];
    case "parbreak":
      return [linebreak2, linebreak2];
    case "string":
      return [node.content];
    case "verb":
      return [
        ESCAPE2,
        node.env,
        node.escape,
        ..._printRaw2(node.content),
        node.escape
      ];
    case "whitespace":
      return [" "];
    default:
      console.warn(
        "Cannot find render for node ",
        node,
        `(of type ${typeof node})`
      );
      return ["" + node];
  }
}
function printRaw2(node, options) {
  const asArray = options != null ? options.asArray : false;
  const printedTokens = _printRaw2(node);
  if (asArray) {
    return printedTokens;
  }
  return printedTokens.map((x) => x === linebreak2 ? "\n" : x).join("");
}
function createMacroMatcher2(macros15) {
  const macrosHash = Array.isArray(macros15) ? macros15.length > 0 ? typeof macros15[0] === "string" ? Object.fromEntries(
    macros15.map((macro262) => {
      if (typeof macro262 !== "string") {
        throw new Error("Wrong branch of map function");
      }
      return [macro262, {}];
    })
  ) : Object.fromEntries(
    macros15.map((macro262) => {
      if (typeof macro262 === "string") {
        throw new Error("Wrong branch of map function");
      }
      if (macro262.escapeToken != null) {
        return [
          macro262.content,
          { escapeToken: macro262.escapeToken }
        ];
      }
      return [macro262.content, {}];
    })
  ) : {} : macros15;
  return function matchAgainstMacros(node) {
    if (node == null || node.type !== "macro") {
      return false;
    }
    const spec = macrosHash[node.content];
    if (!spec) {
      return false;
    }
    if (typeof spec === "object" && "escapeToken" in spec) {
      return spec.escapeToken == null || spec.escapeToken === node.escapeToken;
    }
    return true;
  };
}
function createEnvironmentMatcher2(macros15) {
  const environmentsHash = Array.isArray(macros15) ? Object.fromEntries(
    macros15.map((str) => {
      return [str, {}];
    })
  ) : macros15;
  return function matchAgainstEnvironments(node) {
    if (!match2.anyEnvironment(node)) {
      return false;
    }
    const envName = printRaw2(node.env);
    const spec = environmentsHash[envName];
    if (!spec) {
      return false;
    }
    return true;
  };
}
var match2 = {
  macro(node, macroName) {
    if (node == null) {
      return false;
    }
    return node.type === "macro" && (macroName == null || node.content === macroName);
  },
  anyMacro(node) {
    return match2.macro(node);
  },
  environment(node, envName) {
    if (node == null) {
      return false;
    }
    return (node.type === "environment" || node.type === "mathenv") && (envName == null || printRaw2(node.env) === envName);
  },
  anyEnvironment(node) {
    return match2.environment(node);
  },
  comment(node) {
    if (node == null) {
      return false;
    }
    return node.type === "comment";
  },
  parbreak(node) {
    if (node == null) {
      return false;
    }
    return node.type === "parbreak";
  },
  whitespace(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace";
  },
  /**
   * Matches whitespace or a comment with leading whitespace.
   */
  whitespaceLike(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace" || node.type === "whitespace" && node.leadingWhitespace === true;
  },
  string(node, value) {
    if (node == null) {
      return false;
    }
    return node.type === "string" && (value == null || node.content === value);
  },
  anyString(node) {
    return match2.string(node);
  },
  group(node) {
    if (node == null) {
      return false;
    }
    return node.type === "group";
  },
  argument(node) {
    if (node == null) {
      return false;
    }
    return node.type === "argument";
  },
  blankArgument(node) {
    if (!match2.argument(node)) {
      return false;
    }
    return node.openMark === "" && node.closeMark === "" && node.content.length === 0;
  },
  math(node) {
    if (node == null) {
      return false;
    }
    return node.type === "displaymath" || node.type === "inlinemath";
  },
  createMacroMatcher: createMacroMatcher2,
  createEnvironmentMatcher: createEnvironmentMatcher2
};
var {
  anyEnvironment: anyEnvironment2,
  anyMacro: anyMacro2,
  anyString: anyString2,
  argument: argument2,
  blankArgument: blankArgument2,
  comment: comment2,
  environment: environment2,
  group: group2,
  macro: macro2,
  math: math2,
  parbreak: parbreak2,
  string: string2,
  whitespace: whitespace2
} = match2;
var CONTINUE = Symbol("continue");
var SKIP = Symbol("skip");
var EXIT = Symbol("exit");
function updateRenderInfo(node, renderInfo) {
  if (renderInfo != null) {
    node._renderInfo = { ...node._renderInfo || {}, ...renderInfo };
  }
  return node;
}
var linebreak3 = Symbol("linebreak");
var ESCAPE3 = "\\";
function _printRaw3(node) {
  if (typeof node === "string") {
    return [node];
  }
  if (Array.isArray(node)) {
    return [].concat(
      ...node.map((n) => _printRaw3(n))
    );
  }
  let argsString, escape;
  switch (node.type) {
    case "root":
      return _printRaw3(node.content);
    case "argument":
      return [node.openMark, ..._printRaw3(node.content), node.closeMark];
    case "comment":
      var suffix = node.suffixParbreak ? "" : linebreak3;
      var leadingWhitespace = "";
      if (node.sameline && node.leadingWhitespace) {
        leadingWhitespace = " ";
      }
      if (node.sameline) {
        return [
          leadingWhitespace,
          "%",
          ..._printRaw3(node.content),
          suffix
        ];
      }
      return [linebreak3, "%", ..._printRaw3(node.content), suffix];
    case "environment":
    case "mathenv":
    case "verbatim":
      var env = _printRaw3(node.env);
      var envStart = [ESCAPE3 + "begin{", ...env, "}"];
      var envEnd = [ESCAPE3 + "end{", ...env, "}"];
      argsString = node.args == null ? [] : _printRaw3(node.args);
      return [
        ...envStart,
        ...argsString,
        ..._printRaw3(node.content),
        ...envEnd
      ];
    case "displaymath":
      return [ESCAPE3 + "[", ..._printRaw3(node.content), ESCAPE3 + "]"];
    case "group":
      return ["{", ..._printRaw3(node.content), "}"];
    case "inlinemath":
      return ["$", ..._printRaw3(node.content), "$"];
    case "macro":
      argsString = node.args == null ? [] : _printRaw3(node.args);
      escape = node.escapeToken == null ? ESCAPE3 : node.escapeToken;
      return [escape, ..._printRaw3(node.content), ...argsString];
    case "parbreak":
      return [linebreak3, linebreak3];
    case "string":
      return [node.content];
    case "verb":
      return [
        ESCAPE3,
        node.env,
        node.escape,
        ..._printRaw3(node.content),
        node.escape
      ];
    case "whitespace":
      return [" "];
    default:
      console.warn(
        "Cannot find render for node ",
        node,
        `(of type ${typeof node})`
      );
      return ["" + node];
  }
}
function printRaw3(node, options) {
  const asArray = options != null ? options.asArray : false;
  const printedTokens = _printRaw3(node);
  if (asArray) {
    return printedTokens;
  }
  return printedTokens.map((x) => x === linebreak3 ? "\n" : x).join("");
}
function createMacroMatcher3(macros15) {
  const macrosHash = Array.isArray(macros15) ? macros15.length > 0 ? typeof macros15[0] === "string" ? Object.fromEntries(
    macros15.map((macro2222) => {
      if (typeof macro2222 !== "string") {
        throw new Error("Wrong branch of map function");
      }
      return [macro2222, {}];
    })
  ) : Object.fromEntries(
    macros15.map((macro2222) => {
      if (typeof macro2222 === "string") {
        throw new Error("Wrong branch of map function");
      }
      if (macro2222.escapeToken != null) {
        return [
          macro2222.content,
          { escapeToken: macro2222.escapeToken }
        ];
      }
      return [macro2222.content, {}];
    })
  ) : {} : macros15;
  return function matchAgainstMacros(node) {
    if (node == null || node.type !== "macro") {
      return false;
    }
    const spec = macrosHash[node.content];
    if (!spec) {
      return false;
    }
    if (typeof spec === "object" && "escapeToken" in spec) {
      return spec.escapeToken == null || spec.escapeToken === node.escapeToken;
    }
    return true;
  };
}
function createEnvironmentMatcher3(macros15) {
  const environmentsHash = Array.isArray(macros15) ? Object.fromEntries(
    macros15.map((str) => {
      return [str, {}];
    })
  ) : macros15;
  return function matchAgainstEnvironments(node) {
    if (!match3.anyEnvironment(node)) {
      return false;
    }
    const envName = printRaw3(node.env);
    const spec = environmentsHash[envName];
    if (!spec) {
      return false;
    }
    return true;
  };
}
var match3 = {
  macro(node, macroName) {
    if (node == null) {
      return false;
    }
    return node.type === "macro" && (macroName == null || node.content === macroName);
  },
  anyMacro(node) {
    return match3.macro(node);
  },
  environment(node, envName) {
    if (node == null) {
      return false;
    }
    return (node.type === "environment" || node.type === "mathenv") && (envName == null || printRaw3(node.env) === envName);
  },
  anyEnvironment(node) {
    return match3.environment(node);
  },
  comment(node) {
    if (node == null) {
      return false;
    }
    return node.type === "comment";
  },
  parbreak(node) {
    if (node == null) {
      return false;
    }
    return node.type === "parbreak";
  },
  whitespace(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace";
  },
  /**
   * Matches whitespace or a comment with leading whitespace.
   */
  whitespaceLike(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace" || node.type === "whitespace" && node.leadingWhitespace === true;
  },
  string(node, value) {
    if (node == null) {
      return false;
    }
    return node.type === "string" && (value == null || node.content === value);
  },
  anyString(node) {
    return match3.string(node);
  },
  group(node) {
    if (node == null) {
      return false;
    }
    return node.type === "group";
  },
  argument(node) {
    if (node == null) {
      return false;
    }
    return node.type === "argument";
  },
  blankArgument(node) {
    if (!match3.argument(node)) {
      return false;
    }
    return node.openMark === "" && node.closeMark === "" && node.content.length === 0;
  },
  math(node) {
    if (node == null) {
      return false;
    }
    return node.type === "displaymath" || node.type === "inlinemath";
  },
  createMacroMatcher: createMacroMatcher3,
  createEnvironmentMatcher: createEnvironmentMatcher3
};
var {
  anyEnvironment: anyEnvironment3,
  anyMacro: anyMacro3,
  anyString: anyString3,
  argument: argument3,
  blankArgument: blankArgument3,
  comment: comment3,
  environment: environment3,
  group: group3,
  macro: macro3,
  math: math3,
  parbreak: parbreak3,
  string: string3,
  whitespace: whitespace3
} = match3;
var CONTINUE2 = Symbol("continue");
var SKIP2 = Symbol("skip");
var EXIT2 = Symbol("exit");
var linebreak22 = Symbol("linebreak");
var ESCAPE22 = "\\";
function _printRaw22(node) {
  if (typeof node === "string") {
    return [node];
  }
  if (Array.isArray(node)) {
    return [].concat(
      ...node.map((n) => _printRaw22(n))
    );
  }
  let argsString, escape;
  switch (node.type) {
    case "root":
      return _printRaw22(node.content);
    case "argument":
      return [node.openMark, ..._printRaw22(node.content), node.closeMark];
    case "comment":
      var suffix = node.suffixParbreak ? "" : linebreak22;
      var leadingWhitespace = "";
      if (node.sameline && node.leadingWhitespace) {
        leadingWhitespace = " ";
      }
      if (node.sameline) {
        return [
          leadingWhitespace,
          "%",
          ..._printRaw22(node.content),
          suffix
        ];
      }
      return [linebreak22, "%", ..._printRaw22(node.content), suffix];
    case "environment":
    case "mathenv":
    case "verbatim":
      var env = _printRaw22(node.env);
      var envStart = [ESCAPE22 + "begin{", ...env, "}"];
      var envEnd = [ESCAPE22 + "end{", ...env, "}"];
      argsString = node.args == null ? [] : _printRaw22(node.args);
      return [
        ...envStart,
        ...argsString,
        ..._printRaw22(node.content),
        ...envEnd
      ];
    case "displaymath":
      return [ESCAPE22 + "[", ..._printRaw22(node.content), ESCAPE22 + "]"];
    case "group":
      return ["{", ..._printRaw22(node.content), "}"];
    case "inlinemath":
      return ["$", ..._printRaw22(node.content), "$"];
    case "macro":
      argsString = node.args == null ? [] : _printRaw22(node.args);
      escape = node.escapeToken == null ? ESCAPE22 : node.escapeToken;
      return [escape, ..._printRaw22(node.content), ...argsString];
    case "parbreak":
      return [linebreak22, linebreak22];
    case "string":
      return [node.content];
    case "verb":
      return [
        ESCAPE22,
        node.env,
        node.escape,
        ..._printRaw22(node.content),
        node.escape
      ];
    case "whitespace":
      return [" "];
    default:
      console.warn(
        "Cannot find render for node ",
        node,
        `(of type ${typeof node})`
      );
      return ["" + node];
  }
}
function printRaw22(node, options) {
  const asArray = options != null ? options.asArray : false;
  const printedTokens = _printRaw22(node);
  if (asArray) {
    return printedTokens;
  }
  return printedTokens.map((x) => x === linebreak22 ? "\n" : x).join("");
}
function createMacroMatcher22(macros15) {
  const macrosHash = Array.isArray(macros15) ? macros15.length > 0 ? typeof macros15[0] === "string" ? Object.fromEntries(
    macros15.map((macro2222) => {
      if (typeof macro2222 !== "string") {
        throw new Error("Wrong branch of map function");
      }
      return [macro2222, {}];
    })
  ) : Object.fromEntries(
    macros15.map((macro2222) => {
      if (typeof macro2222 === "string") {
        throw new Error("Wrong branch of map function");
      }
      if (macro2222.escapeToken != null) {
        return [
          macro2222.content,
          { escapeToken: macro2222.escapeToken }
        ];
      }
      return [macro2222.content, {}];
    })
  ) : {} : macros15;
  return function matchAgainstMacros(node) {
    if (node == null || node.type !== "macro") {
      return false;
    }
    const spec = macrosHash[node.content];
    if (!spec) {
      return false;
    }
    if (typeof spec === "object" && "escapeToken" in spec) {
      return spec.escapeToken == null || spec.escapeToken === node.escapeToken;
    }
    return true;
  };
}
function createEnvironmentMatcher22(macros15) {
  const environmentsHash = Array.isArray(macros15) ? Object.fromEntries(
    macros15.map((str) => {
      return [str, {}];
    })
  ) : macros15;
  return function matchAgainstEnvironments(node) {
    if (!match22.anyEnvironment(node)) {
      return false;
    }
    const envName = printRaw22(node.env);
    const spec = environmentsHash[envName];
    if (!spec) {
      return false;
    }
    return true;
  };
}
var match22 = {
  macro(node, macroName) {
    if (node == null) {
      return false;
    }
    return node.type === "macro" && (macroName == null || node.content === macroName);
  },
  anyMacro(node) {
    return match22.macro(node);
  },
  environment(node, envName) {
    if (node == null) {
      return false;
    }
    return (node.type === "environment" || node.type === "mathenv") && (envName == null || printRaw22(node.env) === envName);
  },
  anyEnvironment(node) {
    return match22.environment(node);
  },
  comment(node) {
    if (node == null) {
      return false;
    }
    return node.type === "comment";
  },
  parbreak(node) {
    if (node == null) {
      return false;
    }
    return node.type === "parbreak";
  },
  whitespace(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace";
  },
  /**
   * Matches whitespace or a comment with leading whitespace.
   */
  whitespaceLike(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace" || node.type === "whitespace" && node.leadingWhitespace === true;
  },
  string(node, value) {
    if (node == null) {
      return false;
    }
    return node.type === "string" && (value == null || node.content === value);
  },
  anyString(node) {
    return match22.string(node);
  },
  group(node) {
    if (node == null) {
      return false;
    }
    return node.type === "group";
  },
  argument(node) {
    if (node == null) {
      return false;
    }
    return node.type === "argument";
  },
  blankArgument(node) {
    if (!match22.argument(node)) {
      return false;
    }
    return node.openMark === "" && node.closeMark === "" && node.content.length === 0;
  },
  math(node) {
    if (node == null) {
      return false;
    }
    return node.type === "displaymath" || node.type === "inlinemath";
  },
  createMacroMatcher: createMacroMatcher22,
  createEnvironmentMatcher: createEnvironmentMatcher22
};
var {
  anyEnvironment: anyEnvironment22,
  anyMacro: anyMacro22,
  anyString: anyString22,
  argument: argument22,
  blankArgument: blankArgument22,
  comment: comment22,
  environment: environment22,
  group: group22,
  macro: macro22,
  math: math22,
  parbreak: parbreak22,
  string: string22,
  whitespace: whitespace22
} = match22;
var linebreak32 = Symbol("linebreak");
var ESCAPE32 = "\\";
function _printRaw32(node) {
  if (typeof node === "string") {
    return [node];
  }
  if (Array.isArray(node)) {
    return [].concat(
      ...node.map((n) => _printRaw32(n))
    );
  }
  let argsString, escape;
  switch (node.type) {
    case "root":
      return _printRaw32(node.content);
    case "argument":
      return [node.openMark, ..._printRaw32(node.content), node.closeMark];
    case "comment":
      var suffix = node.suffixParbreak ? "" : linebreak32;
      var leadingWhitespace = "";
      if (node.sameline && node.leadingWhitespace) {
        leadingWhitespace = " ";
      }
      if (node.sameline) {
        return [
          leadingWhitespace,
          "%",
          ..._printRaw32(node.content),
          suffix
        ];
      }
      return [linebreak32, "%", ..._printRaw32(node.content), suffix];
    case "environment":
    case "mathenv":
    case "verbatim":
      var env = _printRaw32(node.env);
      var envStart = [ESCAPE32 + "begin{", ...env, "}"];
      var envEnd = [ESCAPE32 + "end{", ...env, "}"];
      argsString = node.args == null ? [] : _printRaw32(node.args);
      return [
        ...envStart,
        ...argsString,
        ..._printRaw32(node.content),
        ...envEnd
      ];
    case "displaymath":
      return [ESCAPE32 + "[", ..._printRaw32(node.content), ESCAPE32 + "]"];
    case "group":
      return ["{", ..._printRaw32(node.content), "}"];
    case "inlinemath":
      return ["$", ..._printRaw32(node.content), "$"];
    case "macro":
      argsString = node.args == null ? [] : _printRaw32(node.args);
      escape = node.escapeToken == null ? ESCAPE32 : node.escapeToken;
      return [escape, ..._printRaw32(node.content), ...argsString];
    case "parbreak":
      return [linebreak32, linebreak32];
    case "string":
      return [node.content];
    case "verb":
      return [
        ESCAPE32,
        node.env,
        node.escape,
        ..._printRaw32(node.content),
        node.escape
      ];
    case "whitespace":
      return [" "];
    default:
      console.warn(
        "Cannot find render for node ",
        node,
        `(of type ${typeof node})`
      );
      return ["" + node];
  }
}
function printRaw32(node, options) {
  const asArray = options != null ? options.asArray : false;
  const printedTokens = _printRaw32(node);
  if (asArray) {
    return printedTokens;
  }
  return printedTokens.map((x) => x === linebreak32 ? "\n" : x).join("");
}
function createMacroMatcher32(macros15) {
  const macrosHash = Array.isArray(macros15) ? macros15.length > 0 ? typeof macros15[0] === "string" ? Object.fromEntries(
    macros15.map((macro2222) => {
      if (typeof macro2222 !== "string") {
        throw new Error("Wrong branch of map function");
      }
      return [macro2222, {}];
    })
  ) : Object.fromEntries(
    macros15.map((macro2222) => {
      if (typeof macro2222 === "string") {
        throw new Error("Wrong branch of map function");
      }
      if (macro2222.escapeToken != null) {
        return [
          macro2222.content,
          { escapeToken: macro2222.escapeToken }
        ];
      }
      return [macro2222.content, {}];
    })
  ) : {} : macros15;
  return function matchAgainstMacros(node) {
    if (node == null || node.type !== "macro") {
      return false;
    }
    const spec = macrosHash[node.content];
    if (!spec) {
      return false;
    }
    if (typeof spec === "object" && "escapeToken" in spec) {
      return spec.escapeToken == null || spec.escapeToken === node.escapeToken;
    }
    return true;
  };
}
function createEnvironmentMatcher32(macros15) {
  const environmentsHash = Array.isArray(macros15) ? Object.fromEntries(
    macros15.map((str) => {
      return [str, {}];
    })
  ) : macros15;
  return function matchAgainstEnvironments(node) {
    if (!match32.anyEnvironment(node)) {
      return false;
    }
    const envName = printRaw32(node.env);
    const spec = environmentsHash[envName];
    if (!spec) {
      return false;
    }
    return true;
  };
}
var match32 = {
  macro(node, macroName) {
    if (node == null) {
      return false;
    }
    return node.type === "macro" && (macroName == null || node.content === macroName);
  },
  anyMacro(node) {
    return match32.macro(node);
  },
  environment(node, envName) {
    if (node == null) {
      return false;
    }
    return (node.type === "environment" || node.type === "mathenv") && (envName == null || printRaw32(node.env) === envName);
  },
  anyEnvironment(node) {
    return match32.environment(node);
  },
  comment(node) {
    if (node == null) {
      return false;
    }
    return node.type === "comment";
  },
  parbreak(node) {
    if (node == null) {
      return false;
    }
    return node.type === "parbreak";
  },
  whitespace(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace";
  },
  /**
   * Matches whitespace or a comment with leading whitespace.
   */
  whitespaceLike(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace" || node.type === "whitespace" && node.leadingWhitespace === true;
  },
  string(node, value) {
    if (node == null) {
      return false;
    }
    return node.type === "string" && (value == null || node.content === value);
  },
  anyString(node) {
    return match32.string(node);
  },
  group(node) {
    if (node == null) {
      return false;
    }
    return node.type === "group";
  },
  argument(node) {
    if (node == null) {
      return false;
    }
    return node.type === "argument";
  },
  blankArgument(node) {
    if (!match32.argument(node)) {
      return false;
    }
    return node.openMark === "" && node.closeMark === "" && node.content.length === 0;
  },
  math(node) {
    if (node == null) {
      return false;
    }
    return node.type === "displaymath" || node.type === "inlinemath";
  },
  createMacroMatcher: createMacroMatcher32,
  createEnvironmentMatcher: createEnvironmentMatcher32
};
var {
  anyEnvironment: anyEnvironment32,
  anyMacro: anyMacro32,
  anyString: anyString32,
  argument: argument32,
  blankArgument: blankArgument32,
  comment: comment32,
  environment: environment32,
  group: group32,
  macro: macro32,
  math: math32,
  parbreak: parbreak32,
  string: string32,
  whitespace: whitespace32
} = match32;
var CONTINUE22 = Symbol("continue");
var SKIP22 = Symbol("skip");
var EXIT22 = Symbol("exit");
var linebreak4 = Symbol("linebreak");
var ESCAPE4 = "\\";
function _printRaw4(node) {
  if (typeof node === "string") {
    return [node];
  }
  if (Array.isArray(node)) {
    return [].concat(
      ...node.map((n) => _printRaw4(n))
    );
  }
  let argsString, escape;
  switch (node.type) {
    case "root":
      return _printRaw4(node.content);
    case "argument":
      return [node.openMark, ..._printRaw4(node.content), node.closeMark];
    case "comment":
      var suffix = node.suffixParbreak ? "" : linebreak4;
      var leadingWhitespace = "";
      if (node.sameline && node.leadingWhitespace) {
        leadingWhitespace = " ";
      }
      if (node.sameline) {
        return [
          leadingWhitespace,
          "%",
          ..._printRaw4(node.content),
          suffix
        ];
      }
      return [linebreak4, "%", ..._printRaw4(node.content), suffix];
    case "environment":
    case "mathenv":
    case "verbatim":
      var env = _printRaw4(node.env);
      var envStart = [ESCAPE4 + "begin{", ...env, "}"];
      var envEnd = [ESCAPE4 + "end{", ...env, "}"];
      argsString = node.args == null ? [] : _printRaw4(node.args);
      return [
        ...envStart,
        ...argsString,
        ..._printRaw4(node.content),
        ...envEnd
      ];
    case "displaymath":
      return [ESCAPE4 + "[", ..._printRaw4(node.content), ESCAPE4 + "]"];
    case "group":
      return ["{", ..._printRaw4(node.content), "}"];
    case "inlinemath":
      return ["$", ..._printRaw4(node.content), "$"];
    case "macro":
      argsString = node.args == null ? [] : _printRaw4(node.args);
      escape = node.escapeToken == null ? ESCAPE4 : node.escapeToken;
      return [escape, ..._printRaw4(node.content), ...argsString];
    case "parbreak":
      return [linebreak4, linebreak4];
    case "string":
      return [node.content];
    case "verb":
      return [
        ESCAPE4,
        node.env,
        node.escape,
        ..._printRaw4(node.content),
        node.escape
      ];
    case "whitespace":
      return [" "];
    default:
      console.warn(
        "Cannot find render for node ",
        node,
        `(of type ${typeof node})`
      );
      return ["" + node];
  }
}
function printRaw4(node, options) {
  const asArray = options != null ? options.asArray : false;
  const printedTokens = _printRaw4(node);
  if (asArray) {
    return printedTokens;
  }
  return printedTokens.map((x) => x === linebreak4 ? "\n" : x).join("");
}
function createMacroMatcher4(macros15) {
  const macrosHash = Array.isArray(macros15) ? macros15.length > 0 ? typeof macros15[0] === "string" ? Object.fromEntries(
    macros15.map((macro2222) => {
      if (typeof macro2222 !== "string") {
        throw new Error("Wrong branch of map function");
      }
      return [macro2222, {}];
    })
  ) : Object.fromEntries(
    macros15.map((macro2222) => {
      if (typeof macro2222 === "string") {
        throw new Error("Wrong branch of map function");
      }
      if (macro2222.escapeToken != null) {
        return [
          macro2222.content,
          { escapeToken: macro2222.escapeToken }
        ];
      }
      return [macro2222.content, {}];
    })
  ) : {} : macros15;
  return function matchAgainstMacros(node) {
    if (node == null || node.type !== "macro") {
      return false;
    }
    const spec = macrosHash[node.content];
    if (!spec) {
      return false;
    }
    if (typeof spec === "object" && "escapeToken" in spec) {
      return spec.escapeToken == null || spec.escapeToken === node.escapeToken;
    }
    return true;
  };
}
function createEnvironmentMatcher4(macros15) {
  const environmentsHash = Array.isArray(macros15) ? Object.fromEntries(
    macros15.map((str) => {
      return [str, {}];
    })
  ) : macros15;
  return function matchAgainstEnvironments(node) {
    if (!match4.anyEnvironment(node)) {
      return false;
    }
    const envName = printRaw4(node.env);
    const spec = environmentsHash[envName];
    if (!spec) {
      return false;
    }
    return true;
  };
}
var match4 = {
  macro(node, macroName) {
    if (node == null) {
      return false;
    }
    return node.type === "macro" && (macroName == null || node.content === macroName);
  },
  anyMacro(node) {
    return match4.macro(node);
  },
  environment(node, envName) {
    if (node == null) {
      return false;
    }
    return (node.type === "environment" || node.type === "mathenv") && (envName == null || printRaw4(node.env) === envName);
  },
  anyEnvironment(node) {
    return match4.environment(node);
  },
  comment(node) {
    if (node == null) {
      return false;
    }
    return node.type === "comment";
  },
  parbreak(node) {
    if (node == null) {
      return false;
    }
    return node.type === "parbreak";
  },
  whitespace(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace";
  },
  /**
   * Matches whitespace or a comment with leading whitespace.
   */
  whitespaceLike(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace" || node.type === "whitespace" && node.leadingWhitespace === true;
  },
  string(node, value) {
    if (node == null) {
      return false;
    }
    return node.type === "string" && (value == null || node.content === value);
  },
  anyString(node) {
    return match4.string(node);
  },
  group(node) {
    if (node == null) {
      return false;
    }
    return node.type === "group";
  },
  argument(node) {
    if (node == null) {
      return false;
    }
    return node.type === "argument";
  },
  blankArgument(node) {
    if (!match4.argument(node)) {
      return false;
    }
    return node.openMark === "" && node.closeMark === "" && node.content.length === 0;
  },
  math(node) {
    if (node == null) {
      return false;
    }
    return node.type === "displaymath" || node.type === "inlinemath";
  },
  createMacroMatcher: createMacroMatcher4,
  createEnvironmentMatcher: createEnvironmentMatcher4
};
var {
  anyEnvironment: anyEnvironment4,
  anyMacro: anyMacro4,
  anyString: anyString4,
  argument: argument4,
  blankArgument: blankArgument4,
  comment: comment4,
  environment: environment4,
  group: group4,
  macro: macro4,
  math: math4,
  parbreak: parbreak4,
  string: string4,
  whitespace: whitespace4
} = match4;
function lastSignificantNodeIndex(nodes, parbreaksAreInsignificant) {
  for (let i = nodes.length - 1; i >= 0; i--) {
    const node = nodes[i];
    if (match22.whitespace(node) || match22.comment(node) || parbreaksAreInsignificant && match22.parbreak(node)) {
      continue;
    }
    return i;
  }
  return void 0;
}
var linebreak5 = Symbol("linebreak");
var ESCAPE5 = "\\";
function _printRaw5(node) {
  if (typeof node === "string") {
    return [node];
  }
  if (Array.isArray(node)) {
    return [].concat(
      ...node.map((n) => _printRaw5(n))
    );
  }
  let argsString, escape;
  switch (node.type) {
    case "root":
      return _printRaw5(node.content);
    case "argument":
      return [node.openMark, ..._printRaw5(node.content), node.closeMark];
    case "comment":
      var suffix = node.suffixParbreak ? "" : linebreak5;
      var leadingWhitespace = "";
      if (node.sameline && node.leadingWhitespace) {
        leadingWhitespace = " ";
      }
      if (node.sameline) {
        return [
          leadingWhitespace,
          "%",
          ..._printRaw5(node.content),
          suffix
        ];
      }
      return [linebreak5, "%", ..._printRaw5(node.content), suffix];
    case "environment":
    case "mathenv":
    case "verbatim":
      var env = _printRaw5(node.env);
      var envStart = [ESCAPE5 + "begin{", ...env, "}"];
      var envEnd = [ESCAPE5 + "end{", ...env, "}"];
      argsString = node.args == null ? [] : _printRaw5(node.args);
      return [
        ...envStart,
        ...argsString,
        ..._printRaw5(node.content),
        ...envEnd
      ];
    case "displaymath":
      return [ESCAPE5 + "[", ..._printRaw5(node.content), ESCAPE5 + "]"];
    case "group":
      return ["{", ..._printRaw5(node.content), "}"];
    case "inlinemath":
      return ["$", ..._printRaw5(node.content), "$"];
    case "macro":
      argsString = node.args == null ? [] : _printRaw5(node.args);
      escape = node.escapeToken == null ? ESCAPE5 : node.escapeToken;
      return [escape, ..._printRaw5(node.content), ...argsString];
    case "parbreak":
      return [linebreak5, linebreak5];
    case "string":
      return [node.content];
    case "verb":
      return [
        ESCAPE5,
        node.env,
        node.escape,
        ..._printRaw5(node.content),
        node.escape
      ];
    case "whitespace":
      return [" "];
    default:
      console.warn(
        "Cannot find render for node ",
        node,
        `(of type ${typeof node})`
      );
      return ["" + node];
  }
}
function printRaw5(node, options) {
  const asArray = options != null ? options.asArray : false;
  const printedTokens = _printRaw5(node);
  if (asArray) {
    return printedTokens;
  }
  return printedTokens.map((x) => x === linebreak5 ? "\n" : x).join("");
}
function createMacroMatcher5(macros15) {
  const macrosHash = Array.isArray(macros15) ? macros15.length > 0 ? typeof macros15[0] === "string" ? Object.fromEntries(
    macros15.map((macro262) => {
      if (typeof macro262 !== "string") {
        throw new Error("Wrong branch of map function");
      }
      return [macro262, {}];
    })
  ) : Object.fromEntries(
    macros15.map((macro262) => {
      if (typeof macro262 === "string") {
        throw new Error("Wrong branch of map function");
      }
      if (macro262.escapeToken != null) {
        return [
          macro262.content,
          { escapeToken: macro262.escapeToken }
        ];
      }
      return [macro262.content, {}];
    })
  ) : {} : macros15;
  return function matchAgainstMacros(node) {
    if (node == null || node.type !== "macro") {
      return false;
    }
    const spec = macrosHash[node.content];
    if (!spec) {
      return false;
    }
    if (typeof spec === "object" && "escapeToken" in spec) {
      return spec.escapeToken == null || spec.escapeToken === node.escapeToken;
    }
    return true;
  };
}
function createEnvironmentMatcher5(macros15) {
  const environmentsHash = Array.isArray(macros15) ? Object.fromEntries(
    macros15.map((str) => {
      return [str, {}];
    })
  ) : macros15;
  return function matchAgainstEnvironments(node) {
    if (!match5.anyEnvironment(node)) {
      return false;
    }
    const envName = printRaw5(node.env);
    const spec = environmentsHash[envName];
    if (!spec) {
      return false;
    }
    return true;
  };
}
var match5 = {
  macro(node, macroName) {
    if (node == null) {
      return false;
    }
    return node.type === "macro" && (macroName == null || node.content === macroName);
  },
  anyMacro(node) {
    return match5.macro(node);
  },
  environment(node, envName) {
    if (node == null) {
      return false;
    }
    return (node.type === "environment" || node.type === "mathenv") && (envName == null || printRaw5(node.env) === envName);
  },
  anyEnvironment(node) {
    return match5.environment(node);
  },
  comment(node) {
    if (node == null) {
      return false;
    }
    return node.type === "comment";
  },
  parbreak(node) {
    if (node == null) {
      return false;
    }
    return node.type === "parbreak";
  },
  whitespace(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace";
  },
  /**
   * Matches whitespace or a comment with leading whitespace.
   */
  whitespaceLike(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace" || node.type === "whitespace" && node.leadingWhitespace === true;
  },
  string(node, value) {
    if (node == null) {
      return false;
    }
    return node.type === "string" && (value == null || node.content === value);
  },
  anyString(node) {
    return match5.string(node);
  },
  group(node) {
    if (node == null) {
      return false;
    }
    return node.type === "group";
  },
  argument(node) {
    if (node == null) {
      return false;
    }
    return node.type === "argument";
  },
  blankArgument(node) {
    if (!match5.argument(node)) {
      return false;
    }
    return node.openMark === "" && node.closeMark === "" && node.content.length === 0;
  },
  math(node) {
    if (node == null) {
      return false;
    }
    return node.type === "displaymath" || node.type === "inlinemath";
  },
  createMacroMatcher: createMacroMatcher5,
  createEnvironmentMatcher: createEnvironmentMatcher5
};
var {
  anyEnvironment: anyEnvironment5,
  anyMacro: anyMacro5,
  anyString: anyString5,
  argument: argument5,
  blankArgument: blankArgument5,
  comment: comment5,
  environment: environment5,
  group: group5,
  macro: macro5,
  math: math5,
  parbreak: parbreak5,
  string: string5,
  whitespace: whitespace5
} = match5;
function splitOnCondition(nodes, splitFunc = () => false, options) {
  if (!Array.isArray(nodes)) {
    throw new Error(`Can only split an Array, not ${nodes}`);
  }
  const { onlySplitOnFirstOccurrence = false } = options || {};
  const splitIndices = [];
  for (let i = 0; i < nodes.length; i++) {
    if (splitFunc(nodes[i])) {
      splitIndices.push(i);
      if (onlySplitOnFirstOccurrence) {
        break;
      }
    }
  }
  if (splitIndices.length === 0) {
    return { segments: [nodes], separators: [] };
  }
  let separators = splitIndices.map((i) => nodes[i]);
  let segments = splitIndices.map((splitEnd, i) => {
    const splitStart = i === 0 ? 0 : splitIndices[i - 1] + 1;
    return nodes.slice(splitStart, splitEnd);
  });
  segments.push(
    nodes.slice(splitIndices[splitIndices.length - 1] + 1, nodes.length)
  );
  return { segments, separators };
}
function splitOnMacro(ast, macroName) {
  if (typeof macroName === "string") {
    macroName = [macroName];
  }
  if (!Array.isArray(macroName)) {
    throw new Error("Type coercion failed");
  }
  const isSeparator = match5.createMacroMatcher(macroName);
  const { segments, separators } = splitOnCondition(ast, isSeparator);
  return { segments, macros: separators };
}
var linebreak6 = Symbol("linebreak");
var ESCAPE6 = "\\";
function _printRaw6(node) {
  if (typeof node === "string") {
    return [node];
  }
  if (Array.isArray(node)) {
    return [].concat(
      ...node.map((n) => _printRaw6(n))
    );
  }
  let argsString, escape;
  switch (node.type) {
    case "root":
      return _printRaw6(node.content);
    case "argument":
      return [node.openMark, ..._printRaw6(node.content), node.closeMark];
    case "comment":
      var suffix = node.suffixParbreak ? "" : linebreak6;
      var leadingWhitespace = "";
      if (node.sameline && node.leadingWhitespace) {
        leadingWhitespace = " ";
      }
      if (node.sameline) {
        return [
          leadingWhitespace,
          "%",
          ..._printRaw6(node.content),
          suffix
        ];
      }
      return [linebreak6, "%", ..._printRaw6(node.content), suffix];
    case "environment":
    case "mathenv":
    case "verbatim":
      var env = _printRaw6(node.env);
      var envStart = [ESCAPE6 + "begin{", ...env, "}"];
      var envEnd = [ESCAPE6 + "end{", ...env, "}"];
      argsString = node.args == null ? [] : _printRaw6(node.args);
      return [
        ...envStart,
        ...argsString,
        ..._printRaw6(node.content),
        ...envEnd
      ];
    case "displaymath":
      return [ESCAPE6 + "[", ..._printRaw6(node.content), ESCAPE6 + "]"];
    case "group":
      return ["{", ..._printRaw6(node.content), "}"];
    case "inlinemath":
      return ["$", ..._printRaw6(node.content), "$"];
    case "macro":
      argsString = node.args == null ? [] : _printRaw6(node.args);
      escape = node.escapeToken == null ? ESCAPE6 : node.escapeToken;
      return [escape, ..._printRaw6(node.content), ...argsString];
    case "parbreak":
      return [linebreak6, linebreak6];
    case "string":
      return [node.content];
    case "verb":
      return [
        ESCAPE6,
        node.env,
        node.escape,
        ..._printRaw6(node.content),
        node.escape
      ];
    case "whitespace":
      return [" "];
    default:
      console.warn(
        "Cannot find render for node ",
        node,
        `(of type ${typeof node})`
      );
      return ["" + node];
  }
}
function printRaw6(node, options) {
  const asArray = options != null ? options.asArray : false;
  const printedTokens = _printRaw6(node);
  if (asArray) {
    return printedTokens;
  }
  return printedTokens.map((x) => x === linebreak6 ? "\n" : x).join("");
}
function createMacroMatcher6(macros15) {
  const macrosHash = Array.isArray(macros15) ? macros15.length > 0 ? typeof macros15[0] === "string" ? Object.fromEntries(
    macros15.map((macro2222) => {
      if (typeof macro2222 !== "string") {
        throw new Error("Wrong branch of map function");
      }
      return [macro2222, {}];
    })
  ) : Object.fromEntries(
    macros15.map((macro2222) => {
      if (typeof macro2222 === "string") {
        throw new Error("Wrong branch of map function");
      }
      if (macro2222.escapeToken != null) {
        return [
          macro2222.content,
          { escapeToken: macro2222.escapeToken }
        ];
      }
      return [macro2222.content, {}];
    })
  ) : {} : macros15;
  return function matchAgainstMacros(node) {
    if (node == null || node.type !== "macro") {
      return false;
    }
    const spec = macrosHash[node.content];
    if (!spec) {
      return false;
    }
    if (typeof spec === "object" && "escapeToken" in spec) {
      return spec.escapeToken == null || spec.escapeToken === node.escapeToken;
    }
    return true;
  };
}
function createEnvironmentMatcher6(macros15) {
  const environmentsHash = Array.isArray(macros15) ? Object.fromEntries(
    macros15.map((str) => {
      return [str, {}];
    })
  ) : macros15;
  return function matchAgainstEnvironments(node) {
    if (!match6.anyEnvironment(node)) {
      return false;
    }
    const envName = printRaw6(node.env);
    const spec = environmentsHash[envName];
    if (!spec) {
      return false;
    }
    return true;
  };
}
var match6 = {
  macro(node, macroName) {
    if (node == null) {
      return false;
    }
    return node.type === "macro" && (macroName == null || node.content === macroName);
  },
  anyMacro(node) {
    return match6.macro(node);
  },
  environment(node, envName) {
    if (node == null) {
      return false;
    }
    return (node.type === "environment" || node.type === "mathenv") && (envName == null || printRaw6(node.env) === envName);
  },
  anyEnvironment(node) {
    return match6.environment(node);
  },
  comment(node) {
    if (node == null) {
      return false;
    }
    return node.type === "comment";
  },
  parbreak(node) {
    if (node == null) {
      return false;
    }
    return node.type === "parbreak";
  },
  whitespace(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace";
  },
  /**
   * Matches whitespace or a comment with leading whitespace.
   */
  whitespaceLike(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace" || node.type === "whitespace" && node.leadingWhitespace === true;
  },
  string(node, value) {
    if (node == null) {
      return false;
    }
    return node.type === "string" && (value == null || node.content === value);
  },
  anyString(node) {
    return match6.string(node);
  },
  group(node) {
    if (node == null) {
      return false;
    }
    return node.type === "group";
  },
  argument(node) {
    if (node == null) {
      return false;
    }
    return node.type === "argument";
  },
  blankArgument(node) {
    if (!match6.argument(node)) {
      return false;
    }
    return node.openMark === "" && node.closeMark === "" && node.content.length === 0;
  },
  math(node) {
    if (node == null) {
      return false;
    }
    return node.type === "displaymath" || node.type === "inlinemath";
  },
  createMacroMatcher: createMacroMatcher6,
  createEnvironmentMatcher: createEnvironmentMatcher6
};
var {
  anyEnvironment: anyEnvironment6,
  anyMacro: anyMacro6,
  anyString: anyString6,
  argument: argument6,
  blankArgument: blankArgument6,
  comment: comment6,
  environment: environment6,
  group: group6,
  macro: macro6,
  math: math6,
  parbreak: parbreak6,
  string: string6,
  whitespace: whitespace6
} = match6;
function trim(nodes) {
  if (!Array.isArray(nodes)) {
    console.warn("Trying to trim a non-array ast", nodes);
    return nodes;
  }
  const { trimmedStart } = trimStart(nodes);
  const { trimmedEnd } = trimEnd(nodes);
  return { trimmedStart, trimmedEnd };
}
function trimStart(nodes) {
  const { start } = amountOfLeadingAndTrailingWhitespace(nodes);
  nodes.splice(0, start);
  for (const leadingToken of nodes) {
    if (!match6.comment(leadingToken)) {
      break;
    }
    if (leadingToken.leadingWhitespace || leadingToken.sameline) {
      leadingToken.leadingWhitespace = false;
      delete leadingToken.position;
    }
    if (start > 0 && leadingToken.sameline) {
      leadingToken.sameline = false;
      delete leadingToken.position;
    }
  }
  return { trimmedStart: start };
}
function trimEnd(nodes) {
  const { end } = amountOfLeadingAndTrailingWhitespace(nodes);
  nodes.splice(nodes.length - end, end);
  for (let i = nodes.length - 1; i >= 0; i--) {
    const trailingToken = nodes[i];
    if (!match6.comment(trailingToken)) {
      break;
    }
    delete trailingToken.suffixParbreak;
    if (match6.comment(trailingToken) && trailingToken.leadingWhitespace && !trailingToken.sameline) {
      trailingToken.leadingWhitespace = false;
      delete trailingToken.position;
    }
  }
  return { trimmedEnd: end };
}
function amountOfLeadingAndTrailingWhitespace(ast) {
  let start = 0;
  let end = 0;
  for (const node of ast) {
    if (match6.whitespace(node) || match6.parbreak(node)) {
      start++;
    } else {
      break;
    }
  }
  if (start === ast.length) {
    return { start, end: 0 };
  }
  for (let i = ast.length - 1; i >= 0; i--) {
    const node = ast[i];
    if (match6.whitespace(node) || match6.parbreak(node)) {
      end++;
    } else {
      break;
    }
  }
  return { start, end };
}
var linebreak23 = Symbol("linebreak");
var ESCAPE23 = "\\";
function _printRaw23(node) {
  if (typeof node === "string") {
    return [node];
  }
  if (Array.isArray(node)) {
    return [].concat(
      ...node.map((n) => _printRaw23(n))
    );
  }
  let argsString, escape;
  switch (node.type) {
    case "root":
      return _printRaw23(node.content);
    case "argument":
      return [node.openMark, ..._printRaw23(node.content), node.closeMark];
    case "comment":
      var suffix = node.suffixParbreak ? "" : linebreak23;
      var leadingWhitespace = "";
      if (node.sameline && node.leadingWhitespace) {
        leadingWhitespace = " ";
      }
      if (node.sameline) {
        return [
          leadingWhitespace,
          "%",
          ..._printRaw23(node.content),
          suffix
        ];
      }
      return [linebreak23, "%", ..._printRaw23(node.content), suffix];
    case "environment":
    case "mathenv":
    case "verbatim":
      var env = _printRaw23(node.env);
      var envStart = [ESCAPE23 + "begin{", ...env, "}"];
      var envEnd = [ESCAPE23 + "end{", ...env, "}"];
      argsString = node.args == null ? [] : _printRaw23(node.args);
      return [
        ...envStart,
        ...argsString,
        ..._printRaw23(node.content),
        ...envEnd
      ];
    case "displaymath":
      return [ESCAPE23 + "[", ..._printRaw23(node.content), ESCAPE23 + "]"];
    case "group":
      return ["{", ..._printRaw23(node.content), "}"];
    case "inlinemath":
      return ["$", ..._printRaw23(node.content), "$"];
    case "macro":
      argsString = node.args == null ? [] : _printRaw23(node.args);
      escape = node.escapeToken == null ? ESCAPE23 : node.escapeToken;
      return [escape, ..._printRaw23(node.content), ...argsString];
    case "parbreak":
      return [linebreak23, linebreak23];
    case "string":
      return [node.content];
    case "verb":
      return [
        ESCAPE23,
        node.env,
        node.escape,
        ..._printRaw23(node.content),
        node.escape
      ];
    case "whitespace":
      return [" "];
    default:
      console.warn(
        "Cannot find render for node ",
        node,
        `(of type ${typeof node})`
      );
      return ["" + node];
  }
}
function printRaw23(node, options) {
  const asArray = options != null ? options.asArray : false;
  const printedTokens = _printRaw23(node);
  if (asArray) {
    return printedTokens;
  }
  return printedTokens.map((x) => x === linebreak23 ? "\n" : x).join("");
}
function createMacroMatcher23(macros15) {
  const macrosHash = Array.isArray(macros15) ? macros15.length > 0 ? typeof macros15[0] === "string" ? Object.fromEntries(
    macros15.map((macro2222) => {
      if (typeof macro2222 !== "string") {
        throw new Error("Wrong branch of map function");
      }
      return [macro2222, {}];
    })
  ) : Object.fromEntries(
    macros15.map((macro2222) => {
      if (typeof macro2222 === "string") {
        throw new Error("Wrong branch of map function");
      }
      if (macro2222.escapeToken != null) {
        return [
          macro2222.content,
          { escapeToken: macro2222.escapeToken }
        ];
      }
      return [macro2222.content, {}];
    })
  ) : {} : macros15;
  return function matchAgainstMacros(node) {
    if (node == null || node.type !== "macro") {
      return false;
    }
    const spec = macrosHash[node.content];
    if (!spec) {
      return false;
    }
    if (typeof spec === "object" && "escapeToken" in spec) {
      return spec.escapeToken == null || spec.escapeToken === node.escapeToken;
    }
    return true;
  };
}
function createEnvironmentMatcher23(macros15) {
  const environmentsHash = Array.isArray(macros15) ? Object.fromEntries(
    macros15.map((str) => {
      return [str, {}];
    })
  ) : macros15;
  return function matchAgainstEnvironments(node) {
    if (!match23.anyEnvironment(node)) {
      return false;
    }
    const envName = printRaw23(node.env);
    const spec = environmentsHash[envName];
    if (!spec) {
      return false;
    }
    return true;
  };
}
var match23 = {
  macro(node, macroName) {
    if (node == null) {
      return false;
    }
    return node.type === "macro" && (macroName == null || node.content === macroName);
  },
  anyMacro(node) {
    return match23.macro(node);
  },
  environment(node, envName) {
    if (node == null) {
      return false;
    }
    return (node.type === "environment" || node.type === "mathenv") && (envName == null || printRaw23(node.env) === envName);
  },
  anyEnvironment(node) {
    return match23.environment(node);
  },
  comment(node) {
    if (node == null) {
      return false;
    }
    return node.type === "comment";
  },
  parbreak(node) {
    if (node == null) {
      return false;
    }
    return node.type === "parbreak";
  },
  whitespace(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace";
  },
  /**
   * Matches whitespace or a comment with leading whitespace.
   */
  whitespaceLike(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace" || node.type === "whitespace" && node.leadingWhitespace === true;
  },
  string(node, value) {
    if (node == null) {
      return false;
    }
    return node.type === "string" && (value == null || node.content === value);
  },
  anyString(node) {
    return match23.string(node);
  },
  group(node) {
    if (node == null) {
      return false;
    }
    return node.type === "group";
  },
  argument(node) {
    if (node == null) {
      return false;
    }
    return node.type === "argument";
  },
  blankArgument(node) {
    if (!match23.argument(node)) {
      return false;
    }
    return node.openMark === "" && node.closeMark === "" && node.content.length === 0;
  },
  math(node) {
    if (node == null) {
      return false;
    }
    return node.type === "displaymath" || node.type === "inlinemath";
  },
  createMacroMatcher: createMacroMatcher23,
  createEnvironmentMatcher: createEnvironmentMatcher23
};
var {
  anyEnvironment: anyEnvironment23,
  anyMacro: anyMacro23,
  anyString: anyString23,
  argument: argument23,
  blankArgument: blankArgument23,
  comment: comment23,
  environment: environment23,
  group: group23,
  macro: macro23,
  math: math23,
  parbreak: parbreak23,
  string: string23,
  whitespace: whitespace23
} = match23;
var CONTINUE3 = Symbol("continue");
var SKIP3 = Symbol("skip");
var EXIT3 = Symbol("exit");
function cleanEnumerateBody(ast, itemName = "item") {
  let { segments, macros: macros15 } = splitOnMacro(ast, itemName);
  for (let i = 0; i < segments.length; i++) {
    const segment = segments[i];
    if (i === 0) {
      trimEnd(segment);
    } else {
      trim(segment);
    }
    if (segment.length > 0 && i > 0) {
      segment.unshift({ type: "whitespace" });
    }
  }
  let insertParbreakBefore = /* @__PURE__ */ new WeakSet();
  let body = macros15.flatMap((node, i) => {
    var _a;
    const segment = segments[i + 1];
    const trailingComments = popTrailingComments(segment);
    node.args = node.args || [];
    node.args.push(arg(segment, { openMark: "", closeMark: "" }));
    updateRenderInfo(node, { inParMode: true });
    if (i > 0 || ((_a = segments[0]) == null ? void 0 : _a.length) > 0) {
      insertParbreakBefore.add(node);
    }
    return [node, ...trailingComments];
  });
  body = body.flatMap(
    (node) => insertParbreakBefore.has(node) ? [{ type: "parbreak" }, node] : node
  );
  body.unshift(...segments[0]);
  for (let i = 0; i < body.length - 1; i++) {
    const node = body[i];
    const nextNode = body[i + 1];
    if (!match.parbreak(nextNode)) {
      continue;
    }
    if (match.comment(node)) {
      node.suffixParbreak = true;
    }
    if (match.macro(node) && node.args && node.args[node.args.length - 1].closeMark === "") {
      const args = node.args[node.args.length - 1].content;
      const lastArg = args[args.length - 1];
      if (match.comment(lastArg)) {
        lastArg.suffixParbreak = true;
      }
    }
  }
  return body;
}
function popTrailingComments(nodes) {
  let lastNodeIndex = lastSignificantNodeIndex(nodes, true);
  if (lastNodeIndex === nodes.length - 1 || lastNodeIndex == null && nodes.length === 0) {
    return [];
  }
  if (lastNodeIndex == null) {
    lastNodeIndex = -1;
  }
  return nodes.splice(lastNodeIndex + 1);
}
var macros2 = {
  answerline: { signature: "o" },
  fillin: { signature: "o o" },
  fullwidth: { signature: "m" },
  fillwidthlines: { signature: "m" },
  fillwidthdottedlines: { signature: "m" },
  fillwidthgrid: { signature: "m" },
  makeemptybox: { signature: "m" },
  CorrectChoiceEmphasis: {
    signature: "m",
    renderInfo: { breakAround: true }
  },
  SolutionEmphasis: { signature: "m", renderInfo: { breakAround: true } },
  uplevel: { signature: "m", renderInfo: { breakAround: true } },
  checkboxchar: { signature: "m", renderInfo: { breakAround: true } },
  checkedchar: { signature: "m", renderInfo: { breakAround: true } },
  pointname: { signature: "m", renderInfo: { breakAround: true } },
  marginpointname: { signature: "m", renderInfo: { breakAround: true } },
  extrawidth: { signature: "m", renderInfo: { breakAround: true } },
  pointformat: { signature: "m", renderInfo: { breakAround: true } },
  bonuspointformat: { signature: "m", renderInfo: { breakAround: true } },
  totalformat: { signature: "m", renderInfo: { breakAround: true } },
  qformat: { signature: "m", renderInfo: { breakAround: true } },
  titledquestion: { signature: "m o", renderInfo: { breakAround: true } },
  pointpoints: { signature: "m m", renderInfo: { breakAround: true } },
  bonuspointpoints: { signature: "m m", renderInfo: { breakAround: true } }
};
var environments2 = {
  choices: {
    signature: "o",
    processContent: (nodes) => cleanEnumerateBody(nodes, "choice")
  },
  checkboxes: {
    signature: "o",
    processContent: (nodes) => cleanEnumerateBody(nodes, "choice")
  },
  oneparchoices: {
    signature: "o",
    processContent: (nodes) => cleanEnumerateBody(nodes, "choice")
  },
  oneparcheckboxes: {
    signature: "o",
    processContent: (nodes) => cleanEnumerateBody(nodes, "choice")
  },
  parts: {
    signature: "o",
    processContent: (nodes) => cleanEnumerateBody(nodes, "part")
  },
  subparts: {
    signature: "o",
    processContent: (nodes) => cleanEnumerateBody(nodes, "subpart")
  },
  subsubparts: {
    signature: "o",
    processContent: (nodes) => cleanEnumerateBody(nodes, "subsubpart")
  },
  questions: {
    signature: "o",
    processContent: (nodes) => cleanEnumerateBody(nodes, "question")
  }
};
var macros3 = {
  geometry: {
    signature: "m",
    renderInfo: { breakAround: true, pgfkeysArgs: true }
  }
};
var environments3 = {};
var macros4 = {
  hypersetup: {
    signature: "m",
    renderInfo: { breakAround: true, pgfkeysArgs: true }
  },
  href: { signature: "o m m" },
  url: { signature: "m" },
  nolinkurl: { signature: "m" },
  hyperbaseurl: { signature: "m" },
  hyperimage: { signature: "m m" },
  hyperdef: { signature: "m m m" },
  hyperref: { signature: "o m" },
  hyperlink: { signature: "m m" },
  hypertarget: { signature: "m m" },
  autoref: { signature: "s m" },
  pageref: { signature: "s m" },
  autopageref: { signature: "s m" },
  pdfstringdef: { signature: "m m" },
  pdfbookmark: { signature: "o m m" },
  currentpdfbookmark: { signature: "m m" },
  subpdfbookmark: { signature: "m m" },
  belowpdfbookmark: { signature: "m m" },
  texorpdfstring: { signature: "m m" },
  thispdfpagelabel: { signature: "m" },
  hypercalcbp: { signature: "m" }
};
var environments4 = {};
var macros5 = {
  // Special
  "\\": { signature: "!s o" },
  _: { signature: "m", escapeToken: "" },
  "^": { signature: "m", escapeToken: "" },
  // \newcommand arg signature from https://www.texdev.net/2020/08/19/the-good-the-bad-and-the-ugly-creating-document-commands
  // List can be found in latex2e.pdf "An unofficial reference manual"
  newcommand: {
    signature: "s +m o +o +m",
    renderInfo: {
      breakAround: true,
      namedArguments: ["starred", "name", "numArgs", "default", "body"]
    }
  },
  renewcommand: {
    signature: "s +m o +o +m",
    renderInfo: {
      breakAround: true,
      namedArguments: ["starred", "name", "numArgs", "default", "body"]
    }
  },
  providecommand: {
    signature: "s +m o +o +m",
    renderInfo: { breakAround: true }
  },
  // Counters
  newcounter: {
    signature: "m o",
    renderInfo: { breakAround: true }
  },
  usecounter: {
    signature: "m"
  },
  setcounter: {
    signature: "m m",
    renderInfo: { breakAround: true }
  },
  addtocounter: {
    signature: "m m",
    renderInfo: { breakAround: true }
  },
  stepcounter: {
    signature: "m",
    renderInfo: { breakAround: true }
  },
  refstepcounter: {
    signature: "m",
    renderInfo: { breakAround: true }
  },
  // Lengths
  newlength: {
    signature: "m",
    renderInfo: { breakAround: true }
  },
  addtolength: {
    signature: "m m",
    renderInfo: { breakAround: true }
  },
  settodepth: {
    signature: "m m",
    renderInfo: { breakAround: true }
  },
  settoheight: {
    signature: "m m",
    renderInfo: { breakAround: true }
  },
  settowidth: {
    signature: "m m",
    renderInfo: { breakAround: true }
  },
  // Spaces
  stretch: { signature: "m" },
  hspace: { signature: "s m" },
  vspace: { signature: "s m", renderInfo: { breakAround: true } },
  vfill: { renderInfo: { breakAround: true } },
  indent: { renderInfo: { breakAround: true } },
  phantom: { signature: "m" },
  vphantom: { signature: "m" },
  hphantom: { signature: "m" },
  noindent: { renderInfo: { breakAround: true } },
  smallskip: { renderInfo: { breakAround: true } },
  medskip: { renderInfo: { breakAround: true } },
  bigskip: { renderInfo: { breakAround: true } },
  smallbreak: { renderInfo: { breakAround: true } },
  medbreak: { renderInfo: { breakAround: true } },
  bigbreak: { renderInfo: { breakAround: true } },
  newline: { renderInfo: { breakAround: true } },
  linebreak: { signature: "o", renderInfo: { breakAround: true } },
  nolinebreak: { signature: "o", renderInfo: { breakAround: true } },
  clearpage: { renderInfo: { breakAround: true } },
  cleardoublepage: { renderInfo: { breakAround: true } },
  newpage: { renderInfo: { breakAround: true } },
  enlargethispage: { signature: "s", renderInfo: { breakAround: true } },
  pagebreak: { signature: "o", renderInfo: { breakAround: true } },
  nopagebreak: { signature: "o", renderInfo: { breakAround: true } },
  // Boxes
  newsavebox: {
    signature: "m",
    renderInfo: { breakAround: true }
  },
  sbox: {
    signature: "m m",
    renderInfo: { breakAround: true }
  },
  savebox: {
    signature: "m o o m",
    renderInfo: { breakAround: true }
  },
  mbox: { signature: "m" },
  makebox: { signature: "d() o o m", renderInfo: { breakAround: true } },
  fbox: { signature: "m" },
  framebox: { signature: "o o m", renderInfo: { breakAround: true } },
  frame: { signature: "m", renderInfo: { breakAround: true } },
  parbox: { signature: "o o o m m", renderInfo: { breakAround: true } },
  raisebox: { signature: "m o o m" },
  marginpar: { signature: "o m", renderInfo: { breakAround: true } },
  colorbox: { signature: "o m m", renderInfo: { breakAround: true } },
  fcolorbox: { signature: "o m m", renderInfo: { breakAround: true } },
  rotatebox: { signature: "o m m" },
  scalebox: { signature: "m o m" },
  reflectbox: { signature: "m" },
  resizebox: { signature: "s m m m" },
  // Define environments
  newenvironment: {
    signature: "s m o o m m",
    renderInfo: { breakAround: true }
  },
  renewenvironment: {
    signature: "s m o o m m",
    renderInfo: { breakAround: true }
  },
  newtheorem: {
    signature: "s m o m o",
    renderInfo: { breakAround: true }
  },
  newfont: {
    signature: "m m",
    renderInfo: { breakAround: true }
  },
  // Counters
  alph: { signature: "m" },
  Alph: { signature: "m" },
  arabic: { signature: "m" },
  roman: { signature: "m" },
  Roman: { signature: "m" },
  fnsymbol: { signature: "m" },
  // Other
  documentclass: {
    signature: "o m",
    renderInfo: { breakAround: true, pgfkeysArgs: true }
  },
  usepackage: {
    signature: "o m",
    renderInfo: { breakAround: true, pgfkeysArgs: true }
  },
  item: {
    signature: "o",
    renderInfo: { hangingIndent: true, namedArguments: ["label"] }
  },
  value: { signature: "m" },
  centering: { renderInfo: { breakAround: true } },
  input: { signature: "m", renderInfo: { breakAround: true } },
  include: { signature: "m", renderInfo: { breakAround: true } },
  includeonly: {
    signature: "m",
    renderInfo: { breakAround: true, pgfkeysArgs: true }
  },
  discretionary: { signature: "m m m" },
  hyphenation: { signature: "m m m" },
  footnote: { signature: "o m", renderInfo: { inParMode: true } },
  footnotemark: { signature: "o" },
  footnotetext: { signature: "o m", renderInfo: { inParMode: true } },
  caption: {
    signature: "o m",
    renderInfo: { inParMode: true, breakAround: true }
  },
  // Math Commands
  sqrt: { signature: "o m", renderInfo: { inMathMode: true } },
  frac: { signature: "m m", renderInfo: { inMathMode: true } },
  stackrel: { signature: "m m" },
  ensuremath: { signature: "m", renderInfo: { inMathMode: true } },
  // Layout commands
  abstract: {
    signature: "m",
    renderInfo: { breakAround: true, inParMode: true }
  },
  maketitle: { renderInfo: { breakAround: true } },
  doublespacing: { renderInfo: { breakAround: true } },
  singlespacing: { renderInfo: { breakAround: true } },
  author: {
    signature: "m",
    renderInfo: { breakAround: true, inParMode: true }
  },
  date: { signature: "o m", renderInfo: { breakAround: true } },
  thanks: {
    signature: "m",
    renderInfo: { breakAround: true, inParMode: true }
  },
  // amsart document class adds an optional argument
  title: {
    signature: "o m",
    renderInfo: { breakAround: true, inParMode: true }
  },
  pagenumbering: { signature: "m", renderInfo: { breakAround: true } },
  pagestyle: { signature: "m", renderInfo: { breakAround: true } },
  thispagestyle: { signature: "m", renderInfo: { breakAround: true } },
  // Colors
  definecolor: { signature: "m m m", renderInfo: { breakAround: true } },
  pagecolor: { signature: "o m", renderInfo: { breakAround: true } },
  nopagecolor: { renderInfo: { breakAround: true } },
  multicolumn: { signature: "m m m" },
  // Graphics
  includegraphics: {
    signature: "s o o m",
    renderInfo: { breakAround: true, pgfkeysArgs: true }
  },
  rule: { signature: "o m m" },
  // Sectioning
  part: {
    signature: "s o m",
    renderInfo: {
      breakAround: true,
      inParMode: true,
      namedArguments: ["starred", "tocTitle", "title"]
    }
  },
  chapter: {
    signature: "s o m",
    renderInfo: {
      breakAround: true,
      inParMode: true,
      namedArguments: ["starred", "tocTitle", "title"]
    }
  },
  section: {
    signature: "s o m",
    renderInfo: {
      breakAround: true,
      inParMode: true,
      namedArguments: ["starred", "tocTitle", "title"]
    }
  },
  subsection: {
    signature: "s o m",
    renderInfo: {
      breakAround: true,
      inParMode: true,
      namedArguments: ["starred", "tocTitle", "title"]
    }
  },
  subsubsection: {
    signature: "s o m",
    renderInfo: {
      breakAround: true,
      inParMode: true,
      namedArguments: ["starred", "tocTitle", "title"]
    }
  },
  paragraph: {
    signature: "s o m",
    renderInfo: {
      breakAround: true,
      inParMode: true,
      namedArguments: ["starred", "tocTitle", "title"]
    }
  },
  subparagraph: {
    signature: "s o m",
    renderInfo: {
      breakAround: true,
      inParMode: true,
      namedArguments: ["starred", "tocTitle", "title"]
    }
  },
  appendix: { renderInfo: { breakAround: true, inParMode: true } },
  frontmatter: { renderInfo: { breakAround: true, inParMode: true } },
  mainmatter: { renderInfo: { breakAround: true, inParMode: true } },
  backmatter: { renderInfo: { breakAround: true, inParMode: true } },
  // Citing and references
  bibitem: { signature: "o m", renderInfo: { hangingIndent: true } },
  cite: { signature: "o m" },
  // Fonts
  textrm: { signature: "m", renderInfo: { inParMode: true } },
  textit: { signature: "m", renderInfo: { inParMode: true } },
  textmd: { signature: "m", renderInfo: { inParMode: true } },
  textbf: { signature: "m", renderInfo: { inParMode: true } },
  textup: { signature: "m", renderInfo: { inParMode: true } },
  textsl: { signature: "m", renderInfo: { inParMode: true } },
  textsf: { signature: "m", renderInfo: { inParMode: true } },
  textsc: { signature: "m", renderInfo: { inParMode: true } },
  texttt: { signature: "m", renderInfo: { inParMode: true } },
  emph: { signature: "m", renderInfo: { inParMode: true } },
  textnormal: { signature: "m", renderInfo: { inParMode: true } },
  uppercase: { signature: "m", renderInfo: { inParMode: true } },
  mathbf: { signature: "m" },
  mathsf: { signature: "m" },
  mathtt: { signature: "m" },
  mathit: { signature: "m" },
  mathnormal: { signature: "m" },
  mathcal: { signature: "m" },
  mathrm: { signature: "m" },
  // Other
  setlength: { signature: "m m", renderInfo: { breakAround: true } },
  ref: { signature: "s m" },
  label: { signature: "o m" },
  // cleveref changes \label to have this signature
  printbibliography: { renderInfo: { breakAround: true } },
  addtocontents: { signature: "m m", renderInfo: { breakAround: true } },
  addcontentsline: { signature: "m m m", renderInfo: { breakAround: true } },
  contentsline: { signature: "m m m", renderInfo: { breakAround: true } },
  bibliography: { signature: "m", renderInfo: { breakAround: true } },
  bibliographystyle: { signature: "m", renderInfo: { breakAround: true } }
};
var environments5 = {
  document: {
    processContent: (nodes) => {
      trim(nodes);
      return nodes;
    }
  },
  array: { signature: "o m", renderInfo: { alignContent: true } },
  description: { signature: "o", processContent: cleanEnumerateBody },
  enumerate: {
    signature: "o",
    processContent: cleanEnumerateBody,
    renderInfo: { pgfkeysArgs: true }
  },
  itemize: { signature: "o", processContent: cleanEnumerateBody },
  trivlist: { signature: "o", processContent: cleanEnumerateBody },
  list: { signature: "m m", processContent: cleanEnumerateBody },
  figure: { signature: "o" },
  "figure*": { signature: "o" },
  filecontents: { signature: "o m" },
  "filecontents*": { signature: "o m" },
  minipage: { signature: "o o o m" },
  picture: { signature: "r() d()" },
  tabbing: { renderInfo: { alignContent: true } },
  table: { signature: "o" },
  tabular: { signature: "o m", renderInfo: { alignContent: true } },
  "tabular*": { signature: "m o m", renderInfo: { alignContent: true } },
  thebibliography: {
    signature: "m",
    processContent: (nodes) => cleanEnumerateBody(nodes, "bibitem")
  },
  // Math
  math: { renderInfo: { inMathMode: true } }
};
var macros6 = {
  see: { signature: "m m" },
  seealso: { signature: "m m" },
  seename: { signature: "m" },
  alsoname: { signature: "m" },
  index: { signature: "m" }
};
var environments6 = {};
var macros7 = {
  mathtoolsset: {
    signature: "m",
    renderInfo: { breakAround: true, pgfkeysArgs: true }
  },
  mathllap: {
    signature: "o m"
  },
  mathrlap: {
    signature: "o m"
  },
  mathclap: {
    signature: "o m"
  },
  clap: {
    signature: "m"
  },
  mathmbox: {
    signature: "m"
  },
  mathmakebox: {
    signature: "o o m"
  },
  cramped: {
    signature: "o m"
  },
  crampedllap: {
    signature: "o m"
  },
  crampedrlap: {
    signature: "o m"
  },
  crampedclap: {
    signature: "o m"
  },
  crampedsubstack: {
    signature: "o m"
  },
  smashoperator: {
    signature: "o m"
  },
  newtagform: {
    signature: "m o m m"
  },
  renewtagform: {
    signature: "m o m m"
  },
  usetagform: {
    signature: "m"
  },
  xleftrightarrow: { signature: "o m" },
  xLeftarrow: { signature: "o m" },
  xhookleftarrow: { signature: "o m" },
  xmapsto: { signature: "o m" },
  xRightarrow: { signature: "o m" },
  xLeftrightarrow: { signature: "o m" },
  xhookrightarrow: { signature: "o m" },
  underbracket: { signature: "o o m" },
  overbracket: { signature: "o o m" },
  underbrace: { signature: "m" },
  overbrace: { signature: "m" },
  shoveleft: { signature: "o m" },
  shoveright: { signature: "o m" },
  ArrowBetweenLines: { signature: "s o" },
  vdotswithin: { signature: "m" },
  shortdotswithin: { signature: "s m" },
  DeclarePairedDelimiter: {
    signature: "m m m",
    renderInfo: { breakAround: true }
  },
  DeclarePairedDelimiterX: {
    signature: "m o m m m",
    renderInfo: { breakAround: true }
  },
  DeclarePairedDelimiterXPP: {
    signature: "m o m m m m m",
    renderInfo: { breakAround: true }
  },
  prescript: { signature: "m m m" },
  DeclareMathSizes: { signature: "m m m m" },
  newgathered: { signature: "m m m m" },
  renewgathered: { signature: "m m m m" },
  splitfrac: { signature: "m m" },
  splitdfrac: { signature: "m m" },
  xmathstrut: { signature: "o m" },
  // amsthm
  newtheorem: { signature: "s m o m o", renderInfo: { breakAround: true } },
  theoremstyle: { signature: "m", renderInfo: { breakAround: true } },
  newtheoremstyle: {
    signature: "m m m m m m m m m",
    renderInfo: { breakAround: true }
  },
  // amsmath
  text: { signature: "m", renderInfo: { inMathMode: false } },
  // amsfonts
  mathbb: { signature: "m" },
  mathscr: { signature: "m" },
  mathfrak: { signature: "m" },
  frak: { signature: "m" },
  Bdd: { signature: "m" },
  bold: { signature: "m" },
  // amsopn
  operatorname: { signature: "s m" },
  DeclareMathOperator: {
    signature: "s m m",
    renderInfo: { breakAround: true }
  }
};
var environments7 = {
  crampedsubarray: {
    signature: "m",
    renderInfo: { alignContent: true, inMathMode: true }
  },
  matrix: { renderInfo: { alignContent: true, inMathMode: true } },
  bmatrix: { renderInfo: { alignContent: true, inMathMode: true } },
  pmatrix: { renderInfo: { alignContent: true, inMathMode: true } },
  vmatrix: { renderInfo: { alignContent: true, inMathMode: true } },
  Bmatrix: { renderInfo: { alignContent: true, inMathMode: true } },
  Vmatrix: { renderInfo: { alignContent: true, inMathMode: true } },
  smallmatrix: { renderInfo: { alignContent: true, inMathMode: true } },
  psmallmatrix: { renderInfo: { alignContent: true, inMathMode: true } },
  vsmallmatrix: { renderInfo: { alignContent: true, inMathMode: true } },
  bsmallmatrix: { renderInfo: { alignContent: true, inMathMode: true } },
  Bsmallmatrix: { renderInfo: { alignContent: true, inMathMode: true } },
  Vsmallmatrix: { renderInfo: { alignContent: true, inMathMode: true } },
  "matrix*": {
    signature: "o",
    renderInfo: { alignContent: true, inMathMode: true }
  },
  "bmatrix*": {
    signature: "o",
    renderInfo: { alignContent: true, inMathMode: true }
  },
  "pmatrix*": {
    signature: "o",
    renderInfo: { alignContent: true, inMathMode: true }
  },
  "vmatrix*": {
    signature: "o",
    renderInfo: { alignContent: true, inMathMode: true }
  },
  "Bmatrix*": {
    signature: "o",
    renderInfo: { alignContent: true, inMathMode: true }
  },
  "Vmatrix*": {
    signature: "o",
    renderInfo: { alignContent: true, inMathMode: true }
  },
  "smallmatrix*": {
    signature: "o",
    renderInfo: { alignContent: true, inMathMode: true }
  },
  "psmallmatrix*": {
    signature: "o",
    renderInfo: { alignContent: true, inMathMode: true }
  },
  "bsmallmatrix*": {
    signature: "o",
    renderInfo: { alignContent: true, inMathMode: true }
  },
  "vsmallmatrix*": {
    signature: "o",
    renderInfo: { alignContent: true, inMathMode: true }
  },
  "Bsmallmatrix*": {
    signature: "o",
    renderInfo: { alignContent: true, inMathMode: true }
  },
  "Vsmallmatrix*": {
    signature: "o",
    renderInfo: { alignContent: true, inMathMode: true }
  },
  multilined: { signature: "o o", renderInfo: { inMathMode: true } },
  cases: { renderInfo: { alignContent: true, inMathMode: true } },
  "cases*": { renderInfo: { alignContent: true, inMathMode: true } },
  dcases: { renderInfo: { alignContent: true, inMathMode: true } },
  "dcases*": { renderInfo: { alignContent: true, inMathMode: true } },
  rcases: { renderInfo: { alignContent: true, inMathMode: true } },
  "rcases*": { renderInfo: { alignContent: true, inMathMode: true } },
  drcases: { renderInfo: { alignContent: true, inMathMode: true } },
  "drcases*": { renderInfo: { alignContent: true, inMathMode: true } },
  spreadlines: { signature: "m", renderInfo: { inMathMode: true } },
  lgathered: { signature: "o", renderInfo: { inMathMode: true } },
  rgathered: { signature: "o", renderInfo: { inMathMode: true } },
  // amsmath
  "align*": { renderInfo: { inMathMode: true, alignContent: true } },
  align: { renderInfo: { inMathMode: true, alignContent: true } },
  aligned: { renderInfo: { inMathMode: true, alignContent: true } },
  "alignat*": { renderInfo: { inMathMode: true, alignContent: true } },
  alignat: { renderInfo: { inMathMode: true, alignContent: true } },
  "equation*": { renderInfo: { inMathMode: true } },
  equation: { renderInfo: { inMathMode: true } },
  "gather*": { renderInfo: { inMathMode: true } },
  gather: { renderInfo: { inMathMode: true } },
  "multline*": { renderInfo: { inMathMode: true } },
  multline: { renderInfo: { inMathMode: true } },
  "flalign*": { renderInfo: { inMathMode: true, alignContent: true } },
  flalign: { renderInfo: { inMathMode: true, alignContent: true } },
  split: { renderInfo: { inMathMode: true } },
  // Math environments
  displaymath: { renderInfo: { inMathMode: true } },
  // Typical amsthm environments
  theorem: { signature: "o" },
  lemma: { signature: "o" },
  definition: { signature: "o" },
  proposition: { signature: "o" },
  corollary: { signature: "o" },
  remark: { signature: "!o" },
  example: { signature: "!o" },
  proof: { signature: "o" }
};
var macros8 = {
  NiceMatrixOptions: {
    signature: "m",
    renderInfo: { pgfkeysArgs: true, breakAround: true }
  }
};
var environments8 = {
  NiceTabular: {
    signature: "o m !o",
    renderInfo: { pgfkeysArgs: true, alignContent: true }
  },
  NiceMatrixBlock: {
    signature: "!o",
    renderInfo: { pgfkeysArgs: true, alignContent: true }
  },
  NiceArrayWithDelims: {
    signature: "m m o m !o",
    renderInfo: { pgfkeysArgs: true, alignContent: true }
  },
  NiceArray: {
    signature: "o m !o",
    renderInfo: { pgfkeysArgs: true, alignContent: true }
  },
  pNiceArray: {
    signature: "o m !o",
    renderInfo: { pgfkeysArgs: true, alignContent: true }
  },
  bNiceArray: {
    signature: "o m !o",
    renderInfo: { pgfkeysArgs: true, alignContent: true }
  },
  BNiceArray: {
    signature: "o m !o",
    renderInfo: { pgfkeysArgs: true, alignContent: true }
  },
  vNiceArray: {
    signature: "o m !o",
    renderInfo: { pgfkeysArgs: true, alignContent: true }
  },
  VNiceArray: {
    signature: "o m !o",
    renderInfo: { pgfkeysArgs: true, alignContent: true }
  },
  NiceMatrix: {
    signature: "!o",
    renderInfo: { pgfkeysArgs: true, alignContent: true }
  },
  pNiceMatrix: {
    signature: "!o",
    renderInfo: { pgfkeysArgs: true, alignContent: true }
  },
  bNiceMatrix: {
    signature: "!o",
    renderInfo: { pgfkeysArgs: true, alignContent: true }
  },
  BNiceMatrix: {
    signature: "!o",
    renderInfo: { pgfkeysArgs: true, alignContent: true }
  },
  vNiceMatrix: {
    signature: "!o",
    renderInfo: { pgfkeysArgs: true, alignContent: true }
  },
  VNiceMatrix: {
    signature: "!o",
    renderInfo: { pgfkeysArgs: true, alignContent: true }
  }
};
var macros9 = {
  systeme: {
    signature: "s o o m",
    renderInfo: { inMathMode: true }
  },
  sysdelim: {
    signature: "m m"
  },
  syseqsep: { signature: "m" },
  sysalign: { signature: "m" },
  syssignspace: { signature: "m" },
  syseqspace: { signature: "m" },
  syslineskipcoeff: { signature: "m" },
  syseqivsign: { signature: "m" },
  sysaddeqsign: { signature: "m" },
  sysremoveeqsign: { signature: "m" },
  sysextracolonsign: { signature: "m" },
  syscodeextracol: { signature: "m" },
  sysautonum: { signature: "m" },
  syssubstitute: { signature: "m" }
};
var environments9 = {};
var linebreak7 = Symbol("linebreak");
var ESCAPE7 = "\\";
function _printRaw7(node) {
  if (typeof node === "string") {
    return [node];
  }
  if (Array.isArray(node)) {
    return [].concat(
      ...node.map((n) => _printRaw7(n))
    );
  }
  let argsString, escape;
  switch (node.type) {
    case "root":
      return _printRaw7(node.content);
    case "argument":
      return [node.openMark, ..._printRaw7(node.content), node.closeMark];
    case "comment":
      var suffix = node.suffixParbreak ? "" : linebreak7;
      var leadingWhitespace = "";
      if (node.sameline && node.leadingWhitespace) {
        leadingWhitespace = " ";
      }
      if (node.sameline) {
        return [
          leadingWhitespace,
          "%",
          ..._printRaw7(node.content),
          suffix
        ];
      }
      return [linebreak7, "%", ..._printRaw7(node.content), suffix];
    case "environment":
    case "mathenv":
    case "verbatim":
      var env = _printRaw7(node.env);
      var envStart = [ESCAPE7 + "begin{", ...env, "}"];
      var envEnd = [ESCAPE7 + "end{", ...env, "}"];
      argsString = node.args == null ? [] : _printRaw7(node.args);
      return [
        ...envStart,
        ...argsString,
        ..._printRaw7(node.content),
        ...envEnd
      ];
    case "displaymath":
      return [ESCAPE7 + "[", ..._printRaw7(node.content), ESCAPE7 + "]"];
    case "group":
      return ["{", ..._printRaw7(node.content), "}"];
    case "inlinemath":
      return ["$", ..._printRaw7(node.content), "$"];
    case "macro":
      argsString = node.args == null ? [] : _printRaw7(node.args);
      escape = node.escapeToken == null ? ESCAPE7 : node.escapeToken;
      return [escape, ..._printRaw7(node.content), ...argsString];
    case "parbreak":
      return [linebreak7, linebreak7];
    case "string":
      return [node.content];
    case "verb":
      return [
        ESCAPE7,
        node.env,
        node.escape,
        ..._printRaw7(node.content),
        node.escape
      ];
    case "whitespace":
      return [" "];
    default:
      console.warn(
        "Cannot find render for node ",
        node,
        `(of type ${typeof node})`
      );
      return ["" + node];
  }
}
function printRaw7(node, options) {
  const asArray = options != null ? options.asArray : false;
  const printedTokens = _printRaw7(node);
  if (asArray) {
    return printedTokens;
  }
  return printedTokens.map((x) => x === linebreak7 ? "\n" : x).join("");
}
function createMacroMatcher7(macros15) {
  const macrosHash = Array.isArray(macros15) ? macros15.length > 0 ? typeof macros15[0] === "string" ? Object.fromEntries(
    macros15.map((macro262) => {
      if (typeof macro262 !== "string") {
        throw new Error("Wrong branch of map function");
      }
      return [macro262, {}];
    })
  ) : Object.fromEntries(
    macros15.map((macro262) => {
      if (typeof macro262 === "string") {
        throw new Error("Wrong branch of map function");
      }
      if (macro262.escapeToken != null) {
        return [
          macro262.content,
          { escapeToken: macro262.escapeToken }
        ];
      }
      return [macro262.content, {}];
    })
  ) : {} : macros15;
  return function matchAgainstMacros(node) {
    if (node == null || node.type !== "macro") {
      return false;
    }
    const spec = macrosHash[node.content];
    if (!spec) {
      return false;
    }
    if (typeof spec === "object" && "escapeToken" in spec) {
      return spec.escapeToken == null || spec.escapeToken === node.escapeToken;
    }
    return true;
  };
}
function createEnvironmentMatcher7(macros15) {
  const environmentsHash = Array.isArray(macros15) ? Object.fromEntries(
    macros15.map((str) => {
      return [str, {}];
    })
  ) : macros15;
  return function matchAgainstEnvironments(node) {
    if (!match7.anyEnvironment(node)) {
      return false;
    }
    const envName = printRaw7(node.env);
    const spec = environmentsHash[envName];
    if (!spec) {
      return false;
    }
    return true;
  };
}
var match7 = {
  macro(node, macroName) {
    if (node == null) {
      return false;
    }
    return node.type === "macro" && (macroName == null || node.content === macroName);
  },
  anyMacro(node) {
    return match7.macro(node);
  },
  environment(node, envName) {
    if (node == null) {
      return false;
    }
    return (node.type === "environment" || node.type === "mathenv") && (envName == null || printRaw7(node.env) === envName);
  },
  anyEnvironment(node) {
    return match7.environment(node);
  },
  comment(node) {
    if (node == null) {
      return false;
    }
    return node.type === "comment";
  },
  parbreak(node) {
    if (node == null) {
      return false;
    }
    return node.type === "parbreak";
  },
  whitespace(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace";
  },
  /**
   * Matches whitespace or a comment with leading whitespace.
   */
  whitespaceLike(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace" || node.type === "whitespace" && node.leadingWhitespace === true;
  },
  string(node, value) {
    if (node == null) {
      return false;
    }
    return node.type === "string" && (value == null || node.content === value);
  },
  anyString(node) {
    return match7.string(node);
  },
  group(node) {
    if (node == null) {
      return false;
    }
    return node.type === "group";
  },
  argument(node) {
    if (node == null) {
      return false;
    }
    return node.type === "argument";
  },
  blankArgument(node) {
    if (!match7.argument(node)) {
      return false;
    }
    return node.openMark === "" && node.closeMark === "" && node.content.length === 0;
  },
  math(node) {
    if (node == null) {
      return false;
    }
    return node.type === "displaymath" || node.type === "inlinemath";
  },
  createMacroMatcher: createMacroMatcher7,
  createEnvironmentMatcher: createEnvironmentMatcher7
};
var {
  anyEnvironment: anyEnvironment7,
  anyMacro: anyMacro7,
  anyString: anyString7,
  argument: argument7,
  blankArgument: blankArgument7,
  comment: comment7,
  environment: environment7,
  group: group7,
  macro: macro7,
  math: math7,
  parbreak: parbreak7,
  string: string7,
  whitespace: whitespace7
} = match7;
var latex_default = (
  // Generated by Peggy 2.0.1.
  //
  // https://peggyjs.org/
  function() {
    "use strict";
    function peg$subclass(child, parent) {
      function C() {
        this.constructor = child;
      }
      C.prototype = parent.prototype;
      child.prototype = new C();
    }
    function peg$SyntaxError(message, expected, found, location) {
      var self = Error.call(this, message);
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(self, peg$SyntaxError.prototype);
      }
      self.expected = expected;
      self.found = found;
      self.location = location;
      self.name = "SyntaxError";
      return self;
    }
    peg$subclass(peg$SyntaxError, Error);
    function peg$padEnd(str, targetLength, padString) {
      padString = padString || " ";
      if (str.length > targetLength) {
        return str;
      }
      targetLength -= str.length;
      padString += padString.repeat(targetLength);
      return str + padString.slice(0, targetLength);
    }
    peg$SyntaxError.prototype.format = function(sources) {
      var str = "Error: " + this.message;
      if (this.location) {
        var src = null;
        var k;
        for (k = 0; k < sources.length; k++) {
          if (sources[k].source === this.location.source) {
            src = sources[k].text.split(/\r\n|\n|\r/g);
            break;
          }
        }
        var s32 = this.location.start;
        var loc = this.location.source + ":" + s32.line + ":" + s32.column;
        if (src) {
          var e = this.location.end;
          var filler = peg$padEnd("", s32.line.toString().length, " ");
          var line = src[s32.line - 1];
          var last = s32.line === e.line ? e.column : line.length + 1;
          var hatLen = last - s32.column || 1;
          str += "\n --> " + loc + "\n" + filler + " |\n" + s32.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s32.column - 1, " ") + peg$padEnd("", hatLen, "^");
        } else {
          str += "\n at " + loc;
        }
      }
      return str;
    };
    peg$SyntaxError.buildMessage = function(expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        class: function(expectation) {
          var escapedParts = expectation.parts.map(function(part) {
            return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
          });
          return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
        },
        any: function() {
          return "any character";
        },
        end: function() {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        }
      };
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s32) {
        return s32.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function classEscape(s32) {
        return s32.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = expected2.map(describeExpectation);
        var i, j;
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {};
      var peg$source = options.grammarSource;
      var peg$startRuleFunctions = { document: peg$parsedocument, math: peg$parsemath };
      var peg$startRuleFunction = peg$parsedocument;
      var peg$c0 = "%";
      var peg$c1 = ".";
      var peg$c2 = "verb*";
      var peg$c3 = "verb";
      var peg$c4 = "verbatim*";
      var peg$c5 = "verbatim";
      var peg$c6 = "filecontents*";
      var peg$c7 = "filecontents";
      var peg$c8 = "comment";
      var peg$c9 = "lstlisting";
      var peg$c10 = "[";
      var peg$c11 = "]";
      var peg$c12 = "(";
      var peg$c13 = ")";
      var peg$c14 = "begin";
      var peg$c15 = "end";
      var peg$c16 = "equation*";
      var peg$c17 = "equation";
      var peg$c18 = "align*";
      var peg$c19 = "align";
      var peg$c20 = "alignat*";
      var peg$c21 = "alignat";
      var peg$c22 = "gather*";
      var peg$c23 = "gather";
      var peg$c24 = "multline*";
      var peg$c25 = "multline";
      var peg$c26 = "flalign*";
      var peg$c27 = "flalign";
      var peg$c28 = "split";
      var peg$c29 = "math";
      var peg$c30 = "displaymath";
      var peg$c31 = "\\";
      var peg$c32 = "{";
      var peg$c33 = "}";
      var peg$c34 = "$";
      var peg$c35 = "&";
      var peg$c36 = "\r";
      var peg$c37 = "\n";
      var peg$c38 = "\r\n";
      var peg$c39 = "#";
      var peg$c40 = "^";
      var peg$c41 = "_";
      var peg$c42 = "\0";
      var peg$r0 = /^[ \t]/;
      var peg$r1 = /^[a-zA-Z]/;
      var peg$r2 = /^[0-9]/;
      var peg$r3 = /^[.,;:\-*\/()!?=+<>[\]`'"~]/;
      var peg$e0 = peg$otherExpectation("document");
      var peg$e1 = peg$otherExpectation("math");
      var peg$e2 = peg$otherExpectation("token");
      var peg$e3 = peg$anyExpectation();
      var peg$e4 = peg$otherExpectation("parbreak");
      var peg$e5 = peg$otherExpectation("math token");
      var peg$e6 = peg$otherExpectation("nonchar token");
      var peg$e7 = peg$literalExpectation("%", false);
      var peg$e8 = peg$otherExpectation("whitespace");
      var peg$e9 = peg$otherExpectation("number");
      var peg$e10 = peg$literalExpectation(".", false);
      var peg$e11 = peg$otherExpectation("special macro");
      var peg$e12 = peg$literalExpectation("verb*", false);
      var peg$e13 = peg$literalExpectation("verb", false);
      var peg$e14 = peg$otherExpectation("verbatim environment");
      var peg$e15 = peg$literalExpectation("verbatim*", false);
      var peg$e16 = peg$literalExpectation("verbatim", false);
      var peg$e17 = peg$literalExpectation("filecontents*", false);
      var peg$e18 = peg$literalExpectation("filecontents", false);
      var peg$e19 = peg$literalExpectation("comment", false);
      var peg$e20 = peg$literalExpectation("lstlisting", false);
      var peg$e21 = peg$otherExpectation("macro");
      var peg$e22 = peg$otherExpectation("group");
      var peg$e23 = peg$otherExpectation("environment");
      var peg$e24 = peg$otherExpectation("math environment");
      var peg$e25 = peg$otherExpectation("math group");
      var peg$e26 = peg$literalExpectation("[", false);
      var peg$e27 = peg$literalExpectation("]", false);
      var peg$e28 = peg$literalExpectation("(", false);
      var peg$e29 = peg$literalExpectation(")", false);
      var peg$e30 = peg$literalExpectation("begin", false);
      var peg$e31 = peg$literalExpectation("end", false);
      var peg$e32 = peg$literalExpectation("equation*", false);
      var peg$e33 = peg$literalExpectation("equation", false);
      var peg$e34 = peg$literalExpectation("align*", false);
      var peg$e35 = peg$literalExpectation("align", false);
      var peg$e36 = peg$literalExpectation("alignat*", false);
      var peg$e37 = peg$literalExpectation("alignat", false);
      var peg$e38 = peg$literalExpectation("gather*", false);
      var peg$e39 = peg$literalExpectation("gather", false);
      var peg$e40 = peg$literalExpectation("multline*", false);
      var peg$e41 = peg$literalExpectation("multline", false);
      var peg$e42 = peg$literalExpectation("flalign*", false);
      var peg$e43 = peg$literalExpectation("flalign", false);
      var peg$e44 = peg$literalExpectation("split", false);
      var peg$e45 = peg$literalExpectation("math", false);
      var peg$e46 = peg$literalExpectation("displaymath", false);
      var peg$e47 = peg$otherExpectation("escape");
      var peg$e48 = peg$literalExpectation("\\", false);
      var peg$e49 = peg$literalExpectation("{", false);
      var peg$e50 = peg$literalExpectation("}", false);
      var peg$e51 = peg$literalExpectation("$", false);
      var peg$e52 = peg$literalExpectation("&", false);
      var peg$e53 = peg$otherExpectation("newline");
      var peg$e54 = peg$literalExpectation("\r", false);
      var peg$e55 = peg$literalExpectation("\n", false);
      var peg$e56 = peg$literalExpectation("\r\n", false);
      var peg$e57 = peg$literalExpectation("#", false);
      var peg$e58 = peg$literalExpectation("^", false);
      var peg$e59 = peg$literalExpectation("_", false);
      var peg$e60 = peg$literalExpectation("\0", false);
      var peg$e61 = peg$classExpectation([" ", "	"], false, false);
      var peg$e62 = peg$otherExpectation("letter");
      var peg$e63 = peg$classExpectation([["a", "z"], ["A", "Z"]], false, false);
      var peg$e64 = peg$otherExpectation("digit");
      var peg$e65 = peg$classExpectation([["0", "9"]], false, false);
      var peg$e66 = peg$otherExpectation("punctuation");
      var peg$e67 = peg$classExpectation([".", ",", ";", ":", "-", "*", "/", "(", ")", "!", "?", "=", "+", "<", ">", "[", "]", "`", "'", '"', "~"], false, false);
      var peg$e68 = peg$otherExpectation("full comment");
      var peg$e69 = peg$otherExpectation("comment");
      var peg$f0 = function(content) {
        return createNode("root", { content });
      };
      var peg$f1 = function(t) {
        return t;
      };
      var peg$f2 = function(eq) {
        return createNode("inlinemath", { content: eq });
      };
      var peg$f3 = function(s32) {
        return createNode("string", { content: s32 });
      };
      var peg$f4 = function(s32) {
        return createNode("string", { content: s32 });
      };
      var peg$f5 = function() {
        return createNode("parbreak");
      };
      var peg$f6 = function(x) {
        return x;
      };
      var peg$f7 = function(x) {
        return x;
      };
      var peg$f8 = function() {
        return createNode("macro", { content: "^", escapeToken: "" });
      };
      var peg$f9 = function() {
        return createNode("macro", { content: "_", escapeToken: "" });
      };
      var peg$f10 = function(s32) {
        return createNode("string", { content: s32 });
      };
      var peg$f11 = function() {
        return createNode("whitespace");
      };
      var peg$f12 = function(a, b) {
        return a.join("") + "." + b.join("");
      };
      var peg$f13 = function(b) {
        return "." + b.join("");
      };
      var peg$f14 = function(a) {
        return a.join("") + ".";
      };
      var peg$f15 = function(s32) {
        return createNode("string", { content: s32 });
      };
      var peg$f16 = function(env, e, end) {
        return end == e;
      };
      var peg$f17 = function(env, e, x) {
        return x;
      };
      var peg$f18 = function(env, e, x, end) {
        return end == e;
      };
      var peg$f19 = function(env, e, x) {
        return createNode("verb", {
          env,
          escape: e,
          content: x.join("")
        });
      };
      var peg$f20 = function(x) {
        return x;
      };
      var peg$f21 = function(x) {
        return createNode("displaymath", { content: x });
      };
      var peg$f22 = function(x) {
        return x;
      };
      var peg$f23 = function(x) {
        return createNode("inlinemath", { content: x });
      };
      var peg$f24 = function(x) {
        return x;
      };
      var peg$f25 = function(x) {
        return createNode("displaymath", { content: x });
      };
      var peg$f26 = function(env, end_env) {
        return compare_env({ content: [env] }, end_env);
      };
      var peg$f27 = function(env, x) {
        return x;
      };
      var peg$f28 = function(env, body) {
        return createNode("verbatim", {
          env,
          content: body.join("")
        });
      };
      var peg$f29 = function(n) {
        return n.join("");
      };
      var peg$f30 = function(n) {
        return n;
      };
      var peg$f31 = function(m) {
        return createNode("macro", { content: m });
      };
      var peg$f32 = function(c) {
        return c;
      };
      var peg$f33 = function(x) {
        return createNode("group", { content: x });
      };
      var peg$f34 = function(g) {
        return text().slice(1, -1);
      };
      var peg$f35 = function(env, env_comment, end_env) {
        return compare_env(env, end_env);
      };
      var peg$f36 = function(env, env_comment, x) {
        return x;
      };
      var peg$f37 = function(env, env_comment, body) {
        return createNode("environment", {
          env,
          content: env_comment ? [env_comment, ...body] : body
        });
      };
      var peg$f38 = function(env, env_comment, end_env) {
        return compare_env({ content: [env] }, end_env);
      };
      var peg$f39 = function(env, env_comment, x) {
        return x;
      };
      var peg$f40 = function(env, env_comment, body) {
        return createNode("mathenv", {
          env,
          content: env_comment ? [env_comment, ...body] : body
        });
      };
      var peg$f41 = function(c) {
        return c;
      };
      var peg$f42 = function(x) {
        return createNode("group", { content: x });
      };
      var peg$f43 = function(e) {
        return createNode("string", { content: e });
      };
      var peg$f44 = function() {
        return createNode("string", { content: "\\" });
      };
      var peg$f45 = function(s32) {
        return createNode("string", { content: s32 });
      };
      var peg$f46 = function(s32) {
        return createNode("string", { content: s32 });
      };
      var peg$f47 = function(s32) {
        return createNode("string", { content: s32 });
      };
      var peg$f48 = function(s32) {
        return createNode("string", { content: s32 });
      };
      var peg$f49 = function(s32) {
        return createNode("string", { content: s32 });
      };
      var peg$f50 = function(s32) {
        return createNode("string", { content: s32 });
      };
      var peg$f51 = function(s32) {
        return createNode("string", { content: s32 });
      };
      var peg$f52 = function() {
        return " ";
      };
      var peg$f53 = function(p) {
        return createNode("string", { content: p });
      };
      var peg$f54 = function(leading_sp, comment262) {
        return createNode("comment", {
          ...comment262,
          sameline: false,
          leadingWhitespace: leading_sp.length > 0
        });
      };
      var peg$f55 = function(spaces, x) {
        return createNode("comment", {
          ...x,
          sameline: true,
          leadingWhitespace: spaces.length > 0
        });
      };
      var peg$f56 = function(c) {
        return c;
      };
      var peg$f57 = function(c) {
        return { content: c.join(""), suffixParbreak: true };
      };
      var peg$f58 = function(c) {
        return c;
      };
      var peg$f59 = function(c) {
        return { content: c.join("") };
      };
      var peg$f60 = function() {
        var loc = location();
        return loc.start.column === 1;
      };
      var peg$currPos = 0;
      var peg$savedPos = 0;
      var peg$posDetailsCache = [{ line: 1, column: 1 }];
      var peg$maxFailPos = 0;
      var peg$maxFailExpected = [];
      var peg$silentFails = 0;
      var peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function offset() {
        return peg$savedPos;
      }
      function range() {
        return {
          source: peg$source,
          start: peg$savedPos,
          end: peg$currPos
        };
      }
      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError(
          [peg$otherExpectation(description)],
          input.substring(peg$savedPos, peg$currPos),
          location2
        );
      }
      function error(message, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location2);
      }
      function peg$literalExpectation(text2, ignoreCase) {
        return { type: "literal", text: text2, ignoreCase };
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts, inverted, ignoreCase };
      }
      function peg$anyExpectation() {
        return { type: "any" };
      }
      function peg$endExpectation() {
        return { type: "end" };
      }
      function peg$otherExpectation(description) {
        return { type: "other", description };
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p;
        if (details) {
          return details;
        } else {
          p = pos - 1;
          while (!peg$posDetailsCache[p]) {
            p--;
          }
          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };
          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos);
        var endPosDetails = peg$computePosDetails(endPos);
        return {
          source: peg$source,
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildSimpleError(message, location2) {
        return new peg$SyntaxError(message, null, null, location2);
      }
      function peg$buildStructuredError(expected2, found, location2) {
        return new peg$SyntaxError(
          peg$SyntaxError.buildMessage(expected2, found),
          expected2,
          found,
          location2
        );
      }
      function peg$parsedocument() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsetoken();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parsetoken();
        }
        peg$savedPos = s0;
        s1 = peg$f0(s1);
        s0 = s1;
        peg$silentFails--;
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e0);
        }
        return s0;
      }
      function peg$parsemath() {
        var s0, s1;
        peg$silentFails++;
        s0 = [];
        s1 = peg$parsemath_token();
        while (s1 !== peg$FAILED) {
          s0.push(s1);
          s1 = peg$parsemath_token();
        }
        peg$silentFails--;
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e1);
        }
        return s0;
      }
      function peg$parsetoken() {
        var s0, s1, s22, s32, s42, s5;
        peg$silentFails++;
        s0 = peg$parsespecial_macro();
        if (s0 === peg$FAILED) {
          s0 = peg$parsemacro();
          if (s0 === peg$FAILED) {
            s0 = peg$parsefull_comment();
            if (s0 === peg$FAILED) {
              s0 = peg$parsegroup();
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parsemath_shift();
                if (s1 !== peg$FAILED) {
                  s22 = [];
                  s32 = peg$currPos;
                  s42 = peg$currPos;
                  peg$silentFails++;
                  s5 = peg$parsemath_shift();
                  peg$silentFails--;
                  if (s5 === peg$FAILED) {
                    s42 = void 0;
                  } else {
                    peg$currPos = s42;
                    s42 = peg$FAILED;
                  }
                  if (s42 !== peg$FAILED) {
                    s5 = peg$parsemath_token();
                    if (s5 !== peg$FAILED) {
                      peg$savedPos = s32;
                      s32 = peg$f1(s5);
                    } else {
                      peg$currPos = s32;
                      s32 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s32;
                    s32 = peg$FAILED;
                  }
                  if (s32 !== peg$FAILED) {
                    while (s32 !== peg$FAILED) {
                      s22.push(s32);
                      s32 = peg$currPos;
                      s42 = peg$currPos;
                      peg$silentFails++;
                      s5 = peg$parsemath_shift();
                      peg$silentFails--;
                      if (s5 === peg$FAILED) {
                        s42 = void 0;
                      } else {
                        peg$currPos = s42;
                        s42 = peg$FAILED;
                      }
                      if (s42 !== peg$FAILED) {
                        s5 = peg$parsemath_token();
                        if (s5 !== peg$FAILED) {
                          peg$savedPos = s32;
                          s32 = peg$f1(s5);
                        } else {
                          peg$currPos = s32;
                          s32 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s32;
                        s32 = peg$FAILED;
                      }
                    }
                  } else {
                    s22 = peg$FAILED;
                  }
                  if (s22 !== peg$FAILED) {
                    s32 = peg$parsemath_shift();
                    if (s32 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s0 = peg$f2(s22);
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
                if (s0 === peg$FAILED) {
                  s0 = peg$parsealignment_tab();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parseparbreak();
                    if (s0 === peg$FAILED) {
                      s0 = peg$parsemacro_parameter();
                      if (s0 === peg$FAILED) {
                        s0 = peg$parseignore();
                        if (s0 === peg$FAILED) {
                          s0 = peg$parsenumber();
                          if (s0 === peg$FAILED) {
                            s0 = peg$parsewhitespace();
                            if (s0 === peg$FAILED) {
                              s0 = peg$parsepunctuation();
                              if (s0 === peg$FAILED) {
                                s0 = peg$currPos;
                                s1 = peg$currPos;
                                s22 = [];
                                s32 = peg$currPos;
                                s42 = peg$currPos;
                                peg$silentFails++;
                                s5 = peg$parsenonchar_token();
                                peg$silentFails--;
                                if (s5 === peg$FAILED) {
                                  s42 = void 0;
                                } else {
                                  peg$currPos = s42;
                                  s42 = peg$FAILED;
                                }
                                if (s42 !== peg$FAILED) {
                                  if (input.length > peg$currPos) {
                                    s5 = input.charAt(peg$currPos);
                                    peg$currPos++;
                                  } else {
                                    s5 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                      peg$fail(peg$e3);
                                    }
                                  }
                                  if (s5 !== peg$FAILED) {
                                    s42 = [s42, s5];
                                    s32 = s42;
                                  } else {
                                    peg$currPos = s32;
                                    s32 = peg$FAILED;
                                  }
                                } else {
                                  peg$currPos = s32;
                                  s32 = peg$FAILED;
                                }
                                if (s32 !== peg$FAILED) {
                                  while (s32 !== peg$FAILED) {
                                    s22.push(s32);
                                    s32 = peg$currPos;
                                    s42 = peg$currPos;
                                    peg$silentFails++;
                                    s5 = peg$parsenonchar_token();
                                    peg$silentFails--;
                                    if (s5 === peg$FAILED) {
                                      s42 = void 0;
                                    } else {
                                      peg$currPos = s42;
                                      s42 = peg$FAILED;
                                    }
                                    if (s42 !== peg$FAILED) {
                                      if (input.length > peg$currPos) {
                                        s5 = input.charAt(peg$currPos);
                                        peg$currPos++;
                                      } else {
                                        s5 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                          peg$fail(peg$e3);
                                        }
                                      }
                                      if (s5 !== peg$FAILED) {
                                        s42 = [s42, s5];
                                        s32 = s42;
                                      } else {
                                        peg$currPos = s32;
                                        s32 = peg$FAILED;
                                      }
                                    } else {
                                      peg$currPos = s32;
                                      s32 = peg$FAILED;
                                    }
                                  }
                                } else {
                                  s22 = peg$FAILED;
                                }
                                if (s22 !== peg$FAILED) {
                                  s1 = input.substring(s1, peg$currPos);
                                } else {
                                  s1 = s22;
                                }
                                if (s1 !== peg$FAILED) {
                                  peg$savedPos = s0;
                                  s1 = peg$f3(s1);
                                }
                                s0 = s1;
                                if (s0 === peg$FAILED) {
                                  s0 = peg$parsebegin_group();
                                  if (s0 === peg$FAILED) {
                                    s0 = peg$parseend_group();
                                    if (s0 === peg$FAILED) {
                                      s0 = peg$parsemath_shift();
                                      if (s0 === peg$FAILED) {
                                        s0 = peg$currPos;
                                        if (input.length > peg$currPos) {
                                          s1 = input.charAt(peg$currPos);
                                          peg$currPos++;
                                        } else {
                                          s1 = peg$FAILED;
                                          if (peg$silentFails === 0) {
                                            peg$fail(peg$e3);
                                          }
                                        }
                                        if (s1 !== peg$FAILED) {
                                          peg$savedPos = s0;
                                          s1 = peg$f4(s1);
                                        }
                                        s0 = s1;
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        return s0;
      }
      function peg$parseparbreak() {
        var s0, s1, s22, s32, s42, s5, s6, s7;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = [];
        s32 = peg$parsesp();
        while (s32 !== peg$FAILED) {
          s22.push(s32);
          s32 = peg$parsesp();
        }
        s32 = peg$parsenl();
        if (s32 !== peg$FAILED) {
          s42 = [];
          s5 = peg$currPos;
          s6 = [];
          s7 = peg$parsesp();
          while (s7 !== peg$FAILED) {
            s6.push(s7);
            s7 = peg$parsesp();
          }
          s7 = peg$parsenl();
          if (s7 !== peg$FAILED) {
            s6 = [s6, s7];
            s5 = s6;
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
          if (s5 !== peg$FAILED) {
            while (s5 !== peg$FAILED) {
              s42.push(s5);
              s5 = peg$currPos;
              s6 = [];
              s7 = peg$parsesp();
              while (s7 !== peg$FAILED) {
                s6.push(s7);
                s7 = peg$parsesp();
              }
              s7 = peg$parsenl();
              if (s7 !== peg$FAILED) {
                s6 = [s6, s7];
                s5 = s6;
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            }
          } else {
            s42 = peg$FAILED;
          }
          if (s42 !== peg$FAILED) {
            s5 = [];
            s6 = peg$parsesp();
            while (s6 !== peg$FAILED) {
              s5.push(s6);
              s6 = peg$parsesp();
            }
            s6 = peg$currPos;
            peg$silentFails++;
            s7 = peg$parsecomment_start();
            peg$silentFails--;
            if (s7 === peg$FAILED) {
              s6 = void 0;
            } else {
              peg$currPos = s6;
              s6 = peg$FAILED;
            }
            if (s6 !== peg$FAILED) {
              s22 = [s22, s32, s42, s5, s6];
              s1 = s22;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
          s1 = peg$currPos;
          s22 = [];
          s32 = peg$parsesp();
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parsesp();
          }
          s32 = peg$parsenl();
          if (s32 !== peg$FAILED) {
            s42 = [];
            s5 = peg$currPos;
            s6 = [];
            s7 = peg$parsesp();
            while (s7 !== peg$FAILED) {
              s6.push(s7);
              s7 = peg$parsesp();
            }
            s7 = peg$parsenl();
            if (s7 !== peg$FAILED) {
              s6 = [s6, s7];
              s5 = s6;
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
            if (s5 !== peg$FAILED) {
              while (s5 !== peg$FAILED) {
                s42.push(s5);
                s5 = peg$currPos;
                s6 = [];
                s7 = peg$parsesp();
                while (s7 !== peg$FAILED) {
                  s6.push(s7);
                  s7 = peg$parsesp();
                }
                s7 = peg$parsenl();
                if (s7 !== peg$FAILED) {
                  s6 = [s6, s7];
                  s5 = s6;
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              }
            } else {
              s42 = peg$FAILED;
            }
            if (s42 !== peg$FAILED) {
              s22 = [s22, s32, s42];
              s1 = s22;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f5();
        }
        s0 = s1;
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e4);
          }
        }
        return s0;
      }
      function peg$parsemath_token() {
        var s0, s1, s22, s32, s42;
        peg$silentFails++;
        s0 = peg$parsespecial_macro();
        if (s0 === peg$FAILED) {
          s0 = peg$parsemacro();
          if (s0 === peg$FAILED) {
            s0 = peg$parsefull_comment();
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = [];
              s22 = peg$parsewhitespace();
              while (s22 !== peg$FAILED) {
                s1.push(s22);
                s22 = peg$parsewhitespace();
              }
              s22 = peg$parsegroup();
              if (s22 !== peg$FAILED) {
                s32 = [];
                s42 = peg$parsewhitespace();
                while (s42 !== peg$FAILED) {
                  s32.push(s42);
                  s42 = peg$parsewhitespace();
                }
                peg$savedPos = s0;
                s0 = peg$f6(s22);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = [];
                s22 = peg$parsewhitespace();
                while (s22 !== peg$FAILED) {
                  s1.push(s22);
                  s22 = peg$parsewhitespace();
                }
                s22 = peg$parsealignment_tab();
                if (s22 !== peg$FAILED) {
                  s32 = [];
                  s42 = peg$parsewhitespace();
                  while (s42 !== peg$FAILED) {
                    s32.push(s42);
                    s42 = peg$parsewhitespace();
                  }
                  peg$savedPos = s0;
                  s0 = peg$f7(s22);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
                if (s0 === peg$FAILED) {
                  s0 = peg$parsemacro_parameter();
                  if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    s1 = [];
                    s22 = peg$parsewhitespace();
                    while (s22 !== peg$FAILED) {
                      s1.push(s22);
                      s22 = peg$parsewhitespace();
                    }
                    s22 = peg$parsesuperscript();
                    if (s22 !== peg$FAILED) {
                      s32 = [];
                      s42 = peg$parsewhitespace();
                      while (s42 !== peg$FAILED) {
                        s32.push(s42);
                        s42 = peg$parsewhitespace();
                      }
                      peg$savedPos = s0;
                      s0 = peg$f8();
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                    if (s0 === peg$FAILED) {
                      s0 = peg$currPos;
                      s1 = [];
                      s22 = peg$parsewhitespace();
                      while (s22 !== peg$FAILED) {
                        s1.push(s22);
                        s22 = peg$parsewhitespace();
                      }
                      s22 = peg$parsesubscript();
                      if (s22 !== peg$FAILED) {
                        s32 = [];
                        s42 = peg$parsewhitespace();
                        while (s42 !== peg$FAILED) {
                          s32.push(s42);
                          s42 = peg$parsewhitespace();
                        }
                        peg$savedPos = s0;
                        s0 = peg$f9();
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                      if (s0 === peg$FAILED) {
                        s0 = peg$parseignore();
                        if (s0 === peg$FAILED) {
                          s0 = peg$parsewhitespace();
                          if (s0 === peg$FAILED) {
                            s0 = peg$currPos;
                            if (input.length > peg$currPos) {
                              s1 = input.charAt(peg$currPos);
                              peg$currPos++;
                            } else {
                              s1 = peg$FAILED;
                              if (peg$silentFails === 0) {
                                peg$fail(peg$e3);
                              }
                            }
                            if (s1 !== peg$FAILED) {
                              peg$savedPos = s0;
                              s1 = peg$f10(s1);
                            }
                            s0 = s1;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e5);
          }
        }
        return s0;
      }
      function peg$parsenonchar_token() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parseescape();
        if (s0 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 37) {
            s0 = peg$c0;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e7);
            }
          }
          if (s0 === peg$FAILED) {
            s0 = peg$parsebegin_group();
            if (s0 === peg$FAILED) {
              s0 = peg$parseend_group();
              if (s0 === peg$FAILED) {
                s0 = peg$parsemath_shift();
                if (s0 === peg$FAILED) {
                  s0 = peg$parsealignment_tab();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parsenl();
                    if (s0 === peg$FAILED) {
                      s0 = peg$parsemacro_parameter();
                      if (s0 === peg$FAILED) {
                        s0 = peg$parseignore();
                        if (s0 === peg$FAILED) {
                          s0 = peg$parsesp();
                          if (s0 === peg$FAILED) {
                            s0 = peg$parsepunctuation();
                            if (s0 === peg$FAILED) {
                              s0 = peg$parseEOF();
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e6);
          }
        }
        return s0;
      }
      function peg$parsewhitespace() {
        var s0, s1, s22, s32, s42, s5, s6, s7;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$parsenl();
        if (s22 !== peg$FAILED) {
          s32 = [];
          s42 = peg$parsesp();
          while (s42 !== peg$FAILED) {
            s32.push(s42);
            s42 = peg$parsesp();
          }
          s22 = [s22, s32];
          s1 = s22;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
          s1 = peg$currPos;
          s22 = [];
          s32 = peg$parsesp();
          if (s32 !== peg$FAILED) {
            while (s32 !== peg$FAILED) {
              s22.push(s32);
              s32 = peg$parsesp();
            }
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s32 = peg$parsenl();
            if (s32 !== peg$FAILED) {
              s42 = peg$currPos;
              peg$silentFails++;
              s5 = peg$parsecomment_start();
              peg$silentFails--;
              if (s5 === peg$FAILED) {
                s42 = void 0;
              } else {
                peg$currPos = s42;
                s42 = peg$FAILED;
              }
              if (s42 !== peg$FAILED) {
                s5 = [];
                s6 = peg$parsesp();
                while (s6 !== peg$FAILED) {
                  s5.push(s6);
                  s6 = peg$parsesp();
                }
                s6 = peg$currPos;
                peg$silentFails++;
                s7 = peg$parsenl();
                peg$silentFails--;
                if (s7 === peg$FAILED) {
                  s6 = void 0;
                } else {
                  peg$currPos = s6;
                  s6 = peg$FAILED;
                }
                if (s6 !== peg$FAILED) {
                  s22 = [s22, s32, s42, s5, s6];
                  s1 = s22;
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 === peg$FAILED) {
            s1 = [];
            s22 = peg$parsesp();
            if (s22 !== peg$FAILED) {
              while (s22 !== peg$FAILED) {
                s1.push(s22);
                s22 = peg$parsesp();
              }
            } else {
              s1 = peg$FAILED;
            }
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f11();
        }
        s0 = s1;
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e8);
          }
        }
        return s0;
      }
      function peg$parsenumber() {
        var s0, s1, s22, s32, s42, s5;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = [];
        s32 = peg$parsenum();
        if (s32 !== peg$FAILED) {
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parsenum();
          }
        } else {
          s22 = peg$FAILED;
        }
        if (s22 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 46) {
            s32 = peg$c1;
            peg$currPos++;
          } else {
            s32 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e10);
            }
          }
          if (s32 !== peg$FAILED) {
            s42 = [];
            s5 = peg$parsenum();
            if (s5 !== peg$FAILED) {
              while (s5 !== peg$FAILED) {
                s42.push(s5);
                s5 = peg$parsenum();
              }
            } else {
              s42 = peg$FAILED;
            }
            if (s42 !== peg$FAILED) {
              peg$savedPos = s1;
              s1 = peg$f12(s22, s42);
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
          s1 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 46) {
            s22 = peg$c1;
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e10);
            }
          }
          if (s22 !== peg$FAILED) {
            s32 = [];
            s42 = peg$parsenum();
            if (s42 !== peg$FAILED) {
              while (s42 !== peg$FAILED) {
                s32.push(s42);
                s42 = peg$parsenum();
              }
            } else {
              s32 = peg$FAILED;
            }
            if (s32 !== peg$FAILED) {
              peg$savedPos = s1;
              s1 = peg$f13(s32);
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 === peg$FAILED) {
            s1 = peg$currPos;
            s22 = [];
            s32 = peg$parsenum();
            if (s32 !== peg$FAILED) {
              while (s32 !== peg$FAILED) {
                s22.push(s32);
                s32 = peg$parsenum();
              }
            } else {
              s22 = peg$FAILED;
            }
            if (s22 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 46) {
                s32 = peg$c1;
                peg$currPos++;
              } else {
                s32 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e10);
                }
              }
              if (s32 !== peg$FAILED) {
                peg$savedPos = s1;
                s1 = peg$f14(s22);
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f15(s1);
        }
        s0 = s1;
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e9);
          }
        }
        return s0;
      }
      function peg$parsespecial_macro() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8, s9;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parseescape();
        if (s1 !== peg$FAILED) {
          if (input.substr(peg$currPos, 5) === peg$c2) {
            s22 = peg$c2;
            peg$currPos += 5;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e12);
            }
          }
          if (s22 === peg$FAILED) {
            if (input.substr(peg$currPos, 4) === peg$c3) {
              s22 = peg$c3;
              peg$currPos += 4;
            } else {
              s22 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e13);
              }
            }
          }
          if (s22 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s32 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s32 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e3);
              }
            }
            if (s32 !== peg$FAILED) {
              s42 = [];
              s5 = peg$currPos;
              s6 = peg$currPos;
              peg$silentFails++;
              s7 = peg$currPos;
              if (input.length > peg$currPos) {
                s8 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s8 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e3);
                }
              }
              if (s8 !== peg$FAILED) {
                peg$savedPos = peg$currPos;
                s9 = peg$f16(s22, s32, s8);
                if (s9) {
                  s9 = void 0;
                } else {
                  s9 = peg$FAILED;
                }
                if (s9 !== peg$FAILED) {
                  s8 = [s8, s9];
                  s7 = s8;
                } else {
                  peg$currPos = s7;
                  s7 = peg$FAILED;
                }
              } else {
                peg$currPos = s7;
                s7 = peg$FAILED;
              }
              peg$silentFails--;
              if (s7 === peg$FAILED) {
                s6 = void 0;
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
              if (s6 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                  s7 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e3);
                  }
                }
                if (s7 !== peg$FAILED) {
                  peg$savedPos = s5;
                  s5 = peg$f17(s22, s32, s7);
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
              while (s5 !== peg$FAILED) {
                s42.push(s5);
                s5 = peg$currPos;
                s6 = peg$currPos;
                peg$silentFails++;
                s7 = peg$currPos;
                if (input.length > peg$currPos) {
                  s8 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s8 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e3);
                  }
                }
                if (s8 !== peg$FAILED) {
                  peg$savedPos = peg$currPos;
                  s9 = peg$f16(s22, s32, s8);
                  if (s9) {
                    s9 = void 0;
                  } else {
                    s9 = peg$FAILED;
                  }
                  if (s9 !== peg$FAILED) {
                    s8 = [s8, s9];
                    s7 = s8;
                  } else {
                    peg$currPos = s7;
                    s7 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s7;
                  s7 = peg$FAILED;
                }
                peg$silentFails--;
                if (s7 === peg$FAILED) {
                  s6 = void 0;
                } else {
                  peg$currPos = s6;
                  s6 = peg$FAILED;
                }
                if (s6 !== peg$FAILED) {
                  if (input.length > peg$currPos) {
                    s7 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e3);
                    }
                  }
                  if (s7 !== peg$FAILED) {
                    peg$savedPos = s5;
                    s5 = peg$f17(s22, s32, s7);
                  } else {
                    peg$currPos = s5;
                    s5 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              }
              s5 = peg$currPos;
              if (input.length > peg$currPos) {
                s6 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e3);
                }
              }
              if (s6 !== peg$FAILED) {
                peg$savedPos = peg$currPos;
                s7 = peg$f18(s22, s32, s42, s6);
                if (s7) {
                  s7 = void 0;
                } else {
                  s7 = peg$FAILED;
                }
                if (s7 !== peg$FAILED) {
                  s6 = [s6, s7];
                  s5 = s6;
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f19(s22, s32, s42);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$parseverbatim_environment();
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsebegin_display_math();
            if (s1 !== peg$FAILED) {
              s22 = [];
              s32 = peg$currPos;
              s42 = peg$currPos;
              peg$silentFails++;
              s5 = peg$parseend_display_math();
              peg$silentFails--;
              if (s5 === peg$FAILED) {
                s42 = void 0;
              } else {
                peg$currPos = s42;
                s42 = peg$FAILED;
              }
              if (s42 !== peg$FAILED) {
                s5 = peg$parsemath_token();
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s32;
                  s32 = peg$f20(s5);
                } else {
                  peg$currPos = s32;
                  s32 = peg$FAILED;
                }
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
              while (s32 !== peg$FAILED) {
                s22.push(s32);
                s32 = peg$currPos;
                s42 = peg$currPos;
                peg$silentFails++;
                s5 = peg$parseend_display_math();
                peg$silentFails--;
                if (s5 === peg$FAILED) {
                  s42 = void 0;
                } else {
                  peg$currPos = s42;
                  s42 = peg$FAILED;
                }
                if (s42 !== peg$FAILED) {
                  s5 = peg$parsemath_token();
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s32;
                    s32 = peg$f20(s5);
                  } else {
                    peg$currPos = s32;
                    s32 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s32;
                  s32 = peg$FAILED;
                }
              }
              s32 = peg$parseend_display_math();
              if (s32 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f21(s22);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parsebegin_inline_math();
              if (s1 !== peg$FAILED) {
                s22 = [];
                s32 = peg$currPos;
                s42 = peg$currPos;
                peg$silentFails++;
                s5 = peg$parseend_inline_math();
                peg$silentFails--;
                if (s5 === peg$FAILED) {
                  s42 = void 0;
                } else {
                  peg$currPos = s42;
                  s42 = peg$FAILED;
                }
                if (s42 !== peg$FAILED) {
                  s5 = peg$parsemath_token();
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s32;
                    s32 = peg$f22(s5);
                  } else {
                    peg$currPos = s32;
                    s32 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s32;
                  s32 = peg$FAILED;
                }
                while (s32 !== peg$FAILED) {
                  s22.push(s32);
                  s32 = peg$currPos;
                  s42 = peg$currPos;
                  peg$silentFails++;
                  s5 = peg$parseend_inline_math();
                  peg$silentFails--;
                  if (s5 === peg$FAILED) {
                    s42 = void 0;
                  } else {
                    peg$currPos = s42;
                    s42 = peg$FAILED;
                  }
                  if (s42 !== peg$FAILED) {
                    s5 = peg$parsemath_token();
                    if (s5 !== peg$FAILED) {
                      peg$savedPos = s32;
                      s32 = peg$f22(s5);
                    } else {
                      peg$currPos = s32;
                      s32 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s32;
                    s32 = peg$FAILED;
                  }
                }
                s32 = peg$parseend_inline_math();
                if (s32 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s0 = peg$f23(s22);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parsemath_shift();
                if (s1 !== peg$FAILED) {
                  s22 = peg$parsemath_shift();
                  if (s22 !== peg$FAILED) {
                    s32 = [];
                    s42 = peg$currPos;
                    s5 = peg$currPos;
                    peg$silentFails++;
                    s6 = peg$currPos;
                    s7 = peg$parsemath_shift();
                    if (s7 !== peg$FAILED) {
                      s8 = peg$parsemath_shift();
                      if (s8 !== peg$FAILED) {
                        s7 = [s7, s8];
                        s6 = s7;
                      } else {
                        peg$currPos = s6;
                        s6 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s6;
                      s6 = peg$FAILED;
                    }
                    peg$silentFails--;
                    if (s6 === peg$FAILED) {
                      s5 = void 0;
                    } else {
                      peg$currPos = s5;
                      s5 = peg$FAILED;
                    }
                    if (s5 !== peg$FAILED) {
                      s6 = peg$parsemath_token();
                      if (s6 !== peg$FAILED) {
                        peg$savedPos = s42;
                        s42 = peg$f24(s6);
                      } else {
                        peg$currPos = s42;
                        s42 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s42;
                      s42 = peg$FAILED;
                    }
                    while (s42 !== peg$FAILED) {
                      s32.push(s42);
                      s42 = peg$currPos;
                      s5 = peg$currPos;
                      peg$silentFails++;
                      s6 = peg$currPos;
                      s7 = peg$parsemath_shift();
                      if (s7 !== peg$FAILED) {
                        s8 = peg$parsemath_shift();
                        if (s8 !== peg$FAILED) {
                          s7 = [s7, s8];
                          s6 = s7;
                        } else {
                          peg$currPos = s6;
                          s6 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s6;
                        s6 = peg$FAILED;
                      }
                      peg$silentFails--;
                      if (s6 === peg$FAILED) {
                        s5 = void 0;
                      } else {
                        peg$currPos = s5;
                        s5 = peg$FAILED;
                      }
                      if (s5 !== peg$FAILED) {
                        s6 = peg$parsemath_token();
                        if (s6 !== peg$FAILED) {
                          peg$savedPos = s42;
                          s42 = peg$f24(s6);
                        } else {
                          peg$currPos = s42;
                          s42 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s42;
                        s42 = peg$FAILED;
                      }
                    }
                    s42 = peg$parsemath_shift();
                    if (s42 !== peg$FAILED) {
                      s5 = peg$parsemath_shift();
                      if (s5 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s0 = peg$f25(s32);
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
                if (s0 === peg$FAILED) {
                  s0 = peg$parsemath_environment();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parseenvironment();
                  }
                }
              }
            }
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e11);
          }
        }
        return s0;
      }
      function peg$parseverbatim_environment() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8, s9, s10, s11;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parsebegin_env();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsebegin_group();
          if (s22 !== peg$FAILED) {
            s32 = peg$parseverbatim_env_name();
            if (s32 !== peg$FAILED) {
              s42 = peg$parseend_group();
              if (s42 !== peg$FAILED) {
                s5 = [];
                s6 = peg$currPos;
                s7 = peg$currPos;
                peg$silentFails++;
                s8 = peg$currPos;
                s9 = peg$parseend_env();
                if (s9 !== peg$FAILED) {
                  s10 = peg$parsegroup();
                  if (s10 !== peg$FAILED) {
                    peg$savedPos = peg$currPos;
                    s11 = peg$f26(s32, s10);
                    if (s11) {
                      s11 = void 0;
                    } else {
                      s11 = peg$FAILED;
                    }
                    if (s11 !== peg$FAILED) {
                      s9 = [s9, s10, s11];
                      s8 = s9;
                    } else {
                      peg$currPos = s8;
                      s8 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s8;
                    s8 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s8;
                  s8 = peg$FAILED;
                }
                peg$silentFails--;
                if (s8 === peg$FAILED) {
                  s7 = void 0;
                } else {
                  peg$currPos = s7;
                  s7 = peg$FAILED;
                }
                if (s7 !== peg$FAILED) {
                  if (input.length > peg$currPos) {
                    s8 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s8 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e3);
                    }
                  }
                  if (s8 !== peg$FAILED) {
                    peg$savedPos = s6;
                    s6 = peg$f27(s32, s8);
                  } else {
                    peg$currPos = s6;
                    s6 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s6;
                  s6 = peg$FAILED;
                }
                while (s6 !== peg$FAILED) {
                  s5.push(s6);
                  s6 = peg$currPos;
                  s7 = peg$currPos;
                  peg$silentFails++;
                  s8 = peg$currPos;
                  s9 = peg$parseend_env();
                  if (s9 !== peg$FAILED) {
                    s10 = peg$parsegroup();
                    if (s10 !== peg$FAILED) {
                      peg$savedPos = peg$currPos;
                      s11 = peg$f26(s32, s10);
                      if (s11) {
                        s11 = void 0;
                      } else {
                        s11 = peg$FAILED;
                      }
                      if (s11 !== peg$FAILED) {
                        s9 = [s9, s10, s11];
                        s8 = s9;
                      } else {
                        peg$currPos = s8;
                        s8 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s8;
                      s8 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s8;
                    s8 = peg$FAILED;
                  }
                  peg$silentFails--;
                  if (s8 === peg$FAILED) {
                    s7 = void 0;
                  } else {
                    peg$currPos = s7;
                    s7 = peg$FAILED;
                  }
                  if (s7 !== peg$FAILED) {
                    if (input.length > peg$currPos) {
                      s8 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s8 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e3);
                      }
                    }
                    if (s8 !== peg$FAILED) {
                      peg$savedPos = s6;
                      s6 = peg$f27(s32, s8);
                    } else {
                      peg$currPos = s6;
                      s6 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s6;
                    s6 = peg$FAILED;
                  }
                }
                s6 = peg$parseend_env();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parsebegin_group();
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parseverbatim_env_name();
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parseend_group();
                      if (s9 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s0 = peg$f28(s32, s5);
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e14);
          }
        }
        return s0;
      }
      function peg$parseverbatim_env_name() {
        var s0;
        if (input.substr(peg$currPos, 9) === peg$c4) {
          s0 = peg$c4;
          peg$currPos += 9;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e15);
          }
        }
        if (s0 === peg$FAILED) {
          if (input.substr(peg$currPos, 8) === peg$c5) {
            s0 = peg$c5;
            peg$currPos += 8;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e16);
            }
          }
          if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 13) === peg$c6) {
              s0 = peg$c6;
              peg$currPos += 13;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e17);
              }
            }
            if (s0 === peg$FAILED) {
              if (input.substr(peg$currPos, 12) === peg$c7) {
                s0 = peg$c7;
                peg$currPos += 12;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e18);
                }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 7) === peg$c8) {
                  s0 = peg$c8;
                  peg$currPos += 7;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e19);
                  }
                }
                if (s0 === peg$FAILED) {
                  if (input.substr(peg$currPos, 10) === peg$c9) {
                    s0 = peg$c9;
                    peg$currPos += 10;
                  } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e20);
                    }
                  }
                }
              }
            }
          }
        }
        return s0;
      }
      function peg$parsemacro() {
        var s0, s1, s22, s32, s42;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$parseescape();
        if (s22 !== peg$FAILED) {
          s32 = [];
          s42 = peg$parsechar();
          if (s42 !== peg$FAILED) {
            while (s42 !== peg$FAILED) {
              s32.push(s42);
              s42 = peg$parsechar();
            }
          } else {
            s32 = peg$FAILED;
          }
          if (s32 !== peg$FAILED) {
            peg$savedPos = s1;
            s1 = peg$f29(s32);
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
          s1 = peg$currPos;
          s22 = peg$parseescape();
          if (s22 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s32 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s32 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e3);
              }
            }
            if (s32 !== peg$FAILED) {
              peg$savedPos = s1;
              s1 = peg$f30(s32);
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f31(s1);
        }
        s0 = s1;
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e21);
          }
        }
        return s0;
      }
      function peg$parsegroup() {
        var s0, s1, s22, s32, s42, s5;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parsebegin_group();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$currPos;
          s42 = peg$currPos;
          peg$silentFails++;
          s5 = peg$parseend_group();
          peg$silentFails--;
          if (s5 === peg$FAILED) {
            s42 = void 0;
          } else {
            peg$currPos = s42;
            s42 = peg$FAILED;
          }
          if (s42 !== peg$FAILED) {
            s5 = peg$parsetoken();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s32;
              s32 = peg$f32(s5);
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          } else {
            peg$currPos = s32;
            s32 = peg$FAILED;
          }
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$currPos;
            s42 = peg$currPos;
            peg$silentFails++;
            s5 = peg$parseend_group();
            peg$silentFails--;
            if (s5 === peg$FAILED) {
              s42 = void 0;
            } else {
              peg$currPos = s42;
              s42 = peg$FAILED;
            }
            if (s42 !== peg$FAILED) {
              s5 = peg$parsetoken();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s32;
                s32 = peg$f32(s5);
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          }
          s32 = peg$parseend_group();
          if (s32 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f33(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e22);
          }
        }
        return s0;
      }
      function peg$parsegroup_contents_as_string() {
        var s0, s1;
        s0 = peg$currPos;
        s1 = peg$parsegroup();
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f34(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parseenvironment() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8, s9, s10;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parsebegin_env();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsegroup_contents_as_string();
          if (s22 !== peg$FAILED) {
            s32 = peg$parsesameline_comment();
            if (s32 === peg$FAILED) {
              s32 = null;
            }
            s42 = [];
            s5 = peg$currPos;
            s6 = peg$currPos;
            peg$silentFails++;
            s7 = peg$currPos;
            s8 = peg$parseend_env();
            if (s8 !== peg$FAILED) {
              s9 = peg$parsegroup_contents_as_string();
              if (s9 !== peg$FAILED) {
                peg$savedPos = peg$currPos;
                s10 = peg$f35(s22, s32, s9);
                if (s10) {
                  s10 = void 0;
                } else {
                  s10 = peg$FAILED;
                }
                if (s10 !== peg$FAILED) {
                  s8 = [s8, s9, s10];
                  s7 = s8;
                } else {
                  peg$currPos = s7;
                  s7 = peg$FAILED;
                }
              } else {
                peg$currPos = s7;
                s7 = peg$FAILED;
              }
            } else {
              peg$currPos = s7;
              s7 = peg$FAILED;
            }
            peg$silentFails--;
            if (s7 === peg$FAILED) {
              s6 = void 0;
            } else {
              peg$currPos = s6;
              s6 = peg$FAILED;
            }
            if (s6 !== peg$FAILED) {
              s7 = peg$parsetoken();
              if (s7 !== peg$FAILED) {
                peg$savedPos = s5;
                s5 = peg$f36(s22, s32, s7);
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
            while (s5 !== peg$FAILED) {
              s42.push(s5);
              s5 = peg$currPos;
              s6 = peg$currPos;
              peg$silentFails++;
              s7 = peg$currPos;
              s8 = peg$parseend_env();
              if (s8 !== peg$FAILED) {
                s9 = peg$parsegroup_contents_as_string();
                if (s9 !== peg$FAILED) {
                  peg$savedPos = peg$currPos;
                  s10 = peg$f35(s22, s32, s9);
                  if (s10) {
                    s10 = void 0;
                  } else {
                    s10 = peg$FAILED;
                  }
                  if (s10 !== peg$FAILED) {
                    s8 = [s8, s9, s10];
                    s7 = s8;
                  } else {
                    peg$currPos = s7;
                    s7 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s7;
                  s7 = peg$FAILED;
                }
              } else {
                peg$currPos = s7;
                s7 = peg$FAILED;
              }
              peg$silentFails--;
              if (s7 === peg$FAILED) {
                s6 = void 0;
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
              if (s6 !== peg$FAILED) {
                s7 = peg$parsetoken();
                if (s7 !== peg$FAILED) {
                  peg$savedPos = s5;
                  s5 = peg$f36(s22, s32, s7);
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            }
            s5 = peg$parseend_env();
            if (s5 !== peg$FAILED) {
              s6 = peg$parsegroup_contents_as_string();
              if (s6 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f37(s22, s32, s42);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e23);
          }
        }
        return s0;
      }
      function peg$parsemath_environment() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8, s9, s10, s11, s12;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parsebegin_env();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsebegin_group();
          if (s22 !== peg$FAILED) {
            s32 = peg$parsemath_env_name();
            if (s32 !== peg$FAILED) {
              s42 = peg$parseend_group();
              if (s42 !== peg$FAILED) {
                s5 = peg$parsesameline_comment();
                if (s5 === peg$FAILED) {
                  s5 = null;
                }
                s6 = [];
                s7 = peg$currPos;
                s8 = peg$currPos;
                peg$silentFails++;
                s9 = peg$currPos;
                s10 = peg$parseend_env();
                if (s10 !== peg$FAILED) {
                  s11 = peg$parsegroup();
                  if (s11 !== peg$FAILED) {
                    peg$savedPos = peg$currPos;
                    s12 = peg$f38(s32, s5, s11);
                    if (s12) {
                      s12 = void 0;
                    } else {
                      s12 = peg$FAILED;
                    }
                    if (s12 !== peg$FAILED) {
                      s10 = [s10, s11, s12];
                      s9 = s10;
                    } else {
                      peg$currPos = s9;
                      s9 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s9;
                    s9 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s9;
                  s9 = peg$FAILED;
                }
                peg$silentFails--;
                if (s9 === peg$FAILED) {
                  s8 = void 0;
                } else {
                  peg$currPos = s8;
                  s8 = peg$FAILED;
                }
                if (s8 !== peg$FAILED) {
                  s9 = peg$parsemath_token();
                  if (s9 !== peg$FAILED) {
                    peg$savedPos = s7;
                    s7 = peg$f39(s32, s5, s9);
                  } else {
                    peg$currPos = s7;
                    s7 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s7;
                  s7 = peg$FAILED;
                }
                while (s7 !== peg$FAILED) {
                  s6.push(s7);
                  s7 = peg$currPos;
                  s8 = peg$currPos;
                  peg$silentFails++;
                  s9 = peg$currPos;
                  s10 = peg$parseend_env();
                  if (s10 !== peg$FAILED) {
                    s11 = peg$parsegroup();
                    if (s11 !== peg$FAILED) {
                      peg$savedPos = peg$currPos;
                      s12 = peg$f38(s32, s5, s11);
                      if (s12) {
                        s12 = void 0;
                      } else {
                        s12 = peg$FAILED;
                      }
                      if (s12 !== peg$FAILED) {
                        s10 = [s10, s11, s12];
                        s9 = s10;
                      } else {
                        peg$currPos = s9;
                        s9 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s9;
                      s9 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s9;
                    s9 = peg$FAILED;
                  }
                  peg$silentFails--;
                  if (s9 === peg$FAILED) {
                    s8 = void 0;
                  } else {
                    peg$currPos = s8;
                    s8 = peg$FAILED;
                  }
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parsemath_token();
                    if (s9 !== peg$FAILED) {
                      peg$savedPos = s7;
                      s7 = peg$f39(s32, s5, s9);
                    } else {
                      peg$currPos = s7;
                      s7 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s7;
                    s7 = peg$FAILED;
                  }
                }
                s7 = peg$parseend_env();
                if (s7 !== peg$FAILED) {
                  s8 = peg$parsebegin_group();
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parsemath_env_name();
                    if (s9 !== peg$FAILED) {
                      s10 = peg$parseend_group();
                      if (s10 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s0 = peg$f40(s32, s5, s6);
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e24);
          }
        }
        return s0;
      }
      function peg$parsemath_group() {
        var s0, s1, s22, s32, s42, s5;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parsebegin_group();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$currPos;
          s42 = peg$currPos;
          peg$silentFails++;
          s5 = peg$parseend_group();
          peg$silentFails--;
          if (s5 === peg$FAILED) {
            s42 = void 0;
          } else {
            peg$currPos = s42;
            s42 = peg$FAILED;
          }
          if (s42 !== peg$FAILED) {
            s5 = peg$parsemath_token();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s32;
              s32 = peg$f41(s5);
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          } else {
            peg$currPos = s32;
            s32 = peg$FAILED;
          }
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$currPos;
            s42 = peg$currPos;
            peg$silentFails++;
            s5 = peg$parseend_group();
            peg$silentFails--;
            if (s5 === peg$FAILED) {
              s42 = void 0;
            } else {
              peg$currPos = s42;
              s42 = peg$FAILED;
            }
            if (s42 !== peg$FAILED) {
              s5 = peg$parsemath_token();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s32;
                s32 = peg$f41(s5);
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          }
          s32 = peg$parseend_group();
          if (s32 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f42(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e25);
          }
        }
        return s0;
      }
      function peg$parsebegin_display_math() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parseescape();
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 91) {
            s22 = peg$c10;
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e26);
            }
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseend_display_math() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parseescape();
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 93) {
            s22 = peg$c11;
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e27);
            }
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsebegin_inline_math() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parseescape();
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 40) {
            s22 = peg$c12;
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e28);
            }
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseend_inline_math() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parseescape();
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 41) {
            s22 = peg$c13;
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e29);
            }
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsebegin_env() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parseescape();
        if (s1 !== peg$FAILED) {
          if (input.substr(peg$currPos, 5) === peg$c14) {
            s22 = peg$c14;
            peg$currPos += 5;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e30);
            }
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseend_env() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parseescape();
        if (s1 !== peg$FAILED) {
          if (input.substr(peg$currPos, 3) === peg$c15) {
            s22 = peg$c15;
            peg$currPos += 3;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e31);
            }
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsemath_env_name() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 9) === peg$c16) {
          s1 = peg$c16;
          peg$currPos += 9;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e32);
          }
        }
        if (s1 === peg$FAILED) {
          if (input.substr(peg$currPos, 8) === peg$c17) {
            s1 = peg$c17;
            peg$currPos += 8;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e33);
            }
          }
          if (s1 === peg$FAILED) {
            if (input.substr(peg$currPos, 6) === peg$c18) {
              s1 = peg$c18;
              peg$currPos += 6;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e34);
              }
            }
            if (s1 === peg$FAILED) {
              if (input.substr(peg$currPos, 5) === peg$c19) {
                s1 = peg$c19;
                peg$currPos += 5;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e35);
                }
              }
              if (s1 === peg$FAILED) {
                if (input.substr(peg$currPos, 8) === peg$c20) {
                  s1 = peg$c20;
                  peg$currPos += 8;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e36);
                  }
                }
                if (s1 === peg$FAILED) {
                  if (input.substr(peg$currPos, 7) === peg$c21) {
                    s1 = peg$c21;
                    peg$currPos += 7;
                  } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e37);
                    }
                  }
                  if (s1 === peg$FAILED) {
                    if (input.substr(peg$currPos, 7) === peg$c22) {
                      s1 = peg$c22;
                      peg$currPos += 7;
                    } else {
                      s1 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e38);
                      }
                    }
                    if (s1 === peg$FAILED) {
                      if (input.substr(peg$currPos, 6) === peg$c23) {
                        s1 = peg$c23;
                        peg$currPos += 6;
                      } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$e39);
                        }
                      }
                      if (s1 === peg$FAILED) {
                        if (input.substr(peg$currPos, 9) === peg$c24) {
                          s1 = peg$c24;
                          peg$currPos += 9;
                        } else {
                          s1 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$e40);
                          }
                        }
                        if (s1 === peg$FAILED) {
                          if (input.substr(peg$currPos, 8) === peg$c25) {
                            s1 = peg$c25;
                            peg$currPos += 8;
                          } else {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) {
                              peg$fail(peg$e41);
                            }
                          }
                          if (s1 === peg$FAILED) {
                            if (input.substr(peg$currPos, 8) === peg$c26) {
                              s1 = peg$c26;
                              peg$currPos += 8;
                            } else {
                              s1 = peg$FAILED;
                              if (peg$silentFails === 0) {
                                peg$fail(peg$e42);
                              }
                            }
                            if (s1 === peg$FAILED) {
                              if (input.substr(peg$currPos, 7) === peg$c27) {
                                s1 = peg$c27;
                                peg$currPos += 7;
                              } else {
                                s1 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                  peg$fail(peg$e43);
                                }
                              }
                              if (s1 === peg$FAILED) {
                                if (input.substr(peg$currPos, 5) === peg$c28) {
                                  s1 = peg$c28;
                                  peg$currPos += 5;
                                } else {
                                  s1 = peg$FAILED;
                                  if (peg$silentFails === 0) {
                                    peg$fail(peg$e44);
                                  }
                                }
                                if (s1 === peg$FAILED) {
                                  if (input.substr(peg$currPos, 4) === peg$c29) {
                                    s1 = peg$c29;
                                    peg$currPos += 4;
                                  } else {
                                    s1 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                      peg$fail(peg$e45);
                                    }
                                  }
                                  if (s1 === peg$FAILED) {
                                    if (input.substr(peg$currPos, 11) === peg$c30) {
                                      s1 = peg$c30;
                                      peg$currPos += 11;
                                    } else {
                                      s1 = peg$FAILED;
                                      if (peg$silentFails === 0) {
                                        peg$fail(peg$e46);
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f43(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parseescape() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 92) {
          s1 = peg$c31;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e48);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f44();
        }
        s0 = s1;
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e47);
          }
        }
        return s0;
      }
      function peg$parsebegin_group() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 123) {
          s1 = peg$c32;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e49);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f45(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parseend_group() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 125) {
          s1 = peg$c33;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e50);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f46(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parsemath_shift() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 36) {
          s1 = peg$c34;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e51);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f47(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parsealignment_tab() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 38) {
          s1 = peg$c35;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e52);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f48(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parsenl() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 13) {
          s22 = peg$c36;
          peg$currPos++;
        } else {
          s22 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e54);
          }
        }
        peg$silentFails--;
        if (s22 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 10) {
            s22 = peg$c37;
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e55);
            }
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 13) {
            s0 = peg$c36;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e54);
            }
          }
          if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c38) {
              s0 = peg$c38;
              peg$currPos += 2;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e56);
              }
            }
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e53);
          }
        }
        return s0;
      }
      function peg$parsemacro_parameter() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 35) {
          s1 = peg$c39;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e57);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f49(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parsesuperscript() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 94) {
          s1 = peg$c40;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e58);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f50(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parsesubscript() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 95) {
          s1 = peg$c41;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e59);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f51(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parseignore() {
        var s0;
        if (input.charCodeAt(peg$currPos) === 0) {
          s0 = peg$c42;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e60);
          }
        }
        return s0;
      }
      function peg$parsesp() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        if (peg$r0.test(input.charAt(peg$currPos))) {
          s22 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s22 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e61);
          }
        }
        if (s22 !== peg$FAILED) {
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            if (peg$r0.test(input.charAt(peg$currPos))) {
              s22 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s22 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e61);
              }
            }
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f52();
        }
        s0 = s1;
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e8);
          }
        }
        return s0;
      }
      function peg$parsechar() {
        var s0, s1;
        peg$silentFails++;
        if (peg$r1.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e63);
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e62);
          }
        }
        return s0;
      }
      function peg$parsenum() {
        var s0, s1;
        peg$silentFails++;
        if (peg$r2.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e65);
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e64);
          }
        }
        return s0;
      }
      function peg$parsepunctuation() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$currPos;
        if (peg$r3.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e67);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f53(s1);
        }
        s0 = s1;
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e66);
          }
        }
        return s0;
      }
      function peg$parsecomment_start() {
        var s0;
        if (input.charCodeAt(peg$currPos) === 37) {
          s0 = peg$c0;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e7);
          }
        }
        return s0;
      }
      function peg$parsefull_comment() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parseownline_comment();
        if (s0 === peg$FAILED) {
          s0 = peg$parsesameline_comment();
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e68);
          }
        }
        return s0;
      }
      function peg$parseownline_comment() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = [];
        s32 = peg$parsesp();
        while (s32 !== peg$FAILED) {
          s22.push(s32);
          s32 = peg$parsesp();
        }
        s32 = peg$parsenl();
        if (s32 !== peg$FAILED) {
          s22 = [s22, s32];
          s1 = s22;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
          s1 = null;
        }
        s22 = peg$parseleading_sp();
        if (s22 !== peg$FAILED) {
          s32 = peg$parsecomment();
          if (s32 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f54(s22, s32);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsesameline_comment() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsesp();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parsesp();
        }
        s22 = peg$parsecomment();
        if (s22 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f55(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecomment() {
        var s0, s1, s22, s32, s42, s5, s6, s7;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parsecomment_start();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$currPos;
          s42 = peg$currPos;
          peg$silentFails++;
          s5 = peg$parsenl();
          peg$silentFails--;
          if (s5 === peg$FAILED) {
            s42 = void 0;
          } else {
            peg$currPos = s42;
            s42 = peg$FAILED;
          }
          if (s42 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s5 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e3);
              }
            }
            if (s5 !== peg$FAILED) {
              peg$savedPos = s32;
              s32 = peg$f56(s5);
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          } else {
            peg$currPos = s32;
            s32 = peg$FAILED;
          }
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$currPos;
            s42 = peg$currPos;
            peg$silentFails++;
            s5 = peg$parsenl();
            peg$silentFails--;
            if (s5 === peg$FAILED) {
              s42 = void 0;
            } else {
              peg$currPos = s42;
              s42 = peg$FAILED;
            }
            if (s42 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s5 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e3);
                }
              }
              if (s5 !== peg$FAILED) {
                peg$savedPos = s32;
                s32 = peg$f56(s5);
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          }
          s32 = peg$currPos;
          peg$silentFails++;
          s42 = peg$parseparbreak();
          peg$silentFails--;
          if (s42 !== peg$FAILED) {
            peg$currPos = s32;
            s32 = void 0;
          } else {
            s32 = peg$FAILED;
          }
          if (s32 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f57(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsecomment_start();
          if (s1 !== peg$FAILED) {
            s22 = [];
            s32 = peg$currPos;
            s42 = peg$currPos;
            peg$silentFails++;
            s5 = peg$parsenl();
            peg$silentFails--;
            if (s5 === peg$FAILED) {
              s42 = void 0;
            } else {
              peg$currPos = s42;
              s42 = peg$FAILED;
            }
            if (s42 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s5 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e3);
                }
              }
              if (s5 !== peg$FAILED) {
                peg$savedPos = s32;
                s32 = peg$f58(s5);
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
            while (s32 !== peg$FAILED) {
              s22.push(s32);
              s32 = peg$currPos;
              s42 = peg$currPos;
              peg$silentFails++;
              s5 = peg$parsenl();
              peg$silentFails--;
              if (s5 === peg$FAILED) {
                s42 = void 0;
              } else {
                peg$currPos = s42;
                s42 = peg$FAILED;
              }
              if (s42 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                  s5 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e3);
                  }
                }
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s32;
                  s32 = peg$f58(s5);
                } else {
                  peg$currPos = s32;
                  s32 = peg$FAILED;
                }
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
            }
            s32 = peg$currPos;
            s42 = peg$parsenl();
            if (s42 !== peg$FAILED) {
              s5 = [];
              s6 = peg$parsesp();
              while (s6 !== peg$FAILED) {
                s5.push(s6);
                s6 = peg$parsesp();
              }
              s6 = peg$currPos;
              peg$silentFails++;
              s7 = peg$parsecomment_start();
              peg$silentFails--;
              if (s7 === peg$FAILED) {
                s6 = void 0;
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
              if (s6 !== peg$FAILED) {
                s42 = [s42, s5, s6];
                s32 = s42;
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
            if (s32 === peg$FAILED) {
              s32 = peg$parsenl();
              if (s32 === peg$FAILED) {
                s32 = peg$parseEOF();
              }
            }
            if (s32 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f59(s22);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e69);
          }
        }
        return s0;
      }
      function peg$parseleading_sp() {
        var s0, s1, s22, s32, s42;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$parsestart_of_line();
        if (s22 !== peg$FAILED) {
          s32 = [];
          s42 = peg$parsesp();
          while (s42 !== peg$FAILED) {
            s32.push(s42);
            s42 = peg$parsesp();
          }
          s22 = [s22, s32];
          s1 = s22;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }
        return s0;
      }
      function peg$parsestart_of_line() {
        var s0;
        peg$savedPos = peg$currPos;
        s0 = peg$f60();
        if (s0) {
          s0 = void 0;
        } else {
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseEOF() {
        var s0, s1;
        s0 = peg$currPos;
        peg$silentFails++;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        peg$silentFails--;
        if (s1 === peg$FAILED) {
          s0 = void 0;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function toString(e) {
        if (typeof e === "string") {
          return e;
        }
        if (typeof e.content === "string") {
          return e.content;
        }
        if (e && e.type === "whitespace") {
          return " ";
        }
        return e;
      }
      function compare_env(g1, g2) {
        const g1Name = typeof g1 === "string" ? g1 : g1.content.map(toString).join("");
        const g2Name = typeof g2 === "string" ? g2 : g2.content.map(toString).join("");
        return g1Name === g2Name;
      }
      function createNode(type, extra = {}) {
        return { type, ...extra, position: location() };
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(
          peg$maxFailExpected,
          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
      }
    }
    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }()
);
var align_environment_default = (
  // Generated by Peggy 2.0.1.
  //
  // https://peggyjs.org/
  function() {
    "use strict";
    function peg$subclass(child, parent) {
      function C() {
        this.constructor = child;
      }
      C.prototype = parent.prototype;
      child.prototype = new C();
    }
    function peg$SyntaxError(message, expected, found, location) {
      var self = Error.call(this, message);
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(self, peg$SyntaxError.prototype);
      }
      self.expected = expected;
      self.found = found;
      self.location = location;
      self.name = "SyntaxError";
      return self;
    }
    peg$subclass(peg$SyntaxError, Error);
    function peg$padEnd(str, targetLength, padString) {
      padString = padString || " ";
      if (str.length > targetLength) {
        return str;
      }
      targetLength -= str.length;
      padString += padString.repeat(targetLength);
      return str + padString.slice(0, targetLength);
    }
    peg$SyntaxError.prototype.format = function(sources) {
      var str = "Error: " + this.message;
      if (this.location) {
        var src = null;
        var k;
        for (k = 0; k < sources.length; k++) {
          if (sources[k].source === this.location.source) {
            src = sources[k].text.split(/\r\n|\n|\r/g);
            break;
          }
        }
        var s32 = this.location.start;
        var loc = this.location.source + ":" + s32.line + ":" + s32.column;
        if (src) {
          var e = this.location.end;
          var filler = peg$padEnd("", s32.line.toString().length, " ");
          var line = src[s32.line - 1];
          var last = s32.line === e.line ? e.column : line.length + 1;
          var hatLen = last - s32.column || 1;
          str += "\n --> " + loc + "\n" + filler + " |\n" + s32.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s32.column - 1, " ") + peg$padEnd("", hatLen, "^");
        } else {
          str += "\n at " + loc;
        }
      }
      return str;
    };
    peg$SyntaxError.buildMessage = function(expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        class: function(expectation) {
          var escapedParts = expectation.parts.map(function(part) {
            return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
          });
          return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
        },
        any: function() {
          return "any character";
        },
        end: function() {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        }
      };
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s32) {
        return s32.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function classEscape(s32) {
        return s32.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = expected2.map(describeExpectation);
        var i, j;
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {};
      var peg$source = options.grammarSource;
      var peg$startRuleFunctions = { body: peg$parsebody };
      var peg$startRuleFunction = peg$parsebody;
      var peg$e0 = peg$anyExpectation();
      var peg$f0 = function() {
        return [];
      };
      var peg$f1 = function(x) {
        return { cells: [], colSeps: [], ...x };
      };
      var peg$f2 = function(rowItems, rowSep, trailingComment) {
        return { ...rowItems, rowSep, trailingComment };
      };
      var peg$f3 = function(rowItems, trailingComment) {
        return { ...rowItems, rowSep: null, trailingComment };
      };
      var peg$f4 = function(x) {
        return x;
      };
      var peg$f5 = function(x) {
        return {
          cells: [],
          colSeps: [],
          rowSep: null,
          trailingComment: x
        };
      };
      var peg$f6 = function(x) {
        return x;
      };
      var peg$f7 = function(colSep, cell) {
        return { colSep, cell };
      };
      var peg$f8 = function(colSep) {
        return { colSep };
      };
      var peg$f9 = function(a, b) {
        return processRow(a, b);
      };
      var peg$f10 = function(b) {
        return processRow(null, b);
      };
      var peg$f11 = function(tok) {
        return options.isSameLineComment(tok);
      };
      var peg$f12 = function(tok) {
        return tok;
      };
      var peg$f13 = function(tok) {
        return options.isOwnLineComment(tok);
      };
      var peg$f14 = function(tok) {
        return tok;
      };
      var peg$f15 = function(tok) {
        return options.isWhitespace(tok);
      };
      var peg$f16 = function(tok) {
        return tok;
      };
      var peg$f17 = function(tok) {
        return options.isRowSep(tok);
      };
      var peg$f18 = function(tok) {
        return tok;
      };
      var peg$f19 = function(tok) {
        return options.isColSep(tok);
      };
      var peg$f20 = function(tok) {
        return tok;
      };
      var peg$currPos = 0;
      var peg$savedPos = 0;
      var peg$posDetailsCache = [{ line: 1, column: 1 }];
      var peg$maxFailPos = 0;
      var peg$maxFailExpected = [];
      var peg$silentFails = 0;
      var peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function offset() {
        return peg$savedPos;
      }
      function range() {
        return {
          source: peg$source,
          start: peg$savedPos,
          end: peg$currPos
        };
      }
      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError(
          [peg$otherExpectation(description)],
          input.substring(peg$savedPos, peg$currPos),
          location2
        );
      }
      function error(message, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location2);
      }
      function peg$literalExpectation(text2, ignoreCase) {
        return { type: "literal", text: text2, ignoreCase };
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts, inverted, ignoreCase };
      }
      function peg$anyExpectation() {
        return { type: "any" };
      }
      function peg$endExpectation() {
        return { type: "end" };
      }
      function peg$otherExpectation(description) {
        return { type: "other", description };
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p;
        if (details) {
          return details;
        } else {
          p = pos - 1;
          while (!peg$posDetailsCache[p]) {
            p--;
          }
          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };
          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos);
        var endPosDetails = peg$computePosDetails(endPos);
        return {
          source: peg$source,
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildSimpleError(message, location2) {
        return new peg$SyntaxError(message, null, null, location2);
      }
      function peg$buildStructuredError(expected2, found, location2) {
        return new peg$SyntaxError(
          peg$SyntaxError.buildMessage(expected2, found),
          expected2,
          found,
          location2
        );
      }
      function peg$parsebody() {
        var s0, s1;
        s0 = [];
        s1 = peg$parsecomment_only_line();
        if (s1 === peg$FAILED) {
          s1 = peg$parserow_with_end();
          if (s1 === peg$FAILED) {
            s1 = peg$parserow_without_end();
          }
        }
        if (s1 !== peg$FAILED) {
          while (s1 !== peg$FAILED) {
            s0.push(s1);
            s1 = peg$parsecomment_only_line();
            if (s1 === peg$FAILED) {
              s1 = peg$parserow_with_end();
              if (s1 === peg$FAILED) {
                s1 = peg$parserow_without_end();
              }
            }
          }
        } else {
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseEOL();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f0();
          }
          s0 = s1;
        }
        return s0;
      }
      function peg$parserow_with_end() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$parserow_items();
        if (s22 === peg$FAILED) {
          s22 = null;
        }
        peg$savedPos = s1;
        s22 = peg$f1(s22);
        s1 = s22;
        s22 = peg$parserow_sep();
        if (s22 !== peg$FAILED) {
          s32 = peg$parsetrailing_comment();
          if (s32 === peg$FAILED) {
            s32 = null;
          }
          peg$savedPos = s0;
          s0 = peg$f2(s1, s22, s32);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parserow_without_end() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parserow_items();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsetrailing_comment();
          if (s22 === peg$FAILED) {
            s22 = null;
          }
          peg$savedPos = s0;
          s0 = peg$f3(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsetrailing_comment() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsewhitespace();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parsewhitespace();
        }
        s22 = peg$parsesame_line_comment();
        if (s22 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f4(s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecomment_only_line() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsewhitespace();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parsewhitespace();
        }
        s22 = peg$parseown_line_comment();
        if (s22 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f5(s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsetoken() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        s22 = peg$parserow_sep();
        if (s22 === peg$FAILED) {
          s22 = peg$parsecol_sep();
          if (s22 === peg$FAILED) {
            s22 = peg$parsetrailing_comment();
            if (s22 === peg$FAILED) {
              s22 = peg$parseown_line_comment();
            }
          }
        }
        peg$silentFails--;
        if (s22 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s22 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f6(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecell() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsetoken();
        if (s22 !== peg$FAILED) {
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            s22 = peg$parsetoken();
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }
        return s0;
      }
      function peg$parseseparated_cell() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parsecol_sep();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsecell();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f7(s1, s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsecol_sep();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f8(s1);
          }
          s0 = s1;
        }
        return s0;
      }
      function peg$parserow_items() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$parsecell();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$parseseparated_cell();
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parseseparated_cell();
          }
          peg$savedPos = s0;
          s0 = peg$f9(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = [];
          s22 = peg$parseseparated_cell();
          if (s22 !== peg$FAILED) {
            while (s22 !== peg$FAILED) {
              s1.push(s22);
              s22 = peg$parseseparated_cell();
            }
          } else {
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f10(s1);
          }
          s0 = s1;
        }
        return s0;
      }
      function peg$parsesame_line_comment() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f11(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f12(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseown_line_comment() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f13(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f14(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsewhitespace() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f15(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f16(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parserow_sep() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f17(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f18(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecol_sep() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f19(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f20(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseEOL() {
        var s0, s1;
        s0 = peg$currPos;
        peg$silentFails++;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        peg$silentFails--;
        if (s1 === peg$FAILED) {
          s0 = void 0;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function processRow(leadCell, otherCells) {
        const cells = [leadCell || []];
        const seps = [];
        for (const x of otherCells) {
          cells.push(x.cell || []);
          seps.push(x.colSep);
        }
        return { cells, colSeps: seps };
      }
      if (!options.isWhitespace) {
        try {
          Object.assign(
            options,
            createMatchers(["\\", "hline", "cr"], ["&"])
          );
        } catch (e) {
          console.warn("Error when initializing parser", e);
        }
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(
          peg$maxFailExpected,
          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
      }
    }
    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }()
);
var xparse_argspec_default = (
  // Generated by Peggy 2.0.1.
  //
  // https://peggyjs.org/
  function() {
    "use strict";
    function peg$subclass(child, parent) {
      function C() {
        this.constructor = child;
      }
      C.prototype = parent.prototype;
      child.prototype = new C();
    }
    function peg$SyntaxError(message, expected, found, location) {
      var self = Error.call(this, message);
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(self, peg$SyntaxError.prototype);
      }
      self.expected = expected;
      self.found = found;
      self.location = location;
      self.name = "SyntaxError";
      return self;
    }
    peg$subclass(peg$SyntaxError, Error);
    function peg$padEnd(str, targetLength, padString) {
      padString = padString || " ";
      if (str.length > targetLength) {
        return str;
      }
      targetLength -= str.length;
      padString += padString.repeat(targetLength);
      return str + padString.slice(0, targetLength);
    }
    peg$SyntaxError.prototype.format = function(sources) {
      var str = "Error: " + this.message;
      if (this.location) {
        var src = null;
        var k;
        for (k = 0; k < sources.length; k++) {
          if (sources[k].source === this.location.source) {
            src = sources[k].text.split(/\r\n|\n|\r/g);
            break;
          }
        }
        var s32 = this.location.start;
        var loc = this.location.source + ":" + s32.line + ":" + s32.column;
        if (src) {
          var e = this.location.end;
          var filler = peg$padEnd("", s32.line.toString().length, " ");
          var line = src[s32.line - 1];
          var last = s32.line === e.line ? e.column : line.length + 1;
          var hatLen = last - s32.column || 1;
          str += "\n --> " + loc + "\n" + filler + " |\n" + s32.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s32.column - 1, " ") + peg$padEnd("", hatLen, "^");
        } else {
          str += "\n at " + loc;
        }
      }
      return str;
    };
    peg$SyntaxError.buildMessage = function(expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        class: function(expectation) {
          var escapedParts = expectation.parts.map(function(part) {
            return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
          });
          return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
        },
        any: function() {
          return "any character";
        },
        end: function() {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        }
      };
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s32) {
        return s32.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function classEscape(s32) {
        return s32.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = expected2.map(describeExpectation);
        var i, j;
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {};
      var peg$source = options.grammarSource;
      var peg$startRuleFunctions = { args_spec_list: peg$parseargs_spec_list };
      var peg$startRuleFunction = peg$parseargs_spec_list;
      var peg$c0 = "+";
      var peg$c1 = "v";
      var peg$c2 = "b";
      var peg$c3 = "!";
      var peg$c4 = "D";
      var peg$c5 = "d";
      var peg$c6 = "s";
      var peg$c7 = "O";
      var peg$c8 = "o";
      var peg$c9 = "e";
      var peg$c10 = "E";
      var peg$c11 = "t";
      var peg$c12 = "R";
      var peg$c13 = "r";
      var peg$c14 = "u";
      var peg$c15 = "m";
      var peg$c16 = "{";
      var peg$c17 = "}";
      var peg$c18 = " ";
      var peg$c19 = "\n";
      var peg$c20 = "\r";
      var peg$r0 = /^[{ ]/;
      var peg$e0 = peg$literalExpectation("+", false);
      var peg$e1 = peg$literalExpectation("v", false);
      var peg$e2 = peg$anyExpectation();
      var peg$e3 = peg$literalExpectation("b", false);
      var peg$e4 = peg$literalExpectation("!", false);
      var peg$e5 = peg$literalExpectation("D", false);
      var peg$e6 = peg$literalExpectation("d", false);
      var peg$e7 = peg$literalExpectation("s", false);
      var peg$e8 = peg$literalExpectation("O", false);
      var peg$e9 = peg$literalExpectation("o", false);
      var peg$e10 = peg$literalExpectation("e", false);
      var peg$e11 = peg$literalExpectation("E", false);
      var peg$e12 = peg$literalExpectation("t", false);
      var peg$e13 = peg$literalExpectation("R", false);
      var peg$e14 = peg$literalExpectation("r", false);
      var peg$e15 = peg$literalExpectation("u", false);
      var peg$e16 = peg$classExpectation(["{", " "], false, false);
      var peg$e17 = peg$literalExpectation("m", false);
      var peg$e18 = peg$literalExpectation("{", false);
      var peg$e19 = peg$literalExpectation("}", false);
      var peg$e20 = peg$literalExpectation(" ", false);
      var peg$e21 = peg$literalExpectation("\n", false);
      var peg$e22 = peg$literalExpectation("\r", false);
      var peg$f0 = function(x) {
        return x;
      };
      var peg$f1 = function(spec) {
        return spec;
      };
      var peg$f2 = function(spec) {
        return spec;
      };
      var peg$f3 = function(openBrace) {
        return createNode("verbatim", { openBrace, closeBrace: openBrace });
      };
      var peg$f4 = function() {
        return createNode("body");
      };
      var peg$f5 = function(leading_bang, spec) {
        return leading_bang ? { ...spec, noLeadingWhitespace: true } : spec;
      };
      var peg$f6 = function(braceSpec, defaultArg) {
        return createNode("optional", { ...braceSpec, defaultArg });
      };
      var peg$f7 = function(braceSpec) {
        return createNode("optional", braceSpec);
      };
      var peg$f8 = function() {
        return createNode("optionalStar");
      };
      var peg$f9 = function(g) {
        return createNode("optional", { defaultArg: g });
      };
      var peg$f10 = function() {
        return createNode("optional");
      };
      var peg$f11 = function(args) {
        return createNode("embellishment", {
          embellishmentTokens: args.content
        });
      };
      var peg$f12 = function(args, g) {
        return createNode("embellishment", {
          embellishmentTokens: args.content,
          defaultArg: g
        });
      };
      var peg$f13 = function(tok) {
        return createNode("optionalToken", { token: tok });
      };
      var peg$f14 = function(braceSpec, defaultArg) {
        return createNode("mandatory", { ...braceSpec, defaultArg });
      };
      var peg$f15 = function(braceSpec) {
        return createNode("mandatory", braceSpec);
      };
      var peg$f16 = function(stopTokens) {
        return createNode("until", { stopTokens });
      };
      var peg$f17 = function(x) {
        return [x];
      };
      var peg$f18 = function(g) {
        return g.content;
      };
      var peg$f19 = function() {
        return createNode("mandatory");
      };
      var peg$f20 = function(openBrace, closeBrace) {
        return { openBrace, closeBrace };
      };
      var peg$f21 = function(content) {
        return { type: "group", content };
      };
      var peg$f22 = function() {
        return "";
      };
      var peg$currPos = 0;
      var peg$savedPos = 0;
      var peg$posDetailsCache = [{ line: 1, column: 1 }];
      var peg$maxFailPos = 0;
      var peg$maxFailExpected = [];
      var peg$silentFails = 0;
      var peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function offset() {
        return peg$savedPos;
      }
      function range() {
        return {
          source: peg$source,
          start: peg$savedPos,
          end: peg$currPos
        };
      }
      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError(
          [peg$otherExpectation(description)],
          input.substring(peg$savedPos, peg$currPos),
          location2
        );
      }
      function error(message, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location2);
      }
      function peg$literalExpectation(text2, ignoreCase) {
        return { type: "literal", text: text2, ignoreCase };
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts, inverted, ignoreCase };
      }
      function peg$anyExpectation() {
        return { type: "any" };
      }
      function peg$endExpectation() {
        return { type: "end" };
      }
      function peg$otherExpectation(description) {
        return { type: "other", description };
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p;
        if (details) {
          return details;
        } else {
          p = pos - 1;
          while (!peg$posDetailsCache[p]) {
            p--;
          }
          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };
          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos);
        var endPosDetails = peg$computePosDetails(endPos);
        return {
          source: peg$source,
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildSimpleError(message, location2) {
        return new peg$SyntaxError(message, null, null, location2);
      }
      function peg$buildStructuredError(expected2, found, location2) {
        return new peg$SyntaxError(
          peg$SyntaxError.buildMessage(expected2, found),
          expected2,
          found,
          location2
        );
      }
      function peg$parseargs_spec_list() {
        var s0, s1, s22, s32, s42;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$currPos;
        s32 = peg$parsewhitespace();
        s42 = peg$parsearg_spec();
        if (s42 !== peg$FAILED) {
          peg$savedPos = s22;
          s22 = peg$f0(s42);
        } else {
          peg$currPos = s22;
          s22 = peg$FAILED;
        }
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$currPos;
          s32 = peg$parsewhitespace();
          s42 = peg$parsearg_spec();
          if (s42 !== peg$FAILED) {
            peg$savedPos = s22;
            s22 = peg$f0(s42);
          } else {
            peg$currPos = s22;
            s22 = peg$FAILED;
          }
        }
        s22 = peg$parsewhitespace();
        peg$savedPos = s0;
        s0 = peg$f1(s1);
        return s0;
      }
      function peg$parsearg_spec() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 43) {
          s1 = peg$c0;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 === peg$FAILED) {
          s1 = null;
        }
        s22 = peg$parseoptional();
        if (s22 === peg$FAILED) {
          s22 = peg$parsemandatory();
          if (s22 === peg$FAILED) {
            s22 = peg$parseverbatim();
            if (s22 === peg$FAILED) {
              s22 = peg$parserequired();
              if (s22 === peg$FAILED) {
                s22 = peg$parsebody();
                if (s22 === peg$FAILED) {
                  s22 = peg$parseuntil();
                }
              }
            }
          }
        }
        if (s22 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f2(s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseverbatim() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 118) {
          s1 = peg$c1;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e1);
          }
        }
        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s22 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f3(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsebody() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 98) {
          s1 = peg$c2;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f4();
        }
        s0 = s1;
        return s0;
      }
      function peg$parseoptional() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 33) {
          s1 = peg$c3;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e4);
          }
        }
        if (s1 === peg$FAILED) {
          s1 = null;
        }
        s22 = peg$parseoptional_star();
        if (s22 === peg$FAILED) {
          s22 = peg$parseoptional_standard();
          if (s22 === peg$FAILED) {
            s22 = peg$parseoptional_delimited();
            if (s22 === peg$FAILED) {
              s22 = peg$parseoptional_embellishment();
              if (s22 === peg$FAILED) {
                s22 = peg$parseoptional_token();
              }
            }
          }
        }
        if (s22 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f5(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseoptional_delimited() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 68) {
          s1 = peg$c4;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e5);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parsebrace_spec();
          s32 = peg$parsebraced_group();
          if (s32 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f6(s22, s32);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 100) {
            s1 = peg$c5;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e6);
            }
          }
          if (s1 !== peg$FAILED) {
            s22 = peg$parsebrace_spec();
            peg$savedPos = s0;
            s0 = peg$f7(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        return s0;
      }
      function peg$parseoptional_star() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 115) {
          s1 = peg$c6;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e7);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f8();
        }
        s0 = s1;
        return s0;
      }
      function peg$parseoptional_standard() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 79) {
          s1 = peg$c7;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e8);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parsebraced_group();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f9(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 111) {
            s1 = peg$c8;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e9);
            }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f10();
          }
          s0 = s1;
        }
        return s0;
      }
      function peg$parseoptional_embellishment() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 101) {
          s1 = peg$c9;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e10);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parsebraced_group();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f11(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 69) {
            s1 = peg$c10;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e11);
            }
          }
          if (s1 !== peg$FAILED) {
            s22 = peg$parsebraced_group();
            if (s22 !== peg$FAILED) {
              s32 = peg$parsebraced_group();
              if (s32 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f12(s22, s32);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        return s0;
      }
      function peg$parseoptional_token() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 116) {
          s1 = peg$c11;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e12);
          }
        }
        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s22 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f13(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parserequired() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 82) {
          s1 = peg$c12;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e13);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parsebrace_spec();
          s32 = peg$parsebraced_group();
          if (s32 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f14(s22, s32);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 114) {
            s1 = peg$c13;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e14);
            }
          }
          if (s1 !== peg$FAILED) {
            s22 = peg$parsebrace_spec();
            peg$savedPos = s0;
            s0 = peg$f15(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        return s0;
      }
      function peg$parseuntil() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 117) {
          s1 = peg$c14;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e15);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parseuntil_stop_token();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f16(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseuntil_stop_token() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        if (peg$r0.test(input.charAt(peg$currPos))) {
          s22 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s22 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e16);
          }
        }
        peg$silentFails--;
        if (s22 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s22 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f17(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsebraced_group();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f18(s1);
          }
          s0 = s1;
        }
        return s0;
      }
      function peg$parsemandatory() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 109) {
          s1 = peg$c15;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e17);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f19();
        }
        s0 = s1;
        return s0;
      }
      function peg$parsebrace_spec() {
        var s0, s1, s22, s32, s42, s5;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$currPos;
        s32 = peg$currPos;
        peg$silentFails++;
        s42 = peg$parsewhitespace_token();
        peg$silentFails--;
        if (s42 === peg$FAILED) {
          s32 = void 0;
        } else {
          peg$currPos = s32;
          s32 = peg$FAILED;
        }
        if (s32 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s42 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s42 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          if (s42 !== peg$FAILED) {
            s32 = [s32, s42];
            s22 = s32;
          } else {
            peg$currPos = s22;
            s22 = peg$FAILED;
          }
        } else {
          peg$currPos = s22;
          s22 = peg$FAILED;
        }
        if (s22 === peg$FAILED) {
          s22 = null;
        }
        s1 = input.substring(s1, peg$currPos);
        s22 = peg$currPos;
        s32 = peg$currPos;
        s42 = peg$currPos;
        peg$silentFails++;
        s5 = peg$parsewhitespace_token();
        peg$silentFails--;
        if (s5 === peg$FAILED) {
          s42 = void 0;
        } else {
          peg$currPos = s42;
          s42 = peg$FAILED;
        }
        if (s42 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          if (s5 !== peg$FAILED) {
            s42 = [s42, s5];
            s32 = s42;
          } else {
            peg$currPos = s32;
            s32 = peg$FAILED;
          }
        } else {
          peg$currPos = s32;
          s32 = peg$FAILED;
        }
        if (s32 === peg$FAILED) {
          s32 = null;
        }
        s22 = input.substring(s22, peg$currPos);
        peg$savedPos = s0;
        s0 = peg$f20(s1, s22);
        return s0;
      }
      function peg$parsebraced_group() {
        var s0, s1, s22, s32, s42, s5, s6, s7;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 123) {
          s1 = peg$c16;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e18);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$currPos;
          s42 = peg$currPos;
          s5 = peg$currPos;
          peg$silentFails++;
          if (input.charCodeAt(peg$currPos) === 125) {
            s6 = peg$c17;
            peg$currPos++;
          } else {
            s6 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e19);
            }
          }
          peg$silentFails--;
          if (s6 === peg$FAILED) {
            s5 = void 0;
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$currPos;
            peg$silentFails++;
            s7 = peg$parsebraced_group();
            peg$silentFails--;
            if (s7 === peg$FAILED) {
              s6 = void 0;
            } else {
              peg$currPos = s6;
              s6 = peg$FAILED;
            }
            if (s6 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s7 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s7 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e2);
                }
              }
              if (s7 !== peg$FAILED) {
                s5 = [s5, s6, s7];
                s42 = s5;
              } else {
                peg$currPos = s42;
                s42 = peg$FAILED;
              }
            } else {
              peg$currPos = s42;
              s42 = peg$FAILED;
            }
          } else {
            peg$currPos = s42;
            s42 = peg$FAILED;
          }
          if (s42 !== peg$FAILED) {
            s32 = input.substring(s32, peg$currPos);
          } else {
            s32 = s42;
          }
          if (s32 === peg$FAILED) {
            s32 = peg$parsebraced_group();
          }
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$currPos;
            s42 = peg$currPos;
            s5 = peg$currPos;
            peg$silentFails++;
            if (input.charCodeAt(peg$currPos) === 125) {
              s6 = peg$c17;
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e19);
              }
            }
            peg$silentFails--;
            if (s6 === peg$FAILED) {
              s5 = void 0;
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$currPos;
              peg$silentFails++;
              s7 = peg$parsebraced_group();
              peg$silentFails--;
              if (s7 === peg$FAILED) {
                s6 = void 0;
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
              if (s6 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                  s7 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e2);
                  }
                }
                if (s7 !== peg$FAILED) {
                  s5 = [s5, s6, s7];
                  s42 = s5;
                } else {
                  peg$currPos = s42;
                  s42 = peg$FAILED;
                }
              } else {
                peg$currPos = s42;
                s42 = peg$FAILED;
              }
            } else {
              peg$currPos = s42;
              s42 = peg$FAILED;
            }
            if (s42 !== peg$FAILED) {
              s32 = input.substring(s32, peg$currPos);
            } else {
              s32 = s42;
            }
            if (s32 === peg$FAILED) {
              s32 = peg$parsebraced_group();
            }
          }
          if (input.charCodeAt(peg$currPos) === 125) {
            s32 = peg$c17;
            peg$currPos++;
          } else {
            s32 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e19);
            }
          }
          if (s32 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f21(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsewhitespace() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsewhitespace_token();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parsewhitespace_token();
        }
        peg$savedPos = s0;
        s1 = peg$f22();
        s0 = s1;
        return s0;
      }
      function peg$parsewhitespace_token() {
        var s0;
        if (input.charCodeAt(peg$currPos) === 32) {
          s0 = peg$c18;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e20);
          }
        }
        if (s0 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 10) {
            s0 = peg$c19;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e21);
            }
          }
          if (s0 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 13) {
              s0 = peg$c20;
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e22);
              }
            }
          }
        }
        return s0;
      }
      const DEFAULT_OPTIONS = {
        optional: { openBrace: "[", closeBrace: "]" },
        mandatory: { openBrace: "{", closeBrace: "}" }
      };
      function createNode(type, options2) {
        const computedOptions = DEFAULT_OPTIONS[type] || {};
        return { type, ...computedOptions, ...options2 };
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(
          peg$maxFailExpected,
          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
      }
    }
    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }()
);
var pgfkeys_default = (
  // Generated by Peggy 2.0.1.
  //
  // https://peggyjs.org/
  function() {
    "use strict";
    function peg$subclass(child, parent) {
      function C() {
        this.constructor = child;
      }
      C.prototype = parent.prototype;
      child.prototype = new C();
    }
    function peg$SyntaxError(message, expected, found, location) {
      var self = Error.call(this, message);
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(self, peg$SyntaxError.prototype);
      }
      self.expected = expected;
      self.found = found;
      self.location = location;
      self.name = "SyntaxError";
      return self;
    }
    peg$subclass(peg$SyntaxError, Error);
    function peg$padEnd(str, targetLength, padString) {
      padString = padString || " ";
      if (str.length > targetLength) {
        return str;
      }
      targetLength -= str.length;
      padString += padString.repeat(targetLength);
      return str + padString.slice(0, targetLength);
    }
    peg$SyntaxError.prototype.format = function(sources) {
      var str = "Error: " + this.message;
      if (this.location) {
        var src = null;
        var k;
        for (k = 0; k < sources.length; k++) {
          if (sources[k].source === this.location.source) {
            src = sources[k].text.split(/\r\n|\n|\r/g);
            break;
          }
        }
        var s32 = this.location.start;
        var loc = this.location.source + ":" + s32.line + ":" + s32.column;
        if (src) {
          var e = this.location.end;
          var filler = peg$padEnd("", s32.line.toString().length, " ");
          var line = src[s32.line - 1];
          var last = s32.line === e.line ? e.column : line.length + 1;
          var hatLen = last - s32.column || 1;
          str += "\n --> " + loc + "\n" + filler + " |\n" + s32.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s32.column - 1, " ") + peg$padEnd("", hatLen, "^");
        } else {
          str += "\n at " + loc;
        }
      }
      return str;
    };
    peg$SyntaxError.buildMessage = function(expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        class: function(expectation) {
          var escapedParts = expectation.parts.map(function(part) {
            return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
          });
          return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
        },
        any: function() {
          return "any character";
        },
        end: function() {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        }
      };
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s32) {
        return s32.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function classEscape(s32) {
        return s32.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = expected2.map(describeExpectation);
        var i, j;
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {};
      var peg$source = options.grammarSource;
      var peg$startRuleFunctions = { body: peg$parsebody };
      var peg$startRuleFunction = peg$parsebody;
      var peg$e0 = peg$anyExpectation();
      var peg$f0 = function() {
        return [];
      };
      var peg$f1 = function(rowItems, trailingComment) {
        return {
          itemParts: [],
          ...rowItems,
          trailingComment,
          trailingComma: true
        };
      };
      var peg$f2 = function(rowItems, trailingComment) {
        return { ...rowItems, trailingComment };
      };
      var peg$f3 = function(a, b) {
        return processItem(a, b);
      };
      var peg$f4 = function(b) {
        return processItem(null, b);
      };
      var peg$f5 = function(cell) {
        return { cell };
      };
      var peg$f6 = function() {
        return {};
      };
      var peg$f7 = function(part) {
        return part;
      };
      var peg$f8 = function(x) {
        return x;
      };
      var peg$f9 = function(space, x) {
        return {
          trailingComment: x,
          leadingParbreak: space.parbreak > 0
        };
      };
      var peg$f10 = function(list) {
        return {
          whitespace: list.filter((x) => options.isWhitespace(x)).length,
          parbreak: list.filter((x) => options.isParbreak(x)).length
        };
      };
      var peg$f11 = function() {
        return !options.allowParenGroups;
      };
      var peg$f12 = function(tok) {
        return options.isSameLineComment(tok);
      };
      var peg$f13 = function(tok) {
        return tok;
      };
      var peg$f14 = function(tok) {
        return options.isOwnLineComment(tok);
      };
      var peg$f15 = function(tok) {
        return tok;
      };
      var peg$f16 = function(tok) {
        return options.isWhitespace(tok);
      };
      var peg$f17 = function(tok) {
        return tok;
      };
      var peg$f18 = function(tok) {
        return options.isParbreak(tok);
      };
      var peg$f19 = function(tok) {
        return tok;
      };
      var peg$f20 = function(tok) {
        return options.isComma(tok);
      };
      var peg$f21 = function(tok) {
        return tok;
      };
      var peg$f22 = function(tok) {
        return options.isEquals(tok);
      };
      var peg$f23 = function(tok) {
        return tok;
      };
      var peg$f24 = function(tok) {
        return options.isChar(tok, "(");
      };
      var peg$f25 = function(tok) {
        return tok;
      };
      var peg$f26 = function(tok) {
        return options.isChar(tok, ")");
      };
      var peg$f27 = function(tok) {
        return tok;
      };
      var peg$currPos = 0;
      var peg$savedPos = 0;
      var peg$posDetailsCache = [{ line: 1, column: 1 }];
      var peg$maxFailPos = 0;
      var peg$maxFailExpected = [];
      var peg$silentFails = 0;
      var peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function offset() {
        return peg$savedPos;
      }
      function range() {
        return {
          source: peg$source,
          start: peg$savedPos,
          end: peg$currPos
        };
      }
      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError(
          [peg$otherExpectation(description)],
          input.substring(peg$savedPos, peg$currPos),
          location2
        );
      }
      function error(message, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location2);
      }
      function peg$literalExpectation(text2, ignoreCase) {
        return { type: "literal", text: text2, ignoreCase };
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts, inverted, ignoreCase };
      }
      function peg$anyExpectation() {
        return { type: "any" };
      }
      function peg$endExpectation() {
        return { type: "end" };
      }
      function peg$otherExpectation(description) {
        return { type: "other", description };
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p;
        if (details) {
          return details;
        } else {
          p = pos - 1;
          while (!peg$posDetailsCache[p]) {
            p--;
          }
          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };
          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos);
        var endPosDetails = peg$computePosDetails(endPos);
        return {
          source: peg$source,
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildSimpleError(message, location2) {
        return new peg$SyntaxError(message, null, null, location2);
      }
      function peg$buildStructuredError(expected2, found, location2) {
        return new peg$SyntaxError(
          peg$SyntaxError.buildMessage(expected2, found),
          expected2,
          found,
          location2
        );
      }
      function peg$parsebody() {
        var s0, s1, s22;
        s0 = [];
        s1 = peg$parsecomment_only_line();
        if (s1 === peg$FAILED) {
          s1 = peg$parseitem_with_end();
          if (s1 === peg$FAILED) {
            s1 = peg$parseitem_without_end();
          }
        }
        if (s1 !== peg$FAILED) {
          while (s1 !== peg$FAILED) {
            s0.push(s1);
            s1 = peg$parsecomment_only_line();
            if (s1 === peg$FAILED) {
              s1 = peg$parseitem_with_end();
              if (s1 === peg$FAILED) {
                s1 = peg$parseitem_without_end();
              }
            }
          }
        } else {
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = [];
          s22 = peg$parsewhitespace();
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            s22 = peg$parsewhitespace();
          }
          s22 = peg$parseEOL();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f0();
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        return s0;
      }
      function peg$parseitem_with_end() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8;
        s0 = peg$currPos;
        s1 = peg$parsewhitespace_or_parbreaks();
        s22 = peg$parserow_items();
        if (s22 === peg$FAILED) {
          s22 = null;
        }
        s32 = peg$parsewhitespace_or_parbreaks();
        s42 = peg$parseitem_sep();
        if (s42 !== peg$FAILED) {
          s5 = [];
          s6 = peg$parsewhitespace();
          while (s6 !== peg$FAILED) {
            s5.push(s6);
            s6 = peg$parsewhitespace();
          }
          s6 = peg$parsetrailing_comment();
          if (s6 === peg$FAILED) {
            s6 = null;
          }
          s7 = [];
          s8 = peg$parsewhitespace();
          while (s8 !== peg$FAILED) {
            s7.push(s8);
            s8 = peg$parsewhitespace();
          }
          peg$savedPos = s0;
          s0 = peg$f1(s22, s6);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseitem_without_end() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$parsewhitespace_or_parbreaks();
        s22 = peg$parserow_items();
        if (s22 !== peg$FAILED) {
          s32 = peg$parsetrailing_comment();
          if (s32 === peg$FAILED) {
            s32 = null;
          }
          peg$savedPos = s0;
          s0 = peg$f2(s22, s32);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parserow_items() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$parseitem_part();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$parseseparated_part();
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parseseparated_part();
          }
          peg$savedPos = s0;
          s0 = peg$f3(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = [];
          s22 = peg$parseseparated_part();
          if (s22 !== peg$FAILED) {
            while (s22 !== peg$FAILED) {
              s1.push(s22);
              s22 = peg$parseseparated_part();
            }
          } else {
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f4(s1);
          }
          s0 = s1;
        }
        return s0;
      }
      function peg$parseseparated_part() {
        var s0, s1, s22, s32, s42;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parseparbreak();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parseparbreak();
        }
        s22 = peg$parseequals();
        if (s22 !== peg$FAILED) {
          s32 = [];
          s42 = peg$parseparbreak();
          while (s42 !== peg$FAILED) {
            s32.push(s42);
            s42 = peg$parseparbreak();
          }
          s42 = peg$parseitem_part();
          if (s42 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f5(s42);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = [];
          s22 = peg$parseparbreak();
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            s22 = peg$parseparbreak();
          }
          s22 = peg$parseequals();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f6();
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        return s0;
      }
      function peg$parseitem_part() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8, s9;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsewhitespace();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parsewhitespace();
        }
        s22 = peg$currPos;
        s32 = [];
        s42 = peg$parsenon_whitespace_non_parbreak_token();
        if (s42 === peg$FAILED) {
          s42 = peg$currPos;
          s5 = peg$parsewhitespace();
          if (s5 === peg$FAILED) {
            s5 = peg$parseparbreak();
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$currPos;
            peg$silentFails++;
            s7 = peg$currPos;
            s8 = [];
            s9 = peg$parsewhitespace();
            if (s9 === peg$FAILED) {
              s9 = peg$parseparbreak();
            }
            while (s9 !== peg$FAILED) {
              s8.push(s9);
              s9 = peg$parsewhitespace();
              if (s9 === peg$FAILED) {
                s9 = peg$parseparbreak();
              }
            }
            s9 = peg$parsenon_whitespace_non_parbreak_token();
            if (s9 !== peg$FAILED) {
              s8 = [s8, s9];
              s7 = s8;
            } else {
              peg$currPos = s7;
              s7 = peg$FAILED;
            }
            peg$silentFails--;
            if (s7 !== peg$FAILED) {
              peg$currPos = s6;
              s6 = void 0;
            } else {
              s6 = peg$FAILED;
            }
            if (s6 !== peg$FAILED) {
              s5 = [s5, s6];
              s42 = s5;
            } else {
              peg$currPos = s42;
              s42 = peg$FAILED;
            }
          } else {
            peg$currPos = s42;
            s42 = peg$FAILED;
          }
        }
        if (s42 !== peg$FAILED) {
          while (s42 !== peg$FAILED) {
            s32.push(s42);
            s42 = peg$parsenon_whitespace_non_parbreak_token();
            if (s42 === peg$FAILED) {
              s42 = peg$currPos;
              s5 = peg$parsewhitespace();
              if (s5 === peg$FAILED) {
                s5 = peg$parseparbreak();
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$currPos;
                peg$silentFails++;
                s7 = peg$currPos;
                s8 = [];
                s9 = peg$parsewhitespace();
                if (s9 === peg$FAILED) {
                  s9 = peg$parseparbreak();
                }
                while (s9 !== peg$FAILED) {
                  s8.push(s9);
                  s9 = peg$parsewhitespace();
                  if (s9 === peg$FAILED) {
                    s9 = peg$parseparbreak();
                  }
                }
                s9 = peg$parsenon_whitespace_non_parbreak_token();
                if (s9 !== peg$FAILED) {
                  s8 = [s8, s9];
                  s7 = s8;
                } else {
                  peg$currPos = s7;
                  s7 = peg$FAILED;
                }
                peg$silentFails--;
                if (s7 !== peg$FAILED) {
                  peg$currPos = s6;
                  s6 = void 0;
                } else {
                  s6 = peg$FAILED;
                }
                if (s6 !== peg$FAILED) {
                  s5 = [s5, s6];
                  s42 = s5;
                } else {
                  peg$currPos = s42;
                  s42 = peg$FAILED;
                }
              } else {
                peg$currPos = s42;
                s42 = peg$FAILED;
              }
            }
          }
        } else {
          s32 = peg$FAILED;
        }
        if (s32 !== peg$FAILED) {
          s22 = input.substring(s22, peg$currPos);
        } else {
          s22 = s32;
        }
        if (s22 !== peg$FAILED) {
          s32 = [];
          s42 = peg$parsewhitespace();
          while (s42 !== peg$FAILED) {
            s32.push(s42);
            s42 = peg$parsewhitespace();
          }
          peg$savedPos = s0;
          s0 = peg$f7(s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsetrailing_comment() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsewhitespace();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parsewhitespace();
        }
        s22 = peg$parsesame_line_comment();
        if (s22 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f8(s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecomment_only_line() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parsewhitespace_or_parbreaks();
        s22 = peg$parseown_line_comment();
        if (s22 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f9(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsetoken() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$currPos;
        peg$silentFails++;
        s32 = peg$parsenon_token();
        peg$silentFails--;
        if (s32 === peg$FAILED) {
          s22 = void 0;
        } else {
          peg$currPos = s22;
          s22 = peg$FAILED;
        }
        if (s22 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s32 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s32 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s32 !== peg$FAILED) {
            s22 = [s22, s32];
            s1 = s22;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }
        return s0;
      }
      function peg$parsenon_whitespace_non_parbreak_token() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$currPos;
        peg$silentFails++;
        s32 = peg$parsewhitespace();
        if (s32 === peg$FAILED) {
          s32 = peg$parseparbreak();
        }
        peg$silentFails--;
        if (s32 === peg$FAILED) {
          s22 = void 0;
        } else {
          peg$currPos = s22;
          s22 = peg$FAILED;
        }
        if (s22 !== peg$FAILED) {
          s32 = peg$parseparen_block();
          if (s32 === peg$FAILED) {
            s32 = peg$parsetoken();
          }
          if (s32 !== peg$FAILED) {
            s22 = [s22, s32];
            s1 = s22;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }
        return s0;
      }
      function peg$parsenon_token() {
        var s0;
        s0 = peg$parseitem_sep();
        if (s0 === peg$FAILED) {
          s0 = peg$parseequals();
          if (s0 === peg$FAILED) {
            s0 = peg$parsetrailing_comment();
            if (s0 === peg$FAILED) {
              s0 = peg$parseown_line_comment();
            }
          }
        }
        return s0;
      }
      function peg$parsewhitespace_or_parbreaks() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsewhitespace();
        if (s22 === peg$FAILED) {
          s22 = peg$parseparbreak();
        }
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parsewhitespace();
          if (s22 === peg$FAILED) {
            s22 = peg$parseparbreak();
          }
        }
        peg$savedPos = s0;
        s1 = peg$f10(s1);
        s0 = s1;
        return s0;
      }
      function peg$parseparen_block() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8;
        s0 = peg$currPos;
        peg$savedPos = peg$currPos;
        s1 = peg$f11();
        if (s1) {
          s1 = peg$FAILED;
        } else {
          s1 = void 0;
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$currPos;
          s32 = peg$currPos;
          s42 = peg$parseopen_paren();
          if (s42 !== peg$FAILED) {
            s5 = [];
            s6 = peg$currPos;
            s7 = peg$currPos;
            peg$silentFails++;
            s8 = peg$parseclose_paren();
            peg$silentFails--;
            if (s8 === peg$FAILED) {
              s7 = void 0;
            } else {
              peg$currPos = s7;
              s7 = peg$FAILED;
            }
            if (s7 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s8 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s8 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              if (s8 !== peg$FAILED) {
                s7 = [s7, s8];
                s6 = s7;
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
            } else {
              peg$currPos = s6;
              s6 = peg$FAILED;
            }
            while (s6 !== peg$FAILED) {
              s5.push(s6);
              s6 = peg$currPos;
              s7 = peg$currPos;
              peg$silentFails++;
              s8 = peg$parseclose_paren();
              peg$silentFails--;
              if (s8 === peg$FAILED) {
                s7 = void 0;
              } else {
                peg$currPos = s7;
                s7 = peg$FAILED;
              }
              if (s7 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                  s8 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s8 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e0);
                  }
                }
                if (s8 !== peg$FAILED) {
                  s7 = [s7, s8];
                  s6 = s7;
                } else {
                  peg$currPos = s6;
                  s6 = peg$FAILED;
                }
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
            }
            s6 = peg$parseclose_paren();
            if (s6 !== peg$FAILED) {
              s42 = [s42, s5, s6];
              s32 = s42;
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          } else {
            peg$currPos = s32;
            s32 = peg$FAILED;
          }
          if (s32 !== peg$FAILED) {
            s22 = input.substring(s22, peg$currPos);
          } else {
            s22 = s32;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsesame_line_comment() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f12(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f13(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseown_line_comment() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f14(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f15(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsewhitespace() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f16(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f17(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseparbreak() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f18(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f19(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseitem_sep() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f20(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f21(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseequals() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f22(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f23(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseopen_paren() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f24(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f25(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseclose_paren() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f26(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f27(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseEOL() {
        var s0, s1;
        s0 = peg$currPos;
        peg$silentFails++;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        peg$silentFails--;
        if (s1 === peg$FAILED) {
          s0 = void 0;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function processItem(leadCell, otherCells) {
        const cells = [leadCell || []];
        for (const x of otherCells) {
          cells.push(x.cell || []);
        }
        return { itemParts: cells };
      }
      if (!options.isWhitespace) {
        try {
          Object.assign(options, {
            isChar: (node, char) => node.type === "string" && node.content === char,
            isComma(node) {
              return node.type === "string" && node.content === ",";
            },
            isEquals(node) {
              return node.type === "string" && node.content === "=";
            },
            isParbreak(node) {
              return node.type === "parbreak";
            },
            isWhitespace(node) {
              return node.type === "whitespace";
            },
            isSameLineComment: (node) => node.type === "comment" && node.sameline,
            isOwnLineComment: (node) => node.type === "comment" && !node.sameline,
            isComment: (node) => node.type === "comment",
            allowParenGroups: true
          });
        } catch (e) {
          console.warn("Error when initializing parser", e);
        }
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(
          peg$maxFailExpected,
          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
      }
    }
    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }()
);
var macro_substitutions_default = (
  // Generated by Peggy 2.0.1.
  //
  // https://peggyjs.org/
  function() {
    "use strict";
    function peg$subclass(child, parent) {
      function C() {
        this.constructor = child;
      }
      C.prototype = parent.prototype;
      child.prototype = new C();
    }
    function peg$SyntaxError(message, expected, found, location) {
      var self = Error.call(this, message);
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(self, peg$SyntaxError.prototype);
      }
      self.expected = expected;
      self.found = found;
      self.location = location;
      self.name = "SyntaxError";
      return self;
    }
    peg$subclass(peg$SyntaxError, Error);
    function peg$padEnd(str, targetLength, padString) {
      padString = padString || " ";
      if (str.length > targetLength) {
        return str;
      }
      targetLength -= str.length;
      padString += padString.repeat(targetLength);
      return str + padString.slice(0, targetLength);
    }
    peg$SyntaxError.prototype.format = function(sources) {
      var str = "Error: " + this.message;
      if (this.location) {
        var src = null;
        var k;
        for (k = 0; k < sources.length; k++) {
          if (sources[k].source === this.location.source) {
            src = sources[k].text.split(/\r\n|\n|\r/g);
            break;
          }
        }
        var s32 = this.location.start;
        var loc = this.location.source + ":" + s32.line + ":" + s32.column;
        if (src) {
          var e = this.location.end;
          var filler = peg$padEnd("", s32.line.toString().length, " ");
          var line = src[s32.line - 1];
          var last = s32.line === e.line ? e.column : line.length + 1;
          var hatLen = last - s32.column || 1;
          str += "\n --> " + loc + "\n" + filler + " |\n" + s32.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s32.column - 1, " ") + peg$padEnd("", hatLen, "^");
        } else {
          str += "\n at " + loc;
        }
      }
      return str;
    };
    peg$SyntaxError.buildMessage = function(expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        class: function(expectation) {
          var escapedParts = expectation.parts.map(function(part) {
            return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
          });
          return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
        },
        any: function() {
          return "any character";
        },
        end: function() {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        }
      };
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s32) {
        return s32.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function classEscape(s32) {
        return s32.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = expected2.map(describeExpectation);
        var i, j;
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {};
      var peg$source = options.grammarSource;
      var peg$startRuleFunctions = { body: peg$parsebody };
      var peg$startRuleFunction = peg$parsebody;
      var peg$e0 = peg$anyExpectation();
      var peg$f0 = function(e) {
        return [].concat(...e).filter((n) => !!n);
      };
      var peg$f1 = function() {
        return [];
      };
      var peg$f2 = function(tok) {
        return options.isHash(tok);
      };
      var peg$f3 = function(tok) {
        return tok;
      };
      var peg$f4 = function(tok) {
        return options.isNumber(tok);
      };
      var peg$f5 = function(tok) {
        return tok;
      };
      var peg$f6 = function() {
        return { type: "string", content: "#" };
      };
      var peg$f7 = function(num) {
        const split = options.splitNumber(num);
        return [{ type: "hash_number", number: split.number }, split.rest];
      };
      var peg$currPos = 0;
      var peg$savedPos = 0;
      var peg$posDetailsCache = [{ line: 1, column: 1 }];
      var peg$maxFailPos = 0;
      var peg$maxFailExpected = [];
      var peg$silentFails = 0;
      var peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function offset() {
        return peg$savedPos;
      }
      function range() {
        return {
          source: peg$source,
          start: peg$savedPos,
          end: peg$currPos
        };
      }
      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError(
          [peg$otherExpectation(description)],
          input.substring(peg$savedPos, peg$currPos),
          location2
        );
      }
      function error(message, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location2);
      }
      function peg$literalExpectation(text2, ignoreCase) {
        return { type: "literal", text: text2, ignoreCase };
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts, inverted, ignoreCase };
      }
      function peg$anyExpectation() {
        return { type: "any" };
      }
      function peg$endExpectation() {
        return { type: "end" };
      }
      function peg$otherExpectation(description) {
        return { type: "other", description };
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p;
        if (details) {
          return details;
        } else {
          p = pos - 1;
          while (!peg$posDetailsCache[p]) {
            p--;
          }
          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };
          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos);
        var endPosDetails = peg$computePosDetails(endPos);
        return {
          source: peg$source,
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildSimpleError(message, location2) {
        return new peg$SyntaxError(message, null, null, location2);
      }
      function peg$buildStructuredError(expected2, found, location2) {
        return new peg$SyntaxError(
          peg$SyntaxError.buildMessage(expected2, found),
          expected2,
          found,
          location2
        );
      }
      function peg$parsebody() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsedouble_hash();
        if (s22 === peg$FAILED) {
          s22 = peg$parsehash_number();
          if (s22 === peg$FAILED) {
            if (input.length > peg$currPos) {
              s22 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s22 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
          }
        }
        if (s22 !== peg$FAILED) {
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            s22 = peg$parsedouble_hash();
            if (s22 === peg$FAILED) {
              s22 = peg$parsehash_number();
              if (s22 === peg$FAILED) {
                if (input.length > peg$currPos) {
                  s22 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s22 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e0);
                  }
                }
              }
            }
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f0(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseEOL();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f1();
          }
          s0 = s1;
        }
        return s0;
      }
      function peg$parsehash() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f2(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f3(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsenumber() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f4(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f5(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsedouble_hash() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parsehash();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsehash();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f6();
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsehash_number() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parsehash();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsenumber();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f7(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseEOL() {
        var s0, s1;
        s0 = peg$currPos;
        peg$silentFails++;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        peg$silentFails--;
        if (s1 === peg$FAILED) {
          s0 = void 0;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      if (!options.isHash) {
        try {
          Object.assign(options, {
            isHash: (node) => node.type === "string" && node.content === "#",
            isNumber: (node) => node.type === "string" && 0 < +node.content.charAt(0),
            splitNumber: (node) => {
              const number = +node.content.charAt(0);
              if (node.content.length > 1) {
                return {
                  number,
                  rest: {
                    type: "string",
                    content: node.content.slice(1)
                  }
                };
              }
              return { number };
            }
          });
        } catch (e) {
          console.warn("Error when initializing parser", e);
        }
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(
          peg$maxFailExpected,
          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
      }
    }
    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }()
);
var ligatures_default = (
  // Generated by Peggy 2.0.1.
  //
  // https://peggyjs.org/
  function() {
    "use strict";
    function peg$subclass(child, parent) {
      function C() {
        this.constructor = child;
      }
      C.prototype = parent.prototype;
      child.prototype = new C();
    }
    function peg$SyntaxError(message, expected, found, location) {
      var self = Error.call(this, message);
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(self, peg$SyntaxError.prototype);
      }
      self.expected = expected;
      self.found = found;
      self.location = location;
      self.name = "SyntaxError";
      return self;
    }
    peg$subclass(peg$SyntaxError, Error);
    function peg$padEnd(str, targetLength, padString) {
      padString = padString || " ";
      if (str.length > targetLength) {
        return str;
      }
      targetLength -= str.length;
      padString += padString.repeat(targetLength);
      return str + padString.slice(0, targetLength);
    }
    peg$SyntaxError.prototype.format = function(sources) {
      var str = "Error: " + this.message;
      if (this.location) {
        var src = null;
        var k;
        for (k = 0; k < sources.length; k++) {
          if (sources[k].source === this.location.source) {
            src = sources[k].text.split(/\r\n|\n|\r/g);
            break;
          }
        }
        var s32 = this.location.start;
        var loc = this.location.source + ":" + s32.line + ":" + s32.column;
        if (src) {
          var e = this.location.end;
          var filler = peg$padEnd("", s32.line.toString().length, " ");
          var line = src[s32.line - 1];
          var last = s32.line === e.line ? e.column : line.length + 1;
          var hatLen = last - s32.column || 1;
          str += "\n --> " + loc + "\n" + filler + " |\n" + s32.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s32.column - 1, " ") + peg$padEnd("", hatLen, "^");
        } else {
          str += "\n at " + loc;
        }
      }
      return str;
    };
    peg$SyntaxError.buildMessage = function(expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        class: function(expectation) {
          var escapedParts = expectation.parts.map(function(part) {
            return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
          });
          return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
        },
        any: function() {
          return "any character";
        },
        end: function() {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        }
      };
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s32) {
        return s32.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function classEscape(s32) {
        return s32.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = expected2.map(describeExpectation);
        var i, j;
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {};
      var peg$source = options.grammarSource;
      var peg$startRuleFunctions = { body: peg$parsebody };
      var peg$startRuleFunction = peg$parsebody;
      var peg$e0 = peg$anyExpectation();
      var peg$f0 = function(e) {
        return [].concat(...e).filter((n) => !!n);
      };
      var peg$f1 = function() {
        return [];
      };
      var peg$f2 = function(toks) {
        return options.isRecognized(toks);
      };
      var peg$f3 = function(toks) {
        return options.isRecognized(toks);
      };
      var peg$f4 = function(tok1, tok2) {
        const split = options.split(tok2);
        return options.isRecognized([tok1, split[0]]);
      };
      var peg$f5 = function(tok1, tok2) {
        const split = options.split(tok2);
        return [options.isRecognized([tok1, split[0]]), split[1]];
      };
      var peg$f6 = function(tok1, tok2) {
        return options.isRecognized([tok1, tok2]);
      };
      var peg$f7 = function(tok1, tok2) {
        return options.isRecognized([tok1, tok2]);
      };
      var peg$f8 = function(toks) {
        return options.isRecognized(toks);
      };
      var peg$f9 = function(toks) {
        return options.isRecognized(toks);
      };
      var peg$f10 = function(tok) {
        return options.isRecognized([tok]);
      };
      var peg$f11 = function(tok) {
        return options.isRecognized([tok]);
      };
      var peg$f12 = function(tok) {
        return options.isMacro(tok);
      };
      var peg$f13 = function(tok) {
        return tok;
      };
      var peg$f14 = function(tok) {
        return options.isWhitespace(tok);
      };
      var peg$f15 = function(tok) {
        return tok;
      };
      var peg$f16 = function(tok) {
        return options.isSplitable(tok);
      };
      var peg$f17 = function(tok) {
        return tok;
      };
      var peg$currPos = 0;
      var peg$savedPos = 0;
      var peg$posDetailsCache = [{ line: 1, column: 1 }];
      var peg$maxFailPos = 0;
      var peg$maxFailExpected = [];
      var peg$silentFails = 0;
      var peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function offset() {
        return peg$savedPos;
      }
      function range() {
        return {
          source: peg$source,
          start: peg$savedPos,
          end: peg$currPos
        };
      }
      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError(
          [peg$otherExpectation(description)],
          input.substring(peg$savedPos, peg$currPos),
          location2
        );
      }
      function error(message, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location2);
      }
      function peg$literalExpectation(text2, ignoreCase) {
        return { type: "literal", text: text2, ignoreCase };
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts, inverted, ignoreCase };
      }
      function peg$anyExpectation() {
        return { type: "any" };
      }
      function peg$endExpectation() {
        return { type: "end" };
      }
      function peg$otherExpectation(description) {
        return { type: "other", description };
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p;
        if (details) {
          return details;
        } else {
          p = pos - 1;
          while (!peg$posDetailsCache[p]) {
            p--;
          }
          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };
          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos);
        var endPosDetails = peg$computePosDetails(endPos);
        return {
          source: peg$source,
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildSimpleError(message, location2) {
        return new peg$SyntaxError(message, null, null, location2);
      }
      function peg$buildStructuredError(expected2, found, location2) {
        return new peg$SyntaxError(
          peg$SyntaxError.buildMessage(expected2, found),
          expected2,
          found,
          location2
        );
      }
      function peg$parsebody() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsetriple_ligature();
        if (s22 === peg$FAILED) {
          s22 = peg$parsedouble_ligature();
          if (s22 === peg$FAILED) {
            s22 = peg$parsemono_ligature();
            if (s22 === peg$FAILED) {
              if (input.length > peg$currPos) {
                s22 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s22 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
            }
          }
        }
        if (s22 !== peg$FAILED) {
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            s22 = peg$parsetriple_ligature();
            if (s22 === peg$FAILED) {
              s22 = peg$parsedouble_ligature();
              if (s22 === peg$FAILED) {
                s22 = peg$parsemono_ligature();
                if (s22 === peg$FAILED) {
                  if (input.length > peg$currPos) {
                    s22 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s22 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e0);
                    }
                  }
                }
              }
            }
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f0(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseEOL();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f1();
          }
          s0 = s1;
        }
        return s0;
      }
      function peg$parsetriple_ligature() {
        var s0, s1, s22, s32, s42;
        s0 = peg$currPos;
        s1 = peg$currPos;
        if (input.length > peg$currPos) {
          s22 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s22 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s22 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s32 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s32 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s32 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s42 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s42 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            if (s42 !== peg$FAILED) {
              s22 = [s22, s32, s42];
              s1 = s22;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f2(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f3(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsedouble_ligature() {
        var s0;
        s0 = peg$parsedouble_macro_ligature();
        if (s0 === peg$FAILED) {
          s0 = peg$parsedouble_macro_ligature_extracted();
          if (s0 === peg$FAILED) {
            s0 = peg$parsedouble_char_ligature();
          }
        }
        return s0;
      }
      function peg$parsedouble_macro_ligature_extracted() {
        var s0, s1, s22, s32, s42;
        s0 = peg$currPos;
        s1 = peg$parsemacro();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$parsewhitespace();
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parsewhitespace();
          }
          s32 = peg$parsesplitable();
          if (s32 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s42 = peg$f4(s1, s32);
            if (s42) {
              s42 = void 0;
            } else {
              s42 = peg$FAILED;
            }
            if (s42 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f5(s1, s32);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsedouble_macro_ligature() {
        var s0, s1, s22, s32, s42;
        s0 = peg$currPos;
        s1 = peg$parsemacro();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$parsewhitespace();
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parsewhitespace();
          }
          if (input.length > peg$currPos) {
            s32 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s32 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s32 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s42 = peg$f6(s1, s32);
            if (s42) {
              s42 = void 0;
            } else {
              s42 = peg$FAILED;
            }
            if (s42 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f7(s1, s32);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsedouble_char_ligature() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$currPos;
        if (input.length > peg$currPos) {
          s22 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s22 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s22 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s32 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s32 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s32 !== peg$FAILED) {
            s22 = [s22, s32];
            s1 = s22;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f8(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f9(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsemono_ligature() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f10(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f11(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsemacro() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f12(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f13(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsewhitespace() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f14(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f15(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsesplitable() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f16(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f17(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseEOL() {
        var s0, s1;
        s0 = peg$currPos;
        peg$silentFails++;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        peg$silentFails--;
        if (s1 === peg$FAILED) {
          s0 = void 0;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      if (!options.isWhitespace) {
        try {
          Object.assign(options, {
            isMacro: (node) => node.type === "macro",
            isWhitespace: (node) => node.type === "whitespace",
            isRecognized: (nodes) => {
              if (nodes.length == 2 && nodes[0].content === "^" && nodes[1].content === "o") {
                return { type: "string", content: "\xF4" };
              }
              return null;
            },
            isSplitable: (node) => node.type === "string" && node.content.length > 1,
            split: (node) => [
              { type: "string", content: node.content.charAt(0) },
              { type: "string", content: node.content.slice(1) }
            ]
          });
        } catch (e) {
          console.warn("Error when initializing parser", e);
        }
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(
          peg$maxFailExpected,
          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
      }
    }
    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }()
);
var xcolor_expressions_default = (
  // Generated by Peggy 2.0.1.
  //
  // https://peggyjs.org/
  function() {
    "use strict";
    function peg$subclass(child, parent) {
      function C() {
        this.constructor = child;
      }
      C.prototype = parent.prototype;
      child.prototype = new C();
    }
    function peg$SyntaxError(message, expected, found, location) {
      var self = Error.call(this, message);
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(self, peg$SyntaxError.prototype);
      }
      self.expected = expected;
      self.found = found;
      self.location = location;
      self.name = "SyntaxError";
      return self;
    }
    peg$subclass(peg$SyntaxError, Error);
    function peg$padEnd(str, targetLength, padString) {
      padString = padString || " ";
      if (str.length > targetLength) {
        return str;
      }
      targetLength -= str.length;
      padString += padString.repeat(targetLength);
      return str + padString.slice(0, targetLength);
    }
    peg$SyntaxError.prototype.format = function(sources) {
      var str = "Error: " + this.message;
      if (this.location) {
        var src = null;
        var k;
        for (k = 0; k < sources.length; k++) {
          if (sources[k].source === this.location.source) {
            src = sources[k].text.split(/\r\n|\n|\r/g);
            break;
          }
        }
        var s32 = this.location.start;
        var loc = this.location.source + ":" + s32.line + ":" + s32.column;
        if (src) {
          var e = this.location.end;
          var filler = peg$padEnd("", s32.line.toString().length, " ");
          var line = src[s32.line - 1];
          var last = s32.line === e.line ? e.column : line.length + 1;
          var hatLen = last - s32.column || 1;
          str += "\n --> " + loc + "\n" + filler + " |\n" + s32.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s32.column - 1, " ") + peg$padEnd("", hatLen, "^");
        } else {
          str += "\n at " + loc;
        }
      }
      return str;
    };
    peg$SyntaxError.buildMessage = function(expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        class: function(expectation) {
          var escapedParts = expectation.parts.map(function(part) {
            return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
          });
          return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
        },
        any: function() {
          return "any character";
        },
        end: function() {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        }
      };
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s32) {
        return s32.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function classEscape(s32) {
        return s32.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = expected2.map(describeExpectation);
        var i, j;
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {};
      var peg$source = options.grammarSource;
      var peg$startRuleFunctions = { start: peg$parsestart };
      var peg$startRuleFunction = peg$parsestart;
      var peg$c0 = ";";
      var peg$c1 = ",";
      var peg$c2 = ":";
      var peg$c3 = "/";
      var peg$c4 = ">";
      var peg$c5 = "!";
      var peg$c6 = ".";
      var peg$c7 = "!![";
      var peg$c8 = "]";
      var peg$c9 = "!!";
      var peg$c10 = "+";
      var peg$c11 = "-";
      var peg$r0 = /^[a-zA-Z0-9]/;
      var peg$r1 = /^[0-9]/;
      var peg$r2 = /^[ \t\n\r]/;
      var peg$r3 = /^[0-9a-fA-F]/;
      var peg$e0 = peg$anyExpectation();
      var peg$e1 = peg$literalExpectation(";", false);
      var peg$e2 = peg$literalExpectation(",", false);
      var peg$e3 = peg$otherExpectation("model list");
      var peg$e4 = peg$literalExpectation(":", false);
      var peg$e5 = peg$literalExpectation("/", false);
      var peg$e6 = peg$otherExpectation("model");
      var peg$e7 = peg$otherExpectation("color spec list");
      var peg$e8 = peg$otherExpectation("color spec");
      var peg$e9 = peg$otherExpectation("color");
      var peg$e10 = peg$otherExpectation("function expression");
      var peg$e11 = peg$literalExpectation(">", false);
      var peg$e12 = peg$otherExpectation("function");
      var peg$e13 = peg$otherExpectation("extended expression");
      var peg$e14 = peg$otherExpectation("core model");
      var peg$e15 = peg$otherExpectation("expr");
      var peg$e16 = peg$literalExpectation("!", false);
      var peg$e17 = peg$otherExpectation("mix expr");
      var peg$e18 = peg$otherExpectation("name");
      var peg$e19 = peg$literalExpectation(".", false);
      var peg$e20 = peg$classExpectation([["a", "z"], ["A", "Z"], ["0", "9"]], false, false);
      var peg$e21 = peg$otherExpectation("postfix");
      var peg$e22 = peg$literalExpectation("!![", false);
      var peg$e23 = peg$literalExpectation("]", false);
      var peg$e24 = peg$literalExpectation("!!", false);
      var peg$e25 = peg$otherExpectation("prefix");
      var peg$e26 = peg$otherExpectation("plus");
      var peg$e27 = peg$literalExpectation("+", false);
      var peg$e28 = peg$otherExpectation("minus");
      var peg$e29 = peg$literalExpectation("-", false);
      var peg$e30 = peg$otherExpectation("num");
      var peg$e31 = peg$classExpectation([["0", "9"]], false, false);
      var peg$e32 = peg$otherExpectation("positive float");
      var peg$e33 = peg$otherExpectation("divisor");
      var peg$e34 = peg$otherExpectation("int");
      var peg$e35 = peg$otherExpectation("whitespace");
      var peg$e36 = peg$classExpectation([" ", "	", "\n", "\r"], false, false);
      var peg$e37 = peg$classExpectation([["0", "9"], ["a", "f"], ["A", "F"]], false, false);
      var peg$f0 = function(m) {
        return m;
      };
      var peg$f1 = function(m) {
        return m;
      };
      var peg$f2 = function(m) {
        return m;
      };
      var peg$f3 = function(m) {
        return m;
      };
      var peg$f4 = function(m) {
        return m;
      };
      var peg$f5 = function(a) {
        return { type: "invalid_spec", content: a };
      };
      var peg$f6 = function(f, c) {
        return c;
      };
      var peg$f7 = function(f, r) {
        return { type: "color_set", content: [f].concat(r) };
      };
      var peg$f8 = function(n, s32) {
        return { type: "color_set_item", name: n, spec_list: s32 };
      };
      var peg$f9 = function(c, m) {
        return { type: "model_list", contents: m, core_model: c };
      };
      var peg$f10 = function(m) {
        return { type: "model_list", contents: m, core_model: null };
      };
      var peg$f11 = function(m, a) {
        return a;
      };
      var peg$f12 = function(m, r) {
        return [m].concat(r);
      };
      var peg$f13 = function(s32, a) {
        return a;
      };
      var peg$f14 = function(s32, r) {
        return { type: "spec_list", content: [s32].concat(r) };
      };
      var peg$f15 = function(c) {
        return { type: "hex_spec", content: [c] };
      };
      var peg$f16 = function(c, d) {
        return d;
      };
      var peg$f17 = function(c, d) {
        return d;
      };
      var peg$f18 = function(c, r) {
        return { type: "num_spec", content: r ? [c].concat(r) : [c] };
      };
      var peg$f19 = function(c, fs) {
        return { type: "color", color: c, functions: fs };
      };
      var peg$f20 = function(f, n) {
        return n;
      };
      var peg$f21 = function(f, args) {
        return { type: "function", name: f, args };
      };
      var peg$f22 = function(core, d, e, es) {
        return {
          type: "extended_expr",
          core_model: core,
          div: d,
          expressions: [e].concat(es)
        };
      };
      var peg$f23 = function(core, e, es) {
        return {
          type: "extended_expr",
          core_model: core,
          div: null,
          expressions: [e].concat(es)
        };
      };
      var peg$f24 = function(e, d) {
        return { type: "weighted_expr", color: e, weight: d };
      };
      var peg$f25 = function(e) {
        return e;
      };
      var peg$f26 = function(p, n, e, po) {
        return {
          type: "expr",
          prefix: p,
          name: n,
          mix_expr: e,
          postfix: po
        };
      };
      var peg$f27 = function(p, n) {
        return { type: "complete_mix", mix_percent: p, name: n };
      };
      var peg$f28 = function(p) {
        return { type: "partial_mix", mix_percent: p };
      };
      var peg$f29 = function(c, p) {
        return c.concat(p || []);
      };
      var peg$f30 = function(n) {
        return { type: "postfix", num: n };
      };
      var peg$f31 = function(p) {
        return { type: "postfix", plusses: p };
      };
      var peg$f32 = function(n) {
        return parseInt(n, 10);
      };
      var peg$f33 = function(n) {
        return parseFloat(n);
      };
      var peg$f34 = function(n) {
        return n;
      };
      var peg$f35 = function(n) {
        return -n;
      };
      var peg$f36 = function(m, n) {
        return m ? -n : n;
      };
      var peg$f37 = function(h) {
        return h.toUpperCase();
      };
      var peg$currPos = 0;
      var peg$savedPos = 0;
      var peg$posDetailsCache = [{ line: 1, column: 1 }];
      var peg$maxFailPos = 0;
      var peg$maxFailExpected = [];
      var peg$silentFails = 0;
      var peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function offset() {
        return peg$savedPos;
      }
      function range() {
        return {
          source: peg$source,
          start: peg$savedPos,
          end: peg$currPos
        };
      }
      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError(
          [peg$otherExpectation(description)],
          input.substring(peg$savedPos, peg$currPos),
          location2
        );
      }
      function error(message, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location2);
      }
      function peg$literalExpectation(text2, ignoreCase) {
        return { type: "literal", text: text2, ignoreCase };
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts, inverted, ignoreCase };
      }
      function peg$anyExpectation() {
        return { type: "any" };
      }
      function peg$endExpectation() {
        return { type: "end" };
      }
      function peg$otherExpectation(description) {
        return { type: "other", description };
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p;
        if (details) {
          return details;
        } else {
          p = pos - 1;
          while (!peg$posDetailsCache[p]) {
            p--;
          }
          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };
          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos);
        var endPosDetails = peg$computePosDetails(endPos);
        return {
          source: peg$source,
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildSimpleError(message, location2) {
        return new peg$SyntaxError(message, null, null, location2);
      }
      function peg$buildStructuredError(expected2, found, location2) {
        return new peg$SyntaxError(
          peg$SyntaxError.buildMessage(expected2, found),
          expected2,
          found,
          location2
        );
      }
      function peg$parsestart() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$parsespec();
        if (s1 !== peg$FAILED) {
          s22 = peg$parseEOL();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f0(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsespec_list();
          if (s1 !== peg$FAILED) {
            s22 = peg$parseEOL();
            if (s22 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f1(s1);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsecolor();
            if (s1 !== peg$FAILED) {
              s22 = peg$parseEOL();
              if (s22 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f2(s1);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parsemodel_list();
              if (s1 !== peg$FAILED) {
                s22 = peg$parseEOL();
                if (s22 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s0 = peg$f3(s1);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parsecolor_set_spec();
                if (s1 !== peg$FAILED) {
                  s22 = peg$parseEOL();
                  if (s22 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s0 = peg$f4(s1);
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  s1 = peg$currPos;
                  s22 = [];
                  if (input.length > peg$currPos) {
                    s32 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s32 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e0);
                    }
                  }
                  while (s32 !== peg$FAILED) {
                    s22.push(s32);
                    if (input.length > peg$currPos) {
                      s32 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s32 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e0);
                      }
                    }
                  }
                  s1 = input.substring(s1, peg$currPos);
                  peg$savedPos = s0;
                  s1 = peg$f5(s1);
                  s0 = s1;
                }
              }
            }
          }
        }
        return s0;
      }
      function peg$parsecolor_set_spec() {
        var s0, s1, s22, s32, s42, s5;
        s0 = peg$currPos;
        s1 = peg$parsecolor_set_item();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 59) {
            s42 = peg$c0;
            peg$currPos++;
          } else {
            s42 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e1);
            }
          }
          if (s42 !== peg$FAILED) {
            s5 = peg$parsecolor_set_item();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s32;
              s32 = peg$f6(s1, s5);
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          } else {
            peg$currPos = s32;
            s32 = peg$FAILED;
          }
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 59) {
              s42 = peg$c0;
              peg$currPos++;
            } else {
              s42 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e1);
              }
            }
            if (s42 !== peg$FAILED) {
              s5 = peg$parsecolor_set_item();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s32;
                s32 = peg$f6(s1, s5);
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          }
          peg$savedPos = s0;
          s0 = peg$f7(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecolor_set_item() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$parsename();
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 44) {
            s22 = peg$c1;
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          if (s22 !== peg$FAILED) {
            s32 = peg$parsespec_list();
            if (s32 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f8(s1, s32);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsemodel_list() {
        var s0, s1, s22, s32;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parsecore_model();
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 58) {
            s22 = peg$c2;
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e4);
            }
          }
          if (s22 !== peg$FAILED) {
            s32 = peg$parsemodel_list_tail();
            if (s32 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f9(s1, s32);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsemodel_list_tail();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f10(s1);
          }
          s0 = s1;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        return s0;
      }
      function peg$parsemodel_list_tail() {
        var s0, s1, s22, s32, s42, s5;
        s0 = peg$currPos;
        s1 = peg$parsemodel();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 47) {
            s42 = peg$c3;
            peg$currPos++;
          } else {
            s42 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e5);
            }
          }
          if (s42 !== peg$FAILED) {
            s5 = peg$parsemodel();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s32;
              s32 = peg$f11(s1, s5);
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          } else {
            peg$currPos = s32;
            s32 = peg$FAILED;
          }
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 47) {
              s42 = peg$c3;
              peg$currPos++;
            } else {
              s42 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e5);
              }
            }
            if (s42 !== peg$FAILED) {
              s5 = peg$parsemodel();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s32;
                s32 = peg$f11(s1, s5);
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          }
          peg$savedPos = s0;
          s0 = peg$f12(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsemodel() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parsecore_model();
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e6);
          }
        }
        return s0;
      }
      function peg$parsespec_list() {
        var s0, s1, s22, s32, s42, s5;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parsespec();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 47) {
            s42 = peg$c3;
            peg$currPos++;
          } else {
            s42 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e5);
            }
          }
          if (s42 !== peg$FAILED) {
            s5 = peg$parsespec();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s32;
              s32 = peg$f13(s1, s5);
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          } else {
            peg$currPos = s32;
            s32 = peg$FAILED;
          }
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 47) {
              s42 = peg$c3;
              peg$currPos++;
            } else {
              s42 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e5);
              }
            }
            if (s42 !== peg$FAILED) {
              s5 = peg$parsespec();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s32;
                s32 = peg$f13(s1, s5);
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          }
          peg$savedPos = s0;
          s0 = peg$f14(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e7);
          }
        }
        return s0;
      }
      function peg$parsespec() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$currPos;
        s32 = peg$parsehex();
        if (s32 !== peg$FAILED) {
          s42 = peg$parsehex();
          if (s42 !== peg$FAILED) {
            s5 = peg$parsehex();
            if (s5 !== peg$FAILED) {
              s6 = peg$parsehex();
              if (s6 !== peg$FAILED) {
                s7 = peg$parsehex();
                if (s7 !== peg$FAILED) {
                  s8 = peg$parsehex();
                  if (s8 !== peg$FAILED) {
                    s32 = [s32, s42, s5, s6, s7, s8];
                    s22 = s32;
                  } else {
                    peg$currPos = s22;
                    s22 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s22;
                  s22 = peg$FAILED;
                }
              } else {
                peg$currPos = s22;
                s22 = peg$FAILED;
              }
            } else {
              peg$currPos = s22;
              s22 = peg$FAILED;
            }
          } else {
            peg$currPos = s22;
            s22 = peg$FAILED;
          }
        } else {
          peg$currPos = s22;
          s22 = peg$FAILED;
        }
        if (s22 !== peg$FAILED) {
          s1 = input.substring(s1, peg$currPos);
        } else {
          s1 = s22;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f15(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsedec();
          if (s1 !== peg$FAILED) {
            s22 = [];
            s32 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 44) {
              s42 = peg$c1;
              peg$currPos++;
            } else {
              s42 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e2);
              }
            }
            if (s42 !== peg$FAILED) {
              s5 = peg$parsedec();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s32;
                s32 = peg$f16(s1, s5);
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
            if (s32 !== peg$FAILED) {
              while (s32 !== peg$FAILED) {
                s22.push(s32);
                s32 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 44) {
                  s42 = peg$c1;
                  peg$currPos++;
                } else {
                  s42 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e2);
                  }
                }
                if (s42 !== peg$FAILED) {
                  s5 = peg$parsedec();
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s32;
                    s32 = peg$f16(s1, s5);
                  } else {
                    peg$currPos = s32;
                    s32 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s32;
                  s32 = peg$FAILED;
                }
              }
            } else {
              s22 = peg$FAILED;
            }
            if (s22 === peg$FAILED) {
              s22 = [];
              s32 = peg$currPos;
              s42 = peg$parsesp();
              if (s42 !== peg$FAILED) {
                s5 = peg$parsedec();
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s32;
                  s32 = peg$f17(s1, s5);
                } else {
                  peg$currPos = s32;
                  s32 = peg$FAILED;
                }
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
              if (s32 !== peg$FAILED) {
                while (s32 !== peg$FAILED) {
                  s22.push(s32);
                  s32 = peg$currPos;
                  s42 = peg$parsesp();
                  if (s42 !== peg$FAILED) {
                    s5 = peg$parsedec();
                    if (s5 !== peg$FAILED) {
                      peg$savedPos = s32;
                      s32 = peg$f17(s1, s5);
                    } else {
                      peg$currPos = s32;
                      s32 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s32;
                    s32 = peg$FAILED;
                  }
                }
              } else {
                s22 = peg$FAILED;
              }
            }
            if (s22 === peg$FAILED) {
              s22 = null;
            }
            peg$savedPos = s0;
            s0 = peg$f18(s1, s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e8);
          }
        }
        return s0;
      }
      function peg$parsecolor() {
        var s0, s1, s22, s32;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parsecolor_expr();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$parsefunc_expr();
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parsefunc_expr();
          }
          peg$savedPos = s0;
          s0 = peg$f19(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e9);
          }
        }
        return s0;
      }
      function peg$parsecolor_expr() {
        var s0;
        s0 = peg$parseext_expr();
        if (s0 === peg$FAILED) {
          s0 = peg$parseexpr();
          if (s0 === peg$FAILED) {
            s0 = peg$parsename();
          }
        }
        return s0;
      }
      function peg$parsefunc_expr() {
        var s0, s1, s22, s32, s42, s5, s6;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 62) {
          s1 = peg$c4;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e11);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parsefunction();
          if (s22 !== peg$FAILED) {
            s32 = [];
            s42 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 44) {
              s5 = peg$c1;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e2);
              }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parseint();
              if (s6 !== peg$FAILED) {
                peg$savedPos = s42;
                s42 = peg$f20(s22, s6);
              } else {
                peg$currPos = s42;
                s42 = peg$FAILED;
              }
            } else {
              peg$currPos = s42;
              s42 = peg$FAILED;
            }
            while (s42 !== peg$FAILED) {
              s32.push(s42);
              s42 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 44) {
                s5 = peg$c1;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e2);
                }
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parseint();
                if (s6 !== peg$FAILED) {
                  peg$savedPos = s42;
                  s42 = peg$f20(s22, s6);
                } else {
                  peg$currPos = s42;
                  s42 = peg$FAILED;
                }
              } else {
                peg$currPos = s42;
                s42 = peg$FAILED;
              }
            }
            peg$savedPos = s0;
            s0 = peg$f21(s22, s32);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e10);
          }
        }
        return s0;
      }
      function peg$parsefunction() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parsename();
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e12);
          }
        }
        return s0;
      }
      function peg$parseext_expr() {
        var s0, s1, s22, s32, s42, s5, s6, s7;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parsecore_model();
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 44) {
            s22 = peg$c1;
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          if (s22 !== peg$FAILED) {
            s32 = peg$parsediv();
            if (s32 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 58) {
                s42 = peg$c2;
                peg$currPos++;
              } else {
                s42 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e4);
                }
              }
              if (s42 !== peg$FAILED) {
                s5 = peg$parseweighted_expr();
                if (s5 !== peg$FAILED) {
                  s6 = [];
                  s7 = peg$parseadditional_weighted_expr();
                  while (s7 !== peg$FAILED) {
                    s6.push(s7);
                    s7 = peg$parseadditional_weighted_expr();
                  }
                  peg$savedPos = s0;
                  s0 = peg$f22(s1, s32, s5, s6);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsecore_model();
          if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 58) {
              s22 = peg$c2;
              peg$currPos++;
            } else {
              s22 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e4);
              }
            }
            if (s22 !== peg$FAILED) {
              s32 = peg$parseweighted_expr();
              if (s32 !== peg$FAILED) {
                s42 = [];
                s5 = peg$parseadditional_weighted_expr();
                while (s5 !== peg$FAILED) {
                  s42.push(s5);
                  s5 = peg$parseadditional_weighted_expr();
                }
                peg$savedPos = s0;
                s0 = peg$f23(s1, s32, s42);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e13);
          }
        }
        return s0;
      }
      function peg$parseweighted_expr() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$parseexpr();
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 44) {
            s22 = peg$c1;
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          if (s22 !== peg$FAILED) {
            s32 = peg$parsedec();
            if (s32 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f24(s1, s32);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseadditional_weighted_expr() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 59) {
          s1 = peg$c0;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e1);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parseweighted_expr();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f25(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecore_model() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parsename();
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e14);
          }
        }
        return s0;
      }
      function peg$parseexpr() {
        var s0, s1, s22, s32, s42;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parseprefix();
        s22 = peg$parsename();
        if (s22 !== peg$FAILED) {
          s32 = peg$parsemix_expr();
          s42 = peg$parsepostfix();
          if (s42 === peg$FAILED) {
            s42 = null;
          }
          peg$savedPos = s0;
          s0 = peg$f26(s1, s22, s32, s42);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e15);
          }
        }
        return s0;
      }
      function peg$parsecomplete_mix() {
        var s0, s1, s22, s32, s42;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 33) {
          s1 = peg$c5;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e16);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parsepct();
          if (s22 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 33) {
              s32 = peg$c5;
              peg$currPos++;
            } else {
              s32 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e16);
              }
            }
            if (s32 !== peg$FAILED) {
              s42 = peg$parsename();
              if (s42 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f27(s22, s42);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsepartial_mix() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 33) {
          s1 = peg$c5;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e16);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parsepct();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f28(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsemix_expr() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsecomplete_mix();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parsecomplete_mix();
        }
        s22 = peg$parsepartial_mix();
        if (s22 === peg$FAILED) {
          s22 = null;
        }
        peg$savedPos = s0;
        s0 = peg$f29(s1, s22);
        peg$silentFails--;
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e17);
        }
        return s0;
      }
      function peg$parsename() {
        var s0, s1, s22;
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 46) {
          s0 = peg$c6;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e19);
          }
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = [];
          if (peg$r0.test(input.charAt(peg$currPos))) {
            s22 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e20);
            }
          }
          if (s22 !== peg$FAILED) {
            while (s22 !== peg$FAILED) {
              s1.push(s22);
              if (peg$r0.test(input.charAt(peg$currPos))) {
                s22 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s22 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e20);
                }
              }
            }
          } else {
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            s0 = input.substring(s0, peg$currPos);
          } else {
            s0 = s1;
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e18);
          }
        }
        return s0;
      }
      function peg$parsepostfix() {
        var s0, s1, s22, s32, s42;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 3) === peg$c7) {
          s1 = peg$c7;
          peg$currPos += 3;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e22);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parsenum();
          if (s22 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 93) {
              s32 = peg$c8;
              peg$currPos++;
            } else {
              s32 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e23);
              }
            }
            if (s32 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f30(s22);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c9) {
            s1 = peg$c9;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e24);
            }
          }
          if (s1 !== peg$FAILED) {
            s22 = peg$currPos;
            s32 = [];
            s42 = peg$parseplus();
            if (s42 !== peg$FAILED) {
              while (s42 !== peg$FAILED) {
                s32.push(s42);
                s42 = peg$parseplus();
              }
            } else {
              s32 = peg$FAILED;
            }
            if (s32 !== peg$FAILED) {
              s22 = input.substring(s22, peg$currPos);
            } else {
              s22 = s32;
            }
            if (s22 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f31(s22);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e21);
          }
        }
        return s0;
      }
      function peg$parseprefix() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parseminus();
        if (s0 === peg$FAILED) {
          s0 = null;
        }
        peg$silentFails--;
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e25);
        }
        return s0;
      }
      function peg$parseplus() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        if (input.charCodeAt(peg$currPos) === 43) {
          s22 = peg$c10;
          peg$currPos++;
        } else {
          s22 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e27);
          }
        }
        if (s22 !== peg$FAILED) {
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            if (input.charCodeAt(peg$currPos) === 43) {
              s22 = peg$c10;
              peg$currPos++;
            } else {
              s22 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e27);
              }
            }
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e26);
          }
        }
        return s0;
      }
      function peg$parseminus() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        if (input.charCodeAt(peg$currPos) === 45) {
          s22 = peg$c11;
          peg$currPos++;
        } else {
          s22 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e29);
          }
        }
        if (s22 !== peg$FAILED) {
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            if (input.charCodeAt(peg$currPos) === 45) {
              s22 = peg$c11;
              peg$currPos++;
            } else {
              s22 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e29);
              }
            }
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e28);
          }
        }
        return s0;
      }
      function peg$parsenum() {
        var s0, s1, s22, s32;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = [];
        if (peg$r1.test(input.charAt(peg$currPos))) {
          s32 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s32 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e31);
          }
        }
        if (s32 !== peg$FAILED) {
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            if (peg$r1.test(input.charAt(peg$currPos))) {
              s32 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s32 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e31);
              }
            }
          }
        } else {
          s22 = peg$FAILED;
        }
        if (s22 !== peg$FAILED) {
          s1 = input.substring(s1, peg$currPos);
        } else {
          s1 = s22;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f32(s1);
        }
        s0 = s1;
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e30);
          }
        }
        return s0;
      }
      function peg$parsepct() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8, s9;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$currPos;
        s32 = peg$currPos;
        s42 = [];
        if (peg$r1.test(input.charAt(peg$currPos))) {
          s5 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e31);
          }
        }
        if (s5 !== peg$FAILED) {
          while (s5 !== peg$FAILED) {
            s42.push(s5);
            if (peg$r1.test(input.charAt(peg$currPos))) {
              s5 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e31);
              }
            }
          }
        } else {
          s42 = peg$FAILED;
        }
        if (s42 !== peg$FAILED) {
          s32 = input.substring(s32, peg$currPos);
        } else {
          s32 = s42;
        }
        if (s32 !== peg$FAILED) {
          s42 = peg$currPos;
          s5 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 46) {
            s6 = peg$c6;
            peg$currPos++;
          } else {
            s6 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e19);
            }
          }
          if (s6 !== peg$FAILED) {
            s7 = peg$currPos;
            s8 = [];
            if (peg$r1.test(input.charAt(peg$currPos))) {
              s9 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s9 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e31);
              }
            }
            while (s9 !== peg$FAILED) {
              s8.push(s9);
              if (peg$r1.test(input.charAt(peg$currPos))) {
                s9 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s9 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e31);
                }
              }
            }
            s7 = input.substring(s7, peg$currPos);
            s6 = [s6, s7];
            s5 = s6;
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
          if (s5 === peg$FAILED) {
            s5 = null;
          }
          s42 = input.substring(s42, peg$currPos);
          s32 = [s32, s42];
          s22 = s32;
        } else {
          peg$currPos = s22;
          s22 = peg$FAILED;
        }
        if (s22 !== peg$FAILED) {
          s1 = input.substring(s1, peg$currPos);
        } else {
          s1 = s22;
        }
        if (s1 === peg$FAILED) {
          s1 = peg$currPos;
          s22 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 46) {
            s32 = peg$c6;
            peg$currPos++;
          } else {
            s32 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e19);
            }
          }
          if (s32 !== peg$FAILED) {
            s42 = peg$currPos;
            s5 = [];
            if (peg$r1.test(input.charAt(peg$currPos))) {
              s6 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e31);
              }
            }
            if (s6 !== peg$FAILED) {
              while (s6 !== peg$FAILED) {
                s5.push(s6);
                if (peg$r1.test(input.charAt(peg$currPos))) {
                  s6 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e31);
                  }
                }
              }
            } else {
              s5 = peg$FAILED;
            }
            if (s5 !== peg$FAILED) {
              s42 = input.substring(s42, peg$currPos);
            } else {
              s42 = s5;
            }
            if (s42 !== peg$FAILED) {
              s32 = [s32, s42];
              s22 = s32;
            } else {
              peg$currPos = s22;
              s22 = peg$FAILED;
            }
          } else {
            peg$currPos = s22;
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = input.substring(s1, peg$currPos);
          } else {
            s1 = s22;
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f33(s1);
        }
        s0 = s1;
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e32);
          }
        }
        return s0;
      }
      function peg$parsediv() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parsepct();
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e33);
          }
        }
        return s0;
      }
      function peg$parsedec() {
        var s0, s1, s22;
        s0 = peg$parsepct();
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 43) {
            s1 = peg$c10;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e27);
            }
          }
          if (s1 !== peg$FAILED) {
            s22 = peg$parsepct();
            if (s22 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f34(s22);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 45) {
              s1 = peg$c11;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e29);
              }
            }
            if (s1 !== peg$FAILED) {
              s22 = peg$parsepct();
              if (s22 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f35(s22);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
        }
        return s0;
      }
      function peg$parseint() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parseminus();
        if (s1 === peg$FAILED) {
          s1 = null;
        }
        s22 = peg$parsenum();
        if (s22 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f36(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e34);
          }
        }
        return s0;
      }
      function peg$parse_() {
        var s0, s1;
        peg$silentFails++;
        s0 = [];
        if (peg$r2.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e36);
          }
        }
        while (s1 !== peg$FAILED) {
          s0.push(s1);
          if (peg$r2.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e36);
            }
          }
        }
        peg$silentFails--;
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e35);
        }
        return s0;
      }
      function peg$parsesp() {
        var s0, s1;
        s0 = [];
        if (peg$r2.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e36);
          }
        }
        if (s1 !== peg$FAILED) {
          while (s1 !== peg$FAILED) {
            s0.push(s1);
            if (peg$r2.test(input.charAt(peg$currPos))) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e36);
              }
            }
          }
        } else {
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsehex() {
        var s0, s1;
        s0 = peg$currPos;
        if (peg$r3.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e37);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f37(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parseEOL() {
        var s0, s1;
        s0 = peg$currPos;
        peg$silentFails++;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        peg$silentFails--;
        if (s1 === peg$FAILED) {
          s0 = void 0;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(
          peg$maxFailExpected,
          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
      }
    }
    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }()
);
var tabular_spec_default = (
  // Generated by Peggy 2.0.1.
  //
  // https://peggyjs.org/
  function() {
    "use strict";
    function peg$subclass(child, parent) {
      function C() {
        this.constructor = child;
      }
      C.prototype = parent.prototype;
      child.prototype = new C();
    }
    function peg$SyntaxError(message, expected, found, location) {
      var self = Error.call(this, message);
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(self, peg$SyntaxError.prototype);
      }
      self.expected = expected;
      self.found = found;
      self.location = location;
      self.name = "SyntaxError";
      return self;
    }
    peg$subclass(peg$SyntaxError, Error);
    function peg$padEnd(str, targetLength, padString) {
      padString = padString || " ";
      if (str.length > targetLength) {
        return str;
      }
      targetLength -= str.length;
      padString += padString.repeat(targetLength);
      return str + padString.slice(0, targetLength);
    }
    peg$SyntaxError.prototype.format = function(sources) {
      var str = "Error: " + this.message;
      if (this.location) {
        var src = null;
        var k;
        for (k = 0; k < sources.length; k++) {
          if (sources[k].source === this.location.source) {
            src = sources[k].text.split(/\r\n|\n|\r/g);
            break;
          }
        }
        var s32 = this.location.start;
        var loc = this.location.source + ":" + s32.line + ":" + s32.column;
        if (src) {
          var e = this.location.end;
          var filler = peg$padEnd("", s32.line.toString().length, " ");
          var line = src[s32.line - 1];
          var last = s32.line === e.line ? e.column : line.length + 1;
          var hatLen = last - s32.column || 1;
          str += "\n --> " + loc + "\n" + filler + " |\n" + s32.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s32.column - 1, " ") + peg$padEnd("", hatLen, "^");
        } else {
          str += "\n at " + loc;
        }
      }
      return str;
    };
    peg$SyntaxError.buildMessage = function(expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        class: function(expectation) {
          var escapedParts = expectation.parts.map(function(part) {
            return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
          });
          return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
        },
        any: function() {
          return "any character";
        },
        end: function() {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        }
      };
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s32) {
        return s32.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function classEscape(s32) {
        return s32.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = expected2.map(describeExpectation);
        var i, j;
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {};
      var peg$source = options.grammarSource;
      var peg$startRuleFunctions = { body: peg$parsebody };
      var peg$startRuleFunction = peg$parsebody;
      var peg$e0 = peg$otherExpectation("decl_start");
      var peg$e1 = peg$otherExpectation("decl_end");
      var peg$e2 = peg$otherExpectation("vert");
      var peg$e3 = peg$anyExpectation();
      var peg$e4 = peg$otherExpectation("l");
      var peg$e5 = peg$otherExpectation("r");
      var peg$e6 = peg$otherExpectation("c");
      var peg$e7 = peg$otherExpectation("p");
      var peg$e8 = peg$otherExpectation("m");
      var peg$e9 = peg$otherExpectation("b");
      var peg$e10 = peg$otherExpectation("w");
      var peg$e11 = peg$otherExpectation("W");
      var peg$e12 = peg$otherExpectation("X");
      var peg$e13 = peg$otherExpectation("!");
      var peg$e14 = peg$otherExpectation("@");
      var peg$e15 = peg$otherExpectation("<");
      var peg$e16 = peg$otherExpectation(">");
      var peg$e17 = peg$otherExpectation("group");
      var peg$e18 = peg$otherExpectation("whitespace");
      var peg$f0 = function(c) {
        return c;
      };
      var peg$f1 = function(cols) {
        return cols;
      };
      var peg$f2 = function() {
        return [];
      };
      var peg$f3 = function(divs1, start, a, end, divs2) {
        return {
          type: "column",
          pre_dividers: divs1,
          post_dividers: divs2,
          before_start_code: start,
          before_end_code: end,
          alignment: a
        };
      };
      var peg$f4 = function() {
        return {
          type: "vert_divider"
        };
      };
      var peg$f5 = function(b, g) {
        return {
          type: "bang_divider",
          content: g[0].content
        };
      };
      var peg$f6 = function(g) {
        return {
          type: "at_divider",
          content: g[0].content
        };
      };
      var peg$f7 = function(div) {
        return div;
      };
      var peg$f8 = function(g) {
        return { type: "decl_code", code: g[0].content };
      };
      var peg$f9 = function(g) {
        return { type: "decl_code", code: g[0].content };
      };
      var peg$f10 = function() {
        return { type: "alignment", alignment: "left" };
      };
      var peg$f11 = function() {
        return { type: "alignment", alignment: "center" };
      };
      var peg$f12 = function() {
        return { type: "alignment", alignment: "right" };
      };
      var peg$f13 = function() {
        return { type: "alignment", alignment: "X" };
      };
      var peg$f14 = function() {
        return "top";
      };
      var peg$f15 = function() {
        return "default";
      };
      var peg$f16 = function() {
        return "bottom";
      };
      var peg$f17 = function(a, g) {
        return {
          type: "alignment",
          alignment: "parbox",
          baseline: a,
          size: g[0].content
        };
      };
      var peg$f18 = function(g1, g2) {
        return {
          type: "alignment",
          alignment: "parbox",
          baseline: g1[0].content,
          size: g2[0].content
        };
      };
      var peg$f19 = function(tok) {
        return options.matchChar(tok, "|");
      };
      var peg$f20 = function(tok) {
        return options.matchChar(tok, "l");
      };
      var peg$f21 = function(tok) {
        return options.matchChar(tok, "r");
      };
      var peg$f22 = function(tok) {
        return options.matchChar(tok, "c");
      };
      var peg$f23 = function(tok) {
        return options.matchChar(tok, "p");
      };
      var peg$f24 = function(tok) {
        return options.matchChar(tok, "m");
      };
      var peg$f25 = function(tok) {
        return options.matchChar(tok, "b");
      };
      var peg$f26 = function(tok) {
        return options.matchChar(tok, "w");
      };
      var peg$f27 = function(tok) {
        return options.matchChar(tok, "W");
      };
      var peg$f28 = function(tok) {
        return options.matchChar(tok, "X");
      };
      var peg$f29 = function(tok) {
        return options.matchChar(tok, "!");
      };
      var peg$f30 = function(tok) {
        return options.matchChar(tok, "@");
      };
      var peg$f31 = function(tok) {
        return options.matchChar(tok, "<");
      };
      var peg$f32 = function(tok) {
        return options.matchChar(tok, ">");
      };
      var peg$f33 = function(tok) {
        return options.isGroup(tok);
      };
      var peg$f34 = function(tok) {
        return options.isWhitespace(tok);
      };
      var peg$currPos = 0;
      var peg$savedPos = 0;
      var peg$posDetailsCache = [{ line: 1, column: 1 }];
      var peg$maxFailPos = 0;
      var peg$maxFailExpected = [];
      var peg$silentFails = 0;
      var peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function offset() {
        return peg$savedPos;
      }
      function range() {
        return {
          source: peg$source,
          start: peg$savedPos,
          end: peg$currPos
        };
      }
      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError(
          [peg$otherExpectation(description)],
          input.substring(peg$savedPos, peg$currPos),
          location2
        );
      }
      function error(message, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location2);
      }
      function peg$literalExpectation(text2, ignoreCase) {
        return { type: "literal", text: text2, ignoreCase };
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts, inverted, ignoreCase };
      }
      function peg$anyExpectation() {
        return { type: "any" };
      }
      function peg$endExpectation() {
        return { type: "end" };
      }
      function peg$otherExpectation(description) {
        return { type: "other", description };
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p;
        if (details) {
          return details;
        } else {
          p = pos - 1;
          while (!peg$posDetailsCache[p]) {
            p--;
          }
          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };
          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos);
        var endPosDetails = peg$computePosDetails(endPos);
        return {
          source: peg$source,
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildSimpleError(message, location2) {
        return new peg$SyntaxError(message, null, null, location2);
      }
      function peg$buildStructuredError(expected2, found, location2) {
        return new peg$SyntaxError(
          peg$SyntaxError.buildMessage(expected2, found),
          expected2,
          found,
          location2
        );
      }
      function peg$parsebody() {
        var s0, s1, s22, s32, s42, s5;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$currPos;
        s32 = peg$parsecolumn();
        if (s32 !== peg$FAILED) {
          s42 = [];
          s5 = peg$parse_();
          while (s5 !== peg$FAILED) {
            s42.push(s5);
            s5 = peg$parse_();
          }
          peg$savedPos = s22;
          s22 = peg$f0(s32);
        } else {
          peg$currPos = s22;
          s22 = peg$FAILED;
        }
        if (s22 !== peg$FAILED) {
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            s22 = peg$currPos;
            s32 = peg$parsecolumn();
            if (s32 !== peg$FAILED) {
              s42 = [];
              s5 = peg$parse_();
              while (s5 !== peg$FAILED) {
                s42.push(s5);
                s5 = peg$parse_();
              }
              peg$savedPos = s22;
              s22 = peg$f0(s32);
            } else {
              peg$currPos = s22;
              s22 = peg$FAILED;
            }
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f1(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseEOL();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f2();
          }
          s0 = s1;
        }
        return s0;
      }
      function peg$parsecolumn() {
        var s0, s1, s22, s32, s42, s5, s6;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsecolumn_divider();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parsecolumn_divider();
        }
        s22 = peg$parsedecl_start();
        if (s22 === peg$FAILED) {
          s22 = null;
        }
        s32 = peg$parsealignment();
        if (s32 !== peg$FAILED) {
          s42 = peg$parsedecl_end();
          if (s42 === peg$FAILED) {
            s42 = null;
          }
          s5 = [];
          s6 = peg$parsecolumn_divider();
          while (s6 !== peg$FAILED) {
            s5.push(s6);
            s6 = peg$parsecolumn_divider();
          }
          peg$savedPos = s0;
          s0 = peg$f3(s1, s22, s32, s42, s5);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecolumn_divider() {
        var s0, s1, s22, s32, s42;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parse_();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parse_();
        }
        s22 = peg$currPos;
        s32 = peg$parsevert();
        if (s32 !== peg$FAILED) {
          peg$savedPos = s22;
          s32 = peg$f4();
        }
        s22 = s32;
        if (s22 === peg$FAILED) {
          s22 = peg$currPos;
          s32 = peg$parsebang();
          if (s32 !== peg$FAILED) {
            s42 = peg$parsegroup();
            if (s42 !== peg$FAILED) {
              peg$savedPos = s22;
              s22 = peg$f5(s32, s42);
            } else {
              peg$currPos = s22;
              s22 = peg$FAILED;
            }
          } else {
            peg$currPos = s22;
            s22 = peg$FAILED;
          }
          if (s22 === peg$FAILED) {
            s22 = peg$currPos;
            s32 = peg$parseat();
            if (s32 !== peg$FAILED) {
              s42 = peg$parsegroup();
              if (s42 !== peg$FAILED) {
                peg$savedPos = s22;
                s22 = peg$f6(s42);
              } else {
                peg$currPos = s22;
                s22 = peg$FAILED;
              }
            } else {
              peg$currPos = s22;
              s22 = peg$FAILED;
            }
          }
        }
        if (s22 !== peg$FAILED) {
          s32 = [];
          s42 = peg$parse_();
          while (s42 !== peg$FAILED) {
            s32.push(s42);
            s42 = peg$parse_();
          }
          peg$savedPos = s0;
          s0 = peg$f7(s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsedecl_start() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parsegreater();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsegroup();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f8(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        return s0;
      }
      function peg$parsedecl_end() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parseless();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsegroup();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f9(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e1);
          }
        }
        return s0;
      }
      function peg$parsealignment() {
        var s0, s1, s22, s32, s42, s5;
        s0 = peg$currPos;
        s1 = peg$parsel();
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f10();
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsec();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f11();
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parser();
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$f12();
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parseX();
              if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$f13();
              }
              s0 = s1;
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$currPos;
                s22 = peg$parsep();
                if (s22 !== peg$FAILED) {
                  peg$savedPos = s1;
                  s22 = peg$f14();
                }
                s1 = s22;
                if (s1 === peg$FAILED) {
                  s1 = peg$currPos;
                  s22 = peg$parsem();
                  if (s22 !== peg$FAILED) {
                    peg$savedPos = s1;
                    s22 = peg$f15();
                  }
                  s1 = s22;
                  if (s1 === peg$FAILED) {
                    s1 = peg$currPos;
                    s22 = peg$parseb();
                    if (s22 !== peg$FAILED) {
                      peg$savedPos = s1;
                      s22 = peg$f16();
                    }
                    s1 = s22;
                  }
                }
                if (s1 !== peg$FAILED) {
                  s22 = [];
                  s32 = peg$parse_();
                  while (s32 !== peg$FAILED) {
                    s22.push(s32);
                    s32 = peg$parse_();
                  }
                  s32 = peg$parsegroup();
                  if (s32 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s0 = peg$f17(s1, s32);
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  s1 = peg$parsew();
                  if (s1 === peg$FAILED) {
                    s1 = peg$parseW();
                  }
                  if (s1 !== peg$FAILED) {
                    s22 = [];
                    s32 = peg$parse_();
                    while (s32 !== peg$FAILED) {
                      s22.push(s32);
                      s32 = peg$parse_();
                    }
                    s32 = peg$parsegroup();
                    if (s32 !== peg$FAILED) {
                      s42 = [];
                      s5 = peg$parse_();
                      while (s5 !== peg$FAILED) {
                        s42.push(s5);
                        s5 = peg$parse_();
                      }
                      s5 = peg$parsegroup();
                      if (s5 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s0 = peg$f18(s32, s5);
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                }
              }
            }
          }
        }
        return s0;
      }
      function peg$parsevert() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f19(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        return s0;
      }
      function peg$parsel() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f20(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e4);
          }
        }
        return s0;
      }
      function peg$parser() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f21(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e5);
          }
        }
        return s0;
      }
      function peg$parsec() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f22(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e6);
          }
        }
        return s0;
      }
      function peg$parsep() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f23(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e7);
          }
        }
        return s0;
      }
      function peg$parsem() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f24(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e8);
          }
        }
        return s0;
      }
      function peg$parseb() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f25(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e9);
          }
        }
        return s0;
      }
      function peg$parsew() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f26(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e10);
          }
        }
        return s0;
      }
      function peg$parseW() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f27(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e11);
          }
        }
        return s0;
      }
      function peg$parseX() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f28(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e12);
          }
        }
        return s0;
      }
      function peg$parsebang() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f29(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e13);
          }
        }
        return s0;
      }
      function peg$parseat() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f30(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e14);
          }
        }
        return s0;
      }
      function peg$parseless() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f31(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e15);
          }
        }
        return s0;
      }
      function peg$parsegreater() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f32(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e16);
          }
        }
        return s0;
      }
      function peg$parsegroup() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f33(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e17);
          }
        }
        return s0;
      }
      function peg$parse_() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f34(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e18);
          }
        }
        return s0;
      }
      function peg$parseEOL() {
        var s0, s1;
        s0 = peg$currPos;
        peg$silentFails++;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        peg$silentFails--;
        if (s1 === peg$FAILED) {
          s0 = void 0;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      if (!options.isHash) {
        try {
          Object.assign(options, {
            matchChar: (node, char) => node.type === "string" && node.content === char,
            isGroup: (node) => node.type === "group",
            isWhitespace: (node) => node.type === "whitespace"
          });
        } catch (e) {
          console.warn("Error when initializing parser", e);
        }
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(
          peg$maxFailExpected,
          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
      }
    }
    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }()
);
var systeme_environment_default = (
  // Generated by Peggy 2.0.1.
  //
  // https://peggyjs.org/
  function() {
    "use strict";
    function peg$subclass(child, parent) {
      function C() {
        this.constructor = child;
      }
      C.prototype = parent.prototype;
      child.prototype = new C();
    }
    function peg$SyntaxError(message, expected, found, location) {
      var self = Error.call(this, message);
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(self, peg$SyntaxError.prototype);
      }
      self.expected = expected;
      self.found = found;
      self.location = location;
      self.name = "SyntaxError";
      return self;
    }
    peg$subclass(peg$SyntaxError, Error);
    function peg$padEnd(str, targetLength, padString) {
      padString = padString || " ";
      if (str.length > targetLength) {
        return str;
      }
      targetLength -= str.length;
      padString += padString.repeat(targetLength);
      return str + padString.slice(0, targetLength);
    }
    peg$SyntaxError.prototype.format = function(sources) {
      var str = "Error: " + this.message;
      if (this.location) {
        var src = null;
        var k;
        for (k = 0; k < sources.length; k++) {
          if (sources[k].source === this.location.source) {
            src = sources[k].text.split(/\r\n|\n|\r/g);
            break;
          }
        }
        var s32 = this.location.start;
        var loc = this.location.source + ":" + s32.line + ":" + s32.column;
        if (src) {
          var e = this.location.end;
          var filler = peg$padEnd("", s32.line.toString().length, " ");
          var line = src[s32.line - 1];
          var last = s32.line === e.line ? e.column : line.length + 1;
          var hatLen = last - s32.column || 1;
          str += "\n --> " + loc + "\n" + filler + " |\n" + s32.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s32.column - 1, " ") + peg$padEnd("", hatLen, "^");
        } else {
          str += "\n at " + loc;
        }
      }
      return str;
    };
    peg$SyntaxError.buildMessage = function(expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        class: function(expectation) {
          var escapedParts = expectation.parts.map(function(part) {
            return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
          });
          return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
        },
        any: function() {
          return "any character";
        },
        end: function() {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        }
      };
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s32) {
        return s32.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function classEscape(s32) {
        return s32.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = expected2.map(describeExpectation);
        var i, j;
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {};
      var peg$source = options.grammarSource;
      var peg$startRuleFunctions = { body: peg$parsebody };
      var peg$startRuleFunction = peg$parsebody;
      var peg$e0 = peg$otherExpectation("partial item");
      var peg$e1 = peg$otherExpectation("item");
      var peg$e2 = peg$anyExpectation();
      var peg$e3 = peg$otherExpectation("equation");
      var peg$e4 = peg$otherExpectation("trailing comment");
      var peg$e5 = peg$otherExpectation("comment only line");
      var peg$e6 = peg$otherExpectation("non-var token");
      var peg$e7 = peg$otherExpectation("token");
      var peg$e8 = peg$otherExpectation("same line comment");
      var peg$e9 = peg$otherExpectation("own line comment");
      var peg$e10 = peg$otherExpectation(",");
      var peg$e11 = peg$otherExpectation("@");
      var peg$e12 = peg$otherExpectation("variable token");
      var peg$e13 = peg$otherExpectation("+/-");
      var peg$e14 = peg$otherExpectation("=");
      var peg$f0 = function(a, b) {
        return a.concat(b ? b : []);
      };
      var peg$f1 = function() {
        return [];
      };
      var peg$f2 = function(a, b, c) {
        return a.concat(b, c);
      };
      var peg$f3 = function(op, a, b, c) {
        return { type: "item", op, variable: b, content: a.concat(b, c) };
      };
      var peg$f4 = function(op, a) {
        return { type: "item", op, variable: null, content: a };
      };
      var peg$f5 = function(line, sep, comment262) {
        return { ...line, sep: [].concat(sep), trailingComment: comment262 };
      };
      var peg$f6 = function(line, comment262) {
        return { ...line, trailingComment: comment262 };
      };
      var peg$f7 = function(eq, ann) {
        return {
          type: "line",
          equation: eq,
          annotation: ann,
          sep: null
        };
      };
      var peg$f8 = function(at, ann) {
        return at ? { type: "annotation", marker: at, content: ann } : null;
      };
      var peg$f9 = function(left, eq, right) {
        return { type: "equation", left, right, equals: eq };
      };
      var peg$f10 = function(x) {
        return x;
      };
      var peg$f11 = function(x) {
        return {
          type: "line",
          trailingComment: x
        };
      };
      var peg$f12 = function(v, s32) {
        return [v].concat(s32 ? s32 : []);
      };
      var peg$f13 = function(t) {
        return t;
      };
      var peg$f14 = function(x) {
        return x;
      };
      var peg$f15 = function(x) {
        return x;
      };
      var peg$f16 = function(tok) {
        return options.isSameLineComment(tok);
      };
      var peg$f17 = function(tok) {
        return tok;
      };
      var peg$f18 = function(tok) {
        return options.isOwnLineComment(tok);
      };
      var peg$f19 = function(tok) {
        return tok;
      };
      var peg$f20 = function(tok) {
        return options.isWhitespace(tok);
      };
      var peg$f21 = function(tok) {
        return tok;
      };
      var peg$f22 = function(tok) {
        return options.isSep(tok);
      };
      var peg$f23 = function(tok) {
        return tok;
      };
      var peg$f24 = function(tok) {
        return options.isAt(tok);
      };
      var peg$f25 = function(tok) {
        return tok;
      };
      var peg$f26 = function(tok) {
        return options.isVar(tok);
      };
      var peg$f27 = function(tok) {
        return tok;
      };
      var peg$f28 = function(tok) {
        return options.isOperation(tok);
      };
      var peg$f29 = function(tok) {
        return tok;
      };
      var peg$f30 = function(tok) {
        return options.isEquals(tok);
      };
      var peg$f31 = function(tok) {
        return tok;
      };
      var peg$f32 = function(tok) {
        return options.isSubscript(tok);
      };
      var peg$f33 = function(tok) {
        return tok;
      };
      var peg$currPos = 0;
      var peg$savedPos = 0;
      var peg$posDetailsCache = [{ line: 1, column: 1 }];
      var peg$maxFailPos = 0;
      var peg$maxFailExpected = [];
      var peg$silentFails = 0;
      var peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function offset() {
        return peg$savedPos;
      }
      function range() {
        return {
          source: peg$source,
          start: peg$savedPos,
          end: peg$currPos
        };
      }
      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError(
          [peg$otherExpectation(description)],
          input.substring(peg$savedPos, peg$currPos),
          location2
        );
      }
      function error(message, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location2);
      }
      function peg$literalExpectation(text2, ignoreCase) {
        return { type: "literal", text: text2, ignoreCase };
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts, inverted, ignoreCase };
      }
      function peg$anyExpectation() {
        return { type: "any" };
      }
      function peg$endExpectation() {
        return { type: "end" };
      }
      function peg$otherExpectation(description) {
        return { type: "other", description };
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p;
        if (details) {
          return details;
        } else {
          p = pos - 1;
          while (!peg$posDetailsCache[p]) {
            p--;
          }
          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };
          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos);
        var endPosDetails = peg$computePosDetails(endPos);
        return {
          source: peg$source,
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildSimpleError(message, location2) {
        return new peg$SyntaxError(message, null, null, location2);
      }
      function peg$buildStructuredError(expected2, found, location2) {
        return new peg$SyntaxError(
          peg$SyntaxError.buildMessage(expected2, found),
          expected2,
          found,
          location2
        );
      }
      function peg$parsebody() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsecomment_only_line();
        if (s22 === peg$FAILED) {
          s22 = peg$parseline_with_sep();
          if (s22 === peg$FAILED) {
            s22 = peg$parsepartial_line_with_comment();
          }
        }
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parsecomment_only_line();
          if (s22 === peg$FAILED) {
            s22 = peg$parseline_with_sep();
            if (s22 === peg$FAILED) {
              s22 = peg$parsepartial_line_with_comment();
            }
          }
        }
        s22 = peg$parseline_without_sep();
        if (s22 === peg$FAILED) {
          s22 = peg$parseEOL();
        }
        if (s22 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f0(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseEOL();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f1();
          }
          s0 = s1;
        }
        return s0;
      }
      function peg$parsepartial_item() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parse_();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parse_();
        }
        s22 = [];
        s32 = peg$parsenon_var_token();
        while (s32 !== peg$FAILED) {
          s22.push(s32);
          s32 = peg$parsenon_var_token();
        }
        s32 = [];
        s42 = peg$parse_();
        while (s42 !== peg$FAILED) {
          s32.push(s42);
          s42 = peg$parse_();
        }
        s42 = peg$parsevar();
        if (s42 !== peg$FAILED) {
          s5 = [];
          s6 = peg$parse_();
          while (s6 !== peg$FAILED) {
            s5.push(s6);
            s6 = peg$parse_();
          }
          s6 = [];
          s7 = peg$parsetoken();
          while (s7 !== peg$FAILED) {
            s6.push(s7);
            s7 = peg$parsetoken();
          }
          s7 = [];
          s8 = peg$parse_();
          while (s8 !== peg$FAILED) {
            s7.push(s8);
            s8 = peg$parse_();
          }
          peg$savedPos = s0;
          s0 = peg$f2(s22, s42, s6);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        return s0;
      }
      function peg$parseitem() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8, s9;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parseoperation();
        if (s1 === peg$FAILED) {
          s1 = null;
        }
        s22 = [];
        s32 = peg$parse_();
        while (s32 !== peg$FAILED) {
          s22.push(s32);
          s32 = peg$parse_();
        }
        s32 = [];
        s42 = peg$parsenon_var_token();
        while (s42 !== peg$FAILED) {
          s32.push(s42);
          s42 = peg$parsenon_var_token();
        }
        s42 = [];
        s5 = peg$parse_();
        while (s5 !== peg$FAILED) {
          s42.push(s5);
          s5 = peg$parse_();
        }
        s5 = peg$parsevar();
        if (s5 !== peg$FAILED) {
          s6 = [];
          s7 = peg$parse_();
          while (s7 !== peg$FAILED) {
            s6.push(s7);
            s7 = peg$parse_();
          }
          s7 = [];
          s8 = peg$parsetoken();
          while (s8 !== peg$FAILED) {
            s7.push(s8);
            s8 = peg$parsetoken();
          }
          s8 = [];
          s9 = peg$parse_();
          while (s9 !== peg$FAILED) {
            s8.push(s9);
            s9 = peg$parse_();
          }
          peg$savedPos = s0;
          s0 = peg$f3(s1, s32, s5, s7);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseoperation();
          if (s1 === peg$FAILED) {
            s1 = null;
          }
          s22 = [];
          s32 = peg$parse_();
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parse_();
          }
          s32 = [];
          s42 = peg$parsenon_var_token();
          if (s42 !== peg$FAILED) {
            while (s42 !== peg$FAILED) {
              s32.push(s42);
              s42 = peg$parsenon_var_token();
            }
          } else {
            s32 = peg$FAILED;
          }
          if (s32 !== peg$FAILED) {
            s42 = [];
            s5 = peg$parse_();
            while (s5 !== peg$FAILED) {
              s42.push(s5);
              s5 = peg$parse_();
            }
            peg$savedPos = s0;
            s0 = peg$f4(s1, s32);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e1);
          }
        }
        return s0;
      }
      function peg$parseline_with_sep() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$parseline_without_sep();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsesep();
          if (s22 !== peg$FAILED) {
            s32 = peg$parsetrailing_comment();
            if (s32 === peg$FAILED) {
              s32 = null;
            }
            peg$savedPos = s0;
            s0 = peg$f5(s1, s22, s32);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsepartial_line_with_comment() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parseline_without_sep();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsetrailing_comment();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f6(s1, s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseline_without_sep() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        if (input.length > peg$currPos) {
          s22 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s22 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        peg$silentFails--;
        if (s22 !== peg$FAILED) {
          peg$currPos = s1;
          s1 = void 0;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parseequation();
          s32 = peg$parseannotation();
          if (s32 === peg$FAILED) {
            s32 = null;
          }
          peg$savedPos = s0;
          s0 = peg$f7(s22, s32);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseannotation() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$parseat();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$parsenon_sep_token();
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parsenon_sep_token();
          }
          peg$savedPos = s0;
          s0 = peg$f8(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseequation() {
        var s0, s1, s22, s32, s42;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parseitem();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parseitem();
        }
        s22 = peg$parseequals();
        if (s22 === peg$FAILED) {
          s22 = null;
        }
        s32 = [];
        s42 = peg$parsetoken();
        if (s42 === peg$FAILED) {
          s42 = peg$parseoperation();
        }
        while (s42 !== peg$FAILED) {
          s32.push(s42);
          s42 = peg$parsetoken();
          if (s42 === peg$FAILED) {
            s42 = peg$parseoperation();
          }
        }
        peg$savedPos = s0;
        s0 = peg$f9(s1, s22, s32);
        peg$silentFails--;
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e3);
        }
        return s0;
      }
      function peg$parsetrailing_comment() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parse_();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parse_();
        }
        s22 = peg$parsesame_line_comment();
        if (s22 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f10(s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e4);
          }
        }
        return s0;
      }
      function peg$parsecomment_only_line() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parse_();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parse_();
        }
        s22 = peg$parseown_line_comment();
        if (s22 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f11(s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e5);
          }
        }
        return s0;
      }
      function peg$parsevar() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$parsevar_token();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$parse_();
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parse_();
          }
          s32 = peg$parsesubscript();
          if (s32 === peg$FAILED) {
            s32 = null;
          }
          peg$savedPos = s0;
          s0 = peg$f12(s1, s32);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsenon_var_token() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        s22 = peg$parsevar();
        peg$silentFails--;
        if (s22 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parsetoken();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f13(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e6);
          }
        }
        return s0;
      }
      function peg$parsenon_sep_token() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        s22 = peg$parsesep();
        if (s22 === peg$FAILED) {
          s22 = peg$parsetrailing_comment();
          if (s22 === peg$FAILED) {
            s22 = peg$parseown_line_comment();
          }
        }
        peg$silentFails--;
        if (s22 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s22 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f14(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsetoken() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        s22 = peg$parsesep();
        if (s22 === peg$FAILED) {
          s22 = peg$parseat();
          if (s22 === peg$FAILED) {
            s22 = peg$parseoperation();
            if (s22 === peg$FAILED) {
              s22 = peg$parseequals();
              if (s22 === peg$FAILED) {
                s22 = peg$parsetrailing_comment();
                if (s22 === peg$FAILED) {
                  s22 = peg$parseown_line_comment();
                }
              }
            }
          }
        }
        peg$silentFails--;
        if (s22 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s22 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f15(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e7);
          }
        }
        return s0;
      }
      function peg$parsesame_line_comment() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f16(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f17(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e8);
          }
        }
        return s0;
      }
      function peg$parseown_line_comment() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f18(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f19(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e9);
          }
        }
        return s0;
      }
      function peg$parse_() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f20(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f21(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsesep() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f22(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f23(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e10);
          }
        }
        return s0;
      }
      function peg$parseat() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f24(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f25(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e11);
          }
        }
        return s0;
      }
      function peg$parsevar_token() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f26(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f27(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e12);
          }
        }
        return s0;
      }
      function peg$parseoperation() {
        var s0, s1, s22, s32, s42;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parse_();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parse_();
        }
        if (input.length > peg$currPos) {
          s22 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s22 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        if (s22 !== peg$FAILED) {
          s32 = [];
          s42 = peg$parse_();
          while (s42 !== peg$FAILED) {
            s32.push(s42);
            s42 = peg$parse_();
          }
          peg$savedPos = peg$currPos;
          s42 = peg$f28(s22);
          if (s42) {
            s42 = void 0;
          } else {
            s42 = peg$FAILED;
          }
          if (s42 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f29(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e13);
          }
        }
        return s0;
      }
      function peg$parseequals() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f30(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f31(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e14);
          }
        }
        return s0;
      }
      function peg$parsesubscript() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f32(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f33(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseEOL() {
        var s0, s1;
        s0 = peg$currPos;
        peg$silentFails++;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        peg$silentFails--;
        if (s1 === peg$FAILED) {
          s0 = void 0;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      if (!options.isWhitespace) {
        try {
          Object.assign(options, {
            isSep: (node) => node.type === "string" && node.content === ",",
            isVar: (node) => node.type === "string" && node.content.match(/[a-zA-Z]/),
            isOperation: (node) => node.type === "string" && node.content.match(/[+-]/),
            isEquals: (node) => node.type === "string" && node.content === "=",
            isAt: (node) => node.type === "string" && node.content === "@",
            isSubscript: (node) => node.content === "_",
            isWhitespace: (node) => node.type === "whitespace",
            isSameLineComment: (node) => node.type === "comment" && node.sameline,
            isOwnLineComment: (node) => node.type === "comment" && !node.sameline
          });
        } catch (e) {
          console.warn("Error when initializing parser", e);
        }
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(
          peg$maxFailExpected,
          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
      }
    }
    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }()
);
var tex_glue_default = (
  // Generated by Peggy 2.0.1.
  //
  // https://peggyjs.org/
  function() {
    "use strict";
    function peg$subclass(child, parent) {
      function C() {
        this.constructor = child;
      }
      C.prototype = parent.prototype;
      child.prototype = new C();
    }
    function peg$SyntaxError(message, expected, found, location) {
      var self = Error.call(this, message);
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(self, peg$SyntaxError.prototype);
      }
      self.expected = expected;
      self.found = found;
      self.location = location;
      self.name = "SyntaxError";
      return self;
    }
    peg$subclass(peg$SyntaxError, Error);
    function peg$padEnd(str, targetLength, padString) {
      padString = padString || " ";
      if (str.length > targetLength) {
        return str;
      }
      targetLength -= str.length;
      padString += padString.repeat(targetLength);
      return str + padString.slice(0, targetLength);
    }
    peg$SyntaxError.prototype.format = function(sources) {
      var str = "Error: " + this.message;
      if (this.location) {
        var src = null;
        var k;
        for (k = 0; k < sources.length; k++) {
          if (sources[k].source === this.location.source) {
            src = sources[k].text.split(/\r\n|\n|\r/g);
            break;
          }
        }
        var s32 = this.location.start;
        var loc = this.location.source + ":" + s32.line + ":" + s32.column;
        if (src) {
          var e = this.location.end;
          var filler = peg$padEnd("", s32.line.toString().length, " ");
          var line = src[s32.line - 1];
          var last = s32.line === e.line ? e.column : line.length + 1;
          var hatLen = last - s32.column || 1;
          str += "\n --> " + loc + "\n" + filler + " |\n" + s32.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s32.column - 1, " ") + peg$padEnd("", hatLen, "^");
        } else {
          str += "\n at " + loc;
        }
      }
      return str;
    };
    peg$SyntaxError.buildMessage = function(expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        class: function(expectation) {
          var escapedParts = expectation.parts.map(function(part) {
            return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
          });
          return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
        },
        any: function() {
          return "any character";
        },
        end: function() {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        }
      };
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s32) {
        return s32.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function classEscape(s32) {
        return s32.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = expected2.map(describeExpectation);
        var i, j;
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {};
      var peg$source = options.grammarSource;
      var peg$startRuleFunctions = { root: peg$parseroot };
      var peg$startRuleFunction = peg$parseroot;
      var peg$c0 = "plus";
      var peg$c1 = "minus";
      var peg$c2 = "pt";
      var peg$c3 = "mm";
      var peg$c4 = "cm";
      var peg$c5 = "in";
      var peg$c6 = "ex";
      var peg$c7 = "em";
      var peg$c8 = "bp";
      var peg$c9 = "pc";
      var peg$c10 = "dd";
      var peg$c11 = "cc";
      var peg$c12 = "nd";
      var peg$c13 = "nc";
      var peg$c14 = "sp";
      var peg$c15 = "filll";
      var peg$c16 = "fill";
      var peg$c17 = "fil";
      var peg$c18 = ".";
      var peg$c19 = "+";
      var peg$c20 = "-";
      var peg$r0 = /^[0-9]/;
      var peg$e0 = peg$anyExpectation();
      var peg$e1 = peg$literalExpectation("plus", false);
      var peg$e2 = peg$literalExpectation("minus", false);
      var peg$e3 = peg$literalExpectation("pt", false);
      var peg$e4 = peg$literalExpectation("mm", false);
      var peg$e5 = peg$literalExpectation("cm", false);
      var peg$e6 = peg$literalExpectation("in", false);
      var peg$e7 = peg$literalExpectation("ex", false);
      var peg$e8 = peg$literalExpectation("em", false);
      var peg$e9 = peg$literalExpectation("bp", false);
      var peg$e10 = peg$literalExpectation("pc", false);
      var peg$e11 = peg$literalExpectation("dd", false);
      var peg$e12 = peg$literalExpectation("cc", false);
      var peg$e13 = peg$literalExpectation("nd", false);
      var peg$e14 = peg$literalExpectation("nc", false);
      var peg$e15 = peg$literalExpectation("sp", false);
      var peg$e16 = peg$literalExpectation("filll", false);
      var peg$e17 = peg$literalExpectation("fill", false);
      var peg$e18 = peg$literalExpectation("fil", false);
      var peg$e19 = peg$otherExpectation("number");
      var peg$e20 = peg$classExpectation([["0", "9"]], false, false);
      var peg$e21 = peg$literalExpectation(".", false);
      var peg$e22 = peg$literalExpectation("+", false);
      var peg$e23 = peg$literalExpectation("-", false);
      var peg$f0 = function(b, st, sh) {
        return {
          type: "glue",
          fixed: b,
          stretchable: st,
          shrinkable: sh,
          position: location()
        };
      };
      var peg$f1 = function(glue) {
        return glue;
      };
      var peg$f2 = function(n, u) {
        return { type: "dim", value: n, unit: u };
      };
      var peg$f3 = function(n, u) {
        return { type: "dim", value: n, unit: u };
      };
      var peg$f4 = function(n, u) {
        return { type: "dim", value: n, unit: u };
      };
      var peg$f5 = function(n) {
        return parseFloat(n);
      };
      var peg$currPos = 0;
      var peg$savedPos = 0;
      var peg$posDetailsCache = [{ line: 1, column: 1 }];
      var peg$maxFailPos = 0;
      var peg$maxFailExpected = [];
      var peg$silentFails = 0;
      var peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function offset() {
        return peg$savedPos;
      }
      function range() {
        return {
          source: peg$source,
          start: peg$savedPos,
          end: peg$currPos
        };
      }
      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError(
          [peg$otherExpectation(description)],
          input.substring(peg$savedPos, peg$currPos),
          location2
        );
      }
      function error(message, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location2);
      }
      function peg$literalExpectation(text2, ignoreCase) {
        return { type: "literal", text: text2, ignoreCase };
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts, inverted, ignoreCase };
      }
      function peg$anyExpectation() {
        return { type: "any" };
      }
      function peg$endExpectation() {
        return { type: "end" };
      }
      function peg$otherExpectation(description) {
        return { type: "other", description };
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p;
        if (details) {
          return details;
        } else {
          p = pos - 1;
          while (!peg$posDetailsCache[p]) {
            p--;
          }
          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };
          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos);
        var endPosDetails = peg$computePosDetails(endPos);
        return {
          source: peg$source,
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildSimpleError(message, location2) {
        return new peg$SyntaxError(message, null, null, location2);
      }
      function peg$buildStructuredError(expected2, found, location2) {
        return new peg$SyntaxError(
          peg$SyntaxError.buildMessage(expected2, found),
          expected2,
          found,
          location2
        );
      }
      function peg$parseroot() {
        var s0, s1, s22, s32, s42;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$parsebase();
        if (s22 !== peg$FAILED) {
          s32 = peg$parsestretchable();
          if (s32 === peg$FAILED) {
            s32 = null;
          }
          s42 = peg$parseshrinkable();
          if (s42 === peg$FAILED) {
            s42 = null;
          }
          peg$savedPos = s1;
          s1 = peg$f0(s22, s32, s42);
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s22 = [];
          if (input.length > peg$currPos) {
            s32 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s32 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            if (input.length > peg$currPos) {
              s32 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s32 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
          }
          peg$savedPos = s0;
          s0 = peg$f1(s1);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsebase() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parsenumber();
        if (s1 !== peg$FAILED) {
          s22 = peg$parseunit();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f2(s1, s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsestretchable() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 4) === peg$c0) {
          s1 = peg$c0;
          peg$currPos += 4;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e1);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parsenumber();
          if (s22 !== peg$FAILED) {
            s32 = peg$parserubber_unit();
            if (s32 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f3(s22, s32);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseshrinkable() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 5) === peg$c1) {
          s1 = peg$c1;
          peg$currPos += 5;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parsenumber();
          if (s22 !== peg$FAILED) {
            s32 = peg$parserubber_unit();
            if (s32 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f4(s22, s32);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseunit() {
        var s0;
        if (input.substr(peg$currPos, 2) === peg$c2) {
          s0 = peg$c2;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s0 === peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c3) {
            s0 = peg$c3;
            peg$currPos += 2;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e4);
            }
          }
          if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c4) {
              s0 = peg$c4;
              peg$currPos += 2;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e5);
              }
            }
            if (s0 === peg$FAILED) {
              if (input.substr(peg$currPos, 2) === peg$c5) {
                s0 = peg$c5;
                peg$currPos += 2;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e6);
                }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 2) === peg$c6) {
                  s0 = peg$c6;
                  peg$currPos += 2;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e7);
                  }
                }
                if (s0 === peg$FAILED) {
                  if (input.substr(peg$currPos, 2) === peg$c7) {
                    s0 = peg$c7;
                    peg$currPos += 2;
                  } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e8);
                    }
                  }
                  if (s0 === peg$FAILED) {
                    if (input.substr(peg$currPos, 2) === peg$c8) {
                      s0 = peg$c8;
                      peg$currPos += 2;
                    } else {
                      s0 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e9);
                      }
                    }
                    if (s0 === peg$FAILED) {
                      if (input.substr(peg$currPos, 2) === peg$c9) {
                        s0 = peg$c9;
                        peg$currPos += 2;
                      } else {
                        s0 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$e10);
                        }
                      }
                      if (s0 === peg$FAILED) {
                        if (input.substr(peg$currPos, 2) === peg$c10) {
                          s0 = peg$c10;
                          peg$currPos += 2;
                        } else {
                          s0 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$e11);
                          }
                        }
                        if (s0 === peg$FAILED) {
                          if (input.substr(peg$currPos, 2) === peg$c11) {
                            s0 = peg$c11;
                            peg$currPos += 2;
                          } else {
                            s0 = peg$FAILED;
                            if (peg$silentFails === 0) {
                              peg$fail(peg$e12);
                            }
                          }
                          if (s0 === peg$FAILED) {
                            if (input.substr(peg$currPos, 2) === peg$c12) {
                              s0 = peg$c12;
                              peg$currPos += 2;
                            } else {
                              s0 = peg$FAILED;
                              if (peg$silentFails === 0) {
                                peg$fail(peg$e13);
                              }
                            }
                            if (s0 === peg$FAILED) {
                              if (input.substr(peg$currPos, 2) === peg$c13) {
                                s0 = peg$c13;
                                peg$currPos += 2;
                              } else {
                                s0 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                  peg$fail(peg$e14);
                                }
                              }
                              if (s0 === peg$FAILED) {
                                if (input.substr(peg$currPos, 2) === peg$c14) {
                                  s0 = peg$c14;
                                  peg$currPos += 2;
                                } else {
                                  s0 = peg$FAILED;
                                  if (peg$silentFails === 0) {
                                    peg$fail(peg$e15);
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return s0;
      }
      function peg$parserubber_unit() {
        var s0;
        s0 = peg$parseunit();
        if (s0 === peg$FAILED) {
          if (input.substr(peg$currPos, 5) === peg$c15) {
            s0 = peg$c15;
            peg$currPos += 5;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e16);
            }
          }
          if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 4) === peg$c16) {
              s0 = peg$c16;
              peg$currPos += 4;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e17);
              }
            }
            if (s0 === peg$FAILED) {
              if (input.substr(peg$currPos, 3) === peg$c17) {
                s0 = peg$c17;
                peg$currPos += 3;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e18);
                }
              }
            }
          }
        }
        return s0;
      }
      function peg$parsenumber() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$currPos;
        s32 = peg$parsesign();
        if (s32 === peg$FAILED) {
          s32 = null;
        }
        s42 = peg$currPos;
        s5 = [];
        if (peg$r0.test(input.charAt(peg$currPos))) {
          s6 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s6 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e20);
          }
        }
        while (s6 !== peg$FAILED) {
          s5.push(s6);
          if (peg$r0.test(input.charAt(peg$currPos))) {
            s6 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s6 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e20);
            }
          }
        }
        if (input.charCodeAt(peg$currPos) === 46) {
          s6 = peg$c18;
          peg$currPos++;
        } else {
          s6 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e21);
          }
        }
        if (s6 !== peg$FAILED) {
          s7 = [];
          if (peg$r0.test(input.charAt(peg$currPos))) {
            s8 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s8 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e20);
            }
          }
          if (s8 !== peg$FAILED) {
            while (s8 !== peg$FAILED) {
              s7.push(s8);
              if (peg$r0.test(input.charAt(peg$currPos))) {
                s8 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s8 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e20);
                }
              }
            }
          } else {
            s7 = peg$FAILED;
          }
          if (s7 !== peg$FAILED) {
            s5 = [s5, s6, s7];
            s42 = s5;
          } else {
            peg$currPos = s42;
            s42 = peg$FAILED;
          }
        } else {
          peg$currPos = s42;
          s42 = peg$FAILED;
        }
        if (s42 === peg$FAILED) {
          s42 = [];
          if (peg$r0.test(input.charAt(peg$currPos))) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e20);
            }
          }
          if (s5 !== peg$FAILED) {
            while (s5 !== peg$FAILED) {
              s42.push(s5);
              if (peg$r0.test(input.charAt(peg$currPos))) {
                s5 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e20);
                }
              }
            }
          } else {
            s42 = peg$FAILED;
          }
        }
        if (s42 !== peg$FAILED) {
          s32 = [s32, s42];
          s22 = s32;
        } else {
          peg$currPos = s22;
          s22 = peg$FAILED;
        }
        if (s22 !== peg$FAILED) {
          s1 = input.substring(s1, peg$currPos);
        } else {
          s1 = s22;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f5(s1);
        }
        s0 = s1;
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e19);
          }
        }
        return s0;
      }
      function peg$parsesign() {
        var s0;
        if (input.charCodeAt(peg$currPos) === 43) {
          s0 = peg$c19;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e22);
          }
        }
        if (s0 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 45) {
            s0 = peg$c20;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e23);
            }
          }
        }
        return s0;
      }
      function peg$parseEOL() {
        var s0, s1;
        s0 = peg$currPos;
        peg$silentFails++;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        peg$silentFails--;
        if (s1 === peg$FAILED) {
          s0 = void 0;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(
          peg$maxFailExpected,
          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
      }
    }
    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }()
);
var tikz_default = (
  // Generated by Peggy 2.0.1.
  //
  // https://peggyjs.org/
  function() {
    "use strict";
    function peg$subclass(child, parent) {
      function C() {
        this.constructor = child;
      }
      C.prototype = parent.prototype;
      child.prototype = new C();
    }
    function peg$SyntaxError(message, expected, found, location) {
      var self = Error.call(this, message);
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(self, peg$SyntaxError.prototype);
      }
      self.expected = expected;
      self.found = found;
      self.location = location;
      self.name = "SyntaxError";
      return self;
    }
    peg$subclass(peg$SyntaxError, Error);
    function peg$padEnd(str, targetLength, padString) {
      padString = padString || " ";
      if (str.length > targetLength) {
        return str;
      }
      targetLength -= str.length;
      padString += padString.repeat(targetLength);
      return str + padString.slice(0, targetLength);
    }
    peg$SyntaxError.prototype.format = function(sources) {
      var str = "Error: " + this.message;
      if (this.location) {
        var src = null;
        var k;
        for (k = 0; k < sources.length; k++) {
          if (sources[k].source === this.location.source) {
            src = sources[k].text.split(/\r\n|\n|\r/g);
            break;
          }
        }
        var s32 = this.location.start;
        var loc = this.location.source + ":" + s32.line + ":" + s32.column;
        if (src) {
          var e = this.location.end;
          var filler = peg$padEnd("", s32.line.toString().length, " ");
          var line = src[s32.line - 1];
          var last = s32.line === e.line ? e.column : line.length + 1;
          var hatLen = last - s32.column || 1;
          str += "\n --> " + loc + "\n" + filler + " |\n" + s32.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s32.column - 1, " ") + peg$padEnd("", hatLen, "^");
        } else {
          str += "\n at " + loc;
        }
      }
      return str;
    };
    peg$SyntaxError.buildMessage = function(expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        class: function(expectation) {
          var escapedParts = expectation.parts.map(function(part) {
            return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
          });
          return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
        },
        any: function() {
          return "any character";
        },
        end: function() {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        }
      };
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s32) {
        return s32.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function classEscape(s32) {
        return s32.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = expected2.map(describeExpectation);
        var i, j;
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {};
      var peg$source = options.grammarSource;
      var peg$startRuleFunctions = { path_spec: peg$parsepath_spec, foreach_body: peg$parseforeach_body };
      var peg$startRuleFunction = peg$parsepath_spec;
      var peg$e0 = peg$anyExpectation();
      var peg$e1 = peg$otherExpectation("same line comment");
      var peg$e2 = peg$otherExpectation("own line comment");
      var peg$e3 = peg$otherExpectation("comment");
      var peg$e4 = peg$otherExpectation("floating comment");
      var peg$e5 = peg$otherExpectation("operation");
      var peg$e6 = peg$otherExpectation("=");
      var peg$f0 = function(v) {
        return v;
      };
      var peg$f1 = function(ops) {
        return { type: "path_spec", content: ops };
      };
      var peg$f2 = function(c1, op, comment262) {
        return { op, comment: comment262 };
      };
      var peg$f3 = function(c1, ops, c2, body) {
        const comments = [c1, ...ops.map((x) => x.comment), c2].filter(
          (x) => x
        );
        const attribute = ops.map((x) => x.op.content.content).join(" ");
        return {
          type: "animation",
          comments,
          attribute,
          content: body.content
        };
      };
      var peg$f4 = function(start, b) {
        return { ...b, start, type: "foreach" };
      };
      var peg$f5 = function(c1, variables, options2, c2, c3, list, c4, command) {
        const comments = [c1, c2, c3, c4].filter((x) => x);
        return {
          type: "foreach_body",
          variables,
          options: options2 && options2.content,
          list,
          command,
          comments
        };
      };
      var peg$f6 = function(c1, options2, c2, body) {
        const comments = [c1, c2].filter((x) => x);
        return {
          type: "svg_operation",
          options: options2 && options2.content,
          content: body,
          comments
        };
      };
      var peg$f7 = function(c1, c2, coord, c3, c4, x) {
        return { coord: x, comment: c4 };
      };
      var peg$f8 = function(c1, c2, coord, c3, a, c5) {
        const comments = [c1, c2, c3, a && a.comment, c5].filter((x) => x);
        return {
          type: "curve_to",
          controls: a ? [coord, a.coord] : [coord],
          comments
        };
      };
      var peg$f9 = function() {
        return { type: "line_to", command: "|-" };
      };
      var peg$f10 = function() {
        return { type: "line_to", command: "-|" };
      };
      var peg$f11 = function() {
        return { type: "line_to", command: "--" };
      };
      var peg$f12 = function(prefix, content) {
        return { type: "coordinate", content, prefix };
      };
      var peg$f13 = function(content) {
        return { type: "square_brace_group", content };
      };
      var peg$f14 = function(v) {
        return { type: "unknown", content: v };
      };
      var peg$f15 = function(tok) {
        return options.isSameLineComment(tok);
      };
      var peg$f16 = function(tok) {
        return tok;
      };
      var peg$f17 = function(tok) {
        return options.isOwnLineComment(tok);
      };
      var peg$f18 = function(tok) {
        return tok;
      };
      var peg$f19 = function(tok) {
        return options.isComment(tok);
      };
      var peg$f20 = function(tok) {
        return tok;
      };
      var peg$f21 = function(tok) {
        return options.isWhitespace(tok);
      };
      var peg$f22 = function(tok) {
        return tok;
      };
      var peg$f23 = function(c) {
        return c;
      };
      var peg$f24 = function(tok) {
        return options.isOperation(tok);
      };
      var peg$f25 = function(tok) {
        return { type: "operation", content: tok };
      };
      var peg$f26 = function(tok) {
        return options.isChar(tok, "=");
      };
      var peg$f27 = function(tok) {
        return tok;
      };
      var peg$f28 = function(tok) {
        return options.isChar(tok, "[");
      };
      var peg$f29 = function(tok) {
        return tok;
      };
      var peg$f30 = function(tok) {
        return options.isChar(tok, "]");
      };
      var peg$f31 = function(tok) {
        return tok;
      };
      var peg$f32 = function(tok) {
        return options.isChar(tok, "(");
      };
      var peg$f33 = function(tok) {
        return tok;
      };
      var peg$f34 = function(tok) {
        return options.isChar(tok, ")");
      };
      var peg$f35 = function(tok) {
        return tok;
      };
      var peg$f36 = function(tok) {
        return options.isChar(tok, "+");
      };
      var peg$f37 = function(tok) {
        return tok;
      };
      var peg$f38 = function(tok) {
        return options.isChar(tok, "-");
      };
      var peg$f39 = function(tok) {
        return tok;
      };
      var peg$f40 = function(tok) {
        return options.isChar(tok, "|");
      };
      var peg$f41 = function(tok) {
        return tok;
      };
      var peg$f42 = function(tok) {
        return options.isChar(tok, ".");
      };
      var peg$f43 = function(tok) {
        return tok;
      };
      var peg$f44 = function(tok) {
        return options.isChar(tok, "controls");
      };
      var peg$f45 = function(tok) {
        return tok;
      };
      var peg$f46 = function(tok) {
        return options.isChar(tok, "and");
      };
      var peg$f47 = function(tok) {
        return tok;
      };
      var peg$f48 = function(tok) {
        return options.isChar(tok, "svg");
      };
      var peg$f49 = function(tok) {
        return tok;
      };
      var peg$f50 = function(tok) {
        return options.isGroup(tok);
      };
      var peg$f51 = function(tok) {
        return tok;
      };
      var peg$f52 = function(tok) {
        return options.isAnyMacro(tok);
      };
      var peg$f53 = function(tok) {
        return tok;
      };
      var peg$f54 = function(tok) {
        return options.isChar(tok, "foreach");
      };
      var peg$f55 = function(tok) {
        return tok;
      };
      var peg$f56 = function(tok) {
        return options.isMacro(tok, "foreach");
      };
      var peg$f57 = function(tok) {
        return tok;
      };
      var peg$f58 = function(tok) {
        return options.isChar(tok, "in");
      };
      var peg$f59 = function(tok) {
        return tok;
      };
      var peg$f60 = function(tok) {
        return options.isChar(tok, ":");
      };
      var peg$f61 = function(tok) {
        return tok;
      };
      var peg$currPos = 0;
      var peg$savedPos = 0;
      var peg$posDetailsCache = [{ line: 1, column: 1 }];
      var peg$maxFailPos = 0;
      var peg$maxFailExpected = [];
      var peg$silentFails = 0;
      var peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function offset() {
        return peg$savedPos;
      }
      function range() {
        return {
          source: peg$source,
          start: peg$savedPos,
          end: peg$currPos
        };
      }
      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError(
          [peg$otherExpectation(description)],
          input.substring(peg$savedPos, peg$currPos),
          location2
        );
      }
      function error(message, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location2);
      }
      function peg$literalExpectation(text2, ignoreCase) {
        return { type: "literal", text: text2, ignoreCase };
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts, inverted, ignoreCase };
      }
      function peg$anyExpectation() {
        return { type: "any" };
      }
      function peg$endExpectation() {
        return { type: "end" };
      }
      function peg$otherExpectation(description) {
        return { type: "other", description };
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p;
        if (details) {
          return details;
        } else {
          p = pos - 1;
          while (!peg$posDetailsCache[p]) {
            p--;
          }
          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };
          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos);
        var endPosDetails = peg$computePosDetails(endPos);
        return {
          source: peg$source,
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildSimpleError(message, location2) {
        return new peg$SyntaxError(message, null, null, location2);
      }
      function peg$buildStructuredError(expected2, found, location2) {
        return new peg$SyntaxError(
          peg$SyntaxError.buildMessage(expected2, found),
          expected2,
          found,
          location2
        );
      }
      function peg$parsepath_spec() {
        var s0, s1, s22, s32, s42, s5;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$currPos;
        s32 = peg$parsesquare_brace_group();
        if (s32 === peg$FAILED) {
          s32 = peg$parsecoordinate();
          if (s32 === peg$FAILED) {
            s32 = peg$parsecurve_to();
            if (s32 === peg$FAILED) {
              s32 = peg$parseline_to();
              if (s32 === peg$FAILED) {
                s32 = peg$parsesvg();
                if (s32 === peg$FAILED) {
                  s32 = peg$parseforeach();
                  if (s32 === peg$FAILED) {
                    s32 = peg$parseoperation();
                    if (s32 === peg$FAILED) {
                      s32 = peg$parsecomment();
                      if (s32 === peg$FAILED) {
                        s32 = peg$parseanimation();
                        if (s32 === peg$FAILED) {
                          s32 = peg$parseunknown();
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (s32 !== peg$FAILED) {
          s42 = [];
          s5 = peg$parse_();
          while (s5 !== peg$FAILED) {
            s42.push(s5);
            s5 = peg$parse_();
          }
          peg$savedPos = s22;
          s22 = peg$f0(s32);
        } else {
          peg$currPos = s22;
          s22 = peg$FAILED;
        }
        if (s22 !== peg$FAILED) {
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            s22 = peg$currPos;
            s32 = peg$parsesquare_brace_group();
            if (s32 === peg$FAILED) {
              s32 = peg$parsecoordinate();
              if (s32 === peg$FAILED) {
                s32 = peg$parsecurve_to();
                if (s32 === peg$FAILED) {
                  s32 = peg$parseline_to();
                  if (s32 === peg$FAILED) {
                    s32 = peg$parsesvg();
                    if (s32 === peg$FAILED) {
                      s32 = peg$parseforeach();
                      if (s32 === peg$FAILED) {
                        s32 = peg$parseoperation();
                        if (s32 === peg$FAILED) {
                          s32 = peg$parsecomment();
                          if (s32 === peg$FAILED) {
                            s32 = peg$parseanimation();
                            if (s32 === peg$FAILED) {
                              s32 = peg$parseunknown();
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            if (s32 !== peg$FAILED) {
              s42 = [];
              s5 = peg$parse_();
              while (s5 !== peg$FAILED) {
                s42.push(s5);
                s5 = peg$parse_();
              }
              peg$savedPos = s22;
              s22 = peg$f0(s32);
            } else {
              peg$currPos = s22;
              s22 = peg$FAILED;
            }
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f1(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parseanimation() {
        var s0, s1, s22, s32, s42, s5, s6;
        s0 = peg$currPos;
        s1 = peg$parsecolon();
        if (s1 !== peg$FAILED) {
          s22 = peg$parse_comment_();
          s32 = [];
          s42 = peg$currPos;
          s5 = peg$parseoperation();
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_comment_();
            peg$savedPos = s42;
            s42 = peg$f2(s22, s5, s6);
          } else {
            peg$currPos = s42;
            s42 = peg$FAILED;
          }
          if (s42 !== peg$FAILED) {
            while (s42 !== peg$FAILED) {
              s32.push(s42);
              s42 = peg$currPos;
              s5 = peg$parseoperation();
              if (s5 !== peg$FAILED) {
                s6 = peg$parse_comment_();
                peg$savedPos = s42;
                s42 = peg$f2(s22, s5, s6);
              } else {
                peg$currPos = s42;
                s42 = peg$FAILED;
              }
            }
          } else {
            s32 = peg$FAILED;
          }
          if (s32 !== peg$FAILED) {
            s42 = peg$parseequals();
            if (s42 !== peg$FAILED) {
              s5 = peg$parse_comment_();
              s6 = peg$parsegroup();
              if (s6 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f3(s22, s32, s5, s6);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseforeach() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parseforeach_keyword();
        if (s1 === peg$FAILED) {
          s1 = peg$parseforeach_macro();
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parseforeach_body();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f4(s1, s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseforeach_body() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8, s9;
        s0 = peg$currPos;
        s1 = peg$parse_comment_();
        s22 = peg$currPos;
        s32 = [];
        s42 = peg$currPos;
        s5 = peg$currPos;
        peg$silentFails++;
        s6 = peg$parsein_keyword();
        if (s6 === peg$FAILED) {
          s6 = peg$parsesquare_brace_group();
        }
        peg$silentFails--;
        if (s6 === peg$FAILED) {
          s5 = void 0;
        } else {
          peg$currPos = s5;
          s5 = peg$FAILED;
        }
        if (s5 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s6 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s6 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s6 !== peg$FAILED) {
            s5 = [s5, s6];
            s42 = s5;
          } else {
            peg$currPos = s42;
            s42 = peg$FAILED;
          }
        } else {
          peg$currPos = s42;
          s42 = peg$FAILED;
        }
        while (s42 !== peg$FAILED) {
          s32.push(s42);
          s42 = peg$currPos;
          s5 = peg$currPos;
          peg$silentFails++;
          s6 = peg$parsein_keyword();
          if (s6 === peg$FAILED) {
            s6 = peg$parsesquare_brace_group();
          }
          peg$silentFails--;
          if (s6 === peg$FAILED) {
            s5 = void 0;
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
          if (s5 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s6 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            if (s6 !== peg$FAILED) {
              s5 = [s5, s6];
              s42 = s5;
            } else {
              peg$currPos = s42;
              s42 = peg$FAILED;
            }
          } else {
            peg$currPos = s42;
            s42 = peg$FAILED;
          }
        }
        s22 = input.substring(s22, peg$currPos);
        s32 = peg$parsesquare_brace_group();
        if (s32 === peg$FAILED) {
          s32 = null;
        }
        s42 = peg$parse_comment_();
        s5 = peg$parsein_keyword();
        if (s5 !== peg$FAILED) {
          s6 = peg$parse_comment_();
          s7 = peg$parsegroup();
          if (s7 === peg$FAILED) {
            s7 = peg$parsemacro();
          }
          if (s7 !== peg$FAILED) {
            s8 = peg$parse_comment_();
            s9 = peg$parseforeach();
            if (s9 === peg$FAILED) {
              s9 = peg$parsegroup();
              if (s9 === peg$FAILED) {
                s9 = peg$parsemacro();
              }
            }
            if (s9 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f5(s1, s22, s32, s42, s6, s7, s8, s9);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsesvg() {
        var s0, s1, s22, s32, s42, s5;
        s0 = peg$currPos;
        s1 = peg$parsesvg_keyword();
        if (s1 !== peg$FAILED) {
          s22 = peg$parse_comment_();
          s32 = peg$parsesquare_brace_group();
          if (s32 === peg$FAILED) {
            s32 = null;
          }
          s42 = peg$parse_comment_();
          s5 = peg$parsegroup();
          if (s5 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f6(s22, s32, s42, s5);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecurve_to() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8, s9, s10;
        s0 = peg$currPos;
        s1 = peg$parsedotdot();
        if (s1 !== peg$FAILED) {
          s22 = peg$parse_comment_();
          s32 = peg$parsecontrols_keyword();
          if (s32 !== peg$FAILED) {
            s42 = peg$parse_comment_();
            s5 = peg$parsecoordinate();
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_comment_();
              s7 = peg$currPos;
              s8 = peg$parseand_keyword();
              if (s8 !== peg$FAILED) {
                s9 = peg$parse_comment_();
                s10 = peg$parsecoordinate();
                if (s10 !== peg$FAILED) {
                  peg$savedPos = s7;
                  s7 = peg$f7(s22, s42, s5, s6, s9, s10);
                } else {
                  peg$currPos = s7;
                  s7 = peg$FAILED;
                }
              } else {
                peg$currPos = s7;
                s7 = peg$FAILED;
              }
              if (s7 === peg$FAILED) {
                s7 = null;
              }
              s8 = peg$parse_comment_();
              s9 = peg$parsedotdot();
              if (s9 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f8(s22, s42, s5, s6, s7, s8);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseline_to() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parsepipe();
        if (s1 !== peg$FAILED) {
          s22 = peg$parseminus();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f9();
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseminus();
          if (s1 !== peg$FAILED) {
            s22 = peg$parsepipe();
            if (s22 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f10();
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseminus();
            if (s1 !== peg$FAILED) {
              s22 = peg$parseminus();
              if (s22 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f11();
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
        }
        return s0;
      }
      function peg$parsecoordinate() {
        var s0, s1, s22, s32, s42, s5, s6, s7;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$currPos;
        s32 = peg$parseplus();
        if (s32 !== peg$FAILED) {
          s42 = peg$parseplus();
          if (s42 === peg$FAILED) {
            s42 = null;
          }
          s32 = [s32, s42];
          s22 = s32;
        } else {
          peg$currPos = s22;
          s22 = peg$FAILED;
        }
        if (s22 === peg$FAILED) {
          s22 = null;
        }
        s1 = input.substring(s1, peg$currPos);
        s22 = peg$parseopen_paren();
        if (s22 !== peg$FAILED) {
          s32 = peg$currPos;
          s42 = [];
          s5 = peg$currPos;
          s6 = peg$currPos;
          peg$silentFails++;
          s7 = peg$parseclose_paren();
          peg$silentFails--;
          if (s7 === peg$FAILED) {
            s6 = void 0;
          } else {
            peg$currPos = s6;
            s6 = peg$FAILED;
          }
          if (s6 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s7 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s7 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            if (s7 !== peg$FAILED) {
              s6 = [s6, s7];
              s5 = s6;
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
          while (s5 !== peg$FAILED) {
            s42.push(s5);
            s5 = peg$currPos;
            s6 = peg$currPos;
            peg$silentFails++;
            s7 = peg$parseclose_paren();
            peg$silentFails--;
            if (s7 === peg$FAILED) {
              s6 = void 0;
            } else {
              peg$currPos = s6;
              s6 = peg$FAILED;
            }
            if (s6 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s7 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s7 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              if (s7 !== peg$FAILED) {
                s6 = [s6, s7];
                s5 = s6;
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
          }
          s32 = input.substring(s32, peg$currPos);
          s42 = peg$parseclose_paren();
          if (s42 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f12(s1, s32);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsesquare_brace_group() {
        var s0, s1, s22, s32, s42, s5, s6;
        s0 = peg$currPos;
        s1 = peg$parseopen_square_brace();
        if (s1 !== peg$FAILED) {
          s22 = peg$currPos;
          s32 = [];
          s42 = peg$currPos;
          s5 = peg$currPos;
          peg$silentFails++;
          s6 = peg$parseclose_square_brace();
          peg$silentFails--;
          if (s6 === peg$FAILED) {
            s5 = void 0;
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
          if (s5 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s6 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            if (s6 !== peg$FAILED) {
              s5 = [s5, s6];
              s42 = s5;
            } else {
              peg$currPos = s42;
              s42 = peg$FAILED;
            }
          } else {
            peg$currPos = s42;
            s42 = peg$FAILED;
          }
          while (s42 !== peg$FAILED) {
            s32.push(s42);
            s42 = peg$currPos;
            s5 = peg$currPos;
            peg$silentFails++;
            s6 = peg$parseclose_square_brace();
            peg$silentFails--;
            if (s6 === peg$FAILED) {
              s5 = void 0;
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
            if (s5 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s6 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              if (s6 !== peg$FAILED) {
                s5 = [s5, s6];
                s42 = s5;
              } else {
                peg$currPos = s42;
                s42 = peg$FAILED;
              }
            } else {
              peg$currPos = s42;
              s42 = peg$FAILED;
            }
          }
          s22 = input.substring(s22, peg$currPos);
          s32 = peg$parseclose_square_brace();
          if (s32 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f13(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsedotdot() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parsedot();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsedot();
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseunknown() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f14(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parsesame_line_comment() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f15(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f16(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e1);
          }
        }
        return s0;
      }
      function peg$parseown_line_comment() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f17(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f18(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        return s0;
      }
      function peg$parsecomment() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f19(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f20(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        return s0;
      }
      function peg$parse_() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f21(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f22(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parse_comment_() {
        var s0, s1, s22, s32, s42;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parse_();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parse_();
        }
        s22 = peg$parsecomment();
        if (s22 === peg$FAILED) {
          s22 = null;
        }
        s32 = [];
        s42 = peg$parse_();
        while (s42 !== peg$FAILED) {
          s32.push(s42);
          s42 = peg$parse_();
        }
        peg$savedPos = s0;
        s0 = peg$f23(s22);
        peg$silentFails--;
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e4);
        }
        return s0;
      }
      function peg$parseoperation() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f24(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f25(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e5);
          }
        }
        return s0;
      }
      function peg$parseequals() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f26(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f27(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e6);
          }
        }
        return s0;
      }
      function peg$parseopen_square_brace() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f28(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f29(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseclose_square_brace() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f30(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f31(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseopen_paren() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f32(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f33(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseclose_paren() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f34(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f35(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseplus() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f36(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f37(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseminus() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f38(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f39(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsepipe() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f40(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f41(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsedot() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f42(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f43(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecontrols_keyword() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f44(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f45(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseand_keyword() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f46(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f47(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsesvg_keyword() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f48(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f49(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsegroup() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f50(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f51(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsemacro() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f52(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f53(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseforeach_keyword() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f54(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f55(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseforeach_macro() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f56(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f57(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsein_keyword() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f58(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f59(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecolon() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f60(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f61(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseEOL() {
        var s0, s1;
        s0 = peg$currPos;
        peg$silentFails++;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        peg$silentFails--;
        if (s1 === peg$FAILED) {
          s0 = void 0;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      if (!options.isWhitespace) {
        try {
          Object.assign(options, {
            isChar: (node, char) => node.type === "string" && node.content === char,
            isOperation: (node) => node.type === "string" && node.content.match(/[a-zA-Z]/),
            isWhitespace: (node) => node.type === "whitespace" || node.type === "parbreak",
            isSameLineComment: (node) => node.type === "comment" && node.sameline,
            isOwnLineComment: (node) => node.type === "comment" && !node.sameline,
            isComment: (node) => node.type === "comment",
            isGroup: (node) => node.type === "group",
            isMacro: (node, name) => node.type === "macro" && node.content === name,
            isAnyMacro: (node) => node.type === "macro"
          });
        } catch (e) {
          console.warn("Error when initializing parser", e);
        }
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(
          peg$maxFailExpected,
          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
      }
    }
    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }()
);
var linebreak8 = Symbol("linebreak");
(function() {
  if (typeof globalThis === "object")
    return;
  Object.defineProperty(Object.prototype, "__magic__", {
    get: function() {
      return this;
    },
    configurable: true
    // This makes it possible to `delete` the getter later.
  });
  __magic__.globalThis = __magic__;
  delete Object.prototype.__magic__;
})();
var clone = typeof globalThis.structuredClone === "function" ? globalThis.structuredClone : (obj) => JSON.parse(JSON.stringify(obj));
var linebreak9 = Symbol("linebreak");
var ESCAPE8 = "\\";
function _printRaw8(node) {
  if (typeof node === "string") {
    return [node];
  }
  if (Array.isArray(node)) {
    return [].concat(
      ...node.map((n) => _printRaw8(n))
    );
  }
  let argsString, escape;
  switch (node.type) {
    case "root":
      return _printRaw8(node.content);
    case "argument":
      return [node.openMark, ..._printRaw8(node.content), node.closeMark];
    case "comment":
      var suffix = node.suffixParbreak ? "" : linebreak9;
      var leadingWhitespace = "";
      if (node.sameline && node.leadingWhitespace) {
        leadingWhitespace = " ";
      }
      if (node.sameline) {
        return [
          leadingWhitespace,
          "%",
          ..._printRaw8(node.content),
          suffix
        ];
      }
      return [linebreak9, "%", ..._printRaw8(node.content), suffix];
    case "environment":
    case "mathenv":
    case "verbatim":
      var env = _printRaw8(node.env);
      var envStart = [ESCAPE8 + "begin{", ...env, "}"];
      var envEnd = [ESCAPE8 + "end{", ...env, "}"];
      argsString = node.args == null ? [] : _printRaw8(node.args);
      return [
        ...envStart,
        ...argsString,
        ..._printRaw8(node.content),
        ...envEnd
      ];
    case "displaymath":
      return [ESCAPE8 + "[", ..._printRaw8(node.content), ESCAPE8 + "]"];
    case "group":
      return ["{", ..._printRaw8(node.content), "}"];
    case "inlinemath":
      return ["$", ..._printRaw8(node.content), "$"];
    case "macro":
      argsString = node.args == null ? [] : _printRaw8(node.args);
      escape = node.escapeToken == null ? ESCAPE8 : node.escapeToken;
      return [escape, ..._printRaw8(node.content), ...argsString];
    case "parbreak":
      return [linebreak9, linebreak9];
    case "string":
      return [node.content];
    case "verb":
      return [
        ESCAPE8,
        node.env,
        node.escape,
        ..._printRaw8(node.content),
        node.escape
      ];
    case "whitespace":
      return [" "];
    default:
      console.warn(
        "Cannot find render for node ",
        node,
        `(of type ${typeof node})`
      );
      return ["" + node];
  }
}
function printRaw9(node, options) {
  const asArray = options != null ? options.asArray : false;
  const printedTokens = _printRaw8(node);
  if (asArray) {
    return printedTokens;
  }
  return printedTokens.map((x) => x === linebreak9 ? "\n" : x).join("");
}
function createMacroMatcher8(macros15) {
  const macrosHash = Array.isArray(macros15) ? macros15.length > 0 ? typeof macros15[0] === "string" ? Object.fromEntries(
    macros15.map((macro2222) => {
      if (typeof macro2222 !== "string") {
        throw new Error("Wrong branch of map function");
      }
      return [macro2222, {}];
    })
  ) : Object.fromEntries(
    macros15.map((macro2222) => {
      if (typeof macro2222 === "string") {
        throw new Error("Wrong branch of map function");
      }
      if (macro2222.escapeToken != null) {
        return [
          macro2222.content,
          { escapeToken: macro2222.escapeToken }
        ];
      }
      return [macro2222.content, {}];
    })
  ) : {} : macros15;
  return function matchAgainstMacros(node) {
    if (node == null || node.type !== "macro") {
      return false;
    }
    const spec = macrosHash[node.content];
    if (!spec) {
      return false;
    }
    if (typeof spec === "object" && "escapeToken" in spec) {
      return spec.escapeToken == null || spec.escapeToken === node.escapeToken;
    }
    return true;
  };
}
function createEnvironmentMatcher8(macros15) {
  const environmentsHash = Array.isArray(macros15) ? Object.fromEntries(
    macros15.map((str) => {
      return [str, {}];
    })
  ) : macros15;
  return function matchAgainstEnvironments(node) {
    if (!match8.anyEnvironment(node)) {
      return false;
    }
    const envName = printRaw9(node.env);
    const spec = environmentsHash[envName];
    if (!spec) {
      return false;
    }
    return true;
  };
}
var match8 = {
  macro(node, macroName) {
    if (node == null) {
      return false;
    }
    return node.type === "macro" && (macroName == null || node.content === macroName);
  },
  anyMacro(node) {
    return match8.macro(node);
  },
  environment(node, envName) {
    if (node == null) {
      return false;
    }
    return (node.type === "environment" || node.type === "mathenv") && (envName == null || printRaw9(node.env) === envName);
  },
  anyEnvironment(node) {
    return match8.environment(node);
  },
  comment(node) {
    if (node == null) {
      return false;
    }
    return node.type === "comment";
  },
  parbreak(node) {
    if (node == null) {
      return false;
    }
    return node.type === "parbreak";
  },
  whitespace(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace";
  },
  /**
   * Matches whitespace or a comment with leading whitespace.
   */
  whitespaceLike(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace" || node.type === "whitespace" && node.leadingWhitespace === true;
  },
  string(node, value) {
    if (node == null) {
      return false;
    }
    return node.type === "string" && (value == null || node.content === value);
  },
  anyString(node) {
    return match8.string(node);
  },
  group(node) {
    if (node == null) {
      return false;
    }
    return node.type === "group";
  },
  argument(node) {
    if (node == null) {
      return false;
    }
    return node.type === "argument";
  },
  blankArgument(node) {
    if (!match8.argument(node)) {
      return false;
    }
    return node.openMark === "" && node.closeMark === "" && node.content.length === 0;
  },
  math(node) {
    if (node == null) {
      return false;
    }
    return node.type === "displaymath" || node.type === "inlinemath";
  },
  createMacroMatcher: createMacroMatcher8,
  createEnvironmentMatcher: createEnvironmentMatcher8
};
var {
  anyEnvironment: anyEnvironment8,
  anyMacro: anyMacro8,
  anyString: anyString8,
  argument: argument8,
  blankArgument: blankArgument8,
  comment: comment8,
  environment: environment8,
  group: group8,
  macro: macro8,
  math: math8,
  parbreak: parbreak8,
  string: string8,
  whitespace: whitespace8
} = match8;
var linebreak24 = Symbol("linebreak");
var ESCAPE24 = "\\";
function _printRaw24(node) {
  if (typeof node === "string") {
    return [node];
  }
  if (Array.isArray(node)) {
    return [].concat(
      ...node.map((n) => _printRaw24(n))
    );
  }
  let argsString, escape;
  switch (node.type) {
    case "root":
      return _printRaw24(node.content);
    case "argument":
      return [node.openMark, ..._printRaw24(node.content), node.closeMark];
    case "comment":
      var suffix = node.suffixParbreak ? "" : linebreak24;
      var leadingWhitespace = "";
      if (node.sameline && node.leadingWhitespace) {
        leadingWhitespace = " ";
      }
      if (node.sameline) {
        return [
          leadingWhitespace,
          "%",
          ..._printRaw24(node.content),
          suffix
        ];
      }
      return [linebreak24, "%", ..._printRaw24(node.content), suffix];
    case "environment":
    case "mathenv":
    case "verbatim":
      var env = _printRaw24(node.env);
      var envStart = [ESCAPE24 + "begin{", ...env, "}"];
      var envEnd = [ESCAPE24 + "end{", ...env, "}"];
      argsString = node.args == null ? [] : _printRaw24(node.args);
      return [
        ...envStart,
        ...argsString,
        ..._printRaw24(node.content),
        ...envEnd
      ];
    case "displaymath":
      return [ESCAPE24 + "[", ..._printRaw24(node.content), ESCAPE24 + "]"];
    case "group":
      return ["{", ..._printRaw24(node.content), "}"];
    case "inlinemath":
      return ["$", ..._printRaw24(node.content), "$"];
    case "macro":
      argsString = node.args == null ? [] : _printRaw24(node.args);
      escape = node.escapeToken == null ? ESCAPE24 : node.escapeToken;
      return [escape, ..._printRaw24(node.content), ...argsString];
    case "parbreak":
      return [linebreak24, linebreak24];
    case "string":
      return [node.content];
    case "verb":
      return [
        ESCAPE24,
        node.env,
        node.escape,
        ..._printRaw24(node.content),
        node.escape
      ];
    case "whitespace":
      return [" "];
    default:
      console.warn(
        "Cannot find render for node ",
        node,
        `(of type ${typeof node})`
      );
      return ["" + node];
  }
}
function printRaw24(node, options) {
  const asArray = options != null ? options.asArray : false;
  const printedTokens = _printRaw24(node);
  if (asArray) {
    return printedTokens;
  }
  return printedTokens.map((x) => x === linebreak24 ? "\n" : x).join("");
}
function createMacroMatcher24(macros15) {
  const macrosHash = Array.isArray(macros15) ? macros15.length > 0 ? typeof macros15[0] === "string" ? Object.fromEntries(
    macros15.map((macro2222) => {
      if (typeof macro2222 !== "string") {
        throw new Error("Wrong branch of map function");
      }
      return [macro2222, {}];
    })
  ) : Object.fromEntries(
    macros15.map((macro2222) => {
      if (typeof macro2222 === "string") {
        throw new Error("Wrong branch of map function");
      }
      if (macro2222.escapeToken != null) {
        return [
          macro2222.content,
          { escapeToken: macro2222.escapeToken }
        ];
      }
      return [macro2222.content, {}];
    })
  ) : {} : macros15;
  return function matchAgainstMacros(node) {
    if (node == null || node.type !== "macro") {
      return false;
    }
    const spec = macrosHash[node.content];
    if (!spec) {
      return false;
    }
    if (typeof spec === "object" && "escapeToken" in spec) {
      return spec.escapeToken == null || spec.escapeToken === node.escapeToken;
    }
    return true;
  };
}
function createEnvironmentMatcher24(macros15) {
  const environmentsHash = Array.isArray(macros15) ? Object.fromEntries(
    macros15.map((str) => {
      return [str, {}];
    })
  ) : macros15;
  return function matchAgainstEnvironments(node) {
    if (!match24.anyEnvironment(node)) {
      return false;
    }
    const envName = printRaw24(node.env);
    const spec = environmentsHash[envName];
    if (!spec) {
      return false;
    }
    return true;
  };
}
var match24 = {
  macro(node, macroName) {
    if (node == null) {
      return false;
    }
    return node.type === "macro" && (macroName == null || node.content === macroName);
  },
  anyMacro(node) {
    return match24.macro(node);
  },
  environment(node, envName) {
    if (node == null) {
      return false;
    }
    return (node.type === "environment" || node.type === "mathenv") && (envName == null || printRaw24(node.env) === envName);
  },
  anyEnvironment(node) {
    return match24.environment(node);
  },
  comment(node) {
    if (node == null) {
      return false;
    }
    return node.type === "comment";
  },
  parbreak(node) {
    if (node == null) {
      return false;
    }
    return node.type === "parbreak";
  },
  whitespace(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace";
  },
  /**
   * Matches whitespace or a comment with leading whitespace.
   */
  whitespaceLike(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace" || node.type === "whitespace" && node.leadingWhitespace === true;
  },
  string(node, value) {
    if (node == null) {
      return false;
    }
    return node.type === "string" && (value == null || node.content === value);
  },
  anyString(node) {
    return match24.string(node);
  },
  group(node) {
    if (node == null) {
      return false;
    }
    return node.type === "group";
  },
  argument(node) {
    if (node == null) {
      return false;
    }
    return node.type === "argument";
  },
  blankArgument(node) {
    if (!match24.argument(node)) {
      return false;
    }
    return node.openMark === "" && node.closeMark === "" && node.content.length === 0;
  },
  math(node) {
    if (node == null) {
      return false;
    }
    return node.type === "displaymath" || node.type === "inlinemath";
  },
  createMacroMatcher: createMacroMatcher24,
  createEnvironmentMatcher: createEnvironmentMatcher24
};
var {
  anyEnvironment: anyEnvironment24,
  anyMacro: anyMacro24,
  anyString: anyString24,
  argument: argument24,
  blankArgument: blankArgument24,
  comment: comment24,
  environment: environment24,
  group: group24,
  macro: macro24,
  math: math24,
  parbreak: parbreak24,
  string: string24,
  whitespace: whitespace24
} = match24;
var CONTINUE4 = Symbol("continue");
var SKIP4 = Symbol("skip");
var EXIT4 = Symbol("exit");
var linebreak10 = Symbol("linebreak");
var ESCAPE9 = "\\";
function _printRaw9(node) {
  if (typeof node === "string") {
    return [node];
  }
  if (Array.isArray(node)) {
    return [].concat(
      ...node.map((n) => _printRaw9(n))
    );
  }
  let argsString, escape;
  switch (node.type) {
    case "root":
      return _printRaw9(node.content);
    case "argument":
      return [node.openMark, ..._printRaw9(node.content), node.closeMark];
    case "comment":
      var suffix = node.suffixParbreak ? "" : linebreak10;
      var leadingWhitespace = "";
      if (node.sameline && node.leadingWhitespace) {
        leadingWhitespace = " ";
      }
      if (node.sameline) {
        return [
          leadingWhitespace,
          "%",
          ..._printRaw9(node.content),
          suffix
        ];
      }
      return [linebreak10, "%", ..._printRaw9(node.content), suffix];
    case "environment":
    case "mathenv":
    case "verbatim":
      var env = _printRaw9(node.env);
      var envStart = [ESCAPE9 + "begin{", ...env, "}"];
      var envEnd = [ESCAPE9 + "end{", ...env, "}"];
      argsString = node.args == null ? [] : _printRaw9(node.args);
      return [
        ...envStart,
        ...argsString,
        ..._printRaw9(node.content),
        ...envEnd
      ];
    case "displaymath":
      return [ESCAPE9 + "[", ..._printRaw9(node.content), ESCAPE9 + "]"];
    case "group":
      return ["{", ..._printRaw9(node.content), "}"];
    case "inlinemath":
      return ["$", ..._printRaw9(node.content), "$"];
    case "macro":
      argsString = node.args == null ? [] : _printRaw9(node.args);
      escape = node.escapeToken == null ? ESCAPE9 : node.escapeToken;
      return [escape, ..._printRaw9(node.content), ...argsString];
    case "parbreak":
      return [linebreak10, linebreak10];
    case "string":
      return [node.content];
    case "verb":
      return [
        ESCAPE9,
        node.env,
        node.escape,
        ..._printRaw9(node.content),
        node.escape
      ];
    case "whitespace":
      return [" "];
    default:
      console.warn(
        "Cannot find render for node ",
        node,
        `(of type ${typeof node})`
      );
      return ["" + node];
  }
}
function printRaw10(node, options) {
  const asArray = options != null ? options.asArray : false;
  const printedTokens = _printRaw9(node);
  if (asArray) {
    return printedTokens;
  }
  return printedTokens.map((x) => x === linebreak10 ? "\n" : x).join("");
}
function createMacroMatcher9(macros15) {
  const macrosHash = Array.isArray(macros15) ? macros15.length > 0 ? typeof macros15[0] === "string" ? Object.fromEntries(
    macros15.map((macro262) => {
      if (typeof macro262 !== "string") {
        throw new Error("Wrong branch of map function");
      }
      return [macro262, {}];
    })
  ) : Object.fromEntries(
    macros15.map((macro262) => {
      if (typeof macro262 === "string") {
        throw new Error("Wrong branch of map function");
      }
      if (macro262.escapeToken != null) {
        return [
          macro262.content,
          { escapeToken: macro262.escapeToken }
        ];
      }
      return [macro262.content, {}];
    })
  ) : {} : macros15;
  return function matchAgainstMacros(node) {
    if (node == null || node.type !== "macro") {
      return false;
    }
    const spec = macrosHash[node.content];
    if (!spec) {
      return false;
    }
    if (typeof spec === "object" && "escapeToken" in spec) {
      return spec.escapeToken == null || spec.escapeToken === node.escapeToken;
    }
    return true;
  };
}
function createEnvironmentMatcher9(macros15) {
  const environmentsHash = Array.isArray(macros15) ? Object.fromEntries(
    macros15.map((str) => {
      return [str, {}];
    })
  ) : macros15;
  return function matchAgainstEnvironments(node) {
    if (!match9.anyEnvironment(node)) {
      return false;
    }
    const envName = printRaw10(node.env);
    const spec = environmentsHash[envName];
    if (!spec) {
      return false;
    }
    return true;
  };
}
var match9 = {
  macro(node, macroName) {
    if (node == null) {
      return false;
    }
    return node.type === "macro" && (macroName == null || node.content === macroName);
  },
  anyMacro(node) {
    return match9.macro(node);
  },
  environment(node, envName) {
    if (node == null) {
      return false;
    }
    return (node.type === "environment" || node.type === "mathenv") && (envName == null || printRaw10(node.env) === envName);
  },
  anyEnvironment(node) {
    return match9.environment(node);
  },
  comment(node) {
    if (node == null) {
      return false;
    }
    return node.type === "comment";
  },
  parbreak(node) {
    if (node == null) {
      return false;
    }
    return node.type === "parbreak";
  },
  whitespace(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace";
  },
  /**
   * Matches whitespace or a comment with leading whitespace.
   */
  whitespaceLike(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace" || node.type === "whitespace" && node.leadingWhitespace === true;
  },
  string(node, value) {
    if (node == null) {
      return false;
    }
    return node.type === "string" && (value == null || node.content === value);
  },
  anyString(node) {
    return match9.string(node);
  },
  group(node) {
    if (node == null) {
      return false;
    }
    return node.type === "group";
  },
  argument(node) {
    if (node == null) {
      return false;
    }
    return node.type === "argument";
  },
  blankArgument(node) {
    if (!match9.argument(node)) {
      return false;
    }
    return node.openMark === "" && node.closeMark === "" && node.content.length === 0;
  },
  math(node) {
    if (node == null) {
      return false;
    }
    return node.type === "displaymath" || node.type === "inlinemath";
  },
  createMacroMatcher: createMacroMatcher9,
  createEnvironmentMatcher: createEnvironmentMatcher9
};
var {
  anyEnvironment: anyEnvironment9,
  anyMacro: anyMacro9,
  anyString: anyString9,
  argument: argument9,
  blankArgument: blankArgument9,
  comment: comment9,
  environment: environment9,
  group: group9,
  macro: macro9,
  math: math9,
  parbreak: parbreak9,
  string: string9,
  whitespace: whitespace9
} = match9;
var CONTINUE5 = Symbol("continue");
var SKIP5 = Symbol("skip");
var EXIT5 = Symbol("exit");
var linebreak11 = Symbol("linebreak");
var ESCAPE10 = "\\";
function _printRaw10(node) {
  if (typeof node === "string") {
    return [node];
  }
  if (Array.isArray(node)) {
    return [].concat(
      ...node.map((n) => _printRaw10(n))
    );
  }
  let argsString, escape;
  switch (node.type) {
    case "root":
      return _printRaw10(node.content);
    case "argument":
      return [node.openMark, ..._printRaw10(node.content), node.closeMark];
    case "comment":
      var suffix = node.suffixParbreak ? "" : linebreak11;
      var leadingWhitespace = "";
      if (node.sameline && node.leadingWhitespace) {
        leadingWhitespace = " ";
      }
      if (node.sameline) {
        return [
          leadingWhitespace,
          "%",
          ..._printRaw10(node.content),
          suffix
        ];
      }
      return [linebreak11, "%", ..._printRaw10(node.content), suffix];
    case "environment":
    case "mathenv":
    case "verbatim":
      var env = _printRaw10(node.env);
      var envStart = [ESCAPE10 + "begin{", ...env, "}"];
      var envEnd = [ESCAPE10 + "end{", ...env, "}"];
      argsString = node.args == null ? [] : _printRaw10(node.args);
      return [
        ...envStart,
        ...argsString,
        ..._printRaw10(node.content),
        ...envEnd
      ];
    case "displaymath":
      return [ESCAPE10 + "[", ..._printRaw10(node.content), ESCAPE10 + "]"];
    case "group":
      return ["{", ..._printRaw10(node.content), "}"];
    case "inlinemath":
      return ["$", ..._printRaw10(node.content), "$"];
    case "macro":
      argsString = node.args == null ? [] : _printRaw10(node.args);
      escape = node.escapeToken == null ? ESCAPE10 : node.escapeToken;
      return [escape, ..._printRaw10(node.content), ...argsString];
    case "parbreak":
      return [linebreak11, linebreak11];
    case "string":
      return [node.content];
    case "verb":
      return [
        ESCAPE10,
        node.env,
        node.escape,
        ..._printRaw10(node.content),
        node.escape
      ];
    case "whitespace":
      return [" "];
    default:
      console.warn(
        "Cannot find render for node ",
        node,
        `(of type ${typeof node})`
      );
      return ["" + node];
  }
}
function printRaw11(node, options) {
  const asArray = options != null ? options.asArray : false;
  const printedTokens = _printRaw10(node);
  if (asArray) {
    return printedTokens;
  }
  return printedTokens.map((x) => x === linebreak11 ? "\n" : x).join("");
}
function createMacroMatcher10(macros15) {
  const macrosHash = Array.isArray(macros15) ? macros15.length > 0 ? typeof macros15[0] === "string" ? Object.fromEntries(
    macros15.map((macro2222) => {
      if (typeof macro2222 !== "string") {
        throw new Error("Wrong branch of map function");
      }
      return [macro2222, {}];
    })
  ) : Object.fromEntries(
    macros15.map((macro2222) => {
      if (typeof macro2222 === "string") {
        throw new Error("Wrong branch of map function");
      }
      if (macro2222.escapeToken != null) {
        return [
          macro2222.content,
          { escapeToken: macro2222.escapeToken }
        ];
      }
      return [macro2222.content, {}];
    })
  ) : {} : macros15;
  return function matchAgainstMacros(node) {
    if (node == null || node.type !== "macro") {
      return false;
    }
    const spec = macrosHash[node.content];
    if (!spec) {
      return false;
    }
    if (typeof spec === "object" && "escapeToken" in spec) {
      return spec.escapeToken == null || spec.escapeToken === node.escapeToken;
    }
    return true;
  };
}
function createEnvironmentMatcher10(macros15) {
  const environmentsHash = Array.isArray(macros15) ? Object.fromEntries(
    macros15.map((str) => {
      return [str, {}];
    })
  ) : macros15;
  return function matchAgainstEnvironments(node) {
    if (!match10.anyEnvironment(node)) {
      return false;
    }
    const envName = printRaw11(node.env);
    const spec = environmentsHash[envName];
    if (!spec) {
      return false;
    }
    return true;
  };
}
var match10 = {
  macro(node, macroName) {
    if (node == null) {
      return false;
    }
    return node.type === "macro" && (macroName == null || node.content === macroName);
  },
  anyMacro(node) {
    return match10.macro(node);
  },
  environment(node, envName) {
    if (node == null) {
      return false;
    }
    return (node.type === "environment" || node.type === "mathenv") && (envName == null || printRaw11(node.env) === envName);
  },
  anyEnvironment(node) {
    return match10.environment(node);
  },
  comment(node) {
    if (node == null) {
      return false;
    }
    return node.type === "comment";
  },
  parbreak(node) {
    if (node == null) {
      return false;
    }
    return node.type === "parbreak";
  },
  whitespace(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace";
  },
  /**
   * Matches whitespace or a comment with leading whitespace.
   */
  whitespaceLike(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace" || node.type === "whitespace" && node.leadingWhitespace === true;
  },
  string(node, value) {
    if (node == null) {
      return false;
    }
    return node.type === "string" && (value == null || node.content === value);
  },
  anyString(node) {
    return match10.string(node);
  },
  group(node) {
    if (node == null) {
      return false;
    }
    return node.type === "group";
  },
  argument(node) {
    if (node == null) {
      return false;
    }
    return node.type === "argument";
  },
  blankArgument(node) {
    if (!match10.argument(node)) {
      return false;
    }
    return node.openMark === "" && node.closeMark === "" && node.content.length === 0;
  },
  math(node) {
    if (node == null) {
      return false;
    }
    return node.type === "displaymath" || node.type === "inlinemath";
  },
  createMacroMatcher: createMacroMatcher10,
  createEnvironmentMatcher: createEnvironmentMatcher10
};
var {
  anyEnvironment: anyEnvironment10,
  anyMacro: anyMacro10,
  anyString: anyString10,
  argument: argument10,
  blankArgument: blankArgument10,
  comment: comment10,
  environment: environment10,
  group: group10,
  macro: macro10,
  math: math10,
  parbreak: parbreak10,
  string: string10,
  whitespace: whitespace10
} = match10;
var latex_default2 = (
  // Generated by Peggy 2.0.1.
  //
  // https://peggyjs.org/
  function() {
    "use strict";
    function peg$subclass(child, parent) {
      function C() {
        this.constructor = child;
      }
      C.prototype = parent.prototype;
      child.prototype = new C();
    }
    function peg$SyntaxError(message, expected, found, location) {
      var self = Error.call(this, message);
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(self, peg$SyntaxError.prototype);
      }
      self.expected = expected;
      self.found = found;
      self.location = location;
      self.name = "SyntaxError";
      return self;
    }
    peg$subclass(peg$SyntaxError, Error);
    function peg$padEnd(str, targetLength, padString) {
      padString = padString || " ";
      if (str.length > targetLength) {
        return str;
      }
      targetLength -= str.length;
      padString += padString.repeat(targetLength);
      return str + padString.slice(0, targetLength);
    }
    peg$SyntaxError.prototype.format = function(sources) {
      var str = "Error: " + this.message;
      if (this.location) {
        var src = null;
        var k;
        for (k = 0; k < sources.length; k++) {
          if (sources[k].source === this.location.source) {
            src = sources[k].text.split(/\r\n|\n|\r/g);
            break;
          }
        }
        var s22 = this.location.start;
        var loc = this.location.source + ":" + s22.line + ":" + s22.column;
        if (src) {
          var e = this.location.end;
          var filler = peg$padEnd("", s22.line.toString().length, " ");
          var line = src[s22.line - 1];
          var last = s22.line === e.line ? e.column : line.length + 1;
          var hatLen = last - s22.column || 1;
          str += "\n --> " + loc + "\n" + filler + " |\n" + s22.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s22.column - 1, " ") + peg$padEnd("", hatLen, "^");
        } else {
          str += "\n at " + loc;
        }
      }
      return str;
    };
    peg$SyntaxError.buildMessage = function(expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        class: function(expectation) {
          var escapedParts = expectation.parts.map(function(part) {
            return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
          });
          return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
        },
        any: function() {
          return "any character";
        },
        end: function() {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        }
      };
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s22) {
        return s22.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function classEscape(s22) {
        return s22.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = expected2.map(describeExpectation);
        var i, j;
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {};
      var peg$source = options.grammarSource;
      var peg$startRuleFunctions = { document: peg$parsedocument, math: peg$parsemath };
      var peg$startRuleFunction = peg$parsedocument;
      var peg$c0 = "%";
      var peg$c1 = ".";
      var peg$c2 = "verb*";
      var peg$c3 = "verb";
      var peg$c4 = "verbatim*";
      var peg$c5 = "verbatim";
      var peg$c6 = "filecontents*";
      var peg$c7 = "filecontents";
      var peg$c8 = "comment";
      var peg$c9 = "lstlisting";
      var peg$c10 = "[";
      var peg$c11 = "]";
      var peg$c12 = "(";
      var peg$c13 = ")";
      var peg$c14 = "begin";
      var peg$c15 = "end";
      var peg$c16 = "equation*";
      var peg$c17 = "equation";
      var peg$c18 = "align*";
      var peg$c19 = "align";
      var peg$c20 = "alignat*";
      var peg$c21 = "alignat";
      var peg$c22 = "gather*";
      var peg$c23 = "gather";
      var peg$c24 = "multline*";
      var peg$c25 = "multline";
      var peg$c26 = "flalign*";
      var peg$c27 = "flalign";
      var peg$c28 = "split";
      var peg$c29 = "math";
      var peg$c30 = "displaymath";
      var peg$c31 = "\\";
      var peg$c32 = "{";
      var peg$c33 = "}";
      var peg$c34 = "$";
      var peg$c35 = "&";
      var peg$c36 = "\r";
      var peg$c37 = "\n";
      var peg$c38 = "\r\n";
      var peg$c39 = "#";
      var peg$c40 = "^";
      var peg$c41 = "_";
      var peg$c42 = "\0";
      var peg$r0 = /^[ \t]/;
      var peg$r1 = /^[a-zA-Z]/;
      var peg$r2 = /^[0-9]/;
      var peg$r3 = /^[.,;:\-*\/()!?=+<>[\]`'"~]/;
      var peg$e0 = peg$otherExpectation("document");
      var peg$e1 = peg$otherExpectation("math");
      var peg$e2 = peg$otherExpectation("token");
      var peg$e3 = peg$anyExpectation();
      var peg$e4 = peg$otherExpectation("parbreak");
      var peg$e5 = peg$otherExpectation("math token");
      var peg$e6 = peg$otherExpectation("nonchar token");
      var peg$e7 = peg$literalExpectation("%", false);
      var peg$e8 = peg$otherExpectation("whitespace");
      var peg$e9 = peg$otherExpectation("number");
      var peg$e10 = peg$literalExpectation(".", false);
      var peg$e11 = peg$otherExpectation("special macro");
      var peg$e12 = peg$literalExpectation("verb*", false);
      var peg$e13 = peg$literalExpectation("verb", false);
      var peg$e14 = peg$otherExpectation("verbatim environment");
      var peg$e15 = peg$literalExpectation("verbatim*", false);
      var peg$e16 = peg$literalExpectation("verbatim", false);
      var peg$e17 = peg$literalExpectation("filecontents*", false);
      var peg$e18 = peg$literalExpectation("filecontents", false);
      var peg$e19 = peg$literalExpectation("comment", false);
      var peg$e20 = peg$literalExpectation("lstlisting", false);
      var peg$e21 = peg$otherExpectation("macro");
      var peg$e22 = peg$otherExpectation("group");
      var peg$e23 = peg$otherExpectation("environment");
      var peg$e24 = peg$otherExpectation("math environment");
      var peg$e25 = peg$otherExpectation("math group");
      var peg$e26 = peg$literalExpectation("[", false);
      var peg$e27 = peg$literalExpectation("]", false);
      var peg$e28 = peg$literalExpectation("(", false);
      var peg$e29 = peg$literalExpectation(")", false);
      var peg$e30 = peg$literalExpectation("begin", false);
      var peg$e31 = peg$literalExpectation("end", false);
      var peg$e32 = peg$literalExpectation("equation*", false);
      var peg$e33 = peg$literalExpectation("equation", false);
      var peg$e34 = peg$literalExpectation("align*", false);
      var peg$e35 = peg$literalExpectation("align", false);
      var peg$e36 = peg$literalExpectation("alignat*", false);
      var peg$e37 = peg$literalExpectation("alignat", false);
      var peg$e38 = peg$literalExpectation("gather*", false);
      var peg$e39 = peg$literalExpectation("gather", false);
      var peg$e40 = peg$literalExpectation("multline*", false);
      var peg$e41 = peg$literalExpectation("multline", false);
      var peg$e42 = peg$literalExpectation("flalign*", false);
      var peg$e43 = peg$literalExpectation("flalign", false);
      var peg$e44 = peg$literalExpectation("split", false);
      var peg$e45 = peg$literalExpectation("math", false);
      var peg$e46 = peg$literalExpectation("displaymath", false);
      var peg$e47 = peg$otherExpectation("escape");
      var peg$e48 = peg$literalExpectation("\\", false);
      var peg$e49 = peg$literalExpectation("{", false);
      var peg$e50 = peg$literalExpectation("}", false);
      var peg$e51 = peg$literalExpectation("$", false);
      var peg$e52 = peg$literalExpectation("&", false);
      var peg$e53 = peg$otherExpectation("newline");
      var peg$e54 = peg$literalExpectation("\r", false);
      var peg$e55 = peg$literalExpectation("\n", false);
      var peg$e56 = peg$literalExpectation("\r\n", false);
      var peg$e57 = peg$literalExpectation("#", false);
      var peg$e58 = peg$literalExpectation("^", false);
      var peg$e59 = peg$literalExpectation("_", false);
      var peg$e60 = peg$literalExpectation("\0", false);
      var peg$e61 = peg$classExpectation([" ", "	"], false, false);
      var peg$e62 = peg$otherExpectation("letter");
      var peg$e63 = peg$classExpectation([["a", "z"], ["A", "Z"]], false, false);
      var peg$e64 = peg$otherExpectation("digit");
      var peg$e65 = peg$classExpectation([["0", "9"]], false, false);
      var peg$e66 = peg$otherExpectation("punctuation");
      var peg$e67 = peg$classExpectation([".", ",", ";", ":", "-", "*", "/", "(", ")", "!", "?", "=", "+", "<", ">", "[", "]", "`", "'", '"', "~"], false, false);
      var peg$e68 = peg$otherExpectation("full comment");
      var peg$e69 = peg$otherExpectation("comment");
      var peg$f0 = function(content) {
        return createNode("root", { content });
      };
      var peg$f1 = function(t) {
        return t;
      };
      var peg$f2 = function(eq) {
        return createNode("inlinemath", { content: eq });
      };
      var peg$f3 = function(s22) {
        return createNode("string", { content: s22 });
      };
      var peg$f4 = function(s22) {
        return createNode("string", { content: s22 });
      };
      var peg$f5 = function() {
        return createNode("parbreak");
      };
      var peg$f6 = function(x) {
        return x;
      };
      var peg$f7 = function(x) {
        return x;
      };
      var peg$f8 = function() {
        return createNode("macro", { content: "^", escapeToken: "" });
      };
      var peg$f9 = function() {
        return createNode("macro", { content: "_", escapeToken: "" });
      };
      var peg$f10 = function(s22) {
        return createNode("string", { content: s22 });
      };
      var peg$f11 = function() {
        return createNode("whitespace");
      };
      var peg$f12 = function(a, b) {
        return a.join("") + "." + b.join("");
      };
      var peg$f13 = function(b) {
        return "." + b.join("");
      };
      var peg$f14 = function(a) {
        return a.join("") + ".";
      };
      var peg$f15 = function(s22) {
        return createNode("string", { content: s22 });
      };
      var peg$f16 = function(env, e, end) {
        return end == e;
      };
      var peg$f17 = function(env, e, x) {
        return x;
      };
      var peg$f18 = function(env, e, x, end) {
        return end == e;
      };
      var peg$f19 = function(env, e, x) {
        return createNode("verb", {
          env,
          escape: e,
          content: x.join("")
        });
      };
      var peg$f20 = function(x) {
        return x;
      };
      var peg$f21 = function(x) {
        return createNode("displaymath", { content: x });
      };
      var peg$f22 = function(x) {
        return x;
      };
      var peg$f23 = function(x) {
        return createNode("inlinemath", { content: x });
      };
      var peg$f24 = function(x) {
        return x;
      };
      var peg$f25 = function(x) {
        return createNode("displaymath", { content: x });
      };
      var peg$f26 = function(env, end_env) {
        return compare_env({ content: [env] }, end_env);
      };
      var peg$f27 = function(env, x) {
        return x;
      };
      var peg$f28 = function(env, body) {
        return createNode("verbatim", {
          env,
          content: body.join("")
        });
      };
      var peg$f29 = function(n) {
        return n.join("");
      };
      var peg$f30 = function(n) {
        return n;
      };
      var peg$f31 = function(m) {
        return createNode("macro", { content: m });
      };
      var peg$f32 = function(c) {
        return c;
      };
      var peg$f33 = function(x) {
        return createNode("group", { content: x });
      };
      var peg$f34 = function(g) {
        return text().slice(1, -1);
      };
      var peg$f35 = function(env, env_comment, end_env) {
        return compare_env(env, end_env);
      };
      var peg$f36 = function(env, env_comment, x) {
        return x;
      };
      var peg$f37 = function(env, env_comment, body) {
        return createNode("environment", {
          env,
          content: env_comment ? [env_comment, ...body] : body
        });
      };
      var peg$f38 = function(env, env_comment, end_env) {
        return compare_env({ content: [env] }, end_env);
      };
      var peg$f39 = function(env, env_comment, x) {
        return x;
      };
      var peg$f40 = function(env, env_comment, body) {
        return createNode("mathenv", {
          env,
          content: env_comment ? [env_comment, ...body] : body
        });
      };
      var peg$f41 = function(c) {
        return c;
      };
      var peg$f42 = function(x) {
        return createNode("group", { content: x });
      };
      var peg$f43 = function(e) {
        return createNode("string", { content: e });
      };
      var peg$f44 = function() {
        return createNode("string", { content: "\\" });
      };
      var peg$f45 = function(s22) {
        return createNode("string", { content: s22 });
      };
      var peg$f46 = function(s22) {
        return createNode("string", { content: s22 });
      };
      var peg$f47 = function(s22) {
        return createNode("string", { content: s22 });
      };
      var peg$f48 = function(s22) {
        return createNode("string", { content: s22 });
      };
      var peg$f49 = function(s22) {
        return createNode("string", { content: s22 });
      };
      var peg$f50 = function(s22) {
        return createNode("string", { content: s22 });
      };
      var peg$f51 = function(s22) {
        return createNode("string", { content: s22 });
      };
      var peg$f52 = function() {
        return " ";
      };
      var peg$f53 = function(p) {
        return createNode("string", { content: p });
      };
      var peg$f54 = function(leading_sp, comment2222) {
        return createNode("comment", {
          ...comment2222,
          sameline: false,
          leadingWhitespace: leading_sp.length > 0
        });
      };
      var peg$f55 = function(spaces, x) {
        return createNode("comment", {
          ...x,
          sameline: true,
          leadingWhitespace: spaces.length > 0
        });
      };
      var peg$f56 = function(c) {
        return c;
      };
      var peg$f57 = function(c) {
        return { content: c.join(""), suffixParbreak: true };
      };
      var peg$f58 = function(c) {
        return c;
      };
      var peg$f59 = function(c) {
        return { content: c.join("") };
      };
      var peg$f60 = function() {
        var loc = location();
        return loc.start.column === 1;
      };
      var peg$currPos = 0;
      var peg$savedPos = 0;
      var peg$posDetailsCache = [{ line: 1, column: 1 }];
      var peg$maxFailPos = 0;
      var peg$maxFailExpected = [];
      var peg$silentFails = 0;
      var peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function offset() {
        return peg$savedPos;
      }
      function range() {
        return {
          source: peg$source,
          start: peg$savedPos,
          end: peg$currPos
        };
      }
      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError(
          [peg$otherExpectation(description)],
          input.substring(peg$savedPos, peg$currPos),
          location2
        );
      }
      function error(message, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location2);
      }
      function peg$literalExpectation(text2, ignoreCase) {
        return { type: "literal", text: text2, ignoreCase };
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts, inverted, ignoreCase };
      }
      function peg$anyExpectation() {
        return { type: "any" };
      }
      function peg$endExpectation() {
        return { type: "end" };
      }
      function peg$otherExpectation(description) {
        return { type: "other", description };
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p;
        if (details) {
          return details;
        } else {
          p = pos - 1;
          while (!peg$posDetailsCache[p]) {
            p--;
          }
          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };
          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos);
        var endPosDetails = peg$computePosDetails(endPos);
        return {
          source: peg$source,
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildSimpleError(message, location2) {
        return new peg$SyntaxError(message, null, null, location2);
      }
      function peg$buildStructuredError(expected2, found, location2) {
        return new peg$SyntaxError(
          peg$SyntaxError.buildMessage(expected2, found),
          expected2,
          found,
          location2
        );
      }
      function peg$parsedocument() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsetoken();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parsetoken();
        }
        peg$savedPos = s0;
        s1 = peg$f0(s1);
        s0 = s1;
        peg$silentFails--;
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e0);
        }
        return s0;
      }
      function peg$parsemath() {
        var s0, s1;
        peg$silentFails++;
        s0 = [];
        s1 = peg$parsemath_token();
        while (s1 !== peg$FAILED) {
          s0.push(s1);
          s1 = peg$parsemath_token();
        }
        peg$silentFails--;
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e1);
        }
        return s0;
      }
      function peg$parsetoken() {
        var s0, s1, s22, s32, s42, s5;
        peg$silentFails++;
        s0 = peg$parsespecial_macro();
        if (s0 === peg$FAILED) {
          s0 = peg$parsemacro();
          if (s0 === peg$FAILED) {
            s0 = peg$parsefull_comment();
            if (s0 === peg$FAILED) {
              s0 = peg$parsegroup();
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parsemath_shift();
                if (s1 !== peg$FAILED) {
                  s22 = [];
                  s32 = peg$currPos;
                  s42 = peg$currPos;
                  peg$silentFails++;
                  s5 = peg$parsemath_shift();
                  peg$silentFails--;
                  if (s5 === peg$FAILED) {
                    s42 = void 0;
                  } else {
                    peg$currPos = s42;
                    s42 = peg$FAILED;
                  }
                  if (s42 !== peg$FAILED) {
                    s5 = peg$parsemath_token();
                    if (s5 !== peg$FAILED) {
                      peg$savedPos = s32;
                      s32 = peg$f1(s5);
                    } else {
                      peg$currPos = s32;
                      s32 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s32;
                    s32 = peg$FAILED;
                  }
                  if (s32 !== peg$FAILED) {
                    while (s32 !== peg$FAILED) {
                      s22.push(s32);
                      s32 = peg$currPos;
                      s42 = peg$currPos;
                      peg$silentFails++;
                      s5 = peg$parsemath_shift();
                      peg$silentFails--;
                      if (s5 === peg$FAILED) {
                        s42 = void 0;
                      } else {
                        peg$currPos = s42;
                        s42 = peg$FAILED;
                      }
                      if (s42 !== peg$FAILED) {
                        s5 = peg$parsemath_token();
                        if (s5 !== peg$FAILED) {
                          peg$savedPos = s32;
                          s32 = peg$f1(s5);
                        } else {
                          peg$currPos = s32;
                          s32 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s32;
                        s32 = peg$FAILED;
                      }
                    }
                  } else {
                    s22 = peg$FAILED;
                  }
                  if (s22 !== peg$FAILED) {
                    s32 = peg$parsemath_shift();
                    if (s32 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s0 = peg$f2(s22);
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
                if (s0 === peg$FAILED) {
                  s0 = peg$parsealignment_tab();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parseparbreak();
                    if (s0 === peg$FAILED) {
                      s0 = peg$parsemacro_parameter();
                      if (s0 === peg$FAILED) {
                        s0 = peg$parseignore();
                        if (s0 === peg$FAILED) {
                          s0 = peg$parsenumber();
                          if (s0 === peg$FAILED) {
                            s0 = peg$parsewhitespace();
                            if (s0 === peg$FAILED) {
                              s0 = peg$parsepunctuation();
                              if (s0 === peg$FAILED) {
                                s0 = peg$currPos;
                                s1 = peg$currPos;
                                s22 = [];
                                s32 = peg$currPos;
                                s42 = peg$currPos;
                                peg$silentFails++;
                                s5 = peg$parsenonchar_token();
                                peg$silentFails--;
                                if (s5 === peg$FAILED) {
                                  s42 = void 0;
                                } else {
                                  peg$currPos = s42;
                                  s42 = peg$FAILED;
                                }
                                if (s42 !== peg$FAILED) {
                                  if (input.length > peg$currPos) {
                                    s5 = input.charAt(peg$currPos);
                                    peg$currPos++;
                                  } else {
                                    s5 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                      peg$fail(peg$e3);
                                    }
                                  }
                                  if (s5 !== peg$FAILED) {
                                    s42 = [s42, s5];
                                    s32 = s42;
                                  } else {
                                    peg$currPos = s32;
                                    s32 = peg$FAILED;
                                  }
                                } else {
                                  peg$currPos = s32;
                                  s32 = peg$FAILED;
                                }
                                if (s32 !== peg$FAILED) {
                                  while (s32 !== peg$FAILED) {
                                    s22.push(s32);
                                    s32 = peg$currPos;
                                    s42 = peg$currPos;
                                    peg$silentFails++;
                                    s5 = peg$parsenonchar_token();
                                    peg$silentFails--;
                                    if (s5 === peg$FAILED) {
                                      s42 = void 0;
                                    } else {
                                      peg$currPos = s42;
                                      s42 = peg$FAILED;
                                    }
                                    if (s42 !== peg$FAILED) {
                                      if (input.length > peg$currPos) {
                                        s5 = input.charAt(peg$currPos);
                                        peg$currPos++;
                                      } else {
                                        s5 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                          peg$fail(peg$e3);
                                        }
                                      }
                                      if (s5 !== peg$FAILED) {
                                        s42 = [s42, s5];
                                        s32 = s42;
                                      } else {
                                        peg$currPos = s32;
                                        s32 = peg$FAILED;
                                      }
                                    } else {
                                      peg$currPos = s32;
                                      s32 = peg$FAILED;
                                    }
                                  }
                                } else {
                                  s22 = peg$FAILED;
                                }
                                if (s22 !== peg$FAILED) {
                                  s1 = input.substring(s1, peg$currPos);
                                } else {
                                  s1 = s22;
                                }
                                if (s1 !== peg$FAILED) {
                                  peg$savedPos = s0;
                                  s1 = peg$f3(s1);
                                }
                                s0 = s1;
                                if (s0 === peg$FAILED) {
                                  s0 = peg$parsebegin_group();
                                  if (s0 === peg$FAILED) {
                                    s0 = peg$parseend_group();
                                    if (s0 === peg$FAILED) {
                                      s0 = peg$parsemath_shift();
                                      if (s0 === peg$FAILED) {
                                        s0 = peg$currPos;
                                        if (input.length > peg$currPos) {
                                          s1 = input.charAt(peg$currPos);
                                          peg$currPos++;
                                        } else {
                                          s1 = peg$FAILED;
                                          if (peg$silentFails === 0) {
                                            peg$fail(peg$e3);
                                          }
                                        }
                                        if (s1 !== peg$FAILED) {
                                          peg$savedPos = s0;
                                          s1 = peg$f4(s1);
                                        }
                                        s0 = s1;
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        return s0;
      }
      function peg$parseparbreak() {
        var s0, s1, s22, s32, s42, s5, s6, s7;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = [];
        s32 = peg$parsesp();
        while (s32 !== peg$FAILED) {
          s22.push(s32);
          s32 = peg$parsesp();
        }
        s32 = peg$parsenl();
        if (s32 !== peg$FAILED) {
          s42 = [];
          s5 = peg$currPos;
          s6 = [];
          s7 = peg$parsesp();
          while (s7 !== peg$FAILED) {
            s6.push(s7);
            s7 = peg$parsesp();
          }
          s7 = peg$parsenl();
          if (s7 !== peg$FAILED) {
            s6 = [s6, s7];
            s5 = s6;
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
          if (s5 !== peg$FAILED) {
            while (s5 !== peg$FAILED) {
              s42.push(s5);
              s5 = peg$currPos;
              s6 = [];
              s7 = peg$parsesp();
              while (s7 !== peg$FAILED) {
                s6.push(s7);
                s7 = peg$parsesp();
              }
              s7 = peg$parsenl();
              if (s7 !== peg$FAILED) {
                s6 = [s6, s7];
                s5 = s6;
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            }
          } else {
            s42 = peg$FAILED;
          }
          if (s42 !== peg$FAILED) {
            s5 = [];
            s6 = peg$parsesp();
            while (s6 !== peg$FAILED) {
              s5.push(s6);
              s6 = peg$parsesp();
            }
            s6 = peg$currPos;
            peg$silentFails++;
            s7 = peg$parsecomment_start();
            peg$silentFails--;
            if (s7 === peg$FAILED) {
              s6 = void 0;
            } else {
              peg$currPos = s6;
              s6 = peg$FAILED;
            }
            if (s6 !== peg$FAILED) {
              s22 = [s22, s32, s42, s5, s6];
              s1 = s22;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
          s1 = peg$currPos;
          s22 = [];
          s32 = peg$parsesp();
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parsesp();
          }
          s32 = peg$parsenl();
          if (s32 !== peg$FAILED) {
            s42 = [];
            s5 = peg$currPos;
            s6 = [];
            s7 = peg$parsesp();
            while (s7 !== peg$FAILED) {
              s6.push(s7);
              s7 = peg$parsesp();
            }
            s7 = peg$parsenl();
            if (s7 !== peg$FAILED) {
              s6 = [s6, s7];
              s5 = s6;
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
            if (s5 !== peg$FAILED) {
              while (s5 !== peg$FAILED) {
                s42.push(s5);
                s5 = peg$currPos;
                s6 = [];
                s7 = peg$parsesp();
                while (s7 !== peg$FAILED) {
                  s6.push(s7);
                  s7 = peg$parsesp();
                }
                s7 = peg$parsenl();
                if (s7 !== peg$FAILED) {
                  s6 = [s6, s7];
                  s5 = s6;
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              }
            } else {
              s42 = peg$FAILED;
            }
            if (s42 !== peg$FAILED) {
              s22 = [s22, s32, s42];
              s1 = s22;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f5();
        }
        s0 = s1;
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e4);
          }
        }
        return s0;
      }
      function peg$parsemath_token() {
        var s0, s1, s22, s32, s42;
        peg$silentFails++;
        s0 = peg$parsespecial_macro();
        if (s0 === peg$FAILED) {
          s0 = peg$parsemacro();
          if (s0 === peg$FAILED) {
            s0 = peg$parsefull_comment();
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = [];
              s22 = peg$parsewhitespace();
              while (s22 !== peg$FAILED) {
                s1.push(s22);
                s22 = peg$parsewhitespace();
              }
              s22 = peg$parsegroup();
              if (s22 !== peg$FAILED) {
                s32 = [];
                s42 = peg$parsewhitespace();
                while (s42 !== peg$FAILED) {
                  s32.push(s42);
                  s42 = peg$parsewhitespace();
                }
                peg$savedPos = s0;
                s0 = peg$f6(s22);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = [];
                s22 = peg$parsewhitespace();
                while (s22 !== peg$FAILED) {
                  s1.push(s22);
                  s22 = peg$parsewhitespace();
                }
                s22 = peg$parsealignment_tab();
                if (s22 !== peg$FAILED) {
                  s32 = [];
                  s42 = peg$parsewhitespace();
                  while (s42 !== peg$FAILED) {
                    s32.push(s42);
                    s42 = peg$parsewhitespace();
                  }
                  peg$savedPos = s0;
                  s0 = peg$f7(s22);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
                if (s0 === peg$FAILED) {
                  s0 = peg$parsemacro_parameter();
                  if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    s1 = [];
                    s22 = peg$parsewhitespace();
                    while (s22 !== peg$FAILED) {
                      s1.push(s22);
                      s22 = peg$parsewhitespace();
                    }
                    s22 = peg$parsesuperscript();
                    if (s22 !== peg$FAILED) {
                      s32 = [];
                      s42 = peg$parsewhitespace();
                      while (s42 !== peg$FAILED) {
                        s32.push(s42);
                        s42 = peg$parsewhitespace();
                      }
                      peg$savedPos = s0;
                      s0 = peg$f8();
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                    if (s0 === peg$FAILED) {
                      s0 = peg$currPos;
                      s1 = [];
                      s22 = peg$parsewhitespace();
                      while (s22 !== peg$FAILED) {
                        s1.push(s22);
                        s22 = peg$parsewhitespace();
                      }
                      s22 = peg$parsesubscript();
                      if (s22 !== peg$FAILED) {
                        s32 = [];
                        s42 = peg$parsewhitespace();
                        while (s42 !== peg$FAILED) {
                          s32.push(s42);
                          s42 = peg$parsewhitespace();
                        }
                        peg$savedPos = s0;
                        s0 = peg$f9();
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                      if (s0 === peg$FAILED) {
                        s0 = peg$parseignore();
                        if (s0 === peg$FAILED) {
                          s0 = peg$parsewhitespace();
                          if (s0 === peg$FAILED) {
                            s0 = peg$currPos;
                            if (input.length > peg$currPos) {
                              s1 = input.charAt(peg$currPos);
                              peg$currPos++;
                            } else {
                              s1 = peg$FAILED;
                              if (peg$silentFails === 0) {
                                peg$fail(peg$e3);
                              }
                            }
                            if (s1 !== peg$FAILED) {
                              peg$savedPos = s0;
                              s1 = peg$f10(s1);
                            }
                            s0 = s1;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e5);
          }
        }
        return s0;
      }
      function peg$parsenonchar_token() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parseescape();
        if (s0 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 37) {
            s0 = peg$c0;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e7);
            }
          }
          if (s0 === peg$FAILED) {
            s0 = peg$parsebegin_group();
            if (s0 === peg$FAILED) {
              s0 = peg$parseend_group();
              if (s0 === peg$FAILED) {
                s0 = peg$parsemath_shift();
                if (s0 === peg$FAILED) {
                  s0 = peg$parsealignment_tab();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parsenl();
                    if (s0 === peg$FAILED) {
                      s0 = peg$parsemacro_parameter();
                      if (s0 === peg$FAILED) {
                        s0 = peg$parseignore();
                        if (s0 === peg$FAILED) {
                          s0 = peg$parsesp();
                          if (s0 === peg$FAILED) {
                            s0 = peg$parsepunctuation();
                            if (s0 === peg$FAILED) {
                              s0 = peg$parseEOF();
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e6);
          }
        }
        return s0;
      }
      function peg$parsewhitespace() {
        var s0, s1, s22, s32, s42, s5, s6, s7;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$parsenl();
        if (s22 !== peg$FAILED) {
          s32 = [];
          s42 = peg$parsesp();
          while (s42 !== peg$FAILED) {
            s32.push(s42);
            s42 = peg$parsesp();
          }
          s22 = [s22, s32];
          s1 = s22;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
          s1 = peg$currPos;
          s22 = [];
          s32 = peg$parsesp();
          if (s32 !== peg$FAILED) {
            while (s32 !== peg$FAILED) {
              s22.push(s32);
              s32 = peg$parsesp();
            }
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s32 = peg$parsenl();
            if (s32 !== peg$FAILED) {
              s42 = peg$currPos;
              peg$silentFails++;
              s5 = peg$parsecomment_start();
              peg$silentFails--;
              if (s5 === peg$FAILED) {
                s42 = void 0;
              } else {
                peg$currPos = s42;
                s42 = peg$FAILED;
              }
              if (s42 !== peg$FAILED) {
                s5 = [];
                s6 = peg$parsesp();
                while (s6 !== peg$FAILED) {
                  s5.push(s6);
                  s6 = peg$parsesp();
                }
                s6 = peg$currPos;
                peg$silentFails++;
                s7 = peg$parsenl();
                peg$silentFails--;
                if (s7 === peg$FAILED) {
                  s6 = void 0;
                } else {
                  peg$currPos = s6;
                  s6 = peg$FAILED;
                }
                if (s6 !== peg$FAILED) {
                  s22 = [s22, s32, s42, s5, s6];
                  s1 = s22;
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 === peg$FAILED) {
            s1 = [];
            s22 = peg$parsesp();
            if (s22 !== peg$FAILED) {
              while (s22 !== peg$FAILED) {
                s1.push(s22);
                s22 = peg$parsesp();
              }
            } else {
              s1 = peg$FAILED;
            }
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f11();
        }
        s0 = s1;
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e8);
          }
        }
        return s0;
      }
      function peg$parsenumber() {
        var s0, s1, s22, s32, s42, s5;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = [];
        s32 = peg$parsenum();
        if (s32 !== peg$FAILED) {
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parsenum();
          }
        } else {
          s22 = peg$FAILED;
        }
        if (s22 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 46) {
            s32 = peg$c1;
            peg$currPos++;
          } else {
            s32 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e10);
            }
          }
          if (s32 !== peg$FAILED) {
            s42 = [];
            s5 = peg$parsenum();
            if (s5 !== peg$FAILED) {
              while (s5 !== peg$FAILED) {
                s42.push(s5);
                s5 = peg$parsenum();
              }
            } else {
              s42 = peg$FAILED;
            }
            if (s42 !== peg$FAILED) {
              peg$savedPos = s1;
              s1 = peg$f12(s22, s42);
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
          s1 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 46) {
            s22 = peg$c1;
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e10);
            }
          }
          if (s22 !== peg$FAILED) {
            s32 = [];
            s42 = peg$parsenum();
            if (s42 !== peg$FAILED) {
              while (s42 !== peg$FAILED) {
                s32.push(s42);
                s42 = peg$parsenum();
              }
            } else {
              s32 = peg$FAILED;
            }
            if (s32 !== peg$FAILED) {
              peg$savedPos = s1;
              s1 = peg$f13(s32);
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 === peg$FAILED) {
            s1 = peg$currPos;
            s22 = [];
            s32 = peg$parsenum();
            if (s32 !== peg$FAILED) {
              while (s32 !== peg$FAILED) {
                s22.push(s32);
                s32 = peg$parsenum();
              }
            } else {
              s22 = peg$FAILED;
            }
            if (s22 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 46) {
                s32 = peg$c1;
                peg$currPos++;
              } else {
                s32 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e10);
                }
              }
              if (s32 !== peg$FAILED) {
                peg$savedPos = s1;
                s1 = peg$f14(s22);
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f15(s1);
        }
        s0 = s1;
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e9);
          }
        }
        return s0;
      }
      function peg$parsespecial_macro() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8, s9;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parseescape();
        if (s1 !== peg$FAILED) {
          if (input.substr(peg$currPos, 5) === peg$c2) {
            s22 = peg$c2;
            peg$currPos += 5;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e12);
            }
          }
          if (s22 === peg$FAILED) {
            if (input.substr(peg$currPos, 4) === peg$c3) {
              s22 = peg$c3;
              peg$currPos += 4;
            } else {
              s22 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e13);
              }
            }
          }
          if (s22 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s32 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s32 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e3);
              }
            }
            if (s32 !== peg$FAILED) {
              s42 = [];
              s5 = peg$currPos;
              s6 = peg$currPos;
              peg$silentFails++;
              s7 = peg$currPos;
              if (input.length > peg$currPos) {
                s8 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s8 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e3);
                }
              }
              if (s8 !== peg$FAILED) {
                peg$savedPos = peg$currPos;
                s9 = peg$f16(s22, s32, s8);
                if (s9) {
                  s9 = void 0;
                } else {
                  s9 = peg$FAILED;
                }
                if (s9 !== peg$FAILED) {
                  s8 = [s8, s9];
                  s7 = s8;
                } else {
                  peg$currPos = s7;
                  s7 = peg$FAILED;
                }
              } else {
                peg$currPos = s7;
                s7 = peg$FAILED;
              }
              peg$silentFails--;
              if (s7 === peg$FAILED) {
                s6 = void 0;
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
              if (s6 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                  s7 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e3);
                  }
                }
                if (s7 !== peg$FAILED) {
                  peg$savedPos = s5;
                  s5 = peg$f17(s22, s32, s7);
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
              while (s5 !== peg$FAILED) {
                s42.push(s5);
                s5 = peg$currPos;
                s6 = peg$currPos;
                peg$silentFails++;
                s7 = peg$currPos;
                if (input.length > peg$currPos) {
                  s8 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s8 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e3);
                  }
                }
                if (s8 !== peg$FAILED) {
                  peg$savedPos = peg$currPos;
                  s9 = peg$f16(s22, s32, s8);
                  if (s9) {
                    s9 = void 0;
                  } else {
                    s9 = peg$FAILED;
                  }
                  if (s9 !== peg$FAILED) {
                    s8 = [s8, s9];
                    s7 = s8;
                  } else {
                    peg$currPos = s7;
                    s7 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s7;
                  s7 = peg$FAILED;
                }
                peg$silentFails--;
                if (s7 === peg$FAILED) {
                  s6 = void 0;
                } else {
                  peg$currPos = s6;
                  s6 = peg$FAILED;
                }
                if (s6 !== peg$FAILED) {
                  if (input.length > peg$currPos) {
                    s7 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e3);
                    }
                  }
                  if (s7 !== peg$FAILED) {
                    peg$savedPos = s5;
                    s5 = peg$f17(s22, s32, s7);
                  } else {
                    peg$currPos = s5;
                    s5 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              }
              s5 = peg$currPos;
              if (input.length > peg$currPos) {
                s6 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e3);
                }
              }
              if (s6 !== peg$FAILED) {
                peg$savedPos = peg$currPos;
                s7 = peg$f18(s22, s32, s42, s6);
                if (s7) {
                  s7 = void 0;
                } else {
                  s7 = peg$FAILED;
                }
                if (s7 !== peg$FAILED) {
                  s6 = [s6, s7];
                  s5 = s6;
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f19(s22, s32, s42);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$parseverbatim_environment();
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsebegin_display_math();
            if (s1 !== peg$FAILED) {
              s22 = [];
              s32 = peg$currPos;
              s42 = peg$currPos;
              peg$silentFails++;
              s5 = peg$parseend_display_math();
              peg$silentFails--;
              if (s5 === peg$FAILED) {
                s42 = void 0;
              } else {
                peg$currPos = s42;
                s42 = peg$FAILED;
              }
              if (s42 !== peg$FAILED) {
                s5 = peg$parsemath_token();
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s32;
                  s32 = peg$f20(s5);
                } else {
                  peg$currPos = s32;
                  s32 = peg$FAILED;
                }
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
              while (s32 !== peg$FAILED) {
                s22.push(s32);
                s32 = peg$currPos;
                s42 = peg$currPos;
                peg$silentFails++;
                s5 = peg$parseend_display_math();
                peg$silentFails--;
                if (s5 === peg$FAILED) {
                  s42 = void 0;
                } else {
                  peg$currPos = s42;
                  s42 = peg$FAILED;
                }
                if (s42 !== peg$FAILED) {
                  s5 = peg$parsemath_token();
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s32;
                    s32 = peg$f20(s5);
                  } else {
                    peg$currPos = s32;
                    s32 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s32;
                  s32 = peg$FAILED;
                }
              }
              s32 = peg$parseend_display_math();
              if (s32 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f21(s22);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parsebegin_inline_math();
              if (s1 !== peg$FAILED) {
                s22 = [];
                s32 = peg$currPos;
                s42 = peg$currPos;
                peg$silentFails++;
                s5 = peg$parseend_inline_math();
                peg$silentFails--;
                if (s5 === peg$FAILED) {
                  s42 = void 0;
                } else {
                  peg$currPos = s42;
                  s42 = peg$FAILED;
                }
                if (s42 !== peg$FAILED) {
                  s5 = peg$parsemath_token();
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s32;
                    s32 = peg$f22(s5);
                  } else {
                    peg$currPos = s32;
                    s32 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s32;
                  s32 = peg$FAILED;
                }
                while (s32 !== peg$FAILED) {
                  s22.push(s32);
                  s32 = peg$currPos;
                  s42 = peg$currPos;
                  peg$silentFails++;
                  s5 = peg$parseend_inline_math();
                  peg$silentFails--;
                  if (s5 === peg$FAILED) {
                    s42 = void 0;
                  } else {
                    peg$currPos = s42;
                    s42 = peg$FAILED;
                  }
                  if (s42 !== peg$FAILED) {
                    s5 = peg$parsemath_token();
                    if (s5 !== peg$FAILED) {
                      peg$savedPos = s32;
                      s32 = peg$f22(s5);
                    } else {
                      peg$currPos = s32;
                      s32 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s32;
                    s32 = peg$FAILED;
                  }
                }
                s32 = peg$parseend_inline_math();
                if (s32 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s0 = peg$f23(s22);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parsemath_shift();
                if (s1 !== peg$FAILED) {
                  s22 = peg$parsemath_shift();
                  if (s22 !== peg$FAILED) {
                    s32 = [];
                    s42 = peg$currPos;
                    s5 = peg$currPos;
                    peg$silentFails++;
                    s6 = peg$currPos;
                    s7 = peg$parsemath_shift();
                    if (s7 !== peg$FAILED) {
                      s8 = peg$parsemath_shift();
                      if (s8 !== peg$FAILED) {
                        s7 = [s7, s8];
                        s6 = s7;
                      } else {
                        peg$currPos = s6;
                        s6 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s6;
                      s6 = peg$FAILED;
                    }
                    peg$silentFails--;
                    if (s6 === peg$FAILED) {
                      s5 = void 0;
                    } else {
                      peg$currPos = s5;
                      s5 = peg$FAILED;
                    }
                    if (s5 !== peg$FAILED) {
                      s6 = peg$parsemath_token();
                      if (s6 !== peg$FAILED) {
                        peg$savedPos = s42;
                        s42 = peg$f24(s6);
                      } else {
                        peg$currPos = s42;
                        s42 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s42;
                      s42 = peg$FAILED;
                    }
                    while (s42 !== peg$FAILED) {
                      s32.push(s42);
                      s42 = peg$currPos;
                      s5 = peg$currPos;
                      peg$silentFails++;
                      s6 = peg$currPos;
                      s7 = peg$parsemath_shift();
                      if (s7 !== peg$FAILED) {
                        s8 = peg$parsemath_shift();
                        if (s8 !== peg$FAILED) {
                          s7 = [s7, s8];
                          s6 = s7;
                        } else {
                          peg$currPos = s6;
                          s6 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s6;
                        s6 = peg$FAILED;
                      }
                      peg$silentFails--;
                      if (s6 === peg$FAILED) {
                        s5 = void 0;
                      } else {
                        peg$currPos = s5;
                        s5 = peg$FAILED;
                      }
                      if (s5 !== peg$FAILED) {
                        s6 = peg$parsemath_token();
                        if (s6 !== peg$FAILED) {
                          peg$savedPos = s42;
                          s42 = peg$f24(s6);
                        } else {
                          peg$currPos = s42;
                          s42 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s42;
                        s42 = peg$FAILED;
                      }
                    }
                    s42 = peg$parsemath_shift();
                    if (s42 !== peg$FAILED) {
                      s5 = peg$parsemath_shift();
                      if (s5 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s0 = peg$f25(s32);
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
                if (s0 === peg$FAILED) {
                  s0 = peg$parsemath_environment();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parseenvironment();
                  }
                }
              }
            }
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e11);
          }
        }
        return s0;
      }
      function peg$parseverbatim_environment() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8, s9, s10, s11;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parsebegin_env();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsebegin_group();
          if (s22 !== peg$FAILED) {
            s32 = peg$parseverbatim_env_name();
            if (s32 !== peg$FAILED) {
              s42 = peg$parseend_group();
              if (s42 !== peg$FAILED) {
                s5 = [];
                s6 = peg$currPos;
                s7 = peg$currPos;
                peg$silentFails++;
                s8 = peg$currPos;
                s9 = peg$parseend_env();
                if (s9 !== peg$FAILED) {
                  s10 = peg$parsegroup();
                  if (s10 !== peg$FAILED) {
                    peg$savedPos = peg$currPos;
                    s11 = peg$f26(s32, s10);
                    if (s11) {
                      s11 = void 0;
                    } else {
                      s11 = peg$FAILED;
                    }
                    if (s11 !== peg$FAILED) {
                      s9 = [s9, s10, s11];
                      s8 = s9;
                    } else {
                      peg$currPos = s8;
                      s8 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s8;
                    s8 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s8;
                  s8 = peg$FAILED;
                }
                peg$silentFails--;
                if (s8 === peg$FAILED) {
                  s7 = void 0;
                } else {
                  peg$currPos = s7;
                  s7 = peg$FAILED;
                }
                if (s7 !== peg$FAILED) {
                  if (input.length > peg$currPos) {
                    s8 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s8 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e3);
                    }
                  }
                  if (s8 !== peg$FAILED) {
                    peg$savedPos = s6;
                    s6 = peg$f27(s32, s8);
                  } else {
                    peg$currPos = s6;
                    s6 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s6;
                  s6 = peg$FAILED;
                }
                while (s6 !== peg$FAILED) {
                  s5.push(s6);
                  s6 = peg$currPos;
                  s7 = peg$currPos;
                  peg$silentFails++;
                  s8 = peg$currPos;
                  s9 = peg$parseend_env();
                  if (s9 !== peg$FAILED) {
                    s10 = peg$parsegroup();
                    if (s10 !== peg$FAILED) {
                      peg$savedPos = peg$currPos;
                      s11 = peg$f26(s32, s10);
                      if (s11) {
                        s11 = void 0;
                      } else {
                        s11 = peg$FAILED;
                      }
                      if (s11 !== peg$FAILED) {
                        s9 = [s9, s10, s11];
                        s8 = s9;
                      } else {
                        peg$currPos = s8;
                        s8 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s8;
                      s8 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s8;
                    s8 = peg$FAILED;
                  }
                  peg$silentFails--;
                  if (s8 === peg$FAILED) {
                    s7 = void 0;
                  } else {
                    peg$currPos = s7;
                    s7 = peg$FAILED;
                  }
                  if (s7 !== peg$FAILED) {
                    if (input.length > peg$currPos) {
                      s8 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s8 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e3);
                      }
                    }
                    if (s8 !== peg$FAILED) {
                      peg$savedPos = s6;
                      s6 = peg$f27(s32, s8);
                    } else {
                      peg$currPos = s6;
                      s6 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s6;
                    s6 = peg$FAILED;
                  }
                }
                s6 = peg$parseend_env();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parsebegin_group();
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parseverbatim_env_name();
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parseend_group();
                      if (s9 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s0 = peg$f28(s32, s5);
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e14);
          }
        }
        return s0;
      }
      function peg$parseverbatim_env_name() {
        var s0;
        if (input.substr(peg$currPos, 9) === peg$c4) {
          s0 = peg$c4;
          peg$currPos += 9;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e15);
          }
        }
        if (s0 === peg$FAILED) {
          if (input.substr(peg$currPos, 8) === peg$c5) {
            s0 = peg$c5;
            peg$currPos += 8;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e16);
            }
          }
          if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 13) === peg$c6) {
              s0 = peg$c6;
              peg$currPos += 13;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e17);
              }
            }
            if (s0 === peg$FAILED) {
              if (input.substr(peg$currPos, 12) === peg$c7) {
                s0 = peg$c7;
                peg$currPos += 12;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e18);
                }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 7) === peg$c8) {
                  s0 = peg$c8;
                  peg$currPos += 7;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e19);
                  }
                }
                if (s0 === peg$FAILED) {
                  if (input.substr(peg$currPos, 10) === peg$c9) {
                    s0 = peg$c9;
                    peg$currPos += 10;
                  } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e20);
                    }
                  }
                }
              }
            }
          }
        }
        return s0;
      }
      function peg$parsemacro() {
        var s0, s1, s22, s32, s42;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$parseescape();
        if (s22 !== peg$FAILED) {
          s32 = [];
          s42 = peg$parsechar();
          if (s42 !== peg$FAILED) {
            while (s42 !== peg$FAILED) {
              s32.push(s42);
              s42 = peg$parsechar();
            }
          } else {
            s32 = peg$FAILED;
          }
          if (s32 !== peg$FAILED) {
            peg$savedPos = s1;
            s1 = peg$f29(s32);
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
          s1 = peg$currPos;
          s22 = peg$parseescape();
          if (s22 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s32 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s32 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e3);
              }
            }
            if (s32 !== peg$FAILED) {
              peg$savedPos = s1;
              s1 = peg$f30(s32);
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f31(s1);
        }
        s0 = s1;
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e21);
          }
        }
        return s0;
      }
      function peg$parsegroup() {
        var s0, s1, s22, s32, s42, s5;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parsebegin_group();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$currPos;
          s42 = peg$currPos;
          peg$silentFails++;
          s5 = peg$parseend_group();
          peg$silentFails--;
          if (s5 === peg$FAILED) {
            s42 = void 0;
          } else {
            peg$currPos = s42;
            s42 = peg$FAILED;
          }
          if (s42 !== peg$FAILED) {
            s5 = peg$parsetoken();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s32;
              s32 = peg$f32(s5);
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          } else {
            peg$currPos = s32;
            s32 = peg$FAILED;
          }
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$currPos;
            s42 = peg$currPos;
            peg$silentFails++;
            s5 = peg$parseend_group();
            peg$silentFails--;
            if (s5 === peg$FAILED) {
              s42 = void 0;
            } else {
              peg$currPos = s42;
              s42 = peg$FAILED;
            }
            if (s42 !== peg$FAILED) {
              s5 = peg$parsetoken();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s32;
                s32 = peg$f32(s5);
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          }
          s32 = peg$parseend_group();
          if (s32 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f33(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e22);
          }
        }
        return s0;
      }
      function peg$parsegroup_contents_as_string() {
        var s0, s1;
        s0 = peg$currPos;
        s1 = peg$parsegroup();
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f34(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parseenvironment() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8, s9, s10;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parsebegin_env();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsegroup_contents_as_string();
          if (s22 !== peg$FAILED) {
            s32 = peg$parsesameline_comment();
            if (s32 === peg$FAILED) {
              s32 = null;
            }
            s42 = [];
            s5 = peg$currPos;
            s6 = peg$currPos;
            peg$silentFails++;
            s7 = peg$currPos;
            s8 = peg$parseend_env();
            if (s8 !== peg$FAILED) {
              s9 = peg$parsegroup_contents_as_string();
              if (s9 !== peg$FAILED) {
                peg$savedPos = peg$currPos;
                s10 = peg$f35(s22, s32, s9);
                if (s10) {
                  s10 = void 0;
                } else {
                  s10 = peg$FAILED;
                }
                if (s10 !== peg$FAILED) {
                  s8 = [s8, s9, s10];
                  s7 = s8;
                } else {
                  peg$currPos = s7;
                  s7 = peg$FAILED;
                }
              } else {
                peg$currPos = s7;
                s7 = peg$FAILED;
              }
            } else {
              peg$currPos = s7;
              s7 = peg$FAILED;
            }
            peg$silentFails--;
            if (s7 === peg$FAILED) {
              s6 = void 0;
            } else {
              peg$currPos = s6;
              s6 = peg$FAILED;
            }
            if (s6 !== peg$FAILED) {
              s7 = peg$parsetoken();
              if (s7 !== peg$FAILED) {
                peg$savedPos = s5;
                s5 = peg$f36(s22, s32, s7);
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
            while (s5 !== peg$FAILED) {
              s42.push(s5);
              s5 = peg$currPos;
              s6 = peg$currPos;
              peg$silentFails++;
              s7 = peg$currPos;
              s8 = peg$parseend_env();
              if (s8 !== peg$FAILED) {
                s9 = peg$parsegroup_contents_as_string();
                if (s9 !== peg$FAILED) {
                  peg$savedPos = peg$currPos;
                  s10 = peg$f35(s22, s32, s9);
                  if (s10) {
                    s10 = void 0;
                  } else {
                    s10 = peg$FAILED;
                  }
                  if (s10 !== peg$FAILED) {
                    s8 = [s8, s9, s10];
                    s7 = s8;
                  } else {
                    peg$currPos = s7;
                    s7 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s7;
                  s7 = peg$FAILED;
                }
              } else {
                peg$currPos = s7;
                s7 = peg$FAILED;
              }
              peg$silentFails--;
              if (s7 === peg$FAILED) {
                s6 = void 0;
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
              if (s6 !== peg$FAILED) {
                s7 = peg$parsetoken();
                if (s7 !== peg$FAILED) {
                  peg$savedPos = s5;
                  s5 = peg$f36(s22, s32, s7);
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            }
            s5 = peg$parseend_env();
            if (s5 !== peg$FAILED) {
              s6 = peg$parsegroup_contents_as_string();
              if (s6 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f37(s22, s32, s42);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e23);
          }
        }
        return s0;
      }
      function peg$parsemath_environment() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8, s9, s10, s11, s12;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parsebegin_env();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsebegin_group();
          if (s22 !== peg$FAILED) {
            s32 = peg$parsemath_env_name();
            if (s32 !== peg$FAILED) {
              s42 = peg$parseend_group();
              if (s42 !== peg$FAILED) {
                s5 = peg$parsesameline_comment();
                if (s5 === peg$FAILED) {
                  s5 = null;
                }
                s6 = [];
                s7 = peg$currPos;
                s8 = peg$currPos;
                peg$silentFails++;
                s9 = peg$currPos;
                s10 = peg$parseend_env();
                if (s10 !== peg$FAILED) {
                  s11 = peg$parsegroup();
                  if (s11 !== peg$FAILED) {
                    peg$savedPos = peg$currPos;
                    s12 = peg$f38(s32, s5, s11);
                    if (s12) {
                      s12 = void 0;
                    } else {
                      s12 = peg$FAILED;
                    }
                    if (s12 !== peg$FAILED) {
                      s10 = [s10, s11, s12];
                      s9 = s10;
                    } else {
                      peg$currPos = s9;
                      s9 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s9;
                    s9 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s9;
                  s9 = peg$FAILED;
                }
                peg$silentFails--;
                if (s9 === peg$FAILED) {
                  s8 = void 0;
                } else {
                  peg$currPos = s8;
                  s8 = peg$FAILED;
                }
                if (s8 !== peg$FAILED) {
                  s9 = peg$parsemath_token();
                  if (s9 !== peg$FAILED) {
                    peg$savedPos = s7;
                    s7 = peg$f39(s32, s5, s9);
                  } else {
                    peg$currPos = s7;
                    s7 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s7;
                  s7 = peg$FAILED;
                }
                while (s7 !== peg$FAILED) {
                  s6.push(s7);
                  s7 = peg$currPos;
                  s8 = peg$currPos;
                  peg$silentFails++;
                  s9 = peg$currPos;
                  s10 = peg$parseend_env();
                  if (s10 !== peg$FAILED) {
                    s11 = peg$parsegroup();
                    if (s11 !== peg$FAILED) {
                      peg$savedPos = peg$currPos;
                      s12 = peg$f38(s32, s5, s11);
                      if (s12) {
                        s12 = void 0;
                      } else {
                        s12 = peg$FAILED;
                      }
                      if (s12 !== peg$FAILED) {
                        s10 = [s10, s11, s12];
                        s9 = s10;
                      } else {
                        peg$currPos = s9;
                        s9 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s9;
                      s9 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s9;
                    s9 = peg$FAILED;
                  }
                  peg$silentFails--;
                  if (s9 === peg$FAILED) {
                    s8 = void 0;
                  } else {
                    peg$currPos = s8;
                    s8 = peg$FAILED;
                  }
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parsemath_token();
                    if (s9 !== peg$FAILED) {
                      peg$savedPos = s7;
                      s7 = peg$f39(s32, s5, s9);
                    } else {
                      peg$currPos = s7;
                      s7 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s7;
                    s7 = peg$FAILED;
                  }
                }
                s7 = peg$parseend_env();
                if (s7 !== peg$FAILED) {
                  s8 = peg$parsebegin_group();
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parsemath_env_name();
                    if (s9 !== peg$FAILED) {
                      s10 = peg$parseend_group();
                      if (s10 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s0 = peg$f40(s32, s5, s6);
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e24);
          }
        }
        return s0;
      }
      function peg$parsemath_group() {
        var s0, s1, s22, s32, s42, s5;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parsebegin_group();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$currPos;
          s42 = peg$currPos;
          peg$silentFails++;
          s5 = peg$parseend_group();
          peg$silentFails--;
          if (s5 === peg$FAILED) {
            s42 = void 0;
          } else {
            peg$currPos = s42;
            s42 = peg$FAILED;
          }
          if (s42 !== peg$FAILED) {
            s5 = peg$parsemath_token();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s32;
              s32 = peg$f41(s5);
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          } else {
            peg$currPos = s32;
            s32 = peg$FAILED;
          }
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$currPos;
            s42 = peg$currPos;
            peg$silentFails++;
            s5 = peg$parseend_group();
            peg$silentFails--;
            if (s5 === peg$FAILED) {
              s42 = void 0;
            } else {
              peg$currPos = s42;
              s42 = peg$FAILED;
            }
            if (s42 !== peg$FAILED) {
              s5 = peg$parsemath_token();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s32;
                s32 = peg$f41(s5);
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          }
          s32 = peg$parseend_group();
          if (s32 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f42(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e25);
          }
        }
        return s0;
      }
      function peg$parsebegin_display_math() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parseescape();
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 91) {
            s22 = peg$c10;
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e26);
            }
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseend_display_math() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parseescape();
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 93) {
            s22 = peg$c11;
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e27);
            }
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsebegin_inline_math() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parseescape();
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 40) {
            s22 = peg$c12;
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e28);
            }
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseend_inline_math() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parseescape();
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 41) {
            s22 = peg$c13;
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e29);
            }
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsebegin_env() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parseescape();
        if (s1 !== peg$FAILED) {
          if (input.substr(peg$currPos, 5) === peg$c14) {
            s22 = peg$c14;
            peg$currPos += 5;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e30);
            }
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseend_env() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parseescape();
        if (s1 !== peg$FAILED) {
          if (input.substr(peg$currPos, 3) === peg$c15) {
            s22 = peg$c15;
            peg$currPos += 3;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e31);
            }
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsemath_env_name() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 9) === peg$c16) {
          s1 = peg$c16;
          peg$currPos += 9;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e32);
          }
        }
        if (s1 === peg$FAILED) {
          if (input.substr(peg$currPos, 8) === peg$c17) {
            s1 = peg$c17;
            peg$currPos += 8;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e33);
            }
          }
          if (s1 === peg$FAILED) {
            if (input.substr(peg$currPos, 6) === peg$c18) {
              s1 = peg$c18;
              peg$currPos += 6;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e34);
              }
            }
            if (s1 === peg$FAILED) {
              if (input.substr(peg$currPos, 5) === peg$c19) {
                s1 = peg$c19;
                peg$currPos += 5;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e35);
                }
              }
              if (s1 === peg$FAILED) {
                if (input.substr(peg$currPos, 8) === peg$c20) {
                  s1 = peg$c20;
                  peg$currPos += 8;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e36);
                  }
                }
                if (s1 === peg$FAILED) {
                  if (input.substr(peg$currPos, 7) === peg$c21) {
                    s1 = peg$c21;
                    peg$currPos += 7;
                  } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e37);
                    }
                  }
                  if (s1 === peg$FAILED) {
                    if (input.substr(peg$currPos, 7) === peg$c22) {
                      s1 = peg$c22;
                      peg$currPos += 7;
                    } else {
                      s1 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e38);
                      }
                    }
                    if (s1 === peg$FAILED) {
                      if (input.substr(peg$currPos, 6) === peg$c23) {
                        s1 = peg$c23;
                        peg$currPos += 6;
                      } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$e39);
                        }
                      }
                      if (s1 === peg$FAILED) {
                        if (input.substr(peg$currPos, 9) === peg$c24) {
                          s1 = peg$c24;
                          peg$currPos += 9;
                        } else {
                          s1 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$e40);
                          }
                        }
                        if (s1 === peg$FAILED) {
                          if (input.substr(peg$currPos, 8) === peg$c25) {
                            s1 = peg$c25;
                            peg$currPos += 8;
                          } else {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) {
                              peg$fail(peg$e41);
                            }
                          }
                          if (s1 === peg$FAILED) {
                            if (input.substr(peg$currPos, 8) === peg$c26) {
                              s1 = peg$c26;
                              peg$currPos += 8;
                            } else {
                              s1 = peg$FAILED;
                              if (peg$silentFails === 0) {
                                peg$fail(peg$e42);
                              }
                            }
                            if (s1 === peg$FAILED) {
                              if (input.substr(peg$currPos, 7) === peg$c27) {
                                s1 = peg$c27;
                                peg$currPos += 7;
                              } else {
                                s1 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                  peg$fail(peg$e43);
                                }
                              }
                              if (s1 === peg$FAILED) {
                                if (input.substr(peg$currPos, 5) === peg$c28) {
                                  s1 = peg$c28;
                                  peg$currPos += 5;
                                } else {
                                  s1 = peg$FAILED;
                                  if (peg$silentFails === 0) {
                                    peg$fail(peg$e44);
                                  }
                                }
                                if (s1 === peg$FAILED) {
                                  if (input.substr(peg$currPos, 4) === peg$c29) {
                                    s1 = peg$c29;
                                    peg$currPos += 4;
                                  } else {
                                    s1 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                      peg$fail(peg$e45);
                                    }
                                  }
                                  if (s1 === peg$FAILED) {
                                    if (input.substr(peg$currPos, 11) === peg$c30) {
                                      s1 = peg$c30;
                                      peg$currPos += 11;
                                    } else {
                                      s1 = peg$FAILED;
                                      if (peg$silentFails === 0) {
                                        peg$fail(peg$e46);
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f43(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parseescape() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 92) {
          s1 = peg$c31;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e48);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f44();
        }
        s0 = s1;
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e47);
          }
        }
        return s0;
      }
      function peg$parsebegin_group() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 123) {
          s1 = peg$c32;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e49);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f45(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parseend_group() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 125) {
          s1 = peg$c33;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e50);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f46(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parsemath_shift() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 36) {
          s1 = peg$c34;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e51);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f47(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parsealignment_tab() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 38) {
          s1 = peg$c35;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e52);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f48(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parsenl() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 13) {
          s22 = peg$c36;
          peg$currPos++;
        } else {
          s22 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e54);
          }
        }
        peg$silentFails--;
        if (s22 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 10) {
            s22 = peg$c37;
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e55);
            }
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 13) {
            s0 = peg$c36;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e54);
            }
          }
          if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c38) {
              s0 = peg$c38;
              peg$currPos += 2;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e56);
              }
            }
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e53);
          }
        }
        return s0;
      }
      function peg$parsemacro_parameter() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 35) {
          s1 = peg$c39;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e57);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f49(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parsesuperscript() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 94) {
          s1 = peg$c40;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e58);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f50(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parsesubscript() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 95) {
          s1 = peg$c41;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e59);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f51(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parseignore() {
        var s0;
        if (input.charCodeAt(peg$currPos) === 0) {
          s0 = peg$c42;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e60);
          }
        }
        return s0;
      }
      function peg$parsesp() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        if (peg$r0.test(input.charAt(peg$currPos))) {
          s22 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s22 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e61);
          }
        }
        if (s22 !== peg$FAILED) {
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            if (peg$r0.test(input.charAt(peg$currPos))) {
              s22 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s22 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e61);
              }
            }
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f52();
        }
        s0 = s1;
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e8);
          }
        }
        return s0;
      }
      function peg$parsechar() {
        var s0, s1;
        peg$silentFails++;
        if (peg$r1.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e63);
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e62);
          }
        }
        return s0;
      }
      function peg$parsenum() {
        var s0, s1;
        peg$silentFails++;
        if (peg$r2.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e65);
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e64);
          }
        }
        return s0;
      }
      function peg$parsepunctuation() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$currPos;
        if (peg$r3.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e67);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f53(s1);
        }
        s0 = s1;
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e66);
          }
        }
        return s0;
      }
      function peg$parsecomment_start() {
        var s0;
        if (input.charCodeAt(peg$currPos) === 37) {
          s0 = peg$c0;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e7);
          }
        }
        return s0;
      }
      function peg$parsefull_comment() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parseownline_comment();
        if (s0 === peg$FAILED) {
          s0 = peg$parsesameline_comment();
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e68);
          }
        }
        return s0;
      }
      function peg$parseownline_comment() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = [];
        s32 = peg$parsesp();
        while (s32 !== peg$FAILED) {
          s22.push(s32);
          s32 = peg$parsesp();
        }
        s32 = peg$parsenl();
        if (s32 !== peg$FAILED) {
          s22 = [s22, s32];
          s1 = s22;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
          s1 = null;
        }
        s22 = peg$parseleading_sp();
        if (s22 !== peg$FAILED) {
          s32 = peg$parsecomment();
          if (s32 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f54(s22, s32);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsesameline_comment() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsesp();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parsesp();
        }
        s22 = peg$parsecomment();
        if (s22 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f55(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecomment() {
        var s0, s1, s22, s32, s42, s5, s6, s7;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parsecomment_start();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$currPos;
          s42 = peg$currPos;
          peg$silentFails++;
          s5 = peg$parsenl();
          peg$silentFails--;
          if (s5 === peg$FAILED) {
            s42 = void 0;
          } else {
            peg$currPos = s42;
            s42 = peg$FAILED;
          }
          if (s42 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s5 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e3);
              }
            }
            if (s5 !== peg$FAILED) {
              peg$savedPos = s32;
              s32 = peg$f56(s5);
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          } else {
            peg$currPos = s32;
            s32 = peg$FAILED;
          }
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$currPos;
            s42 = peg$currPos;
            peg$silentFails++;
            s5 = peg$parsenl();
            peg$silentFails--;
            if (s5 === peg$FAILED) {
              s42 = void 0;
            } else {
              peg$currPos = s42;
              s42 = peg$FAILED;
            }
            if (s42 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s5 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e3);
                }
              }
              if (s5 !== peg$FAILED) {
                peg$savedPos = s32;
                s32 = peg$f56(s5);
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          }
          s32 = peg$currPos;
          peg$silentFails++;
          s42 = peg$parseparbreak();
          peg$silentFails--;
          if (s42 !== peg$FAILED) {
            peg$currPos = s32;
            s32 = void 0;
          } else {
            s32 = peg$FAILED;
          }
          if (s32 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f57(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsecomment_start();
          if (s1 !== peg$FAILED) {
            s22 = [];
            s32 = peg$currPos;
            s42 = peg$currPos;
            peg$silentFails++;
            s5 = peg$parsenl();
            peg$silentFails--;
            if (s5 === peg$FAILED) {
              s42 = void 0;
            } else {
              peg$currPos = s42;
              s42 = peg$FAILED;
            }
            if (s42 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s5 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e3);
                }
              }
              if (s5 !== peg$FAILED) {
                peg$savedPos = s32;
                s32 = peg$f58(s5);
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
            while (s32 !== peg$FAILED) {
              s22.push(s32);
              s32 = peg$currPos;
              s42 = peg$currPos;
              peg$silentFails++;
              s5 = peg$parsenl();
              peg$silentFails--;
              if (s5 === peg$FAILED) {
                s42 = void 0;
              } else {
                peg$currPos = s42;
                s42 = peg$FAILED;
              }
              if (s42 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                  s5 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e3);
                  }
                }
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s32;
                  s32 = peg$f58(s5);
                } else {
                  peg$currPos = s32;
                  s32 = peg$FAILED;
                }
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
            }
            s32 = peg$currPos;
            s42 = peg$parsenl();
            if (s42 !== peg$FAILED) {
              s5 = [];
              s6 = peg$parsesp();
              while (s6 !== peg$FAILED) {
                s5.push(s6);
                s6 = peg$parsesp();
              }
              s6 = peg$currPos;
              peg$silentFails++;
              s7 = peg$parsecomment_start();
              peg$silentFails--;
              if (s7 === peg$FAILED) {
                s6 = void 0;
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
              if (s6 !== peg$FAILED) {
                s42 = [s42, s5, s6];
                s32 = s42;
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
            if (s32 === peg$FAILED) {
              s32 = peg$parsenl();
              if (s32 === peg$FAILED) {
                s32 = peg$parseEOF();
              }
            }
            if (s32 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f59(s22);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e69);
          }
        }
        return s0;
      }
      function peg$parseleading_sp() {
        var s0, s1, s22, s32, s42;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$parsestart_of_line();
        if (s22 !== peg$FAILED) {
          s32 = [];
          s42 = peg$parsesp();
          while (s42 !== peg$FAILED) {
            s32.push(s42);
            s42 = peg$parsesp();
          }
          s22 = [s22, s32];
          s1 = s22;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }
        return s0;
      }
      function peg$parsestart_of_line() {
        var s0;
        peg$savedPos = peg$currPos;
        s0 = peg$f60();
        if (s0) {
          s0 = void 0;
        } else {
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseEOF() {
        var s0, s1;
        s0 = peg$currPos;
        peg$silentFails++;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        peg$silentFails--;
        if (s1 === peg$FAILED) {
          s0 = void 0;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function toString(e) {
        if (typeof e === "string") {
          return e;
        }
        if (typeof e.content === "string") {
          return e.content;
        }
        if (e && e.type === "whitespace") {
          return " ";
        }
        return e;
      }
      function compare_env(g1, g2) {
        const g1Name = typeof g1 === "string" ? g1 : g1.content.map(toString).join("");
        const g2Name = typeof g2 === "string" ? g2 : g2.content.map(toString).join("");
        return g1Name === g2Name;
      }
      function createNode(type, extra = {}) {
        return { type, ...extra, position: location() };
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(
          peg$maxFailExpected,
          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
      }
    }
    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }()
);
var align_environment_default2 = (
  // Generated by Peggy 2.0.1.
  //
  // https://peggyjs.org/
  function() {
    "use strict";
    function peg$subclass(child, parent) {
      function C() {
        this.constructor = child;
      }
      C.prototype = parent.prototype;
      child.prototype = new C();
    }
    function peg$SyntaxError(message, expected, found, location) {
      var self = Error.call(this, message);
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(self, peg$SyntaxError.prototype);
      }
      self.expected = expected;
      self.found = found;
      self.location = location;
      self.name = "SyntaxError";
      return self;
    }
    peg$subclass(peg$SyntaxError, Error);
    function peg$padEnd(str, targetLength, padString) {
      padString = padString || " ";
      if (str.length > targetLength) {
        return str;
      }
      targetLength -= str.length;
      padString += padString.repeat(targetLength);
      return str + padString.slice(0, targetLength);
    }
    peg$SyntaxError.prototype.format = function(sources) {
      var str = "Error: " + this.message;
      if (this.location) {
        var src = null;
        var k;
        for (k = 0; k < sources.length; k++) {
          if (sources[k].source === this.location.source) {
            src = sources[k].text.split(/\r\n|\n|\r/g);
            break;
          }
        }
        var s22 = this.location.start;
        var loc = this.location.source + ":" + s22.line + ":" + s22.column;
        if (src) {
          var e = this.location.end;
          var filler = peg$padEnd("", s22.line.toString().length, " ");
          var line = src[s22.line - 1];
          var last = s22.line === e.line ? e.column : line.length + 1;
          var hatLen = last - s22.column || 1;
          str += "\n --> " + loc + "\n" + filler + " |\n" + s22.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s22.column - 1, " ") + peg$padEnd("", hatLen, "^");
        } else {
          str += "\n at " + loc;
        }
      }
      return str;
    };
    peg$SyntaxError.buildMessage = function(expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        class: function(expectation) {
          var escapedParts = expectation.parts.map(function(part) {
            return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
          });
          return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
        },
        any: function() {
          return "any character";
        },
        end: function() {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        }
      };
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s22) {
        return s22.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function classEscape(s22) {
        return s22.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = expected2.map(describeExpectation);
        var i, j;
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {};
      var peg$source = options.grammarSource;
      var peg$startRuleFunctions = { body: peg$parsebody };
      var peg$startRuleFunction = peg$parsebody;
      var peg$e0 = peg$anyExpectation();
      var peg$f0 = function() {
        return [];
      };
      var peg$f1 = function(x) {
        return { cells: [], colSeps: [], ...x };
      };
      var peg$f2 = function(rowItems, rowSep, trailingComment) {
        return { ...rowItems, rowSep, trailingComment };
      };
      var peg$f3 = function(rowItems, trailingComment) {
        return { ...rowItems, rowSep: null, trailingComment };
      };
      var peg$f4 = function(x) {
        return x;
      };
      var peg$f5 = function(x) {
        return {
          cells: [],
          colSeps: [],
          rowSep: null,
          trailingComment: x
        };
      };
      var peg$f6 = function(x) {
        return x;
      };
      var peg$f7 = function(colSep, cell) {
        return { colSep, cell };
      };
      var peg$f8 = function(colSep) {
        return { colSep };
      };
      var peg$f9 = function(a, b) {
        return processRow(a, b);
      };
      var peg$f10 = function(b) {
        return processRow(null, b);
      };
      var peg$f11 = function(tok) {
        return options.isSameLineComment(tok);
      };
      var peg$f12 = function(tok) {
        return tok;
      };
      var peg$f13 = function(tok) {
        return options.isOwnLineComment(tok);
      };
      var peg$f14 = function(tok) {
        return tok;
      };
      var peg$f15 = function(tok) {
        return options.isWhitespace(tok);
      };
      var peg$f16 = function(tok) {
        return tok;
      };
      var peg$f17 = function(tok) {
        return options.isRowSep(tok);
      };
      var peg$f18 = function(tok) {
        return tok;
      };
      var peg$f19 = function(tok) {
        return options.isColSep(tok);
      };
      var peg$f20 = function(tok) {
        return tok;
      };
      var peg$currPos = 0;
      var peg$savedPos = 0;
      var peg$posDetailsCache = [{ line: 1, column: 1 }];
      var peg$maxFailPos = 0;
      var peg$maxFailExpected = [];
      var peg$silentFails = 0;
      var peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function offset() {
        return peg$savedPos;
      }
      function range() {
        return {
          source: peg$source,
          start: peg$savedPos,
          end: peg$currPos
        };
      }
      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError(
          [peg$otherExpectation(description)],
          input.substring(peg$savedPos, peg$currPos),
          location2
        );
      }
      function error(message, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location2);
      }
      function peg$literalExpectation(text2, ignoreCase) {
        return { type: "literal", text: text2, ignoreCase };
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts, inverted, ignoreCase };
      }
      function peg$anyExpectation() {
        return { type: "any" };
      }
      function peg$endExpectation() {
        return { type: "end" };
      }
      function peg$otherExpectation(description) {
        return { type: "other", description };
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p;
        if (details) {
          return details;
        } else {
          p = pos - 1;
          while (!peg$posDetailsCache[p]) {
            p--;
          }
          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };
          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos);
        var endPosDetails = peg$computePosDetails(endPos);
        return {
          source: peg$source,
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildSimpleError(message, location2) {
        return new peg$SyntaxError(message, null, null, location2);
      }
      function peg$buildStructuredError(expected2, found, location2) {
        return new peg$SyntaxError(
          peg$SyntaxError.buildMessage(expected2, found),
          expected2,
          found,
          location2
        );
      }
      function peg$parsebody() {
        var s0, s1;
        s0 = [];
        s1 = peg$parsecomment_only_line();
        if (s1 === peg$FAILED) {
          s1 = peg$parserow_with_end();
          if (s1 === peg$FAILED) {
            s1 = peg$parserow_without_end();
          }
        }
        if (s1 !== peg$FAILED) {
          while (s1 !== peg$FAILED) {
            s0.push(s1);
            s1 = peg$parsecomment_only_line();
            if (s1 === peg$FAILED) {
              s1 = peg$parserow_with_end();
              if (s1 === peg$FAILED) {
                s1 = peg$parserow_without_end();
              }
            }
          }
        } else {
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseEOL();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f0();
          }
          s0 = s1;
        }
        return s0;
      }
      function peg$parserow_with_end() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$parserow_items();
        if (s22 === peg$FAILED) {
          s22 = null;
        }
        peg$savedPos = s1;
        s22 = peg$f1(s22);
        s1 = s22;
        s22 = peg$parserow_sep();
        if (s22 !== peg$FAILED) {
          s32 = peg$parsetrailing_comment();
          if (s32 === peg$FAILED) {
            s32 = null;
          }
          peg$savedPos = s0;
          s0 = peg$f2(s1, s22, s32);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parserow_without_end() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parserow_items();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsetrailing_comment();
          if (s22 === peg$FAILED) {
            s22 = null;
          }
          peg$savedPos = s0;
          s0 = peg$f3(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsetrailing_comment() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsewhitespace();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parsewhitespace();
        }
        s22 = peg$parsesame_line_comment();
        if (s22 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f4(s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecomment_only_line() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsewhitespace();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parsewhitespace();
        }
        s22 = peg$parseown_line_comment();
        if (s22 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f5(s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsetoken() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        s22 = peg$parserow_sep();
        if (s22 === peg$FAILED) {
          s22 = peg$parsecol_sep();
          if (s22 === peg$FAILED) {
            s22 = peg$parsetrailing_comment();
            if (s22 === peg$FAILED) {
              s22 = peg$parseown_line_comment();
            }
          }
        }
        peg$silentFails--;
        if (s22 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s22 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f6(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecell() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsetoken();
        if (s22 !== peg$FAILED) {
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            s22 = peg$parsetoken();
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }
        return s0;
      }
      function peg$parseseparated_cell() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parsecol_sep();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsecell();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f7(s1, s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsecol_sep();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f8(s1);
          }
          s0 = s1;
        }
        return s0;
      }
      function peg$parserow_items() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$parsecell();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$parseseparated_cell();
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parseseparated_cell();
          }
          peg$savedPos = s0;
          s0 = peg$f9(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = [];
          s22 = peg$parseseparated_cell();
          if (s22 !== peg$FAILED) {
            while (s22 !== peg$FAILED) {
              s1.push(s22);
              s22 = peg$parseseparated_cell();
            }
          } else {
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f10(s1);
          }
          s0 = s1;
        }
        return s0;
      }
      function peg$parsesame_line_comment() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f11(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f12(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseown_line_comment() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f13(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f14(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsewhitespace() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f15(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f16(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parserow_sep() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f17(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f18(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecol_sep() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f19(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f20(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseEOL() {
        var s0, s1;
        s0 = peg$currPos;
        peg$silentFails++;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        peg$silentFails--;
        if (s1 === peg$FAILED) {
          s0 = void 0;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function processRow(leadCell, otherCells) {
        const cells = [leadCell || []];
        const seps = [];
        for (const x of otherCells) {
          cells.push(x.cell || []);
          seps.push(x.colSep);
        }
        return { cells, colSeps: seps };
      }
      if (!options.isWhitespace) {
        try {
          Object.assign(
            options,
            createMatchers(["\\", "hline", "cr"], ["&"])
          );
        } catch (e) {
          console.warn("Error when initializing parser", e);
        }
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(
          peg$maxFailExpected,
          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
      }
    }
    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }()
);
var xparse_argspec_default2 = (
  // Generated by Peggy 2.0.1.
  //
  // https://peggyjs.org/
  function() {
    "use strict";
    function peg$subclass(child, parent) {
      function C() {
        this.constructor = child;
      }
      C.prototype = parent.prototype;
      child.prototype = new C();
    }
    function peg$SyntaxError(message, expected, found, location) {
      var self = Error.call(this, message);
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(self, peg$SyntaxError.prototype);
      }
      self.expected = expected;
      self.found = found;
      self.location = location;
      self.name = "SyntaxError";
      return self;
    }
    peg$subclass(peg$SyntaxError, Error);
    function peg$padEnd(str, targetLength, padString) {
      padString = padString || " ";
      if (str.length > targetLength) {
        return str;
      }
      targetLength -= str.length;
      padString += padString.repeat(targetLength);
      return str + padString.slice(0, targetLength);
    }
    peg$SyntaxError.prototype.format = function(sources) {
      var str = "Error: " + this.message;
      if (this.location) {
        var src = null;
        var k;
        for (k = 0; k < sources.length; k++) {
          if (sources[k].source === this.location.source) {
            src = sources[k].text.split(/\r\n|\n|\r/g);
            break;
          }
        }
        var s22 = this.location.start;
        var loc = this.location.source + ":" + s22.line + ":" + s22.column;
        if (src) {
          var e = this.location.end;
          var filler = peg$padEnd("", s22.line.toString().length, " ");
          var line = src[s22.line - 1];
          var last = s22.line === e.line ? e.column : line.length + 1;
          var hatLen = last - s22.column || 1;
          str += "\n --> " + loc + "\n" + filler + " |\n" + s22.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s22.column - 1, " ") + peg$padEnd("", hatLen, "^");
        } else {
          str += "\n at " + loc;
        }
      }
      return str;
    };
    peg$SyntaxError.buildMessage = function(expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        class: function(expectation) {
          var escapedParts = expectation.parts.map(function(part) {
            return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
          });
          return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
        },
        any: function() {
          return "any character";
        },
        end: function() {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        }
      };
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s22) {
        return s22.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function classEscape(s22) {
        return s22.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = expected2.map(describeExpectation);
        var i, j;
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {};
      var peg$source = options.grammarSource;
      var peg$startRuleFunctions = { args_spec_list: peg$parseargs_spec_list };
      var peg$startRuleFunction = peg$parseargs_spec_list;
      var peg$c0 = "+";
      var peg$c1 = "v";
      var peg$c2 = "b";
      var peg$c3 = "!";
      var peg$c4 = "D";
      var peg$c5 = "d";
      var peg$c6 = "s";
      var peg$c7 = "O";
      var peg$c8 = "o";
      var peg$c9 = "e";
      var peg$c10 = "E";
      var peg$c11 = "t";
      var peg$c12 = "R";
      var peg$c13 = "r";
      var peg$c14 = "u";
      var peg$c15 = "m";
      var peg$c16 = "{";
      var peg$c17 = "}";
      var peg$c18 = " ";
      var peg$c19 = "\n";
      var peg$c20 = "\r";
      var peg$r0 = /^[{ ]/;
      var peg$e0 = peg$literalExpectation("+", false);
      var peg$e1 = peg$literalExpectation("v", false);
      var peg$e2 = peg$anyExpectation();
      var peg$e3 = peg$literalExpectation("b", false);
      var peg$e4 = peg$literalExpectation("!", false);
      var peg$e5 = peg$literalExpectation("D", false);
      var peg$e6 = peg$literalExpectation("d", false);
      var peg$e7 = peg$literalExpectation("s", false);
      var peg$e8 = peg$literalExpectation("O", false);
      var peg$e9 = peg$literalExpectation("o", false);
      var peg$e10 = peg$literalExpectation("e", false);
      var peg$e11 = peg$literalExpectation("E", false);
      var peg$e12 = peg$literalExpectation("t", false);
      var peg$e13 = peg$literalExpectation("R", false);
      var peg$e14 = peg$literalExpectation("r", false);
      var peg$e15 = peg$literalExpectation("u", false);
      var peg$e16 = peg$classExpectation(["{", " "], false, false);
      var peg$e17 = peg$literalExpectation("m", false);
      var peg$e18 = peg$literalExpectation("{", false);
      var peg$e19 = peg$literalExpectation("}", false);
      var peg$e20 = peg$literalExpectation(" ", false);
      var peg$e21 = peg$literalExpectation("\n", false);
      var peg$e22 = peg$literalExpectation("\r", false);
      var peg$f0 = function(x) {
        return x;
      };
      var peg$f1 = function(spec) {
        return spec;
      };
      var peg$f2 = function(spec) {
        return spec;
      };
      var peg$f3 = function(openBrace) {
        return createNode("verbatim", { openBrace, closeBrace: openBrace });
      };
      var peg$f4 = function() {
        return createNode("body");
      };
      var peg$f5 = function(leading_bang, spec) {
        return leading_bang ? { ...spec, noLeadingWhitespace: true } : spec;
      };
      var peg$f6 = function(braceSpec, defaultArg) {
        return createNode("optional", { ...braceSpec, defaultArg });
      };
      var peg$f7 = function(braceSpec) {
        return createNode("optional", braceSpec);
      };
      var peg$f8 = function() {
        return createNode("optionalStar");
      };
      var peg$f9 = function(g) {
        return createNode("optional", { defaultArg: g });
      };
      var peg$f10 = function() {
        return createNode("optional");
      };
      var peg$f11 = function(args) {
        return createNode("embellishment", {
          embellishmentTokens: args.content
        });
      };
      var peg$f12 = function(args, g) {
        return createNode("embellishment", {
          embellishmentTokens: args.content,
          defaultArg: g
        });
      };
      var peg$f13 = function(tok) {
        return createNode("optionalToken", { token: tok });
      };
      var peg$f14 = function(braceSpec, defaultArg) {
        return createNode("mandatory", { ...braceSpec, defaultArg });
      };
      var peg$f15 = function(braceSpec) {
        return createNode("mandatory", braceSpec);
      };
      var peg$f16 = function(stopTokens) {
        return createNode("until", { stopTokens });
      };
      var peg$f17 = function(x) {
        return [x];
      };
      var peg$f18 = function(g) {
        return g.content;
      };
      var peg$f19 = function() {
        return createNode("mandatory");
      };
      var peg$f20 = function(openBrace, closeBrace) {
        return { openBrace, closeBrace };
      };
      var peg$f21 = function(content) {
        return { type: "group", content };
      };
      var peg$f22 = function() {
        return "";
      };
      var peg$currPos = 0;
      var peg$savedPos = 0;
      var peg$posDetailsCache = [{ line: 1, column: 1 }];
      var peg$maxFailPos = 0;
      var peg$maxFailExpected = [];
      var peg$silentFails = 0;
      var peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function offset() {
        return peg$savedPos;
      }
      function range() {
        return {
          source: peg$source,
          start: peg$savedPos,
          end: peg$currPos
        };
      }
      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError(
          [peg$otherExpectation(description)],
          input.substring(peg$savedPos, peg$currPos),
          location2
        );
      }
      function error(message, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location2);
      }
      function peg$literalExpectation(text2, ignoreCase) {
        return { type: "literal", text: text2, ignoreCase };
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts, inverted, ignoreCase };
      }
      function peg$anyExpectation() {
        return { type: "any" };
      }
      function peg$endExpectation() {
        return { type: "end" };
      }
      function peg$otherExpectation(description) {
        return { type: "other", description };
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p;
        if (details) {
          return details;
        } else {
          p = pos - 1;
          while (!peg$posDetailsCache[p]) {
            p--;
          }
          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };
          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos);
        var endPosDetails = peg$computePosDetails(endPos);
        return {
          source: peg$source,
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildSimpleError(message, location2) {
        return new peg$SyntaxError(message, null, null, location2);
      }
      function peg$buildStructuredError(expected2, found, location2) {
        return new peg$SyntaxError(
          peg$SyntaxError.buildMessage(expected2, found),
          expected2,
          found,
          location2
        );
      }
      function peg$parseargs_spec_list() {
        var s0, s1, s22, s32, s42;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$currPos;
        s32 = peg$parsewhitespace();
        s42 = peg$parsearg_spec();
        if (s42 !== peg$FAILED) {
          peg$savedPos = s22;
          s22 = peg$f0(s42);
        } else {
          peg$currPos = s22;
          s22 = peg$FAILED;
        }
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$currPos;
          s32 = peg$parsewhitespace();
          s42 = peg$parsearg_spec();
          if (s42 !== peg$FAILED) {
            peg$savedPos = s22;
            s22 = peg$f0(s42);
          } else {
            peg$currPos = s22;
            s22 = peg$FAILED;
          }
        }
        s22 = peg$parsewhitespace();
        peg$savedPos = s0;
        s0 = peg$f1(s1);
        return s0;
      }
      function peg$parsearg_spec() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 43) {
          s1 = peg$c0;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 === peg$FAILED) {
          s1 = null;
        }
        s22 = peg$parseoptional();
        if (s22 === peg$FAILED) {
          s22 = peg$parsemandatory();
          if (s22 === peg$FAILED) {
            s22 = peg$parseverbatim();
            if (s22 === peg$FAILED) {
              s22 = peg$parserequired();
              if (s22 === peg$FAILED) {
                s22 = peg$parsebody();
                if (s22 === peg$FAILED) {
                  s22 = peg$parseuntil();
                }
              }
            }
          }
        }
        if (s22 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f2(s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseverbatim() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 118) {
          s1 = peg$c1;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e1);
          }
        }
        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s22 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f3(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsebody() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 98) {
          s1 = peg$c2;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f4();
        }
        s0 = s1;
        return s0;
      }
      function peg$parseoptional() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 33) {
          s1 = peg$c3;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e4);
          }
        }
        if (s1 === peg$FAILED) {
          s1 = null;
        }
        s22 = peg$parseoptional_star();
        if (s22 === peg$FAILED) {
          s22 = peg$parseoptional_standard();
          if (s22 === peg$FAILED) {
            s22 = peg$parseoptional_delimited();
            if (s22 === peg$FAILED) {
              s22 = peg$parseoptional_embellishment();
              if (s22 === peg$FAILED) {
                s22 = peg$parseoptional_token();
              }
            }
          }
        }
        if (s22 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f5(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseoptional_delimited() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 68) {
          s1 = peg$c4;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e5);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parsebrace_spec();
          s32 = peg$parsebraced_group();
          if (s32 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f6(s22, s32);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 100) {
            s1 = peg$c5;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e6);
            }
          }
          if (s1 !== peg$FAILED) {
            s22 = peg$parsebrace_spec();
            peg$savedPos = s0;
            s0 = peg$f7(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        return s0;
      }
      function peg$parseoptional_star() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 115) {
          s1 = peg$c6;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e7);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f8();
        }
        s0 = s1;
        return s0;
      }
      function peg$parseoptional_standard() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 79) {
          s1 = peg$c7;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e8);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parsebraced_group();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f9(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 111) {
            s1 = peg$c8;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e9);
            }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f10();
          }
          s0 = s1;
        }
        return s0;
      }
      function peg$parseoptional_embellishment() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 101) {
          s1 = peg$c9;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e10);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parsebraced_group();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f11(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 69) {
            s1 = peg$c10;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e11);
            }
          }
          if (s1 !== peg$FAILED) {
            s22 = peg$parsebraced_group();
            if (s22 !== peg$FAILED) {
              s32 = peg$parsebraced_group();
              if (s32 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f12(s22, s32);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        return s0;
      }
      function peg$parseoptional_token() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 116) {
          s1 = peg$c11;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e12);
          }
        }
        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s22 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f13(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parserequired() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 82) {
          s1 = peg$c12;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e13);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parsebrace_spec();
          s32 = peg$parsebraced_group();
          if (s32 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f14(s22, s32);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 114) {
            s1 = peg$c13;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e14);
            }
          }
          if (s1 !== peg$FAILED) {
            s22 = peg$parsebrace_spec();
            peg$savedPos = s0;
            s0 = peg$f15(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        return s0;
      }
      function peg$parseuntil() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 117) {
          s1 = peg$c14;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e15);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parseuntil_stop_token();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f16(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseuntil_stop_token() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        if (peg$r0.test(input.charAt(peg$currPos))) {
          s22 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s22 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e16);
          }
        }
        peg$silentFails--;
        if (s22 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s22 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f17(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsebraced_group();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f18(s1);
          }
          s0 = s1;
        }
        return s0;
      }
      function peg$parsemandatory() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 109) {
          s1 = peg$c15;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e17);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f19();
        }
        s0 = s1;
        return s0;
      }
      function peg$parsebrace_spec() {
        var s0, s1, s22, s32, s42, s5;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$currPos;
        s32 = peg$currPos;
        peg$silentFails++;
        s42 = peg$parsewhitespace_token();
        peg$silentFails--;
        if (s42 === peg$FAILED) {
          s32 = void 0;
        } else {
          peg$currPos = s32;
          s32 = peg$FAILED;
        }
        if (s32 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s42 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s42 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          if (s42 !== peg$FAILED) {
            s32 = [s32, s42];
            s22 = s32;
          } else {
            peg$currPos = s22;
            s22 = peg$FAILED;
          }
        } else {
          peg$currPos = s22;
          s22 = peg$FAILED;
        }
        if (s22 === peg$FAILED) {
          s22 = null;
        }
        s1 = input.substring(s1, peg$currPos);
        s22 = peg$currPos;
        s32 = peg$currPos;
        s42 = peg$currPos;
        peg$silentFails++;
        s5 = peg$parsewhitespace_token();
        peg$silentFails--;
        if (s5 === peg$FAILED) {
          s42 = void 0;
        } else {
          peg$currPos = s42;
          s42 = peg$FAILED;
        }
        if (s42 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          if (s5 !== peg$FAILED) {
            s42 = [s42, s5];
            s32 = s42;
          } else {
            peg$currPos = s32;
            s32 = peg$FAILED;
          }
        } else {
          peg$currPos = s32;
          s32 = peg$FAILED;
        }
        if (s32 === peg$FAILED) {
          s32 = null;
        }
        s22 = input.substring(s22, peg$currPos);
        peg$savedPos = s0;
        s0 = peg$f20(s1, s22);
        return s0;
      }
      function peg$parsebraced_group() {
        var s0, s1, s22, s32, s42, s5, s6, s7;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 123) {
          s1 = peg$c16;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e18);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$currPos;
          s42 = peg$currPos;
          s5 = peg$currPos;
          peg$silentFails++;
          if (input.charCodeAt(peg$currPos) === 125) {
            s6 = peg$c17;
            peg$currPos++;
          } else {
            s6 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e19);
            }
          }
          peg$silentFails--;
          if (s6 === peg$FAILED) {
            s5 = void 0;
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$currPos;
            peg$silentFails++;
            s7 = peg$parsebraced_group();
            peg$silentFails--;
            if (s7 === peg$FAILED) {
              s6 = void 0;
            } else {
              peg$currPos = s6;
              s6 = peg$FAILED;
            }
            if (s6 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s7 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s7 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e2);
                }
              }
              if (s7 !== peg$FAILED) {
                s5 = [s5, s6, s7];
                s42 = s5;
              } else {
                peg$currPos = s42;
                s42 = peg$FAILED;
              }
            } else {
              peg$currPos = s42;
              s42 = peg$FAILED;
            }
          } else {
            peg$currPos = s42;
            s42 = peg$FAILED;
          }
          if (s42 !== peg$FAILED) {
            s32 = input.substring(s32, peg$currPos);
          } else {
            s32 = s42;
          }
          if (s32 === peg$FAILED) {
            s32 = peg$parsebraced_group();
          }
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$currPos;
            s42 = peg$currPos;
            s5 = peg$currPos;
            peg$silentFails++;
            if (input.charCodeAt(peg$currPos) === 125) {
              s6 = peg$c17;
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e19);
              }
            }
            peg$silentFails--;
            if (s6 === peg$FAILED) {
              s5 = void 0;
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$currPos;
              peg$silentFails++;
              s7 = peg$parsebraced_group();
              peg$silentFails--;
              if (s7 === peg$FAILED) {
                s6 = void 0;
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
              if (s6 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                  s7 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e2);
                  }
                }
                if (s7 !== peg$FAILED) {
                  s5 = [s5, s6, s7];
                  s42 = s5;
                } else {
                  peg$currPos = s42;
                  s42 = peg$FAILED;
                }
              } else {
                peg$currPos = s42;
                s42 = peg$FAILED;
              }
            } else {
              peg$currPos = s42;
              s42 = peg$FAILED;
            }
            if (s42 !== peg$FAILED) {
              s32 = input.substring(s32, peg$currPos);
            } else {
              s32 = s42;
            }
            if (s32 === peg$FAILED) {
              s32 = peg$parsebraced_group();
            }
          }
          if (input.charCodeAt(peg$currPos) === 125) {
            s32 = peg$c17;
            peg$currPos++;
          } else {
            s32 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e19);
            }
          }
          if (s32 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f21(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsewhitespace() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsewhitespace_token();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parsewhitespace_token();
        }
        peg$savedPos = s0;
        s1 = peg$f22();
        s0 = s1;
        return s0;
      }
      function peg$parsewhitespace_token() {
        var s0;
        if (input.charCodeAt(peg$currPos) === 32) {
          s0 = peg$c18;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e20);
          }
        }
        if (s0 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 10) {
            s0 = peg$c19;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e21);
            }
          }
          if (s0 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 13) {
              s0 = peg$c20;
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e22);
              }
            }
          }
        }
        return s0;
      }
      const DEFAULT_OPTIONS = {
        optional: { openBrace: "[", closeBrace: "]" },
        mandatory: { openBrace: "{", closeBrace: "}" }
      };
      function createNode(type, options2) {
        const computedOptions = DEFAULT_OPTIONS[type] || {};
        return { type, ...computedOptions, ...options2 };
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(
          peg$maxFailExpected,
          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
      }
    }
    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }()
);
var pgfkeys_default2 = (
  // Generated by Peggy 2.0.1.
  //
  // https://peggyjs.org/
  function() {
    "use strict";
    function peg$subclass(child, parent) {
      function C() {
        this.constructor = child;
      }
      C.prototype = parent.prototype;
      child.prototype = new C();
    }
    function peg$SyntaxError(message, expected, found, location) {
      var self = Error.call(this, message);
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(self, peg$SyntaxError.prototype);
      }
      self.expected = expected;
      self.found = found;
      self.location = location;
      self.name = "SyntaxError";
      return self;
    }
    peg$subclass(peg$SyntaxError, Error);
    function peg$padEnd(str, targetLength, padString) {
      padString = padString || " ";
      if (str.length > targetLength) {
        return str;
      }
      targetLength -= str.length;
      padString += padString.repeat(targetLength);
      return str + padString.slice(0, targetLength);
    }
    peg$SyntaxError.prototype.format = function(sources) {
      var str = "Error: " + this.message;
      if (this.location) {
        var src = null;
        var k;
        for (k = 0; k < sources.length; k++) {
          if (sources[k].source === this.location.source) {
            src = sources[k].text.split(/\r\n|\n|\r/g);
            break;
          }
        }
        var s22 = this.location.start;
        var loc = this.location.source + ":" + s22.line + ":" + s22.column;
        if (src) {
          var e = this.location.end;
          var filler = peg$padEnd("", s22.line.toString().length, " ");
          var line = src[s22.line - 1];
          var last = s22.line === e.line ? e.column : line.length + 1;
          var hatLen = last - s22.column || 1;
          str += "\n --> " + loc + "\n" + filler + " |\n" + s22.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s22.column - 1, " ") + peg$padEnd("", hatLen, "^");
        } else {
          str += "\n at " + loc;
        }
      }
      return str;
    };
    peg$SyntaxError.buildMessage = function(expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        class: function(expectation) {
          var escapedParts = expectation.parts.map(function(part) {
            return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
          });
          return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
        },
        any: function() {
          return "any character";
        },
        end: function() {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        }
      };
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s22) {
        return s22.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function classEscape(s22) {
        return s22.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = expected2.map(describeExpectation);
        var i, j;
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {};
      var peg$source = options.grammarSource;
      var peg$startRuleFunctions = { body: peg$parsebody };
      var peg$startRuleFunction = peg$parsebody;
      var peg$e0 = peg$anyExpectation();
      var peg$f0 = function() {
        return [];
      };
      var peg$f1 = function(rowItems, trailingComment) {
        return {
          itemParts: [],
          ...rowItems,
          trailingComment,
          trailingComma: true
        };
      };
      var peg$f2 = function(rowItems, trailingComment) {
        return { ...rowItems, trailingComment };
      };
      var peg$f3 = function(a, b) {
        return processItem(a, b);
      };
      var peg$f4 = function(b) {
        return processItem(null, b);
      };
      var peg$f5 = function(cell) {
        return { cell };
      };
      var peg$f6 = function() {
        return {};
      };
      var peg$f7 = function(part) {
        return part;
      };
      var peg$f8 = function(x) {
        return x;
      };
      var peg$f9 = function(space, x) {
        return {
          trailingComment: x,
          leadingParbreak: space.parbreak > 0
        };
      };
      var peg$f10 = function(list) {
        return {
          whitespace: list.filter((x) => options.isWhitespace(x)).length,
          parbreak: list.filter((x) => options.isParbreak(x)).length
        };
      };
      var peg$f11 = function() {
        return !options.allowParenGroups;
      };
      var peg$f12 = function(tok) {
        return options.isSameLineComment(tok);
      };
      var peg$f13 = function(tok) {
        return tok;
      };
      var peg$f14 = function(tok) {
        return options.isOwnLineComment(tok);
      };
      var peg$f15 = function(tok) {
        return tok;
      };
      var peg$f16 = function(tok) {
        return options.isWhitespace(tok);
      };
      var peg$f17 = function(tok) {
        return tok;
      };
      var peg$f18 = function(tok) {
        return options.isParbreak(tok);
      };
      var peg$f19 = function(tok) {
        return tok;
      };
      var peg$f20 = function(tok) {
        return options.isComma(tok);
      };
      var peg$f21 = function(tok) {
        return tok;
      };
      var peg$f22 = function(tok) {
        return options.isEquals(tok);
      };
      var peg$f23 = function(tok) {
        return tok;
      };
      var peg$f24 = function(tok) {
        return options.isChar(tok, "(");
      };
      var peg$f25 = function(tok) {
        return tok;
      };
      var peg$f26 = function(tok) {
        return options.isChar(tok, ")");
      };
      var peg$f27 = function(tok) {
        return tok;
      };
      var peg$currPos = 0;
      var peg$savedPos = 0;
      var peg$posDetailsCache = [{ line: 1, column: 1 }];
      var peg$maxFailPos = 0;
      var peg$maxFailExpected = [];
      var peg$silentFails = 0;
      var peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function offset() {
        return peg$savedPos;
      }
      function range() {
        return {
          source: peg$source,
          start: peg$savedPos,
          end: peg$currPos
        };
      }
      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError(
          [peg$otherExpectation(description)],
          input.substring(peg$savedPos, peg$currPos),
          location2
        );
      }
      function error(message, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location2);
      }
      function peg$literalExpectation(text2, ignoreCase) {
        return { type: "literal", text: text2, ignoreCase };
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts, inverted, ignoreCase };
      }
      function peg$anyExpectation() {
        return { type: "any" };
      }
      function peg$endExpectation() {
        return { type: "end" };
      }
      function peg$otherExpectation(description) {
        return { type: "other", description };
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p;
        if (details) {
          return details;
        } else {
          p = pos - 1;
          while (!peg$posDetailsCache[p]) {
            p--;
          }
          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };
          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos);
        var endPosDetails = peg$computePosDetails(endPos);
        return {
          source: peg$source,
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildSimpleError(message, location2) {
        return new peg$SyntaxError(message, null, null, location2);
      }
      function peg$buildStructuredError(expected2, found, location2) {
        return new peg$SyntaxError(
          peg$SyntaxError.buildMessage(expected2, found),
          expected2,
          found,
          location2
        );
      }
      function peg$parsebody() {
        var s0, s1, s22;
        s0 = [];
        s1 = peg$parsecomment_only_line();
        if (s1 === peg$FAILED) {
          s1 = peg$parseitem_with_end();
          if (s1 === peg$FAILED) {
            s1 = peg$parseitem_without_end();
          }
        }
        if (s1 !== peg$FAILED) {
          while (s1 !== peg$FAILED) {
            s0.push(s1);
            s1 = peg$parsecomment_only_line();
            if (s1 === peg$FAILED) {
              s1 = peg$parseitem_with_end();
              if (s1 === peg$FAILED) {
                s1 = peg$parseitem_without_end();
              }
            }
          }
        } else {
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = [];
          s22 = peg$parsewhitespace();
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            s22 = peg$parsewhitespace();
          }
          s22 = peg$parseEOL();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f0();
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        return s0;
      }
      function peg$parseitem_with_end() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8;
        s0 = peg$currPos;
        s1 = peg$parsewhitespace_or_parbreaks();
        s22 = peg$parserow_items();
        if (s22 === peg$FAILED) {
          s22 = null;
        }
        s32 = peg$parsewhitespace_or_parbreaks();
        s42 = peg$parseitem_sep();
        if (s42 !== peg$FAILED) {
          s5 = [];
          s6 = peg$parsewhitespace();
          while (s6 !== peg$FAILED) {
            s5.push(s6);
            s6 = peg$parsewhitespace();
          }
          s6 = peg$parsetrailing_comment();
          if (s6 === peg$FAILED) {
            s6 = null;
          }
          s7 = [];
          s8 = peg$parsewhitespace();
          while (s8 !== peg$FAILED) {
            s7.push(s8);
            s8 = peg$parsewhitespace();
          }
          peg$savedPos = s0;
          s0 = peg$f1(s22, s6);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseitem_without_end() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$parsewhitespace_or_parbreaks();
        s22 = peg$parserow_items();
        if (s22 !== peg$FAILED) {
          s32 = peg$parsetrailing_comment();
          if (s32 === peg$FAILED) {
            s32 = null;
          }
          peg$savedPos = s0;
          s0 = peg$f2(s22, s32);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parserow_items() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$parseitem_part();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$parseseparated_part();
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parseseparated_part();
          }
          peg$savedPos = s0;
          s0 = peg$f3(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = [];
          s22 = peg$parseseparated_part();
          if (s22 !== peg$FAILED) {
            while (s22 !== peg$FAILED) {
              s1.push(s22);
              s22 = peg$parseseparated_part();
            }
          } else {
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f4(s1);
          }
          s0 = s1;
        }
        return s0;
      }
      function peg$parseseparated_part() {
        var s0, s1, s22, s32, s42;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parseparbreak();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parseparbreak();
        }
        s22 = peg$parseequals();
        if (s22 !== peg$FAILED) {
          s32 = [];
          s42 = peg$parseparbreak();
          while (s42 !== peg$FAILED) {
            s32.push(s42);
            s42 = peg$parseparbreak();
          }
          s42 = peg$parseitem_part();
          if (s42 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f5(s42);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = [];
          s22 = peg$parseparbreak();
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            s22 = peg$parseparbreak();
          }
          s22 = peg$parseequals();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f6();
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        return s0;
      }
      function peg$parseitem_part() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8, s9;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsewhitespace();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parsewhitespace();
        }
        s22 = peg$currPos;
        s32 = [];
        s42 = peg$parsenon_whitespace_non_parbreak_token();
        if (s42 === peg$FAILED) {
          s42 = peg$currPos;
          s5 = peg$parsewhitespace();
          if (s5 === peg$FAILED) {
            s5 = peg$parseparbreak();
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$currPos;
            peg$silentFails++;
            s7 = peg$currPos;
            s8 = [];
            s9 = peg$parsewhitespace();
            if (s9 === peg$FAILED) {
              s9 = peg$parseparbreak();
            }
            while (s9 !== peg$FAILED) {
              s8.push(s9);
              s9 = peg$parsewhitespace();
              if (s9 === peg$FAILED) {
                s9 = peg$parseparbreak();
              }
            }
            s9 = peg$parsenon_whitespace_non_parbreak_token();
            if (s9 !== peg$FAILED) {
              s8 = [s8, s9];
              s7 = s8;
            } else {
              peg$currPos = s7;
              s7 = peg$FAILED;
            }
            peg$silentFails--;
            if (s7 !== peg$FAILED) {
              peg$currPos = s6;
              s6 = void 0;
            } else {
              s6 = peg$FAILED;
            }
            if (s6 !== peg$FAILED) {
              s5 = [s5, s6];
              s42 = s5;
            } else {
              peg$currPos = s42;
              s42 = peg$FAILED;
            }
          } else {
            peg$currPos = s42;
            s42 = peg$FAILED;
          }
        }
        if (s42 !== peg$FAILED) {
          while (s42 !== peg$FAILED) {
            s32.push(s42);
            s42 = peg$parsenon_whitespace_non_parbreak_token();
            if (s42 === peg$FAILED) {
              s42 = peg$currPos;
              s5 = peg$parsewhitespace();
              if (s5 === peg$FAILED) {
                s5 = peg$parseparbreak();
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$currPos;
                peg$silentFails++;
                s7 = peg$currPos;
                s8 = [];
                s9 = peg$parsewhitespace();
                if (s9 === peg$FAILED) {
                  s9 = peg$parseparbreak();
                }
                while (s9 !== peg$FAILED) {
                  s8.push(s9);
                  s9 = peg$parsewhitespace();
                  if (s9 === peg$FAILED) {
                    s9 = peg$parseparbreak();
                  }
                }
                s9 = peg$parsenon_whitespace_non_parbreak_token();
                if (s9 !== peg$FAILED) {
                  s8 = [s8, s9];
                  s7 = s8;
                } else {
                  peg$currPos = s7;
                  s7 = peg$FAILED;
                }
                peg$silentFails--;
                if (s7 !== peg$FAILED) {
                  peg$currPos = s6;
                  s6 = void 0;
                } else {
                  s6 = peg$FAILED;
                }
                if (s6 !== peg$FAILED) {
                  s5 = [s5, s6];
                  s42 = s5;
                } else {
                  peg$currPos = s42;
                  s42 = peg$FAILED;
                }
              } else {
                peg$currPos = s42;
                s42 = peg$FAILED;
              }
            }
          }
        } else {
          s32 = peg$FAILED;
        }
        if (s32 !== peg$FAILED) {
          s22 = input.substring(s22, peg$currPos);
        } else {
          s22 = s32;
        }
        if (s22 !== peg$FAILED) {
          s32 = [];
          s42 = peg$parsewhitespace();
          while (s42 !== peg$FAILED) {
            s32.push(s42);
            s42 = peg$parsewhitespace();
          }
          peg$savedPos = s0;
          s0 = peg$f7(s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsetrailing_comment() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsewhitespace();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parsewhitespace();
        }
        s22 = peg$parsesame_line_comment();
        if (s22 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f8(s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecomment_only_line() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parsewhitespace_or_parbreaks();
        s22 = peg$parseown_line_comment();
        if (s22 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f9(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsetoken() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$currPos;
        peg$silentFails++;
        s32 = peg$parsenon_token();
        peg$silentFails--;
        if (s32 === peg$FAILED) {
          s22 = void 0;
        } else {
          peg$currPos = s22;
          s22 = peg$FAILED;
        }
        if (s22 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s32 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s32 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s32 !== peg$FAILED) {
            s22 = [s22, s32];
            s1 = s22;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }
        return s0;
      }
      function peg$parsenon_whitespace_non_parbreak_token() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$currPos;
        peg$silentFails++;
        s32 = peg$parsewhitespace();
        if (s32 === peg$FAILED) {
          s32 = peg$parseparbreak();
        }
        peg$silentFails--;
        if (s32 === peg$FAILED) {
          s22 = void 0;
        } else {
          peg$currPos = s22;
          s22 = peg$FAILED;
        }
        if (s22 !== peg$FAILED) {
          s32 = peg$parseparen_block();
          if (s32 === peg$FAILED) {
            s32 = peg$parsetoken();
          }
          if (s32 !== peg$FAILED) {
            s22 = [s22, s32];
            s1 = s22;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }
        return s0;
      }
      function peg$parsenon_token() {
        var s0;
        s0 = peg$parseitem_sep();
        if (s0 === peg$FAILED) {
          s0 = peg$parseequals();
          if (s0 === peg$FAILED) {
            s0 = peg$parsetrailing_comment();
            if (s0 === peg$FAILED) {
              s0 = peg$parseown_line_comment();
            }
          }
        }
        return s0;
      }
      function peg$parsewhitespace_or_parbreaks() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsewhitespace();
        if (s22 === peg$FAILED) {
          s22 = peg$parseparbreak();
        }
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parsewhitespace();
          if (s22 === peg$FAILED) {
            s22 = peg$parseparbreak();
          }
        }
        peg$savedPos = s0;
        s1 = peg$f10(s1);
        s0 = s1;
        return s0;
      }
      function peg$parseparen_block() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8;
        s0 = peg$currPos;
        peg$savedPos = peg$currPos;
        s1 = peg$f11();
        if (s1) {
          s1 = peg$FAILED;
        } else {
          s1 = void 0;
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$currPos;
          s32 = peg$currPos;
          s42 = peg$parseopen_paren();
          if (s42 !== peg$FAILED) {
            s5 = [];
            s6 = peg$currPos;
            s7 = peg$currPos;
            peg$silentFails++;
            s8 = peg$parseclose_paren();
            peg$silentFails--;
            if (s8 === peg$FAILED) {
              s7 = void 0;
            } else {
              peg$currPos = s7;
              s7 = peg$FAILED;
            }
            if (s7 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s8 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s8 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              if (s8 !== peg$FAILED) {
                s7 = [s7, s8];
                s6 = s7;
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
            } else {
              peg$currPos = s6;
              s6 = peg$FAILED;
            }
            while (s6 !== peg$FAILED) {
              s5.push(s6);
              s6 = peg$currPos;
              s7 = peg$currPos;
              peg$silentFails++;
              s8 = peg$parseclose_paren();
              peg$silentFails--;
              if (s8 === peg$FAILED) {
                s7 = void 0;
              } else {
                peg$currPos = s7;
                s7 = peg$FAILED;
              }
              if (s7 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                  s8 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s8 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e0);
                  }
                }
                if (s8 !== peg$FAILED) {
                  s7 = [s7, s8];
                  s6 = s7;
                } else {
                  peg$currPos = s6;
                  s6 = peg$FAILED;
                }
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
            }
            s6 = peg$parseclose_paren();
            if (s6 !== peg$FAILED) {
              s42 = [s42, s5, s6];
              s32 = s42;
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          } else {
            peg$currPos = s32;
            s32 = peg$FAILED;
          }
          if (s32 !== peg$FAILED) {
            s22 = input.substring(s22, peg$currPos);
          } else {
            s22 = s32;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsesame_line_comment() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f12(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f13(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseown_line_comment() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f14(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f15(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsewhitespace() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f16(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f17(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseparbreak() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f18(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f19(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseitem_sep() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f20(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f21(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseequals() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f22(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f23(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseopen_paren() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f24(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f25(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseclose_paren() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f26(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f27(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseEOL() {
        var s0, s1;
        s0 = peg$currPos;
        peg$silentFails++;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        peg$silentFails--;
        if (s1 === peg$FAILED) {
          s0 = void 0;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function processItem(leadCell, otherCells) {
        const cells = [leadCell || []];
        for (const x of otherCells) {
          cells.push(x.cell || []);
        }
        return { itemParts: cells };
      }
      if (!options.isWhitespace) {
        try {
          Object.assign(options, {
            isChar: (node, char) => node.type === "string" && node.content === char,
            isComma(node) {
              return node.type === "string" && node.content === ",";
            },
            isEquals(node) {
              return node.type === "string" && node.content === "=";
            },
            isParbreak(node) {
              return node.type === "parbreak";
            },
            isWhitespace(node) {
              return node.type === "whitespace";
            },
            isSameLineComment: (node) => node.type === "comment" && node.sameline,
            isOwnLineComment: (node) => node.type === "comment" && !node.sameline,
            isComment: (node) => node.type === "comment",
            allowParenGroups: true
          });
        } catch (e) {
          console.warn("Error when initializing parser", e);
        }
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(
          peg$maxFailExpected,
          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
      }
    }
    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }()
);
var macro_substitutions_default2 = (
  // Generated by Peggy 2.0.1.
  //
  // https://peggyjs.org/
  function() {
    "use strict";
    function peg$subclass(child, parent) {
      function C() {
        this.constructor = child;
      }
      C.prototype = parent.prototype;
      child.prototype = new C();
    }
    function peg$SyntaxError(message, expected, found, location) {
      var self = Error.call(this, message);
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(self, peg$SyntaxError.prototype);
      }
      self.expected = expected;
      self.found = found;
      self.location = location;
      self.name = "SyntaxError";
      return self;
    }
    peg$subclass(peg$SyntaxError, Error);
    function peg$padEnd(str, targetLength, padString) {
      padString = padString || " ";
      if (str.length > targetLength) {
        return str;
      }
      targetLength -= str.length;
      padString += padString.repeat(targetLength);
      return str + padString.slice(0, targetLength);
    }
    peg$SyntaxError.prototype.format = function(sources) {
      var str = "Error: " + this.message;
      if (this.location) {
        var src = null;
        var k;
        for (k = 0; k < sources.length; k++) {
          if (sources[k].source === this.location.source) {
            src = sources[k].text.split(/\r\n|\n|\r/g);
            break;
          }
        }
        var s22 = this.location.start;
        var loc = this.location.source + ":" + s22.line + ":" + s22.column;
        if (src) {
          var e = this.location.end;
          var filler = peg$padEnd("", s22.line.toString().length, " ");
          var line = src[s22.line - 1];
          var last = s22.line === e.line ? e.column : line.length + 1;
          var hatLen = last - s22.column || 1;
          str += "\n --> " + loc + "\n" + filler + " |\n" + s22.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s22.column - 1, " ") + peg$padEnd("", hatLen, "^");
        } else {
          str += "\n at " + loc;
        }
      }
      return str;
    };
    peg$SyntaxError.buildMessage = function(expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        class: function(expectation) {
          var escapedParts = expectation.parts.map(function(part) {
            return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
          });
          return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
        },
        any: function() {
          return "any character";
        },
        end: function() {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        }
      };
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s22) {
        return s22.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function classEscape(s22) {
        return s22.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = expected2.map(describeExpectation);
        var i, j;
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {};
      var peg$source = options.grammarSource;
      var peg$startRuleFunctions = { body: peg$parsebody };
      var peg$startRuleFunction = peg$parsebody;
      var peg$e0 = peg$anyExpectation();
      var peg$f0 = function(e) {
        return [].concat(...e).filter((n) => !!n);
      };
      var peg$f1 = function() {
        return [];
      };
      var peg$f2 = function(tok) {
        return options.isHash(tok);
      };
      var peg$f3 = function(tok) {
        return tok;
      };
      var peg$f4 = function(tok) {
        return options.isNumber(tok);
      };
      var peg$f5 = function(tok) {
        return tok;
      };
      var peg$f6 = function() {
        return { type: "string", content: "#" };
      };
      var peg$f7 = function(num) {
        const split = options.splitNumber(num);
        return [{ type: "hash_number", number: split.number }, split.rest];
      };
      var peg$currPos = 0;
      var peg$savedPos = 0;
      var peg$posDetailsCache = [{ line: 1, column: 1 }];
      var peg$maxFailPos = 0;
      var peg$maxFailExpected = [];
      var peg$silentFails = 0;
      var peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function offset() {
        return peg$savedPos;
      }
      function range() {
        return {
          source: peg$source,
          start: peg$savedPos,
          end: peg$currPos
        };
      }
      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError(
          [peg$otherExpectation(description)],
          input.substring(peg$savedPos, peg$currPos),
          location2
        );
      }
      function error(message, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location2);
      }
      function peg$literalExpectation(text2, ignoreCase) {
        return { type: "literal", text: text2, ignoreCase };
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts, inverted, ignoreCase };
      }
      function peg$anyExpectation() {
        return { type: "any" };
      }
      function peg$endExpectation() {
        return { type: "end" };
      }
      function peg$otherExpectation(description) {
        return { type: "other", description };
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p;
        if (details) {
          return details;
        } else {
          p = pos - 1;
          while (!peg$posDetailsCache[p]) {
            p--;
          }
          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };
          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos);
        var endPosDetails = peg$computePosDetails(endPos);
        return {
          source: peg$source,
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildSimpleError(message, location2) {
        return new peg$SyntaxError(message, null, null, location2);
      }
      function peg$buildStructuredError(expected2, found, location2) {
        return new peg$SyntaxError(
          peg$SyntaxError.buildMessage(expected2, found),
          expected2,
          found,
          location2
        );
      }
      function peg$parsebody() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsedouble_hash();
        if (s22 === peg$FAILED) {
          s22 = peg$parsehash_number();
          if (s22 === peg$FAILED) {
            if (input.length > peg$currPos) {
              s22 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s22 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
          }
        }
        if (s22 !== peg$FAILED) {
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            s22 = peg$parsedouble_hash();
            if (s22 === peg$FAILED) {
              s22 = peg$parsehash_number();
              if (s22 === peg$FAILED) {
                if (input.length > peg$currPos) {
                  s22 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s22 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e0);
                  }
                }
              }
            }
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f0(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseEOL();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f1();
          }
          s0 = s1;
        }
        return s0;
      }
      function peg$parsehash() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f2(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f3(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsenumber() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f4(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f5(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsedouble_hash() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parsehash();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsehash();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f6();
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsehash_number() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parsehash();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsenumber();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f7(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseEOL() {
        var s0, s1;
        s0 = peg$currPos;
        peg$silentFails++;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        peg$silentFails--;
        if (s1 === peg$FAILED) {
          s0 = void 0;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      if (!options.isHash) {
        try {
          Object.assign(options, {
            isHash: (node) => node.type === "string" && node.content === "#",
            isNumber: (node) => node.type === "string" && 0 < +node.content.charAt(0),
            splitNumber: (node) => {
              const number = +node.content.charAt(0);
              if (node.content.length > 1) {
                return {
                  number,
                  rest: {
                    type: "string",
                    content: node.content.slice(1)
                  }
                };
              }
              return { number };
            }
          });
        } catch (e) {
          console.warn("Error when initializing parser", e);
        }
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(
          peg$maxFailExpected,
          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
      }
    }
    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }()
);
var ligatures_default2 = (
  // Generated by Peggy 2.0.1.
  //
  // https://peggyjs.org/
  function() {
    "use strict";
    function peg$subclass(child, parent) {
      function C() {
        this.constructor = child;
      }
      C.prototype = parent.prototype;
      child.prototype = new C();
    }
    function peg$SyntaxError(message, expected, found, location) {
      var self = Error.call(this, message);
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(self, peg$SyntaxError.prototype);
      }
      self.expected = expected;
      self.found = found;
      self.location = location;
      self.name = "SyntaxError";
      return self;
    }
    peg$subclass(peg$SyntaxError, Error);
    function peg$padEnd(str, targetLength, padString) {
      padString = padString || " ";
      if (str.length > targetLength) {
        return str;
      }
      targetLength -= str.length;
      padString += padString.repeat(targetLength);
      return str + padString.slice(0, targetLength);
    }
    peg$SyntaxError.prototype.format = function(sources) {
      var str = "Error: " + this.message;
      if (this.location) {
        var src = null;
        var k;
        for (k = 0; k < sources.length; k++) {
          if (sources[k].source === this.location.source) {
            src = sources[k].text.split(/\r\n|\n|\r/g);
            break;
          }
        }
        var s22 = this.location.start;
        var loc = this.location.source + ":" + s22.line + ":" + s22.column;
        if (src) {
          var e = this.location.end;
          var filler = peg$padEnd("", s22.line.toString().length, " ");
          var line = src[s22.line - 1];
          var last = s22.line === e.line ? e.column : line.length + 1;
          var hatLen = last - s22.column || 1;
          str += "\n --> " + loc + "\n" + filler + " |\n" + s22.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s22.column - 1, " ") + peg$padEnd("", hatLen, "^");
        } else {
          str += "\n at " + loc;
        }
      }
      return str;
    };
    peg$SyntaxError.buildMessage = function(expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        class: function(expectation) {
          var escapedParts = expectation.parts.map(function(part) {
            return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
          });
          return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
        },
        any: function() {
          return "any character";
        },
        end: function() {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        }
      };
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s22) {
        return s22.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function classEscape(s22) {
        return s22.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = expected2.map(describeExpectation);
        var i, j;
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {};
      var peg$source = options.grammarSource;
      var peg$startRuleFunctions = { body: peg$parsebody };
      var peg$startRuleFunction = peg$parsebody;
      var peg$e0 = peg$anyExpectation();
      var peg$f0 = function(e) {
        return [].concat(...e).filter((n) => !!n);
      };
      var peg$f1 = function() {
        return [];
      };
      var peg$f2 = function(toks) {
        return options.isRecognized(toks);
      };
      var peg$f3 = function(toks) {
        return options.isRecognized(toks);
      };
      var peg$f4 = function(tok1, tok2) {
        const split = options.split(tok2);
        return options.isRecognized([tok1, split[0]]);
      };
      var peg$f5 = function(tok1, tok2) {
        const split = options.split(tok2);
        return [options.isRecognized([tok1, split[0]]), split[1]];
      };
      var peg$f6 = function(tok1, tok2) {
        return options.isRecognized([tok1, tok2]);
      };
      var peg$f7 = function(tok1, tok2) {
        return options.isRecognized([tok1, tok2]);
      };
      var peg$f8 = function(toks) {
        return options.isRecognized(toks);
      };
      var peg$f9 = function(toks) {
        return options.isRecognized(toks);
      };
      var peg$f10 = function(tok) {
        return options.isRecognized([tok]);
      };
      var peg$f11 = function(tok) {
        return options.isRecognized([tok]);
      };
      var peg$f12 = function(tok) {
        return options.isMacro(tok);
      };
      var peg$f13 = function(tok) {
        return tok;
      };
      var peg$f14 = function(tok) {
        return options.isWhitespace(tok);
      };
      var peg$f15 = function(tok) {
        return tok;
      };
      var peg$f16 = function(tok) {
        return options.isSplitable(tok);
      };
      var peg$f17 = function(tok) {
        return tok;
      };
      var peg$currPos = 0;
      var peg$savedPos = 0;
      var peg$posDetailsCache = [{ line: 1, column: 1 }];
      var peg$maxFailPos = 0;
      var peg$maxFailExpected = [];
      var peg$silentFails = 0;
      var peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function offset() {
        return peg$savedPos;
      }
      function range() {
        return {
          source: peg$source,
          start: peg$savedPos,
          end: peg$currPos
        };
      }
      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError(
          [peg$otherExpectation(description)],
          input.substring(peg$savedPos, peg$currPos),
          location2
        );
      }
      function error(message, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location2);
      }
      function peg$literalExpectation(text2, ignoreCase) {
        return { type: "literal", text: text2, ignoreCase };
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts, inverted, ignoreCase };
      }
      function peg$anyExpectation() {
        return { type: "any" };
      }
      function peg$endExpectation() {
        return { type: "end" };
      }
      function peg$otherExpectation(description) {
        return { type: "other", description };
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p;
        if (details) {
          return details;
        } else {
          p = pos - 1;
          while (!peg$posDetailsCache[p]) {
            p--;
          }
          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };
          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos);
        var endPosDetails = peg$computePosDetails(endPos);
        return {
          source: peg$source,
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildSimpleError(message, location2) {
        return new peg$SyntaxError(message, null, null, location2);
      }
      function peg$buildStructuredError(expected2, found, location2) {
        return new peg$SyntaxError(
          peg$SyntaxError.buildMessage(expected2, found),
          expected2,
          found,
          location2
        );
      }
      function peg$parsebody() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsetriple_ligature();
        if (s22 === peg$FAILED) {
          s22 = peg$parsedouble_ligature();
          if (s22 === peg$FAILED) {
            s22 = peg$parsemono_ligature();
            if (s22 === peg$FAILED) {
              if (input.length > peg$currPos) {
                s22 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s22 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
            }
          }
        }
        if (s22 !== peg$FAILED) {
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            s22 = peg$parsetriple_ligature();
            if (s22 === peg$FAILED) {
              s22 = peg$parsedouble_ligature();
              if (s22 === peg$FAILED) {
                s22 = peg$parsemono_ligature();
                if (s22 === peg$FAILED) {
                  if (input.length > peg$currPos) {
                    s22 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s22 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e0);
                    }
                  }
                }
              }
            }
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f0(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseEOL();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f1();
          }
          s0 = s1;
        }
        return s0;
      }
      function peg$parsetriple_ligature() {
        var s0, s1, s22, s32, s42;
        s0 = peg$currPos;
        s1 = peg$currPos;
        if (input.length > peg$currPos) {
          s22 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s22 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s22 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s32 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s32 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s32 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s42 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s42 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            if (s42 !== peg$FAILED) {
              s22 = [s22, s32, s42];
              s1 = s22;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f2(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f3(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsedouble_ligature() {
        var s0;
        s0 = peg$parsedouble_macro_ligature();
        if (s0 === peg$FAILED) {
          s0 = peg$parsedouble_macro_ligature_extracted();
          if (s0 === peg$FAILED) {
            s0 = peg$parsedouble_char_ligature();
          }
        }
        return s0;
      }
      function peg$parsedouble_macro_ligature_extracted() {
        var s0, s1, s22, s32, s42;
        s0 = peg$currPos;
        s1 = peg$parsemacro();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$parsewhitespace();
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parsewhitespace();
          }
          s32 = peg$parsesplitable();
          if (s32 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s42 = peg$f4(s1, s32);
            if (s42) {
              s42 = void 0;
            } else {
              s42 = peg$FAILED;
            }
            if (s42 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f5(s1, s32);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsedouble_macro_ligature() {
        var s0, s1, s22, s32, s42;
        s0 = peg$currPos;
        s1 = peg$parsemacro();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$parsewhitespace();
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parsewhitespace();
          }
          if (input.length > peg$currPos) {
            s32 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s32 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s32 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s42 = peg$f6(s1, s32);
            if (s42) {
              s42 = void 0;
            } else {
              s42 = peg$FAILED;
            }
            if (s42 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f7(s1, s32);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsedouble_char_ligature() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$currPos;
        if (input.length > peg$currPos) {
          s22 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s22 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s22 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s32 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s32 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s32 !== peg$FAILED) {
            s22 = [s22, s32];
            s1 = s22;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f8(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f9(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsemono_ligature() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f10(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f11(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsemacro() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f12(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f13(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsewhitespace() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f14(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f15(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsesplitable() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f16(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f17(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseEOL() {
        var s0, s1;
        s0 = peg$currPos;
        peg$silentFails++;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        peg$silentFails--;
        if (s1 === peg$FAILED) {
          s0 = void 0;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      if (!options.isWhitespace) {
        try {
          Object.assign(options, {
            isMacro: (node) => node.type === "macro",
            isWhitespace: (node) => node.type === "whitespace",
            isRecognized: (nodes) => {
              if (nodes.length == 2 && nodes[0].content === "^" && nodes[1].content === "o") {
                return { type: "string", content: "\xF4" };
              }
              return null;
            },
            isSplitable: (node) => node.type === "string" && node.content.length > 1,
            split: (node) => [
              { type: "string", content: node.content.charAt(0) },
              { type: "string", content: node.content.slice(1) }
            ]
          });
        } catch (e) {
          console.warn("Error when initializing parser", e);
        }
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(
          peg$maxFailExpected,
          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
      }
    }
    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }()
);
var xcolor_expressions_default2 = (
  // Generated by Peggy 2.0.1.
  //
  // https://peggyjs.org/
  function() {
    "use strict";
    function peg$subclass(child, parent) {
      function C() {
        this.constructor = child;
      }
      C.prototype = parent.prototype;
      child.prototype = new C();
    }
    function peg$SyntaxError(message, expected, found, location) {
      var self = Error.call(this, message);
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(self, peg$SyntaxError.prototype);
      }
      self.expected = expected;
      self.found = found;
      self.location = location;
      self.name = "SyntaxError";
      return self;
    }
    peg$subclass(peg$SyntaxError, Error);
    function peg$padEnd(str, targetLength, padString) {
      padString = padString || " ";
      if (str.length > targetLength) {
        return str;
      }
      targetLength -= str.length;
      padString += padString.repeat(targetLength);
      return str + padString.slice(0, targetLength);
    }
    peg$SyntaxError.prototype.format = function(sources) {
      var str = "Error: " + this.message;
      if (this.location) {
        var src = null;
        var k;
        for (k = 0; k < sources.length; k++) {
          if (sources[k].source === this.location.source) {
            src = sources[k].text.split(/\r\n|\n|\r/g);
            break;
          }
        }
        var s22 = this.location.start;
        var loc = this.location.source + ":" + s22.line + ":" + s22.column;
        if (src) {
          var e = this.location.end;
          var filler = peg$padEnd("", s22.line.toString().length, " ");
          var line = src[s22.line - 1];
          var last = s22.line === e.line ? e.column : line.length + 1;
          var hatLen = last - s22.column || 1;
          str += "\n --> " + loc + "\n" + filler + " |\n" + s22.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s22.column - 1, " ") + peg$padEnd("", hatLen, "^");
        } else {
          str += "\n at " + loc;
        }
      }
      return str;
    };
    peg$SyntaxError.buildMessage = function(expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        class: function(expectation) {
          var escapedParts = expectation.parts.map(function(part) {
            return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
          });
          return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
        },
        any: function() {
          return "any character";
        },
        end: function() {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        }
      };
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s22) {
        return s22.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function classEscape(s22) {
        return s22.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = expected2.map(describeExpectation);
        var i, j;
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {};
      var peg$source = options.grammarSource;
      var peg$startRuleFunctions = { start: peg$parsestart };
      var peg$startRuleFunction = peg$parsestart;
      var peg$c0 = ";";
      var peg$c1 = ",";
      var peg$c2 = ":";
      var peg$c3 = "/";
      var peg$c4 = ">";
      var peg$c5 = "!";
      var peg$c6 = ".";
      var peg$c7 = "!![";
      var peg$c8 = "]";
      var peg$c9 = "!!";
      var peg$c10 = "+";
      var peg$c11 = "-";
      var peg$r0 = /^[a-zA-Z0-9]/;
      var peg$r1 = /^[0-9]/;
      var peg$r2 = /^[ \t\n\r]/;
      var peg$r3 = /^[0-9a-fA-F]/;
      var peg$e0 = peg$anyExpectation();
      var peg$e1 = peg$literalExpectation(";", false);
      var peg$e2 = peg$literalExpectation(",", false);
      var peg$e3 = peg$otherExpectation("model list");
      var peg$e4 = peg$literalExpectation(":", false);
      var peg$e5 = peg$literalExpectation("/", false);
      var peg$e6 = peg$otherExpectation("model");
      var peg$e7 = peg$otherExpectation("color spec list");
      var peg$e8 = peg$otherExpectation("color spec");
      var peg$e9 = peg$otherExpectation("color");
      var peg$e10 = peg$otherExpectation("function expression");
      var peg$e11 = peg$literalExpectation(">", false);
      var peg$e12 = peg$otherExpectation("function");
      var peg$e13 = peg$otherExpectation("extended expression");
      var peg$e14 = peg$otherExpectation("core model");
      var peg$e15 = peg$otherExpectation("expr");
      var peg$e16 = peg$literalExpectation("!", false);
      var peg$e17 = peg$otherExpectation("mix expr");
      var peg$e18 = peg$otherExpectation("name");
      var peg$e19 = peg$literalExpectation(".", false);
      var peg$e20 = peg$classExpectation([["a", "z"], ["A", "Z"], ["0", "9"]], false, false);
      var peg$e21 = peg$otherExpectation("postfix");
      var peg$e22 = peg$literalExpectation("!![", false);
      var peg$e23 = peg$literalExpectation("]", false);
      var peg$e24 = peg$literalExpectation("!!", false);
      var peg$e25 = peg$otherExpectation("prefix");
      var peg$e26 = peg$otherExpectation("plus");
      var peg$e27 = peg$literalExpectation("+", false);
      var peg$e28 = peg$otherExpectation("minus");
      var peg$e29 = peg$literalExpectation("-", false);
      var peg$e30 = peg$otherExpectation("num");
      var peg$e31 = peg$classExpectation([["0", "9"]], false, false);
      var peg$e32 = peg$otherExpectation("positive float");
      var peg$e33 = peg$otherExpectation("divisor");
      var peg$e34 = peg$otherExpectation("int");
      var peg$e35 = peg$otherExpectation("whitespace");
      var peg$e36 = peg$classExpectation([" ", "	", "\n", "\r"], false, false);
      var peg$e37 = peg$classExpectation([["0", "9"], ["a", "f"], ["A", "F"]], false, false);
      var peg$f0 = function(m) {
        return m;
      };
      var peg$f1 = function(m) {
        return m;
      };
      var peg$f2 = function(m) {
        return m;
      };
      var peg$f3 = function(m) {
        return m;
      };
      var peg$f4 = function(m) {
        return m;
      };
      var peg$f5 = function(a) {
        return { type: "invalid_spec", content: a };
      };
      var peg$f6 = function(f, c) {
        return c;
      };
      var peg$f7 = function(f, r) {
        return { type: "color_set", content: [f].concat(r) };
      };
      var peg$f8 = function(n, s22) {
        return { type: "color_set_item", name: n, spec_list: s22 };
      };
      var peg$f9 = function(c, m) {
        return { type: "model_list", contents: m, core_model: c };
      };
      var peg$f10 = function(m) {
        return { type: "model_list", contents: m, core_model: null };
      };
      var peg$f11 = function(m, a) {
        return a;
      };
      var peg$f12 = function(m, r) {
        return [m].concat(r);
      };
      var peg$f13 = function(s22, a) {
        return a;
      };
      var peg$f14 = function(s22, r) {
        return { type: "spec_list", content: [s22].concat(r) };
      };
      var peg$f15 = function(c) {
        return { type: "hex_spec", content: [c] };
      };
      var peg$f16 = function(c, d) {
        return d;
      };
      var peg$f17 = function(c, d) {
        return d;
      };
      var peg$f18 = function(c, r) {
        return { type: "num_spec", content: r ? [c].concat(r) : [c] };
      };
      var peg$f19 = function(c, fs) {
        return { type: "color", color: c, functions: fs };
      };
      var peg$f20 = function(f, n) {
        return n;
      };
      var peg$f21 = function(f, args) {
        return { type: "function", name: f, args };
      };
      var peg$f22 = function(core, d, e, es) {
        return {
          type: "extended_expr",
          core_model: core,
          div: d,
          expressions: [e].concat(es)
        };
      };
      var peg$f23 = function(core, e, es) {
        return {
          type: "extended_expr",
          core_model: core,
          div: null,
          expressions: [e].concat(es)
        };
      };
      var peg$f24 = function(e, d) {
        return { type: "weighted_expr", color: e, weight: d };
      };
      var peg$f25 = function(e) {
        return e;
      };
      var peg$f26 = function(p, n, e, po) {
        return {
          type: "expr",
          prefix: p,
          name: n,
          mix_expr: e,
          postfix: po
        };
      };
      var peg$f27 = function(p, n) {
        return { type: "complete_mix", mix_percent: p, name: n };
      };
      var peg$f28 = function(p) {
        return { type: "partial_mix", mix_percent: p };
      };
      var peg$f29 = function(c, p) {
        return c.concat(p || []);
      };
      var peg$f30 = function(n) {
        return { type: "postfix", num: n };
      };
      var peg$f31 = function(p) {
        return { type: "postfix", plusses: p };
      };
      var peg$f32 = function(n) {
        return parseInt(n, 10);
      };
      var peg$f33 = function(n) {
        return parseFloat(n);
      };
      var peg$f34 = function(n) {
        return n;
      };
      var peg$f35 = function(n) {
        return -n;
      };
      var peg$f36 = function(m, n) {
        return m ? -n : n;
      };
      var peg$f37 = function(h) {
        return h.toUpperCase();
      };
      var peg$currPos = 0;
      var peg$savedPos = 0;
      var peg$posDetailsCache = [{ line: 1, column: 1 }];
      var peg$maxFailPos = 0;
      var peg$maxFailExpected = [];
      var peg$silentFails = 0;
      var peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function offset() {
        return peg$savedPos;
      }
      function range() {
        return {
          source: peg$source,
          start: peg$savedPos,
          end: peg$currPos
        };
      }
      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError(
          [peg$otherExpectation(description)],
          input.substring(peg$savedPos, peg$currPos),
          location2
        );
      }
      function error(message, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location2);
      }
      function peg$literalExpectation(text2, ignoreCase) {
        return { type: "literal", text: text2, ignoreCase };
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts, inverted, ignoreCase };
      }
      function peg$anyExpectation() {
        return { type: "any" };
      }
      function peg$endExpectation() {
        return { type: "end" };
      }
      function peg$otherExpectation(description) {
        return { type: "other", description };
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p;
        if (details) {
          return details;
        } else {
          p = pos - 1;
          while (!peg$posDetailsCache[p]) {
            p--;
          }
          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };
          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos);
        var endPosDetails = peg$computePosDetails(endPos);
        return {
          source: peg$source,
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildSimpleError(message, location2) {
        return new peg$SyntaxError(message, null, null, location2);
      }
      function peg$buildStructuredError(expected2, found, location2) {
        return new peg$SyntaxError(
          peg$SyntaxError.buildMessage(expected2, found),
          expected2,
          found,
          location2
        );
      }
      function peg$parsestart() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$parsespec();
        if (s1 !== peg$FAILED) {
          s22 = peg$parseEOL();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f0(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsespec_list();
          if (s1 !== peg$FAILED) {
            s22 = peg$parseEOL();
            if (s22 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f1(s1);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsecolor();
            if (s1 !== peg$FAILED) {
              s22 = peg$parseEOL();
              if (s22 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f2(s1);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parsemodel_list();
              if (s1 !== peg$FAILED) {
                s22 = peg$parseEOL();
                if (s22 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s0 = peg$f3(s1);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parsecolor_set_spec();
                if (s1 !== peg$FAILED) {
                  s22 = peg$parseEOL();
                  if (s22 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s0 = peg$f4(s1);
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  s1 = peg$currPos;
                  s22 = [];
                  if (input.length > peg$currPos) {
                    s32 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s32 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e0);
                    }
                  }
                  while (s32 !== peg$FAILED) {
                    s22.push(s32);
                    if (input.length > peg$currPos) {
                      s32 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s32 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e0);
                      }
                    }
                  }
                  s1 = input.substring(s1, peg$currPos);
                  peg$savedPos = s0;
                  s1 = peg$f5(s1);
                  s0 = s1;
                }
              }
            }
          }
        }
        return s0;
      }
      function peg$parsecolor_set_spec() {
        var s0, s1, s22, s32, s42, s5;
        s0 = peg$currPos;
        s1 = peg$parsecolor_set_item();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 59) {
            s42 = peg$c0;
            peg$currPos++;
          } else {
            s42 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e1);
            }
          }
          if (s42 !== peg$FAILED) {
            s5 = peg$parsecolor_set_item();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s32;
              s32 = peg$f6(s1, s5);
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          } else {
            peg$currPos = s32;
            s32 = peg$FAILED;
          }
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 59) {
              s42 = peg$c0;
              peg$currPos++;
            } else {
              s42 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e1);
              }
            }
            if (s42 !== peg$FAILED) {
              s5 = peg$parsecolor_set_item();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s32;
                s32 = peg$f6(s1, s5);
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          }
          peg$savedPos = s0;
          s0 = peg$f7(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecolor_set_item() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$parsename();
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 44) {
            s22 = peg$c1;
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          if (s22 !== peg$FAILED) {
            s32 = peg$parsespec_list();
            if (s32 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f8(s1, s32);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsemodel_list() {
        var s0, s1, s22, s32;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parsecore_model();
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 58) {
            s22 = peg$c2;
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e4);
            }
          }
          if (s22 !== peg$FAILED) {
            s32 = peg$parsemodel_list_tail();
            if (s32 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f9(s1, s32);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsemodel_list_tail();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f10(s1);
          }
          s0 = s1;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        return s0;
      }
      function peg$parsemodel_list_tail() {
        var s0, s1, s22, s32, s42, s5;
        s0 = peg$currPos;
        s1 = peg$parsemodel();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 47) {
            s42 = peg$c3;
            peg$currPos++;
          } else {
            s42 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e5);
            }
          }
          if (s42 !== peg$FAILED) {
            s5 = peg$parsemodel();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s32;
              s32 = peg$f11(s1, s5);
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          } else {
            peg$currPos = s32;
            s32 = peg$FAILED;
          }
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 47) {
              s42 = peg$c3;
              peg$currPos++;
            } else {
              s42 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e5);
              }
            }
            if (s42 !== peg$FAILED) {
              s5 = peg$parsemodel();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s32;
                s32 = peg$f11(s1, s5);
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          }
          peg$savedPos = s0;
          s0 = peg$f12(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsemodel() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parsecore_model();
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e6);
          }
        }
        return s0;
      }
      function peg$parsespec_list() {
        var s0, s1, s22, s32, s42, s5;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parsespec();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 47) {
            s42 = peg$c3;
            peg$currPos++;
          } else {
            s42 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e5);
            }
          }
          if (s42 !== peg$FAILED) {
            s5 = peg$parsespec();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s32;
              s32 = peg$f13(s1, s5);
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          } else {
            peg$currPos = s32;
            s32 = peg$FAILED;
          }
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 47) {
              s42 = peg$c3;
              peg$currPos++;
            } else {
              s42 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e5);
              }
            }
            if (s42 !== peg$FAILED) {
              s5 = peg$parsespec();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s32;
                s32 = peg$f13(s1, s5);
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          }
          peg$savedPos = s0;
          s0 = peg$f14(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e7);
          }
        }
        return s0;
      }
      function peg$parsespec() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$currPos;
        s32 = peg$parsehex();
        if (s32 !== peg$FAILED) {
          s42 = peg$parsehex();
          if (s42 !== peg$FAILED) {
            s5 = peg$parsehex();
            if (s5 !== peg$FAILED) {
              s6 = peg$parsehex();
              if (s6 !== peg$FAILED) {
                s7 = peg$parsehex();
                if (s7 !== peg$FAILED) {
                  s8 = peg$parsehex();
                  if (s8 !== peg$FAILED) {
                    s32 = [s32, s42, s5, s6, s7, s8];
                    s22 = s32;
                  } else {
                    peg$currPos = s22;
                    s22 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s22;
                  s22 = peg$FAILED;
                }
              } else {
                peg$currPos = s22;
                s22 = peg$FAILED;
              }
            } else {
              peg$currPos = s22;
              s22 = peg$FAILED;
            }
          } else {
            peg$currPos = s22;
            s22 = peg$FAILED;
          }
        } else {
          peg$currPos = s22;
          s22 = peg$FAILED;
        }
        if (s22 !== peg$FAILED) {
          s1 = input.substring(s1, peg$currPos);
        } else {
          s1 = s22;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f15(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsedec();
          if (s1 !== peg$FAILED) {
            s22 = [];
            s32 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 44) {
              s42 = peg$c1;
              peg$currPos++;
            } else {
              s42 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e2);
              }
            }
            if (s42 !== peg$FAILED) {
              s5 = peg$parsedec();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s32;
                s32 = peg$f16(s1, s5);
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
            if (s32 !== peg$FAILED) {
              while (s32 !== peg$FAILED) {
                s22.push(s32);
                s32 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 44) {
                  s42 = peg$c1;
                  peg$currPos++;
                } else {
                  s42 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e2);
                  }
                }
                if (s42 !== peg$FAILED) {
                  s5 = peg$parsedec();
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s32;
                    s32 = peg$f16(s1, s5);
                  } else {
                    peg$currPos = s32;
                    s32 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s32;
                  s32 = peg$FAILED;
                }
              }
            } else {
              s22 = peg$FAILED;
            }
            if (s22 === peg$FAILED) {
              s22 = [];
              s32 = peg$currPos;
              s42 = peg$parsesp();
              if (s42 !== peg$FAILED) {
                s5 = peg$parsedec();
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s32;
                  s32 = peg$f17(s1, s5);
                } else {
                  peg$currPos = s32;
                  s32 = peg$FAILED;
                }
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
              if (s32 !== peg$FAILED) {
                while (s32 !== peg$FAILED) {
                  s22.push(s32);
                  s32 = peg$currPos;
                  s42 = peg$parsesp();
                  if (s42 !== peg$FAILED) {
                    s5 = peg$parsedec();
                    if (s5 !== peg$FAILED) {
                      peg$savedPos = s32;
                      s32 = peg$f17(s1, s5);
                    } else {
                      peg$currPos = s32;
                      s32 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s32;
                    s32 = peg$FAILED;
                  }
                }
              } else {
                s22 = peg$FAILED;
              }
            }
            if (s22 === peg$FAILED) {
              s22 = null;
            }
            peg$savedPos = s0;
            s0 = peg$f18(s1, s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e8);
          }
        }
        return s0;
      }
      function peg$parsecolor() {
        var s0, s1, s22, s32;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parsecolor_expr();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$parsefunc_expr();
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parsefunc_expr();
          }
          peg$savedPos = s0;
          s0 = peg$f19(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e9);
          }
        }
        return s0;
      }
      function peg$parsecolor_expr() {
        var s0;
        s0 = peg$parseext_expr();
        if (s0 === peg$FAILED) {
          s0 = peg$parseexpr();
          if (s0 === peg$FAILED) {
            s0 = peg$parsename();
          }
        }
        return s0;
      }
      function peg$parsefunc_expr() {
        var s0, s1, s22, s32, s42, s5, s6;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 62) {
          s1 = peg$c4;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e11);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parsefunction();
          if (s22 !== peg$FAILED) {
            s32 = [];
            s42 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 44) {
              s5 = peg$c1;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e2);
              }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parseint();
              if (s6 !== peg$FAILED) {
                peg$savedPos = s42;
                s42 = peg$f20(s22, s6);
              } else {
                peg$currPos = s42;
                s42 = peg$FAILED;
              }
            } else {
              peg$currPos = s42;
              s42 = peg$FAILED;
            }
            while (s42 !== peg$FAILED) {
              s32.push(s42);
              s42 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 44) {
                s5 = peg$c1;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e2);
                }
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parseint();
                if (s6 !== peg$FAILED) {
                  peg$savedPos = s42;
                  s42 = peg$f20(s22, s6);
                } else {
                  peg$currPos = s42;
                  s42 = peg$FAILED;
                }
              } else {
                peg$currPos = s42;
                s42 = peg$FAILED;
              }
            }
            peg$savedPos = s0;
            s0 = peg$f21(s22, s32);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e10);
          }
        }
        return s0;
      }
      function peg$parsefunction() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parsename();
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e12);
          }
        }
        return s0;
      }
      function peg$parseext_expr() {
        var s0, s1, s22, s32, s42, s5, s6, s7;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parsecore_model();
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 44) {
            s22 = peg$c1;
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          if (s22 !== peg$FAILED) {
            s32 = peg$parsediv();
            if (s32 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 58) {
                s42 = peg$c2;
                peg$currPos++;
              } else {
                s42 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e4);
                }
              }
              if (s42 !== peg$FAILED) {
                s5 = peg$parseweighted_expr();
                if (s5 !== peg$FAILED) {
                  s6 = [];
                  s7 = peg$parseadditional_weighted_expr();
                  while (s7 !== peg$FAILED) {
                    s6.push(s7);
                    s7 = peg$parseadditional_weighted_expr();
                  }
                  peg$savedPos = s0;
                  s0 = peg$f22(s1, s32, s5, s6);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsecore_model();
          if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 58) {
              s22 = peg$c2;
              peg$currPos++;
            } else {
              s22 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e4);
              }
            }
            if (s22 !== peg$FAILED) {
              s32 = peg$parseweighted_expr();
              if (s32 !== peg$FAILED) {
                s42 = [];
                s5 = peg$parseadditional_weighted_expr();
                while (s5 !== peg$FAILED) {
                  s42.push(s5);
                  s5 = peg$parseadditional_weighted_expr();
                }
                peg$savedPos = s0;
                s0 = peg$f23(s1, s32, s42);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e13);
          }
        }
        return s0;
      }
      function peg$parseweighted_expr() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$parseexpr();
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 44) {
            s22 = peg$c1;
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          if (s22 !== peg$FAILED) {
            s32 = peg$parsedec();
            if (s32 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f24(s1, s32);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseadditional_weighted_expr() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 59) {
          s1 = peg$c0;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e1);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parseweighted_expr();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f25(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecore_model() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parsename();
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e14);
          }
        }
        return s0;
      }
      function peg$parseexpr() {
        var s0, s1, s22, s32, s42;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parseprefix();
        s22 = peg$parsename();
        if (s22 !== peg$FAILED) {
          s32 = peg$parsemix_expr();
          s42 = peg$parsepostfix();
          if (s42 === peg$FAILED) {
            s42 = null;
          }
          peg$savedPos = s0;
          s0 = peg$f26(s1, s22, s32, s42);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e15);
          }
        }
        return s0;
      }
      function peg$parsecomplete_mix() {
        var s0, s1, s22, s32, s42;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 33) {
          s1 = peg$c5;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e16);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parsepct();
          if (s22 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 33) {
              s32 = peg$c5;
              peg$currPos++;
            } else {
              s32 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e16);
              }
            }
            if (s32 !== peg$FAILED) {
              s42 = peg$parsename();
              if (s42 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f27(s22, s42);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsepartial_mix() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 33) {
          s1 = peg$c5;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e16);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parsepct();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f28(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsemix_expr() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsecomplete_mix();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parsecomplete_mix();
        }
        s22 = peg$parsepartial_mix();
        if (s22 === peg$FAILED) {
          s22 = null;
        }
        peg$savedPos = s0;
        s0 = peg$f29(s1, s22);
        peg$silentFails--;
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e17);
        }
        return s0;
      }
      function peg$parsename() {
        var s0, s1, s22;
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 46) {
          s0 = peg$c6;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e19);
          }
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = [];
          if (peg$r0.test(input.charAt(peg$currPos))) {
            s22 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e20);
            }
          }
          if (s22 !== peg$FAILED) {
            while (s22 !== peg$FAILED) {
              s1.push(s22);
              if (peg$r0.test(input.charAt(peg$currPos))) {
                s22 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s22 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e20);
                }
              }
            }
          } else {
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            s0 = input.substring(s0, peg$currPos);
          } else {
            s0 = s1;
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e18);
          }
        }
        return s0;
      }
      function peg$parsepostfix() {
        var s0, s1, s22, s32, s42;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 3) === peg$c7) {
          s1 = peg$c7;
          peg$currPos += 3;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e22);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parsenum();
          if (s22 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 93) {
              s32 = peg$c8;
              peg$currPos++;
            } else {
              s32 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e23);
              }
            }
            if (s32 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f30(s22);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c9) {
            s1 = peg$c9;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e24);
            }
          }
          if (s1 !== peg$FAILED) {
            s22 = peg$currPos;
            s32 = [];
            s42 = peg$parseplus();
            if (s42 !== peg$FAILED) {
              while (s42 !== peg$FAILED) {
                s32.push(s42);
                s42 = peg$parseplus();
              }
            } else {
              s32 = peg$FAILED;
            }
            if (s32 !== peg$FAILED) {
              s22 = input.substring(s22, peg$currPos);
            } else {
              s22 = s32;
            }
            if (s22 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f31(s22);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e21);
          }
        }
        return s0;
      }
      function peg$parseprefix() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parseminus();
        if (s0 === peg$FAILED) {
          s0 = null;
        }
        peg$silentFails--;
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e25);
        }
        return s0;
      }
      function peg$parseplus() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        if (input.charCodeAt(peg$currPos) === 43) {
          s22 = peg$c10;
          peg$currPos++;
        } else {
          s22 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e27);
          }
        }
        if (s22 !== peg$FAILED) {
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            if (input.charCodeAt(peg$currPos) === 43) {
              s22 = peg$c10;
              peg$currPos++;
            } else {
              s22 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e27);
              }
            }
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e26);
          }
        }
        return s0;
      }
      function peg$parseminus() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        if (input.charCodeAt(peg$currPos) === 45) {
          s22 = peg$c11;
          peg$currPos++;
        } else {
          s22 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e29);
          }
        }
        if (s22 !== peg$FAILED) {
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            if (input.charCodeAt(peg$currPos) === 45) {
              s22 = peg$c11;
              peg$currPos++;
            } else {
              s22 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e29);
              }
            }
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e28);
          }
        }
        return s0;
      }
      function peg$parsenum() {
        var s0, s1, s22, s32;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = [];
        if (peg$r1.test(input.charAt(peg$currPos))) {
          s32 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s32 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e31);
          }
        }
        if (s32 !== peg$FAILED) {
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            if (peg$r1.test(input.charAt(peg$currPos))) {
              s32 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s32 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e31);
              }
            }
          }
        } else {
          s22 = peg$FAILED;
        }
        if (s22 !== peg$FAILED) {
          s1 = input.substring(s1, peg$currPos);
        } else {
          s1 = s22;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f32(s1);
        }
        s0 = s1;
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e30);
          }
        }
        return s0;
      }
      function peg$parsepct() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8, s9;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$currPos;
        s32 = peg$currPos;
        s42 = [];
        if (peg$r1.test(input.charAt(peg$currPos))) {
          s5 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e31);
          }
        }
        if (s5 !== peg$FAILED) {
          while (s5 !== peg$FAILED) {
            s42.push(s5);
            if (peg$r1.test(input.charAt(peg$currPos))) {
              s5 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e31);
              }
            }
          }
        } else {
          s42 = peg$FAILED;
        }
        if (s42 !== peg$FAILED) {
          s32 = input.substring(s32, peg$currPos);
        } else {
          s32 = s42;
        }
        if (s32 !== peg$FAILED) {
          s42 = peg$currPos;
          s5 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 46) {
            s6 = peg$c6;
            peg$currPos++;
          } else {
            s6 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e19);
            }
          }
          if (s6 !== peg$FAILED) {
            s7 = peg$currPos;
            s8 = [];
            if (peg$r1.test(input.charAt(peg$currPos))) {
              s9 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s9 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e31);
              }
            }
            while (s9 !== peg$FAILED) {
              s8.push(s9);
              if (peg$r1.test(input.charAt(peg$currPos))) {
                s9 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s9 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e31);
                }
              }
            }
            s7 = input.substring(s7, peg$currPos);
            s6 = [s6, s7];
            s5 = s6;
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
          if (s5 === peg$FAILED) {
            s5 = null;
          }
          s42 = input.substring(s42, peg$currPos);
          s32 = [s32, s42];
          s22 = s32;
        } else {
          peg$currPos = s22;
          s22 = peg$FAILED;
        }
        if (s22 !== peg$FAILED) {
          s1 = input.substring(s1, peg$currPos);
        } else {
          s1 = s22;
        }
        if (s1 === peg$FAILED) {
          s1 = peg$currPos;
          s22 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 46) {
            s32 = peg$c6;
            peg$currPos++;
          } else {
            s32 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e19);
            }
          }
          if (s32 !== peg$FAILED) {
            s42 = peg$currPos;
            s5 = [];
            if (peg$r1.test(input.charAt(peg$currPos))) {
              s6 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e31);
              }
            }
            if (s6 !== peg$FAILED) {
              while (s6 !== peg$FAILED) {
                s5.push(s6);
                if (peg$r1.test(input.charAt(peg$currPos))) {
                  s6 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e31);
                  }
                }
              }
            } else {
              s5 = peg$FAILED;
            }
            if (s5 !== peg$FAILED) {
              s42 = input.substring(s42, peg$currPos);
            } else {
              s42 = s5;
            }
            if (s42 !== peg$FAILED) {
              s32 = [s32, s42];
              s22 = s32;
            } else {
              peg$currPos = s22;
              s22 = peg$FAILED;
            }
          } else {
            peg$currPos = s22;
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = input.substring(s1, peg$currPos);
          } else {
            s1 = s22;
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f33(s1);
        }
        s0 = s1;
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e32);
          }
        }
        return s0;
      }
      function peg$parsediv() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parsepct();
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e33);
          }
        }
        return s0;
      }
      function peg$parsedec() {
        var s0, s1, s22;
        s0 = peg$parsepct();
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 43) {
            s1 = peg$c10;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e27);
            }
          }
          if (s1 !== peg$FAILED) {
            s22 = peg$parsepct();
            if (s22 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f34(s22);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 45) {
              s1 = peg$c11;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e29);
              }
            }
            if (s1 !== peg$FAILED) {
              s22 = peg$parsepct();
              if (s22 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f35(s22);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
        }
        return s0;
      }
      function peg$parseint() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parseminus();
        if (s1 === peg$FAILED) {
          s1 = null;
        }
        s22 = peg$parsenum();
        if (s22 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f36(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e34);
          }
        }
        return s0;
      }
      function peg$parse_() {
        var s0, s1;
        peg$silentFails++;
        s0 = [];
        if (peg$r2.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e36);
          }
        }
        while (s1 !== peg$FAILED) {
          s0.push(s1);
          if (peg$r2.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e36);
            }
          }
        }
        peg$silentFails--;
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e35);
        }
        return s0;
      }
      function peg$parsesp() {
        var s0, s1;
        s0 = [];
        if (peg$r2.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e36);
          }
        }
        if (s1 !== peg$FAILED) {
          while (s1 !== peg$FAILED) {
            s0.push(s1);
            if (peg$r2.test(input.charAt(peg$currPos))) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e36);
              }
            }
          }
        } else {
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsehex() {
        var s0, s1;
        s0 = peg$currPos;
        if (peg$r3.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e37);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f37(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parseEOL() {
        var s0, s1;
        s0 = peg$currPos;
        peg$silentFails++;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        peg$silentFails--;
        if (s1 === peg$FAILED) {
          s0 = void 0;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(
          peg$maxFailExpected,
          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
      }
    }
    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }()
);
var tabular_spec_default2 = (
  // Generated by Peggy 2.0.1.
  //
  // https://peggyjs.org/
  function() {
    "use strict";
    function peg$subclass(child, parent) {
      function C() {
        this.constructor = child;
      }
      C.prototype = parent.prototype;
      child.prototype = new C();
    }
    function peg$SyntaxError(message, expected, found, location) {
      var self = Error.call(this, message);
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(self, peg$SyntaxError.prototype);
      }
      self.expected = expected;
      self.found = found;
      self.location = location;
      self.name = "SyntaxError";
      return self;
    }
    peg$subclass(peg$SyntaxError, Error);
    function peg$padEnd(str, targetLength, padString) {
      padString = padString || " ";
      if (str.length > targetLength) {
        return str;
      }
      targetLength -= str.length;
      padString += padString.repeat(targetLength);
      return str + padString.slice(0, targetLength);
    }
    peg$SyntaxError.prototype.format = function(sources) {
      var str = "Error: " + this.message;
      if (this.location) {
        var src = null;
        var k;
        for (k = 0; k < sources.length; k++) {
          if (sources[k].source === this.location.source) {
            src = sources[k].text.split(/\r\n|\n|\r/g);
            break;
          }
        }
        var s22 = this.location.start;
        var loc = this.location.source + ":" + s22.line + ":" + s22.column;
        if (src) {
          var e = this.location.end;
          var filler = peg$padEnd("", s22.line.toString().length, " ");
          var line = src[s22.line - 1];
          var last = s22.line === e.line ? e.column : line.length + 1;
          var hatLen = last - s22.column || 1;
          str += "\n --> " + loc + "\n" + filler + " |\n" + s22.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s22.column - 1, " ") + peg$padEnd("", hatLen, "^");
        } else {
          str += "\n at " + loc;
        }
      }
      return str;
    };
    peg$SyntaxError.buildMessage = function(expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        class: function(expectation) {
          var escapedParts = expectation.parts.map(function(part) {
            return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
          });
          return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
        },
        any: function() {
          return "any character";
        },
        end: function() {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        }
      };
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s22) {
        return s22.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function classEscape(s22) {
        return s22.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = expected2.map(describeExpectation);
        var i, j;
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {};
      var peg$source = options.grammarSource;
      var peg$startRuleFunctions = { body: peg$parsebody };
      var peg$startRuleFunction = peg$parsebody;
      var peg$e0 = peg$otherExpectation("decl_start");
      var peg$e1 = peg$otherExpectation("decl_end");
      var peg$e2 = peg$otherExpectation("vert");
      var peg$e3 = peg$anyExpectation();
      var peg$e4 = peg$otherExpectation("l");
      var peg$e5 = peg$otherExpectation("r");
      var peg$e6 = peg$otherExpectation("c");
      var peg$e7 = peg$otherExpectation("p");
      var peg$e8 = peg$otherExpectation("m");
      var peg$e9 = peg$otherExpectation("b");
      var peg$e10 = peg$otherExpectation("w");
      var peg$e11 = peg$otherExpectation("W");
      var peg$e12 = peg$otherExpectation("X");
      var peg$e13 = peg$otherExpectation("!");
      var peg$e14 = peg$otherExpectation("@");
      var peg$e15 = peg$otherExpectation("<");
      var peg$e16 = peg$otherExpectation(">");
      var peg$e17 = peg$otherExpectation("group");
      var peg$e18 = peg$otherExpectation("whitespace");
      var peg$f0 = function(c) {
        return c;
      };
      var peg$f1 = function(cols) {
        return cols;
      };
      var peg$f2 = function() {
        return [];
      };
      var peg$f3 = function(divs1, start, a, end, divs2) {
        return {
          type: "column",
          pre_dividers: divs1,
          post_dividers: divs2,
          before_start_code: start,
          before_end_code: end,
          alignment: a
        };
      };
      var peg$f4 = function() {
        return {
          type: "vert_divider"
        };
      };
      var peg$f5 = function(b, g) {
        return {
          type: "bang_divider",
          content: g[0].content
        };
      };
      var peg$f6 = function(g) {
        return {
          type: "at_divider",
          content: g[0].content
        };
      };
      var peg$f7 = function(div) {
        return div;
      };
      var peg$f8 = function(g) {
        return { type: "decl_code", code: g[0].content };
      };
      var peg$f9 = function(g) {
        return { type: "decl_code", code: g[0].content };
      };
      var peg$f10 = function() {
        return { type: "alignment", alignment: "left" };
      };
      var peg$f11 = function() {
        return { type: "alignment", alignment: "center" };
      };
      var peg$f12 = function() {
        return { type: "alignment", alignment: "right" };
      };
      var peg$f13 = function() {
        return { type: "alignment", alignment: "X" };
      };
      var peg$f14 = function() {
        return "top";
      };
      var peg$f15 = function() {
        return "default";
      };
      var peg$f16 = function() {
        return "bottom";
      };
      var peg$f17 = function(a, g) {
        return {
          type: "alignment",
          alignment: "parbox",
          baseline: a,
          size: g[0].content
        };
      };
      var peg$f18 = function(g1, g2) {
        return {
          type: "alignment",
          alignment: "parbox",
          baseline: g1[0].content,
          size: g2[0].content
        };
      };
      var peg$f19 = function(tok) {
        return options.matchChar(tok, "|");
      };
      var peg$f20 = function(tok) {
        return options.matchChar(tok, "l");
      };
      var peg$f21 = function(tok) {
        return options.matchChar(tok, "r");
      };
      var peg$f22 = function(tok) {
        return options.matchChar(tok, "c");
      };
      var peg$f23 = function(tok) {
        return options.matchChar(tok, "p");
      };
      var peg$f24 = function(tok) {
        return options.matchChar(tok, "m");
      };
      var peg$f25 = function(tok) {
        return options.matchChar(tok, "b");
      };
      var peg$f26 = function(tok) {
        return options.matchChar(tok, "w");
      };
      var peg$f27 = function(tok) {
        return options.matchChar(tok, "W");
      };
      var peg$f28 = function(tok) {
        return options.matchChar(tok, "X");
      };
      var peg$f29 = function(tok) {
        return options.matchChar(tok, "!");
      };
      var peg$f30 = function(tok) {
        return options.matchChar(tok, "@");
      };
      var peg$f31 = function(tok) {
        return options.matchChar(tok, "<");
      };
      var peg$f32 = function(tok) {
        return options.matchChar(tok, ">");
      };
      var peg$f33 = function(tok) {
        return options.isGroup(tok);
      };
      var peg$f34 = function(tok) {
        return options.isWhitespace(tok);
      };
      var peg$currPos = 0;
      var peg$savedPos = 0;
      var peg$posDetailsCache = [{ line: 1, column: 1 }];
      var peg$maxFailPos = 0;
      var peg$maxFailExpected = [];
      var peg$silentFails = 0;
      var peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function offset() {
        return peg$savedPos;
      }
      function range() {
        return {
          source: peg$source,
          start: peg$savedPos,
          end: peg$currPos
        };
      }
      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError(
          [peg$otherExpectation(description)],
          input.substring(peg$savedPos, peg$currPos),
          location2
        );
      }
      function error(message, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location2);
      }
      function peg$literalExpectation(text2, ignoreCase) {
        return { type: "literal", text: text2, ignoreCase };
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts, inverted, ignoreCase };
      }
      function peg$anyExpectation() {
        return { type: "any" };
      }
      function peg$endExpectation() {
        return { type: "end" };
      }
      function peg$otherExpectation(description) {
        return { type: "other", description };
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p;
        if (details) {
          return details;
        } else {
          p = pos - 1;
          while (!peg$posDetailsCache[p]) {
            p--;
          }
          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };
          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos);
        var endPosDetails = peg$computePosDetails(endPos);
        return {
          source: peg$source,
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildSimpleError(message, location2) {
        return new peg$SyntaxError(message, null, null, location2);
      }
      function peg$buildStructuredError(expected2, found, location2) {
        return new peg$SyntaxError(
          peg$SyntaxError.buildMessage(expected2, found),
          expected2,
          found,
          location2
        );
      }
      function peg$parsebody() {
        var s0, s1, s22, s32, s42, s5;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$currPos;
        s32 = peg$parsecolumn();
        if (s32 !== peg$FAILED) {
          s42 = [];
          s5 = peg$parse_();
          while (s5 !== peg$FAILED) {
            s42.push(s5);
            s5 = peg$parse_();
          }
          peg$savedPos = s22;
          s22 = peg$f0(s32);
        } else {
          peg$currPos = s22;
          s22 = peg$FAILED;
        }
        if (s22 !== peg$FAILED) {
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            s22 = peg$currPos;
            s32 = peg$parsecolumn();
            if (s32 !== peg$FAILED) {
              s42 = [];
              s5 = peg$parse_();
              while (s5 !== peg$FAILED) {
                s42.push(s5);
                s5 = peg$parse_();
              }
              peg$savedPos = s22;
              s22 = peg$f0(s32);
            } else {
              peg$currPos = s22;
              s22 = peg$FAILED;
            }
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f1(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseEOL();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f2();
          }
          s0 = s1;
        }
        return s0;
      }
      function peg$parsecolumn() {
        var s0, s1, s22, s32, s42, s5, s6;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsecolumn_divider();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parsecolumn_divider();
        }
        s22 = peg$parsedecl_start();
        if (s22 === peg$FAILED) {
          s22 = null;
        }
        s32 = peg$parsealignment();
        if (s32 !== peg$FAILED) {
          s42 = peg$parsedecl_end();
          if (s42 === peg$FAILED) {
            s42 = null;
          }
          s5 = [];
          s6 = peg$parsecolumn_divider();
          while (s6 !== peg$FAILED) {
            s5.push(s6);
            s6 = peg$parsecolumn_divider();
          }
          peg$savedPos = s0;
          s0 = peg$f3(s1, s22, s32, s42, s5);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecolumn_divider() {
        var s0, s1, s22, s32, s42;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parse_();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parse_();
        }
        s22 = peg$currPos;
        s32 = peg$parsevert();
        if (s32 !== peg$FAILED) {
          peg$savedPos = s22;
          s32 = peg$f4();
        }
        s22 = s32;
        if (s22 === peg$FAILED) {
          s22 = peg$currPos;
          s32 = peg$parsebang();
          if (s32 !== peg$FAILED) {
            s42 = peg$parsegroup();
            if (s42 !== peg$FAILED) {
              peg$savedPos = s22;
              s22 = peg$f5(s32, s42);
            } else {
              peg$currPos = s22;
              s22 = peg$FAILED;
            }
          } else {
            peg$currPos = s22;
            s22 = peg$FAILED;
          }
          if (s22 === peg$FAILED) {
            s22 = peg$currPos;
            s32 = peg$parseat();
            if (s32 !== peg$FAILED) {
              s42 = peg$parsegroup();
              if (s42 !== peg$FAILED) {
                peg$savedPos = s22;
                s22 = peg$f6(s42);
              } else {
                peg$currPos = s22;
                s22 = peg$FAILED;
              }
            } else {
              peg$currPos = s22;
              s22 = peg$FAILED;
            }
          }
        }
        if (s22 !== peg$FAILED) {
          s32 = [];
          s42 = peg$parse_();
          while (s42 !== peg$FAILED) {
            s32.push(s42);
            s42 = peg$parse_();
          }
          peg$savedPos = s0;
          s0 = peg$f7(s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsedecl_start() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parsegreater();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsegroup();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f8(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        return s0;
      }
      function peg$parsedecl_end() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parseless();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsegroup();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f9(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e1);
          }
        }
        return s0;
      }
      function peg$parsealignment() {
        var s0, s1, s22, s32, s42, s5;
        s0 = peg$currPos;
        s1 = peg$parsel();
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f10();
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsec();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f11();
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parser();
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$f12();
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parseX();
              if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$f13();
              }
              s0 = s1;
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$currPos;
                s22 = peg$parsep();
                if (s22 !== peg$FAILED) {
                  peg$savedPos = s1;
                  s22 = peg$f14();
                }
                s1 = s22;
                if (s1 === peg$FAILED) {
                  s1 = peg$currPos;
                  s22 = peg$parsem();
                  if (s22 !== peg$FAILED) {
                    peg$savedPos = s1;
                    s22 = peg$f15();
                  }
                  s1 = s22;
                  if (s1 === peg$FAILED) {
                    s1 = peg$currPos;
                    s22 = peg$parseb();
                    if (s22 !== peg$FAILED) {
                      peg$savedPos = s1;
                      s22 = peg$f16();
                    }
                    s1 = s22;
                  }
                }
                if (s1 !== peg$FAILED) {
                  s22 = [];
                  s32 = peg$parse_();
                  while (s32 !== peg$FAILED) {
                    s22.push(s32);
                    s32 = peg$parse_();
                  }
                  s32 = peg$parsegroup();
                  if (s32 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s0 = peg$f17(s1, s32);
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  s1 = peg$parsew();
                  if (s1 === peg$FAILED) {
                    s1 = peg$parseW();
                  }
                  if (s1 !== peg$FAILED) {
                    s22 = [];
                    s32 = peg$parse_();
                    while (s32 !== peg$FAILED) {
                      s22.push(s32);
                      s32 = peg$parse_();
                    }
                    s32 = peg$parsegroup();
                    if (s32 !== peg$FAILED) {
                      s42 = [];
                      s5 = peg$parse_();
                      while (s5 !== peg$FAILED) {
                        s42.push(s5);
                        s5 = peg$parse_();
                      }
                      s5 = peg$parsegroup();
                      if (s5 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s0 = peg$f18(s32, s5);
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                }
              }
            }
          }
        }
        return s0;
      }
      function peg$parsevert() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f19(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        return s0;
      }
      function peg$parsel() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f20(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e4);
          }
        }
        return s0;
      }
      function peg$parser() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f21(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e5);
          }
        }
        return s0;
      }
      function peg$parsec() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f22(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e6);
          }
        }
        return s0;
      }
      function peg$parsep() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f23(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e7);
          }
        }
        return s0;
      }
      function peg$parsem() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f24(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e8);
          }
        }
        return s0;
      }
      function peg$parseb() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f25(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e9);
          }
        }
        return s0;
      }
      function peg$parsew() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f26(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e10);
          }
        }
        return s0;
      }
      function peg$parseW() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f27(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e11);
          }
        }
        return s0;
      }
      function peg$parseX() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f28(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e12);
          }
        }
        return s0;
      }
      function peg$parsebang() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f29(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e13);
          }
        }
        return s0;
      }
      function peg$parseat() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f30(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e14);
          }
        }
        return s0;
      }
      function peg$parseless() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f31(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e15);
          }
        }
        return s0;
      }
      function peg$parsegreater() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f32(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e16);
          }
        }
        return s0;
      }
      function peg$parsegroup() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f33(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e17);
          }
        }
        return s0;
      }
      function peg$parse_() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f34(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e18);
          }
        }
        return s0;
      }
      function peg$parseEOL() {
        var s0, s1;
        s0 = peg$currPos;
        peg$silentFails++;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        peg$silentFails--;
        if (s1 === peg$FAILED) {
          s0 = void 0;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      if (!options.isHash) {
        try {
          Object.assign(options, {
            matchChar: (node, char) => node.type === "string" && node.content === char,
            isGroup: (node) => node.type === "group",
            isWhitespace: (node) => node.type === "whitespace"
          });
        } catch (e) {
          console.warn("Error when initializing parser", e);
        }
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(
          peg$maxFailExpected,
          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
      }
    }
    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }()
);
var systeme_environment_default2 = (
  // Generated by Peggy 2.0.1.
  //
  // https://peggyjs.org/
  function() {
    "use strict";
    function peg$subclass(child, parent) {
      function C() {
        this.constructor = child;
      }
      C.prototype = parent.prototype;
      child.prototype = new C();
    }
    function peg$SyntaxError(message, expected, found, location) {
      var self = Error.call(this, message);
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(self, peg$SyntaxError.prototype);
      }
      self.expected = expected;
      self.found = found;
      self.location = location;
      self.name = "SyntaxError";
      return self;
    }
    peg$subclass(peg$SyntaxError, Error);
    function peg$padEnd(str, targetLength, padString) {
      padString = padString || " ";
      if (str.length > targetLength) {
        return str;
      }
      targetLength -= str.length;
      padString += padString.repeat(targetLength);
      return str + padString.slice(0, targetLength);
    }
    peg$SyntaxError.prototype.format = function(sources) {
      var str = "Error: " + this.message;
      if (this.location) {
        var src = null;
        var k;
        for (k = 0; k < sources.length; k++) {
          if (sources[k].source === this.location.source) {
            src = sources[k].text.split(/\r\n|\n|\r/g);
            break;
          }
        }
        var s22 = this.location.start;
        var loc = this.location.source + ":" + s22.line + ":" + s22.column;
        if (src) {
          var e = this.location.end;
          var filler = peg$padEnd("", s22.line.toString().length, " ");
          var line = src[s22.line - 1];
          var last = s22.line === e.line ? e.column : line.length + 1;
          var hatLen = last - s22.column || 1;
          str += "\n --> " + loc + "\n" + filler + " |\n" + s22.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s22.column - 1, " ") + peg$padEnd("", hatLen, "^");
        } else {
          str += "\n at " + loc;
        }
      }
      return str;
    };
    peg$SyntaxError.buildMessage = function(expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        class: function(expectation) {
          var escapedParts = expectation.parts.map(function(part) {
            return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
          });
          return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
        },
        any: function() {
          return "any character";
        },
        end: function() {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        }
      };
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s22) {
        return s22.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function classEscape(s22) {
        return s22.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = expected2.map(describeExpectation);
        var i, j;
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {};
      var peg$source = options.grammarSource;
      var peg$startRuleFunctions = { body: peg$parsebody };
      var peg$startRuleFunction = peg$parsebody;
      var peg$e0 = peg$otherExpectation("partial item");
      var peg$e1 = peg$otherExpectation("item");
      var peg$e2 = peg$anyExpectation();
      var peg$e3 = peg$otherExpectation("equation");
      var peg$e4 = peg$otherExpectation("trailing comment");
      var peg$e5 = peg$otherExpectation("comment only line");
      var peg$e6 = peg$otherExpectation("non-var token");
      var peg$e7 = peg$otherExpectation("token");
      var peg$e8 = peg$otherExpectation("same line comment");
      var peg$e9 = peg$otherExpectation("own line comment");
      var peg$e10 = peg$otherExpectation(",");
      var peg$e11 = peg$otherExpectation("@");
      var peg$e12 = peg$otherExpectation("variable token");
      var peg$e13 = peg$otherExpectation("+/-");
      var peg$e14 = peg$otherExpectation("=");
      var peg$f0 = function(a, b) {
        return a.concat(b ? b : []);
      };
      var peg$f1 = function() {
        return [];
      };
      var peg$f2 = function(a, b, c) {
        return a.concat(b, c);
      };
      var peg$f3 = function(op, a, b, c) {
        return { type: "item", op, variable: b, content: a.concat(b, c) };
      };
      var peg$f4 = function(op, a) {
        return { type: "item", op, variable: null, content: a };
      };
      var peg$f5 = function(line, sep, comment2222) {
        return { ...line, sep: [].concat(sep), trailingComment: comment2222 };
      };
      var peg$f6 = function(line, comment2222) {
        return { ...line, trailingComment: comment2222 };
      };
      var peg$f7 = function(eq, ann) {
        return {
          type: "line",
          equation: eq,
          annotation: ann,
          sep: null
        };
      };
      var peg$f8 = function(at, ann) {
        return at ? { type: "annotation", marker: at, content: ann } : null;
      };
      var peg$f9 = function(left, eq, right) {
        return { type: "equation", left, right, equals: eq };
      };
      var peg$f10 = function(x) {
        return x;
      };
      var peg$f11 = function(x) {
        return {
          type: "line",
          trailingComment: x
        };
      };
      var peg$f12 = function(v, s22) {
        return [v].concat(s22 ? s22 : []);
      };
      var peg$f13 = function(t) {
        return t;
      };
      var peg$f14 = function(x) {
        return x;
      };
      var peg$f15 = function(x) {
        return x;
      };
      var peg$f16 = function(tok) {
        return options.isSameLineComment(tok);
      };
      var peg$f17 = function(tok) {
        return tok;
      };
      var peg$f18 = function(tok) {
        return options.isOwnLineComment(tok);
      };
      var peg$f19 = function(tok) {
        return tok;
      };
      var peg$f20 = function(tok) {
        return options.isWhitespace(tok);
      };
      var peg$f21 = function(tok) {
        return tok;
      };
      var peg$f22 = function(tok) {
        return options.isSep(tok);
      };
      var peg$f23 = function(tok) {
        return tok;
      };
      var peg$f24 = function(tok) {
        return options.isAt(tok);
      };
      var peg$f25 = function(tok) {
        return tok;
      };
      var peg$f26 = function(tok) {
        return options.isVar(tok);
      };
      var peg$f27 = function(tok) {
        return tok;
      };
      var peg$f28 = function(tok) {
        return options.isOperation(tok);
      };
      var peg$f29 = function(tok) {
        return tok;
      };
      var peg$f30 = function(tok) {
        return options.isEquals(tok);
      };
      var peg$f31 = function(tok) {
        return tok;
      };
      var peg$f32 = function(tok) {
        return options.isSubscript(tok);
      };
      var peg$f33 = function(tok) {
        return tok;
      };
      var peg$currPos = 0;
      var peg$savedPos = 0;
      var peg$posDetailsCache = [{ line: 1, column: 1 }];
      var peg$maxFailPos = 0;
      var peg$maxFailExpected = [];
      var peg$silentFails = 0;
      var peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function offset() {
        return peg$savedPos;
      }
      function range() {
        return {
          source: peg$source,
          start: peg$savedPos,
          end: peg$currPos
        };
      }
      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError(
          [peg$otherExpectation(description)],
          input.substring(peg$savedPos, peg$currPos),
          location2
        );
      }
      function error(message, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location2);
      }
      function peg$literalExpectation(text2, ignoreCase) {
        return { type: "literal", text: text2, ignoreCase };
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts, inverted, ignoreCase };
      }
      function peg$anyExpectation() {
        return { type: "any" };
      }
      function peg$endExpectation() {
        return { type: "end" };
      }
      function peg$otherExpectation(description) {
        return { type: "other", description };
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p;
        if (details) {
          return details;
        } else {
          p = pos - 1;
          while (!peg$posDetailsCache[p]) {
            p--;
          }
          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };
          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos);
        var endPosDetails = peg$computePosDetails(endPos);
        return {
          source: peg$source,
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildSimpleError(message, location2) {
        return new peg$SyntaxError(message, null, null, location2);
      }
      function peg$buildStructuredError(expected2, found, location2) {
        return new peg$SyntaxError(
          peg$SyntaxError.buildMessage(expected2, found),
          expected2,
          found,
          location2
        );
      }
      function peg$parsebody() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsecomment_only_line();
        if (s22 === peg$FAILED) {
          s22 = peg$parseline_with_sep();
          if (s22 === peg$FAILED) {
            s22 = peg$parsepartial_line_with_comment();
          }
        }
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parsecomment_only_line();
          if (s22 === peg$FAILED) {
            s22 = peg$parseline_with_sep();
            if (s22 === peg$FAILED) {
              s22 = peg$parsepartial_line_with_comment();
            }
          }
        }
        s22 = peg$parseline_without_sep();
        if (s22 === peg$FAILED) {
          s22 = peg$parseEOL();
        }
        if (s22 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f0(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseEOL();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f1();
          }
          s0 = s1;
        }
        return s0;
      }
      function peg$parsepartial_item() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parse_();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parse_();
        }
        s22 = [];
        s32 = peg$parsenon_var_token();
        while (s32 !== peg$FAILED) {
          s22.push(s32);
          s32 = peg$parsenon_var_token();
        }
        s32 = [];
        s42 = peg$parse_();
        while (s42 !== peg$FAILED) {
          s32.push(s42);
          s42 = peg$parse_();
        }
        s42 = peg$parsevar();
        if (s42 !== peg$FAILED) {
          s5 = [];
          s6 = peg$parse_();
          while (s6 !== peg$FAILED) {
            s5.push(s6);
            s6 = peg$parse_();
          }
          s6 = [];
          s7 = peg$parsetoken();
          while (s7 !== peg$FAILED) {
            s6.push(s7);
            s7 = peg$parsetoken();
          }
          s7 = [];
          s8 = peg$parse_();
          while (s8 !== peg$FAILED) {
            s7.push(s8);
            s8 = peg$parse_();
          }
          peg$savedPos = s0;
          s0 = peg$f2(s22, s42, s6);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        return s0;
      }
      function peg$parseitem() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8, s9;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parseoperation();
        if (s1 === peg$FAILED) {
          s1 = null;
        }
        s22 = [];
        s32 = peg$parse_();
        while (s32 !== peg$FAILED) {
          s22.push(s32);
          s32 = peg$parse_();
        }
        s32 = [];
        s42 = peg$parsenon_var_token();
        while (s42 !== peg$FAILED) {
          s32.push(s42);
          s42 = peg$parsenon_var_token();
        }
        s42 = [];
        s5 = peg$parse_();
        while (s5 !== peg$FAILED) {
          s42.push(s5);
          s5 = peg$parse_();
        }
        s5 = peg$parsevar();
        if (s5 !== peg$FAILED) {
          s6 = [];
          s7 = peg$parse_();
          while (s7 !== peg$FAILED) {
            s6.push(s7);
            s7 = peg$parse_();
          }
          s7 = [];
          s8 = peg$parsetoken();
          while (s8 !== peg$FAILED) {
            s7.push(s8);
            s8 = peg$parsetoken();
          }
          s8 = [];
          s9 = peg$parse_();
          while (s9 !== peg$FAILED) {
            s8.push(s9);
            s9 = peg$parse_();
          }
          peg$savedPos = s0;
          s0 = peg$f3(s1, s32, s5, s7);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseoperation();
          if (s1 === peg$FAILED) {
            s1 = null;
          }
          s22 = [];
          s32 = peg$parse_();
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parse_();
          }
          s32 = [];
          s42 = peg$parsenon_var_token();
          if (s42 !== peg$FAILED) {
            while (s42 !== peg$FAILED) {
              s32.push(s42);
              s42 = peg$parsenon_var_token();
            }
          } else {
            s32 = peg$FAILED;
          }
          if (s32 !== peg$FAILED) {
            s42 = [];
            s5 = peg$parse_();
            while (s5 !== peg$FAILED) {
              s42.push(s5);
              s5 = peg$parse_();
            }
            peg$savedPos = s0;
            s0 = peg$f4(s1, s32);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e1);
          }
        }
        return s0;
      }
      function peg$parseline_with_sep() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$parseline_without_sep();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsesep();
          if (s22 !== peg$FAILED) {
            s32 = peg$parsetrailing_comment();
            if (s32 === peg$FAILED) {
              s32 = null;
            }
            peg$savedPos = s0;
            s0 = peg$f5(s1, s22, s32);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsepartial_line_with_comment() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parseline_without_sep();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsetrailing_comment();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f6(s1, s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseline_without_sep() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        if (input.length > peg$currPos) {
          s22 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s22 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        peg$silentFails--;
        if (s22 !== peg$FAILED) {
          peg$currPos = s1;
          s1 = void 0;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parseequation();
          s32 = peg$parseannotation();
          if (s32 === peg$FAILED) {
            s32 = null;
          }
          peg$savedPos = s0;
          s0 = peg$f7(s22, s32);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseannotation() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$parseat();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$parsenon_sep_token();
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parsenon_sep_token();
          }
          peg$savedPos = s0;
          s0 = peg$f8(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseequation() {
        var s0, s1, s22, s32, s42;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parseitem();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parseitem();
        }
        s22 = peg$parseequals();
        if (s22 === peg$FAILED) {
          s22 = null;
        }
        s32 = [];
        s42 = peg$parsetoken();
        if (s42 === peg$FAILED) {
          s42 = peg$parseoperation();
        }
        while (s42 !== peg$FAILED) {
          s32.push(s42);
          s42 = peg$parsetoken();
          if (s42 === peg$FAILED) {
            s42 = peg$parseoperation();
          }
        }
        peg$savedPos = s0;
        s0 = peg$f9(s1, s22, s32);
        peg$silentFails--;
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e3);
        }
        return s0;
      }
      function peg$parsetrailing_comment() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parse_();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parse_();
        }
        s22 = peg$parsesame_line_comment();
        if (s22 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f10(s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e4);
          }
        }
        return s0;
      }
      function peg$parsecomment_only_line() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parse_();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parse_();
        }
        s22 = peg$parseown_line_comment();
        if (s22 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f11(s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e5);
          }
        }
        return s0;
      }
      function peg$parsevar() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$parsevar_token();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$parse_();
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parse_();
          }
          s32 = peg$parsesubscript();
          if (s32 === peg$FAILED) {
            s32 = null;
          }
          peg$savedPos = s0;
          s0 = peg$f12(s1, s32);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsenon_var_token() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        s22 = peg$parsevar();
        peg$silentFails--;
        if (s22 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parsetoken();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f13(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e6);
          }
        }
        return s0;
      }
      function peg$parsenon_sep_token() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        s22 = peg$parsesep();
        if (s22 === peg$FAILED) {
          s22 = peg$parsetrailing_comment();
          if (s22 === peg$FAILED) {
            s22 = peg$parseown_line_comment();
          }
        }
        peg$silentFails--;
        if (s22 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s22 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f14(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsetoken() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        s22 = peg$parsesep();
        if (s22 === peg$FAILED) {
          s22 = peg$parseat();
          if (s22 === peg$FAILED) {
            s22 = peg$parseoperation();
            if (s22 === peg$FAILED) {
              s22 = peg$parseequals();
              if (s22 === peg$FAILED) {
                s22 = peg$parsetrailing_comment();
                if (s22 === peg$FAILED) {
                  s22 = peg$parseown_line_comment();
                }
              }
            }
          }
        }
        peg$silentFails--;
        if (s22 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s22 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f15(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e7);
          }
        }
        return s0;
      }
      function peg$parsesame_line_comment() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f16(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f17(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e8);
          }
        }
        return s0;
      }
      function peg$parseown_line_comment() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f18(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f19(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e9);
          }
        }
        return s0;
      }
      function peg$parse_() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f20(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f21(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsesep() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f22(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f23(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e10);
          }
        }
        return s0;
      }
      function peg$parseat() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f24(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f25(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e11);
          }
        }
        return s0;
      }
      function peg$parsevar_token() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f26(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f27(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e12);
          }
        }
        return s0;
      }
      function peg$parseoperation() {
        var s0, s1, s22, s32, s42;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parse_();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parse_();
        }
        if (input.length > peg$currPos) {
          s22 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s22 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        if (s22 !== peg$FAILED) {
          s32 = [];
          s42 = peg$parse_();
          while (s42 !== peg$FAILED) {
            s32.push(s42);
            s42 = peg$parse_();
          }
          peg$savedPos = peg$currPos;
          s42 = peg$f28(s22);
          if (s42) {
            s42 = void 0;
          } else {
            s42 = peg$FAILED;
          }
          if (s42 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f29(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e13);
          }
        }
        return s0;
      }
      function peg$parseequals() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f30(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f31(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e14);
          }
        }
        return s0;
      }
      function peg$parsesubscript() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f32(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f33(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseEOL() {
        var s0, s1;
        s0 = peg$currPos;
        peg$silentFails++;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        peg$silentFails--;
        if (s1 === peg$FAILED) {
          s0 = void 0;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      if (!options.isWhitespace) {
        try {
          Object.assign(options, {
            isSep: (node) => node.type === "string" && node.content === ",",
            isVar: (node) => node.type === "string" && node.content.match(/[a-zA-Z]/),
            isOperation: (node) => node.type === "string" && node.content.match(/[+-]/),
            isEquals: (node) => node.type === "string" && node.content === "=",
            isAt: (node) => node.type === "string" && node.content === "@",
            isSubscript: (node) => node.content === "_",
            isWhitespace: (node) => node.type === "whitespace",
            isSameLineComment: (node) => node.type === "comment" && node.sameline,
            isOwnLineComment: (node) => node.type === "comment" && !node.sameline
          });
        } catch (e) {
          console.warn("Error when initializing parser", e);
        }
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(
          peg$maxFailExpected,
          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
      }
    }
    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }()
);
var tex_glue_default2 = (
  // Generated by Peggy 2.0.1.
  //
  // https://peggyjs.org/
  function() {
    "use strict";
    function peg$subclass(child, parent) {
      function C() {
        this.constructor = child;
      }
      C.prototype = parent.prototype;
      child.prototype = new C();
    }
    function peg$SyntaxError(message, expected, found, location) {
      var self = Error.call(this, message);
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(self, peg$SyntaxError.prototype);
      }
      self.expected = expected;
      self.found = found;
      self.location = location;
      self.name = "SyntaxError";
      return self;
    }
    peg$subclass(peg$SyntaxError, Error);
    function peg$padEnd(str, targetLength, padString) {
      padString = padString || " ";
      if (str.length > targetLength) {
        return str;
      }
      targetLength -= str.length;
      padString += padString.repeat(targetLength);
      return str + padString.slice(0, targetLength);
    }
    peg$SyntaxError.prototype.format = function(sources) {
      var str = "Error: " + this.message;
      if (this.location) {
        var src = null;
        var k;
        for (k = 0; k < sources.length; k++) {
          if (sources[k].source === this.location.source) {
            src = sources[k].text.split(/\r\n|\n|\r/g);
            break;
          }
        }
        var s22 = this.location.start;
        var loc = this.location.source + ":" + s22.line + ":" + s22.column;
        if (src) {
          var e = this.location.end;
          var filler = peg$padEnd("", s22.line.toString().length, " ");
          var line = src[s22.line - 1];
          var last = s22.line === e.line ? e.column : line.length + 1;
          var hatLen = last - s22.column || 1;
          str += "\n --> " + loc + "\n" + filler + " |\n" + s22.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s22.column - 1, " ") + peg$padEnd("", hatLen, "^");
        } else {
          str += "\n at " + loc;
        }
      }
      return str;
    };
    peg$SyntaxError.buildMessage = function(expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        class: function(expectation) {
          var escapedParts = expectation.parts.map(function(part) {
            return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
          });
          return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
        },
        any: function() {
          return "any character";
        },
        end: function() {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        }
      };
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s22) {
        return s22.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function classEscape(s22) {
        return s22.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = expected2.map(describeExpectation);
        var i, j;
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {};
      var peg$source = options.grammarSource;
      var peg$startRuleFunctions = { root: peg$parseroot };
      var peg$startRuleFunction = peg$parseroot;
      var peg$c0 = "plus";
      var peg$c1 = "minus";
      var peg$c2 = "pt";
      var peg$c3 = "mm";
      var peg$c4 = "cm";
      var peg$c5 = "in";
      var peg$c6 = "ex";
      var peg$c7 = "em";
      var peg$c8 = "bp";
      var peg$c9 = "pc";
      var peg$c10 = "dd";
      var peg$c11 = "cc";
      var peg$c12 = "nd";
      var peg$c13 = "nc";
      var peg$c14 = "sp";
      var peg$c15 = "filll";
      var peg$c16 = "fill";
      var peg$c17 = "fil";
      var peg$c18 = ".";
      var peg$c19 = "+";
      var peg$c20 = "-";
      var peg$r0 = /^[0-9]/;
      var peg$e0 = peg$anyExpectation();
      var peg$e1 = peg$literalExpectation("plus", false);
      var peg$e2 = peg$literalExpectation("minus", false);
      var peg$e3 = peg$literalExpectation("pt", false);
      var peg$e4 = peg$literalExpectation("mm", false);
      var peg$e5 = peg$literalExpectation("cm", false);
      var peg$e6 = peg$literalExpectation("in", false);
      var peg$e7 = peg$literalExpectation("ex", false);
      var peg$e8 = peg$literalExpectation("em", false);
      var peg$e9 = peg$literalExpectation("bp", false);
      var peg$e10 = peg$literalExpectation("pc", false);
      var peg$e11 = peg$literalExpectation("dd", false);
      var peg$e12 = peg$literalExpectation("cc", false);
      var peg$e13 = peg$literalExpectation("nd", false);
      var peg$e14 = peg$literalExpectation("nc", false);
      var peg$e15 = peg$literalExpectation("sp", false);
      var peg$e16 = peg$literalExpectation("filll", false);
      var peg$e17 = peg$literalExpectation("fill", false);
      var peg$e18 = peg$literalExpectation("fil", false);
      var peg$e19 = peg$otherExpectation("number");
      var peg$e20 = peg$classExpectation([["0", "9"]], false, false);
      var peg$e21 = peg$literalExpectation(".", false);
      var peg$e22 = peg$literalExpectation("+", false);
      var peg$e23 = peg$literalExpectation("-", false);
      var peg$f0 = function(b, st, sh) {
        return {
          type: "glue",
          fixed: b,
          stretchable: st,
          shrinkable: sh,
          position: location()
        };
      };
      var peg$f1 = function(glue) {
        return glue;
      };
      var peg$f2 = function(n, u) {
        return { type: "dim", value: n, unit: u };
      };
      var peg$f3 = function(n, u) {
        return { type: "dim", value: n, unit: u };
      };
      var peg$f4 = function(n, u) {
        return { type: "dim", value: n, unit: u };
      };
      var peg$f5 = function(n) {
        return parseFloat(n);
      };
      var peg$currPos = 0;
      var peg$savedPos = 0;
      var peg$posDetailsCache = [{ line: 1, column: 1 }];
      var peg$maxFailPos = 0;
      var peg$maxFailExpected = [];
      var peg$silentFails = 0;
      var peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function offset() {
        return peg$savedPos;
      }
      function range() {
        return {
          source: peg$source,
          start: peg$savedPos,
          end: peg$currPos
        };
      }
      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError(
          [peg$otherExpectation(description)],
          input.substring(peg$savedPos, peg$currPos),
          location2
        );
      }
      function error(message, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location2);
      }
      function peg$literalExpectation(text2, ignoreCase) {
        return { type: "literal", text: text2, ignoreCase };
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts, inverted, ignoreCase };
      }
      function peg$anyExpectation() {
        return { type: "any" };
      }
      function peg$endExpectation() {
        return { type: "end" };
      }
      function peg$otherExpectation(description) {
        return { type: "other", description };
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p;
        if (details) {
          return details;
        } else {
          p = pos - 1;
          while (!peg$posDetailsCache[p]) {
            p--;
          }
          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };
          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos);
        var endPosDetails = peg$computePosDetails(endPos);
        return {
          source: peg$source,
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildSimpleError(message, location2) {
        return new peg$SyntaxError(message, null, null, location2);
      }
      function peg$buildStructuredError(expected2, found, location2) {
        return new peg$SyntaxError(
          peg$SyntaxError.buildMessage(expected2, found),
          expected2,
          found,
          location2
        );
      }
      function peg$parseroot() {
        var s0, s1, s22, s32, s42;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$parsebase();
        if (s22 !== peg$FAILED) {
          s32 = peg$parsestretchable();
          if (s32 === peg$FAILED) {
            s32 = null;
          }
          s42 = peg$parseshrinkable();
          if (s42 === peg$FAILED) {
            s42 = null;
          }
          peg$savedPos = s1;
          s1 = peg$f0(s22, s32, s42);
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s22 = [];
          if (input.length > peg$currPos) {
            s32 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s32 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            if (input.length > peg$currPos) {
              s32 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s32 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
          }
          peg$savedPos = s0;
          s0 = peg$f1(s1);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsebase() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parsenumber();
        if (s1 !== peg$FAILED) {
          s22 = peg$parseunit();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f2(s1, s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsestretchable() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 4) === peg$c0) {
          s1 = peg$c0;
          peg$currPos += 4;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e1);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parsenumber();
          if (s22 !== peg$FAILED) {
            s32 = peg$parserubber_unit();
            if (s32 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f3(s22, s32);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseshrinkable() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 5) === peg$c1) {
          s1 = peg$c1;
          peg$currPos += 5;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parsenumber();
          if (s22 !== peg$FAILED) {
            s32 = peg$parserubber_unit();
            if (s32 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f4(s22, s32);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseunit() {
        var s0;
        if (input.substr(peg$currPos, 2) === peg$c2) {
          s0 = peg$c2;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s0 === peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c3) {
            s0 = peg$c3;
            peg$currPos += 2;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e4);
            }
          }
          if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c4) {
              s0 = peg$c4;
              peg$currPos += 2;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e5);
              }
            }
            if (s0 === peg$FAILED) {
              if (input.substr(peg$currPos, 2) === peg$c5) {
                s0 = peg$c5;
                peg$currPos += 2;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e6);
                }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 2) === peg$c6) {
                  s0 = peg$c6;
                  peg$currPos += 2;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e7);
                  }
                }
                if (s0 === peg$FAILED) {
                  if (input.substr(peg$currPos, 2) === peg$c7) {
                    s0 = peg$c7;
                    peg$currPos += 2;
                  } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e8);
                    }
                  }
                  if (s0 === peg$FAILED) {
                    if (input.substr(peg$currPos, 2) === peg$c8) {
                      s0 = peg$c8;
                      peg$currPos += 2;
                    } else {
                      s0 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e9);
                      }
                    }
                    if (s0 === peg$FAILED) {
                      if (input.substr(peg$currPos, 2) === peg$c9) {
                        s0 = peg$c9;
                        peg$currPos += 2;
                      } else {
                        s0 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$e10);
                        }
                      }
                      if (s0 === peg$FAILED) {
                        if (input.substr(peg$currPos, 2) === peg$c10) {
                          s0 = peg$c10;
                          peg$currPos += 2;
                        } else {
                          s0 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$e11);
                          }
                        }
                        if (s0 === peg$FAILED) {
                          if (input.substr(peg$currPos, 2) === peg$c11) {
                            s0 = peg$c11;
                            peg$currPos += 2;
                          } else {
                            s0 = peg$FAILED;
                            if (peg$silentFails === 0) {
                              peg$fail(peg$e12);
                            }
                          }
                          if (s0 === peg$FAILED) {
                            if (input.substr(peg$currPos, 2) === peg$c12) {
                              s0 = peg$c12;
                              peg$currPos += 2;
                            } else {
                              s0 = peg$FAILED;
                              if (peg$silentFails === 0) {
                                peg$fail(peg$e13);
                              }
                            }
                            if (s0 === peg$FAILED) {
                              if (input.substr(peg$currPos, 2) === peg$c13) {
                                s0 = peg$c13;
                                peg$currPos += 2;
                              } else {
                                s0 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                  peg$fail(peg$e14);
                                }
                              }
                              if (s0 === peg$FAILED) {
                                if (input.substr(peg$currPos, 2) === peg$c14) {
                                  s0 = peg$c14;
                                  peg$currPos += 2;
                                } else {
                                  s0 = peg$FAILED;
                                  if (peg$silentFails === 0) {
                                    peg$fail(peg$e15);
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return s0;
      }
      function peg$parserubber_unit() {
        var s0;
        s0 = peg$parseunit();
        if (s0 === peg$FAILED) {
          if (input.substr(peg$currPos, 5) === peg$c15) {
            s0 = peg$c15;
            peg$currPos += 5;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e16);
            }
          }
          if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 4) === peg$c16) {
              s0 = peg$c16;
              peg$currPos += 4;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e17);
              }
            }
            if (s0 === peg$FAILED) {
              if (input.substr(peg$currPos, 3) === peg$c17) {
                s0 = peg$c17;
                peg$currPos += 3;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e18);
                }
              }
            }
          }
        }
        return s0;
      }
      function peg$parsenumber() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$currPos;
        s32 = peg$parsesign();
        if (s32 === peg$FAILED) {
          s32 = null;
        }
        s42 = peg$currPos;
        s5 = [];
        if (peg$r0.test(input.charAt(peg$currPos))) {
          s6 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s6 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e20);
          }
        }
        while (s6 !== peg$FAILED) {
          s5.push(s6);
          if (peg$r0.test(input.charAt(peg$currPos))) {
            s6 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s6 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e20);
            }
          }
        }
        if (input.charCodeAt(peg$currPos) === 46) {
          s6 = peg$c18;
          peg$currPos++;
        } else {
          s6 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e21);
          }
        }
        if (s6 !== peg$FAILED) {
          s7 = [];
          if (peg$r0.test(input.charAt(peg$currPos))) {
            s8 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s8 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e20);
            }
          }
          if (s8 !== peg$FAILED) {
            while (s8 !== peg$FAILED) {
              s7.push(s8);
              if (peg$r0.test(input.charAt(peg$currPos))) {
                s8 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s8 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e20);
                }
              }
            }
          } else {
            s7 = peg$FAILED;
          }
          if (s7 !== peg$FAILED) {
            s5 = [s5, s6, s7];
            s42 = s5;
          } else {
            peg$currPos = s42;
            s42 = peg$FAILED;
          }
        } else {
          peg$currPos = s42;
          s42 = peg$FAILED;
        }
        if (s42 === peg$FAILED) {
          s42 = [];
          if (peg$r0.test(input.charAt(peg$currPos))) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e20);
            }
          }
          if (s5 !== peg$FAILED) {
            while (s5 !== peg$FAILED) {
              s42.push(s5);
              if (peg$r0.test(input.charAt(peg$currPos))) {
                s5 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e20);
                }
              }
            }
          } else {
            s42 = peg$FAILED;
          }
        }
        if (s42 !== peg$FAILED) {
          s32 = [s32, s42];
          s22 = s32;
        } else {
          peg$currPos = s22;
          s22 = peg$FAILED;
        }
        if (s22 !== peg$FAILED) {
          s1 = input.substring(s1, peg$currPos);
        } else {
          s1 = s22;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f5(s1);
        }
        s0 = s1;
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e19);
          }
        }
        return s0;
      }
      function peg$parsesign() {
        var s0;
        if (input.charCodeAt(peg$currPos) === 43) {
          s0 = peg$c19;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e22);
          }
        }
        if (s0 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 45) {
            s0 = peg$c20;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e23);
            }
          }
        }
        return s0;
      }
      function peg$parseEOL() {
        var s0, s1;
        s0 = peg$currPos;
        peg$silentFails++;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        peg$silentFails--;
        if (s1 === peg$FAILED) {
          s0 = void 0;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(
          peg$maxFailExpected,
          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
      }
    }
    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }()
);
var tikz_default2 = (
  // Generated by Peggy 2.0.1.
  //
  // https://peggyjs.org/
  function() {
    "use strict";
    function peg$subclass(child, parent) {
      function C() {
        this.constructor = child;
      }
      C.prototype = parent.prototype;
      child.prototype = new C();
    }
    function peg$SyntaxError(message, expected, found, location) {
      var self = Error.call(this, message);
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(self, peg$SyntaxError.prototype);
      }
      self.expected = expected;
      self.found = found;
      self.location = location;
      self.name = "SyntaxError";
      return self;
    }
    peg$subclass(peg$SyntaxError, Error);
    function peg$padEnd(str, targetLength, padString) {
      padString = padString || " ";
      if (str.length > targetLength) {
        return str;
      }
      targetLength -= str.length;
      padString += padString.repeat(targetLength);
      return str + padString.slice(0, targetLength);
    }
    peg$SyntaxError.prototype.format = function(sources) {
      var str = "Error: " + this.message;
      if (this.location) {
        var src = null;
        var k;
        for (k = 0; k < sources.length; k++) {
          if (sources[k].source === this.location.source) {
            src = sources[k].text.split(/\r\n|\n|\r/g);
            break;
          }
        }
        var s22 = this.location.start;
        var loc = this.location.source + ":" + s22.line + ":" + s22.column;
        if (src) {
          var e = this.location.end;
          var filler = peg$padEnd("", s22.line.toString().length, " ");
          var line = src[s22.line - 1];
          var last = s22.line === e.line ? e.column : line.length + 1;
          var hatLen = last - s22.column || 1;
          str += "\n --> " + loc + "\n" + filler + " |\n" + s22.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s22.column - 1, " ") + peg$padEnd("", hatLen, "^");
        } else {
          str += "\n at " + loc;
        }
      }
      return str;
    };
    peg$SyntaxError.buildMessage = function(expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        class: function(expectation) {
          var escapedParts = expectation.parts.map(function(part) {
            return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
          });
          return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
        },
        any: function() {
          return "any character";
        },
        end: function() {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        }
      };
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s22) {
        return s22.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function classEscape(s22) {
        return s22.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = expected2.map(describeExpectation);
        var i, j;
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {};
      var peg$source = options.grammarSource;
      var peg$startRuleFunctions = { path_spec: peg$parsepath_spec, foreach_body: peg$parseforeach_body };
      var peg$startRuleFunction = peg$parsepath_spec;
      var peg$e0 = peg$anyExpectation();
      var peg$e1 = peg$otherExpectation("same line comment");
      var peg$e2 = peg$otherExpectation("own line comment");
      var peg$e3 = peg$otherExpectation("comment");
      var peg$e4 = peg$otherExpectation("floating comment");
      var peg$e5 = peg$otherExpectation("operation");
      var peg$e6 = peg$otherExpectation("=");
      var peg$f0 = function(v) {
        return v;
      };
      var peg$f1 = function(ops) {
        return { type: "path_spec", content: ops };
      };
      var peg$f2 = function(c1, op, comment2222) {
        return { op, comment: comment2222 };
      };
      var peg$f3 = function(c1, ops, c2, body) {
        const comments = [c1, ...ops.map((x) => x.comment), c2].filter(
          (x) => x
        );
        const attribute = ops.map((x) => x.op.content.content).join(" ");
        return {
          type: "animation",
          comments,
          attribute,
          content: body.content
        };
      };
      var peg$f4 = function(start, b) {
        return { ...b, start, type: "foreach" };
      };
      var peg$f5 = function(c1, variables, options2, c2, c3, list, c4, command) {
        const comments = [c1, c2, c3, c4].filter((x) => x);
        return {
          type: "foreach_body",
          variables,
          options: options2 && options2.content,
          list,
          command,
          comments
        };
      };
      var peg$f6 = function(c1, options2, c2, body) {
        const comments = [c1, c2].filter((x) => x);
        return {
          type: "svg_operation",
          options: options2 && options2.content,
          content: body,
          comments
        };
      };
      var peg$f7 = function(c1, c2, coord, c3, c4, x) {
        return { coord: x, comment: c4 };
      };
      var peg$f8 = function(c1, c2, coord, c3, a, c5) {
        const comments = [c1, c2, c3, a && a.comment, c5].filter((x) => x);
        return {
          type: "curve_to",
          controls: a ? [coord, a.coord] : [coord],
          comments
        };
      };
      var peg$f9 = function() {
        return { type: "line_to", command: "|-" };
      };
      var peg$f10 = function() {
        return { type: "line_to", command: "-|" };
      };
      var peg$f11 = function() {
        return { type: "line_to", command: "--" };
      };
      var peg$f12 = function(prefix, content) {
        return { type: "coordinate", content, prefix };
      };
      var peg$f13 = function(content) {
        return { type: "square_brace_group", content };
      };
      var peg$f14 = function(v) {
        return { type: "unknown", content: v };
      };
      var peg$f15 = function(tok) {
        return options.isSameLineComment(tok);
      };
      var peg$f16 = function(tok) {
        return tok;
      };
      var peg$f17 = function(tok) {
        return options.isOwnLineComment(tok);
      };
      var peg$f18 = function(tok) {
        return tok;
      };
      var peg$f19 = function(tok) {
        return options.isComment(tok);
      };
      var peg$f20 = function(tok) {
        return tok;
      };
      var peg$f21 = function(tok) {
        return options.isWhitespace(tok);
      };
      var peg$f22 = function(tok) {
        return tok;
      };
      var peg$f23 = function(c) {
        return c;
      };
      var peg$f24 = function(tok) {
        return options.isOperation(tok);
      };
      var peg$f25 = function(tok) {
        return { type: "operation", content: tok };
      };
      var peg$f26 = function(tok) {
        return options.isChar(tok, "=");
      };
      var peg$f27 = function(tok) {
        return tok;
      };
      var peg$f28 = function(tok) {
        return options.isChar(tok, "[");
      };
      var peg$f29 = function(tok) {
        return tok;
      };
      var peg$f30 = function(tok) {
        return options.isChar(tok, "]");
      };
      var peg$f31 = function(tok) {
        return tok;
      };
      var peg$f32 = function(tok) {
        return options.isChar(tok, "(");
      };
      var peg$f33 = function(tok) {
        return tok;
      };
      var peg$f34 = function(tok) {
        return options.isChar(tok, ")");
      };
      var peg$f35 = function(tok) {
        return tok;
      };
      var peg$f36 = function(tok) {
        return options.isChar(tok, "+");
      };
      var peg$f37 = function(tok) {
        return tok;
      };
      var peg$f38 = function(tok) {
        return options.isChar(tok, "-");
      };
      var peg$f39 = function(tok) {
        return tok;
      };
      var peg$f40 = function(tok) {
        return options.isChar(tok, "|");
      };
      var peg$f41 = function(tok) {
        return tok;
      };
      var peg$f42 = function(tok) {
        return options.isChar(tok, ".");
      };
      var peg$f43 = function(tok) {
        return tok;
      };
      var peg$f44 = function(tok) {
        return options.isChar(tok, "controls");
      };
      var peg$f45 = function(tok) {
        return tok;
      };
      var peg$f46 = function(tok) {
        return options.isChar(tok, "and");
      };
      var peg$f47 = function(tok) {
        return tok;
      };
      var peg$f48 = function(tok) {
        return options.isChar(tok, "svg");
      };
      var peg$f49 = function(tok) {
        return tok;
      };
      var peg$f50 = function(tok) {
        return options.isGroup(tok);
      };
      var peg$f51 = function(tok) {
        return tok;
      };
      var peg$f52 = function(tok) {
        return options.isAnyMacro(tok);
      };
      var peg$f53 = function(tok) {
        return tok;
      };
      var peg$f54 = function(tok) {
        return options.isChar(tok, "foreach");
      };
      var peg$f55 = function(tok) {
        return tok;
      };
      var peg$f56 = function(tok) {
        return options.isMacro(tok, "foreach");
      };
      var peg$f57 = function(tok) {
        return tok;
      };
      var peg$f58 = function(tok) {
        return options.isChar(tok, "in");
      };
      var peg$f59 = function(tok) {
        return tok;
      };
      var peg$f60 = function(tok) {
        return options.isChar(tok, ":");
      };
      var peg$f61 = function(tok) {
        return tok;
      };
      var peg$currPos = 0;
      var peg$savedPos = 0;
      var peg$posDetailsCache = [{ line: 1, column: 1 }];
      var peg$maxFailPos = 0;
      var peg$maxFailExpected = [];
      var peg$silentFails = 0;
      var peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function offset() {
        return peg$savedPos;
      }
      function range() {
        return {
          source: peg$source,
          start: peg$savedPos,
          end: peg$currPos
        };
      }
      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError(
          [peg$otherExpectation(description)],
          input.substring(peg$savedPos, peg$currPos),
          location2
        );
      }
      function error(message, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location2);
      }
      function peg$literalExpectation(text2, ignoreCase) {
        return { type: "literal", text: text2, ignoreCase };
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts, inverted, ignoreCase };
      }
      function peg$anyExpectation() {
        return { type: "any" };
      }
      function peg$endExpectation() {
        return { type: "end" };
      }
      function peg$otherExpectation(description) {
        return { type: "other", description };
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p;
        if (details) {
          return details;
        } else {
          p = pos - 1;
          while (!peg$posDetailsCache[p]) {
            p--;
          }
          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };
          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos);
        var endPosDetails = peg$computePosDetails(endPos);
        return {
          source: peg$source,
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildSimpleError(message, location2) {
        return new peg$SyntaxError(message, null, null, location2);
      }
      function peg$buildStructuredError(expected2, found, location2) {
        return new peg$SyntaxError(
          peg$SyntaxError.buildMessage(expected2, found),
          expected2,
          found,
          location2
        );
      }
      function peg$parsepath_spec() {
        var s0, s1, s22, s32, s42, s5;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$currPos;
        s32 = peg$parsesquare_brace_group();
        if (s32 === peg$FAILED) {
          s32 = peg$parsecoordinate();
          if (s32 === peg$FAILED) {
            s32 = peg$parsecurve_to();
            if (s32 === peg$FAILED) {
              s32 = peg$parseline_to();
              if (s32 === peg$FAILED) {
                s32 = peg$parsesvg();
                if (s32 === peg$FAILED) {
                  s32 = peg$parseforeach();
                  if (s32 === peg$FAILED) {
                    s32 = peg$parseoperation();
                    if (s32 === peg$FAILED) {
                      s32 = peg$parsecomment();
                      if (s32 === peg$FAILED) {
                        s32 = peg$parseanimation();
                        if (s32 === peg$FAILED) {
                          s32 = peg$parseunknown();
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (s32 !== peg$FAILED) {
          s42 = [];
          s5 = peg$parse_();
          while (s5 !== peg$FAILED) {
            s42.push(s5);
            s5 = peg$parse_();
          }
          peg$savedPos = s22;
          s22 = peg$f0(s32);
        } else {
          peg$currPos = s22;
          s22 = peg$FAILED;
        }
        if (s22 !== peg$FAILED) {
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            s22 = peg$currPos;
            s32 = peg$parsesquare_brace_group();
            if (s32 === peg$FAILED) {
              s32 = peg$parsecoordinate();
              if (s32 === peg$FAILED) {
                s32 = peg$parsecurve_to();
                if (s32 === peg$FAILED) {
                  s32 = peg$parseline_to();
                  if (s32 === peg$FAILED) {
                    s32 = peg$parsesvg();
                    if (s32 === peg$FAILED) {
                      s32 = peg$parseforeach();
                      if (s32 === peg$FAILED) {
                        s32 = peg$parseoperation();
                        if (s32 === peg$FAILED) {
                          s32 = peg$parsecomment();
                          if (s32 === peg$FAILED) {
                            s32 = peg$parseanimation();
                            if (s32 === peg$FAILED) {
                              s32 = peg$parseunknown();
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            if (s32 !== peg$FAILED) {
              s42 = [];
              s5 = peg$parse_();
              while (s5 !== peg$FAILED) {
                s42.push(s5);
                s5 = peg$parse_();
              }
              peg$savedPos = s22;
              s22 = peg$f0(s32);
            } else {
              peg$currPos = s22;
              s22 = peg$FAILED;
            }
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f1(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parseanimation() {
        var s0, s1, s22, s32, s42, s5, s6;
        s0 = peg$currPos;
        s1 = peg$parsecolon();
        if (s1 !== peg$FAILED) {
          s22 = peg$parse_comment_();
          s32 = [];
          s42 = peg$currPos;
          s5 = peg$parseoperation();
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_comment_();
            peg$savedPos = s42;
            s42 = peg$f2(s22, s5, s6);
          } else {
            peg$currPos = s42;
            s42 = peg$FAILED;
          }
          if (s42 !== peg$FAILED) {
            while (s42 !== peg$FAILED) {
              s32.push(s42);
              s42 = peg$currPos;
              s5 = peg$parseoperation();
              if (s5 !== peg$FAILED) {
                s6 = peg$parse_comment_();
                peg$savedPos = s42;
                s42 = peg$f2(s22, s5, s6);
              } else {
                peg$currPos = s42;
                s42 = peg$FAILED;
              }
            }
          } else {
            s32 = peg$FAILED;
          }
          if (s32 !== peg$FAILED) {
            s42 = peg$parseequals();
            if (s42 !== peg$FAILED) {
              s5 = peg$parse_comment_();
              s6 = peg$parsegroup();
              if (s6 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f3(s22, s32, s5, s6);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseforeach() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parseforeach_keyword();
        if (s1 === peg$FAILED) {
          s1 = peg$parseforeach_macro();
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parseforeach_body();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f4(s1, s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseforeach_body() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8, s9;
        s0 = peg$currPos;
        s1 = peg$parse_comment_();
        s22 = peg$currPos;
        s32 = [];
        s42 = peg$currPos;
        s5 = peg$currPos;
        peg$silentFails++;
        s6 = peg$parsein_keyword();
        if (s6 === peg$FAILED) {
          s6 = peg$parsesquare_brace_group();
        }
        peg$silentFails--;
        if (s6 === peg$FAILED) {
          s5 = void 0;
        } else {
          peg$currPos = s5;
          s5 = peg$FAILED;
        }
        if (s5 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s6 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s6 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s6 !== peg$FAILED) {
            s5 = [s5, s6];
            s42 = s5;
          } else {
            peg$currPos = s42;
            s42 = peg$FAILED;
          }
        } else {
          peg$currPos = s42;
          s42 = peg$FAILED;
        }
        while (s42 !== peg$FAILED) {
          s32.push(s42);
          s42 = peg$currPos;
          s5 = peg$currPos;
          peg$silentFails++;
          s6 = peg$parsein_keyword();
          if (s6 === peg$FAILED) {
            s6 = peg$parsesquare_brace_group();
          }
          peg$silentFails--;
          if (s6 === peg$FAILED) {
            s5 = void 0;
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
          if (s5 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s6 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            if (s6 !== peg$FAILED) {
              s5 = [s5, s6];
              s42 = s5;
            } else {
              peg$currPos = s42;
              s42 = peg$FAILED;
            }
          } else {
            peg$currPos = s42;
            s42 = peg$FAILED;
          }
        }
        s22 = input.substring(s22, peg$currPos);
        s32 = peg$parsesquare_brace_group();
        if (s32 === peg$FAILED) {
          s32 = null;
        }
        s42 = peg$parse_comment_();
        s5 = peg$parsein_keyword();
        if (s5 !== peg$FAILED) {
          s6 = peg$parse_comment_();
          s7 = peg$parsegroup();
          if (s7 === peg$FAILED) {
            s7 = peg$parsemacro();
          }
          if (s7 !== peg$FAILED) {
            s8 = peg$parse_comment_();
            s9 = peg$parseforeach();
            if (s9 === peg$FAILED) {
              s9 = peg$parsegroup();
              if (s9 === peg$FAILED) {
                s9 = peg$parsemacro();
              }
            }
            if (s9 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f5(s1, s22, s32, s42, s6, s7, s8, s9);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsesvg() {
        var s0, s1, s22, s32, s42, s5;
        s0 = peg$currPos;
        s1 = peg$parsesvg_keyword();
        if (s1 !== peg$FAILED) {
          s22 = peg$parse_comment_();
          s32 = peg$parsesquare_brace_group();
          if (s32 === peg$FAILED) {
            s32 = null;
          }
          s42 = peg$parse_comment_();
          s5 = peg$parsegroup();
          if (s5 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f6(s22, s32, s42, s5);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecurve_to() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8, s9, s10;
        s0 = peg$currPos;
        s1 = peg$parsedotdot();
        if (s1 !== peg$FAILED) {
          s22 = peg$parse_comment_();
          s32 = peg$parsecontrols_keyword();
          if (s32 !== peg$FAILED) {
            s42 = peg$parse_comment_();
            s5 = peg$parsecoordinate();
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_comment_();
              s7 = peg$currPos;
              s8 = peg$parseand_keyword();
              if (s8 !== peg$FAILED) {
                s9 = peg$parse_comment_();
                s10 = peg$parsecoordinate();
                if (s10 !== peg$FAILED) {
                  peg$savedPos = s7;
                  s7 = peg$f7(s22, s42, s5, s6, s9, s10);
                } else {
                  peg$currPos = s7;
                  s7 = peg$FAILED;
                }
              } else {
                peg$currPos = s7;
                s7 = peg$FAILED;
              }
              if (s7 === peg$FAILED) {
                s7 = null;
              }
              s8 = peg$parse_comment_();
              s9 = peg$parsedotdot();
              if (s9 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f8(s22, s42, s5, s6, s7, s8);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseline_to() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parsepipe();
        if (s1 !== peg$FAILED) {
          s22 = peg$parseminus();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f9();
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseminus();
          if (s1 !== peg$FAILED) {
            s22 = peg$parsepipe();
            if (s22 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f10();
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseminus();
            if (s1 !== peg$FAILED) {
              s22 = peg$parseminus();
              if (s22 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f11();
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
        }
        return s0;
      }
      function peg$parsecoordinate() {
        var s0, s1, s22, s32, s42, s5, s6, s7;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$currPos;
        s32 = peg$parseplus();
        if (s32 !== peg$FAILED) {
          s42 = peg$parseplus();
          if (s42 === peg$FAILED) {
            s42 = null;
          }
          s32 = [s32, s42];
          s22 = s32;
        } else {
          peg$currPos = s22;
          s22 = peg$FAILED;
        }
        if (s22 === peg$FAILED) {
          s22 = null;
        }
        s1 = input.substring(s1, peg$currPos);
        s22 = peg$parseopen_paren();
        if (s22 !== peg$FAILED) {
          s32 = peg$currPos;
          s42 = [];
          s5 = peg$currPos;
          s6 = peg$currPos;
          peg$silentFails++;
          s7 = peg$parseclose_paren();
          peg$silentFails--;
          if (s7 === peg$FAILED) {
            s6 = void 0;
          } else {
            peg$currPos = s6;
            s6 = peg$FAILED;
          }
          if (s6 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s7 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s7 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            if (s7 !== peg$FAILED) {
              s6 = [s6, s7];
              s5 = s6;
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
          while (s5 !== peg$FAILED) {
            s42.push(s5);
            s5 = peg$currPos;
            s6 = peg$currPos;
            peg$silentFails++;
            s7 = peg$parseclose_paren();
            peg$silentFails--;
            if (s7 === peg$FAILED) {
              s6 = void 0;
            } else {
              peg$currPos = s6;
              s6 = peg$FAILED;
            }
            if (s6 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s7 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s7 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              if (s7 !== peg$FAILED) {
                s6 = [s6, s7];
                s5 = s6;
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
          }
          s32 = input.substring(s32, peg$currPos);
          s42 = peg$parseclose_paren();
          if (s42 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f12(s1, s32);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsesquare_brace_group() {
        var s0, s1, s22, s32, s42, s5, s6;
        s0 = peg$currPos;
        s1 = peg$parseopen_square_brace();
        if (s1 !== peg$FAILED) {
          s22 = peg$currPos;
          s32 = [];
          s42 = peg$currPos;
          s5 = peg$currPos;
          peg$silentFails++;
          s6 = peg$parseclose_square_brace();
          peg$silentFails--;
          if (s6 === peg$FAILED) {
            s5 = void 0;
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
          if (s5 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s6 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            if (s6 !== peg$FAILED) {
              s5 = [s5, s6];
              s42 = s5;
            } else {
              peg$currPos = s42;
              s42 = peg$FAILED;
            }
          } else {
            peg$currPos = s42;
            s42 = peg$FAILED;
          }
          while (s42 !== peg$FAILED) {
            s32.push(s42);
            s42 = peg$currPos;
            s5 = peg$currPos;
            peg$silentFails++;
            s6 = peg$parseclose_square_brace();
            peg$silentFails--;
            if (s6 === peg$FAILED) {
              s5 = void 0;
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
            if (s5 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s6 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              if (s6 !== peg$FAILED) {
                s5 = [s5, s6];
                s42 = s5;
              } else {
                peg$currPos = s42;
                s42 = peg$FAILED;
              }
            } else {
              peg$currPos = s42;
              s42 = peg$FAILED;
            }
          }
          s22 = input.substring(s22, peg$currPos);
          s32 = peg$parseclose_square_brace();
          if (s32 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f13(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsedotdot() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parsedot();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsedot();
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseunknown() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f14(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parsesame_line_comment() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f15(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f16(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e1);
          }
        }
        return s0;
      }
      function peg$parseown_line_comment() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f17(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f18(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        return s0;
      }
      function peg$parsecomment() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f19(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f20(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        return s0;
      }
      function peg$parse_() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f21(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f22(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parse_comment_() {
        var s0, s1, s22, s32, s42;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parse_();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parse_();
        }
        s22 = peg$parsecomment();
        if (s22 === peg$FAILED) {
          s22 = null;
        }
        s32 = [];
        s42 = peg$parse_();
        while (s42 !== peg$FAILED) {
          s32.push(s42);
          s42 = peg$parse_();
        }
        peg$savedPos = s0;
        s0 = peg$f23(s22);
        peg$silentFails--;
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e4);
        }
        return s0;
      }
      function peg$parseoperation() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f24(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f25(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e5);
          }
        }
        return s0;
      }
      function peg$parseequals() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f26(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f27(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e6);
          }
        }
        return s0;
      }
      function peg$parseopen_square_brace() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f28(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f29(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseclose_square_brace() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f30(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f31(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseopen_paren() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f32(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f33(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseclose_paren() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f34(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f35(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseplus() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f36(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f37(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseminus() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f38(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f39(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsepipe() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f40(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f41(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsedot() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f42(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f43(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecontrols_keyword() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f44(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f45(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseand_keyword() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f46(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f47(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsesvg_keyword() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f48(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f49(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsegroup() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f50(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f51(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsemacro() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f52(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f53(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseforeach_keyword() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f54(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f55(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseforeach_macro() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f56(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f57(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsein_keyword() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f58(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f59(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecolon() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f60(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f61(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseEOL() {
        var s0, s1;
        s0 = peg$currPos;
        peg$silentFails++;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        peg$silentFails--;
        if (s1 === peg$FAILED) {
          s0 = void 0;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      if (!options.isWhitespace) {
        try {
          Object.assign(options, {
            isChar: (node, char) => node.type === "string" && node.content === char,
            isOperation: (node) => node.type === "string" && node.content.match(/[a-zA-Z]/),
            isWhitespace: (node) => node.type === "whitespace" || node.type === "parbreak",
            isSameLineComment: (node) => node.type === "comment" && node.sameline,
            isOwnLineComment: (node) => node.type === "comment" && !node.sameline,
            isComment: (node) => node.type === "comment",
            isGroup: (node) => node.type === "group",
            isMacro: (node, name) => node.type === "macro" && node.content === name,
            isAnyMacro: (node) => node.type === "macro"
          });
        } catch (e) {
          console.warn("Error when initializing parser", e);
        }
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(
          peg$maxFailExpected,
          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
      }
    }
    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }()
);
var ArgSpecPegParser = xparse_argspec_default2;
var parseCache = {};
function parse(str = "") {
  parseCache[str] = parseCache[str] || ArgSpecPegParser.parse(str);
  return parseCache[str];
}
var BRACES_MAP2 = {
  "*": { openMark: "", closeMark: "" },
  "{": { openMark: "{", closeMark: "}" },
  "[": { openMark: "[", closeMark: "]" },
  "(": { openMark: "(", closeMark: ")" },
  "<": { openMark: "<", closeMark: ">" }
};
var CLOSE_BRACES2 = new Set(
  Object.values(BRACES_MAP2).map((x) => x.closeMark).filter((x) => x)
);
function bracesToOpenAndCloseMarks2(braces) {
  const ret = [];
  for (const char of braces.split("")) {
    if (CLOSE_BRACES2.has(char)) {
      continue;
    }
    const braces2 = BRACES_MAP2[char];
    if (braces2 == null) {
      throw new Error(`Unknown open/close mark type "${char}"`);
    }
    braces2;
    ret.push(braces2);
  }
  return ret;
}
function arg2(args2, special) {
  if (args2 == null) {
    return { type: "argument", content: [], openMark: "", closeMark: "" };
  }
  if (typeof args2 === "string") {
    args2 = s2(args2);
  }
  if (!Array.isArray(args2) && args2.type === "argument") {
    return args2;
  }
  let openMark = (special == null ? void 0 : special.openMark) ?? "{";
  let closeMark = (special == null ? void 0 : special.closeMark) ?? "}";
  if (special == null ? void 0 : special.braces) {
    const braces = bracesToOpenAndCloseMarks2(special.braces);
    if (braces[0]) {
      openMark = braces[0].openMark;
      closeMark = braces[0].closeMark;
    }
  }
  if (!Array.isArray(args2)) {
    args2 = [args2];
  }
  return { type: "argument", content: args2, openMark, closeMark };
}
function s2(value) {
  if (typeof value === "string") {
    return { type: "string", content: value };
  }
  return value;
}
var linebreak25 = Symbol("linebreak");
var ESCAPE25 = "\\";
function _printRaw25(node) {
  if (typeof node === "string") {
    return [node];
  }
  if (Array.isArray(node)) {
    return [].concat(
      ...node.map((n) => _printRaw25(n))
    );
  }
  let argsString, escape;
  switch (node.type) {
    case "root":
      return _printRaw25(node.content);
    case "argument":
      return [node.openMark, ..._printRaw25(node.content), node.closeMark];
    case "comment":
      var suffix = node.suffixParbreak ? "" : linebreak25;
      var leadingWhitespace = "";
      if (node.sameline && node.leadingWhitespace) {
        leadingWhitespace = " ";
      }
      if (node.sameline) {
        return [
          leadingWhitespace,
          "%",
          ..._printRaw25(node.content),
          suffix
        ];
      }
      return [linebreak25, "%", ..._printRaw25(node.content), suffix];
    case "environment":
    case "mathenv":
    case "verbatim":
      var env = _printRaw25(node.env);
      var envStart = [ESCAPE25 + "begin{", ...env, "}"];
      var envEnd = [ESCAPE25 + "end{", ...env, "}"];
      argsString = node.args == null ? [] : _printRaw25(node.args);
      return [
        ...envStart,
        ...argsString,
        ..._printRaw25(node.content),
        ...envEnd
      ];
    case "displaymath":
      return [ESCAPE25 + "[", ..._printRaw25(node.content), ESCAPE25 + "]"];
    case "group":
      return ["{", ..._printRaw25(node.content), "}"];
    case "inlinemath":
      return ["$", ..._printRaw25(node.content), "$"];
    case "macro":
      argsString = node.args == null ? [] : _printRaw25(node.args);
      escape = node.escapeToken == null ? ESCAPE25 : node.escapeToken;
      return [escape, ..._printRaw25(node.content), ...argsString];
    case "parbreak":
      return [linebreak25, linebreak25];
    case "string":
      return [node.content];
    case "verb":
      return [
        ESCAPE25,
        node.env,
        node.escape,
        ..._printRaw25(node.content),
        node.escape
      ];
    case "whitespace":
      return [" "];
    default:
      console.warn(
        "Cannot find render for node ",
        node,
        `(of type ${typeof node})`
      );
      return ["" + node];
  }
}
function printRaw25(node, options) {
  const asArray = options != null ? options.asArray : false;
  const printedTokens = _printRaw25(node);
  if (asArray) {
    return printedTokens;
  }
  return printedTokens.map((x) => x === linebreak25 ? "\n" : x).join("");
}
function createMacroMatcher25(macros15) {
  const macrosHash = Array.isArray(macros15) ? macros15.length > 0 ? typeof macros15[0] === "string" ? Object.fromEntries(
    macros15.map((macro2222) => {
      if (typeof macro2222 !== "string") {
        throw new Error("Wrong branch of map function");
      }
      return [macro2222, {}];
    })
  ) : Object.fromEntries(
    macros15.map((macro2222) => {
      if (typeof macro2222 === "string") {
        throw new Error("Wrong branch of map function");
      }
      if (macro2222.escapeToken != null) {
        return [
          macro2222.content,
          { escapeToken: macro2222.escapeToken }
        ];
      }
      return [macro2222.content, {}];
    })
  ) : {} : macros15;
  return function matchAgainstMacros(node) {
    if (node == null || node.type !== "macro") {
      return false;
    }
    const spec = macrosHash[node.content];
    if (!spec) {
      return false;
    }
    if (typeof spec === "object" && "escapeToken" in spec) {
      return spec.escapeToken == null || spec.escapeToken === node.escapeToken;
    }
    return true;
  };
}
function createEnvironmentMatcher25(macros15) {
  const environmentsHash = Array.isArray(macros15) ? Object.fromEntries(
    macros15.map((str) => {
      return [str, {}];
    })
  ) : macros15;
  return function matchAgainstEnvironments(node) {
    if (!match25.anyEnvironment(node)) {
      return false;
    }
    const envName = printRaw25(node.env);
    const spec = environmentsHash[envName];
    if (!spec) {
      return false;
    }
    return true;
  };
}
var match25 = {
  macro(node, macroName) {
    if (node == null) {
      return false;
    }
    return node.type === "macro" && (macroName == null || node.content === macroName);
  },
  anyMacro(node) {
    return match25.macro(node);
  },
  environment(node, envName) {
    if (node == null) {
      return false;
    }
    return (node.type === "environment" || node.type === "mathenv") && (envName == null || printRaw25(node.env) === envName);
  },
  anyEnvironment(node) {
    return match25.environment(node);
  },
  comment(node) {
    if (node == null) {
      return false;
    }
    return node.type === "comment";
  },
  parbreak(node) {
    if (node == null) {
      return false;
    }
    return node.type === "parbreak";
  },
  whitespace(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace";
  },
  /**
   * Matches whitespace or a comment with leading whitespace.
   */
  whitespaceLike(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace" || node.type === "whitespace" && node.leadingWhitespace === true;
  },
  string(node, value) {
    if (node == null) {
      return false;
    }
    return node.type === "string" && (value == null || node.content === value);
  },
  anyString(node) {
    return match25.string(node);
  },
  group(node) {
    if (node == null) {
      return false;
    }
    return node.type === "group";
  },
  argument(node) {
    if (node == null) {
      return false;
    }
    return node.type === "argument";
  },
  blankArgument(node) {
    if (!match25.argument(node)) {
      return false;
    }
    return node.openMark === "" && node.closeMark === "" && node.content.length === 0;
  },
  math(node) {
    if (node == null) {
      return false;
    }
    return node.type === "displaymath" || node.type === "inlinemath";
  },
  createMacroMatcher: createMacroMatcher25,
  createEnvironmentMatcher: createEnvironmentMatcher25
};
var {
  anyEnvironment: anyEnvironment25,
  anyMacro: anyMacro25,
  anyString: anyString25,
  argument: argument25,
  blankArgument: blankArgument25,
  comment: comment25,
  environment: environment25,
  group: group25,
  macro: macro25,
  math: math25,
  parbreak: parbreak25,
  string: string25,
  whitespace: whitespace25
} = match25;
var __create22 = Object.create;
var __defProp22 = Object.defineProperty;
var __getOwnPropDesc22 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames22 = Object.getOwnPropertyNames;
var __getProtoOf22 = Object.getPrototypeOf;
var __hasOwnProp22 = Object.prototype.hasOwnProperty;
var __commonJS22 = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames22(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps22 = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames22(from))
      if (!__hasOwnProp22.call(to, key) && key !== except)
        __defProp22(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc22(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM22 = (mod, isNodeMode, target) => (target = mod != null ? __create22(__getProtoOf22(mod)) : {}, __copyProps22(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp22(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var require_config = __commonJS22({
  "../../node_modules/trie-prefix-tree/dist/config.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = {
      END_WORD: "$",
      END_WORD_REPLACER: "9a219a89-91cd-42e2-abd5-eb113af08ca8",
      PERMS_MIN_LEN: 2
    };
    module2.exports = exports["default"];
  }
});
var require_append = __commonJS22({
  "../../node_modules/trie-prefix-tree/dist/append.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = append;
    var _config = require_config();
    var _config2 = _interopRequireDefault(_config);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function append(trie, letter, index2, array) {
      var isEndWordLetter = letter === _config2.default.END_WORD;
      var isLastLetter = index2 === array.length - 1;
      if (isEndWordLetter && !isLastLetter) {
        trie[_config2.default.END_WORD] = 1;
        trie[_config2.default.END_WORD_REPLACER] = {};
        trie = trie[_config2.default.END_WORD_REPLACER];
      } else {
        trie[letter] = trie[letter] || {};
        trie = trie[letter];
      }
      if (isLastLetter) {
        trie[_config2.default.END_WORD] = 1;
      }
      return trie;
    }
    module2.exports = exports["default"];
  }
});
var require_create = __commonJS22({
  "../../node_modules/trie-prefix-tree/dist/create.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
      return typeof obj;
    } : function(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    exports.default = create;
    var _append = require_append();
    var _append2 = _interopRequireDefault(_append);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function create(input) {
      if (!Array.isArray(input)) {
        throw "Expected parameter Array, received " + (typeof input === "undefined" ? "undefined" : _typeof(input));
      }
      var trie = input.reduce(function(accumulator, item) {
        item.toLowerCase().split("").reduce(_append2.default, accumulator);
        return accumulator;
      }, {});
      return trie;
    }
    module2.exports = exports["default"];
  }
});
var require_utils = __commonJS22({
  "../../node_modules/trie-prefix-tree/dist/utils.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = {
      objectCopy: function objectCopy(obj) {
        if (typeof obj === "undefined") {
          return {};
        }
        return JSON.parse(JSON.stringify(obj));
      },
      stringify: function stringify(obj) {
        var spacer = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2;
        if (typeof obj === "undefined") {
          return "";
        }
        return JSON.stringify(obj, null, spacer);
      }
    };
    module2.exports = exports["default"];
  }
});
var require_checkPrefix = __commonJS22({
  "../../node_modules/trie-prefix-tree/dist/checkPrefix.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = checkPrefix;
    var _utils = require_utils();
    var _utils2 = _interopRequireDefault(_utils);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function checkPrefix(prefixNode, prefix) {
      var input = prefix.toLowerCase().split("");
      var prefixFound = input.every(function(letter, index2) {
        if (!prefixNode[letter]) {
          return false;
        }
        return prefixNode = prefixNode[letter];
      });
      return {
        prefixFound,
        prefixNode
      };
    }
    module2.exports = exports["default"];
  }
});
var require_recursePrefix = __commonJS22({
  "../../node_modules/trie-prefix-tree/dist/recursePrefix.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = recursePrefix;
    var _config = require_config();
    var _config2 = _interopRequireDefault(_config);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var pushInOrder = function pushInOrder2(word, prefixes) {
      var i = 0;
      while (i < prefixes.length) {
        if (word < prefixes[i]) {
          break;
        }
        i += 1;
      }
      prefixes.splice(i, 0, word);
      return prefixes;
    };
    function recursePrefix(node, prefix, sorted) {
      var prefixes = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [];
      var word = prefix;
      for (var branch in node) {
        var currentLetter = branch;
        if (branch === _config2.default.END_WORD && typeof node[branch] === "number") {
          if (sorted) {
            pushInOrder(word, prefixes);
          } else {
            prefixes.push(word);
          }
          word = "";
        } else if (branch === _config2.default.END_WORD_REPLACER) {
          currentLetter = _config2.default.END_WORD;
        }
        recursePrefix(node[branch], prefix + currentLetter, sorted, prefixes);
      }
      return prefixes;
    }
    module2.exports = exports["default"];
  }
});
var require_recurseRandomWord = __commonJS22({
  "../../node_modules/trie-prefix-tree/dist/recurseRandomWord.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = recurseRandomWord;
    var _config = require_config();
    var _config2 = _interopRequireDefault(_config);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function recurseRandomWord(node, prefix) {
      var word = prefix;
      var branches = Object.keys(node);
      var branch = branches[Math.floor(Math.random() * branches.length)];
      if (branch === _config2.default.END_WORD) {
        return word;
      }
      return recurseRandomWord(node[branch], prefix + branch);
    }
    module2.exports = exports["default"];
  }
});
var require_permutations = __commonJS22({
  "../../node_modules/trie-prefix-tree/dist/permutations.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
      return typeof obj;
    } : function(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    exports.default = permutations;
    var _config = require_config();
    var _config2 = _interopRequireDefault(_config);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function permutations(letters, trie) {
      var opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
        type: "anagram"
      };
      if (typeof letters !== "string") {
        throw "Permutations expects string letters, received " + (typeof letters === "undefined" ? "undefined" : _typeof(letters));
      }
      var words = [];
      var permute = function permute2(word, node) {
        var prefix = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
        var wordIsEmpty = word.length === 0;
        var wordFound = words.indexOf(prefix) !== -1;
        var endWordFound = node[_config2.default.END_WORD] === 1;
        if (wordIsEmpty && endWordFound && !wordFound) {
          words.push(prefix);
        }
        for (var i = 0, len = word.length; i < len; i++) {
          var letter = word[i];
          if (opts.type === "sub-anagram") {
            if (endWordFound && !(words.indexOf(prefix) !== -1)) {
              words.push(prefix);
            }
          }
          if (node[letter]) {
            var remaining = word.substring(0, i) + word.substring(i + 1, len);
            permute2(remaining, node[letter], prefix + letter, words);
          }
        }
        return words.sort();
      };
      return permute(letters, trie);
    }
    module2.exports = exports["default"];
  }
});
var require_dist = __commonJS22({
  "../../node_modules/trie-prefix-tree/dist/index.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
      return typeof obj;
    } : function(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    exports.default = function(input) {
      if (!Array.isArray(input)) {
        throw "Expected parameter Array, received " + (typeof input === "undefined" ? "undefined" : _typeof(input));
      }
      var trie = (0, _create2.default)([].concat(_toConsumableArray(input)));
      return {
        /**
         * Get the generated raw trie object
        */
        tree: function tree() {
          return trie;
        },
        /**
         * Get a string representation of the trie
        */
        dump: function dump() {
          var spacer = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
          return _utils2.default.stringify(trie, spacer);
        },
        /**
         * Add a new word to the trie
         */
        addWord: function addWord(word) {
          if (typeof word !== "string" || word === "") {
            throw "Expected parameter string, received " + (typeof word === "undefined" ? "undefined" : _typeof(word));
          }
          var reducer = function reducer2() {
            return _append2.default.apply(void 0, arguments);
          };
          var input2 = word.toLowerCase().split("");
          input2.reduce(reducer, trie);
          return this;
        },
        /**
         * Remove an existing word from the trie
         */
        removeWord: function removeWord(word) {
          if (typeof word !== "string" || word === "") {
            throw "Expected parameter string, received " + (typeof word === "undefined" ? "undefined" : _typeof(word));
          }
          var _checkPrefix = (0, _checkPrefix6.default)(trie, word), prefixFound = _checkPrefix.prefixFound, prefixNode = _checkPrefix.prefixNode;
          if (prefixFound) {
            delete prefixNode[_config2.default.END_WORD];
          }
          return this;
        },
        /**
         * Check a prefix is valid
         * @returns Boolean
        */
        isPrefix: function isPrefix(prefix) {
          if (typeof prefix !== "string") {
            throw "Expected string prefix, received " + (typeof prefix === "undefined" ? "undefined" : _typeof(prefix));
          }
          var _checkPrefix2 = (0, _checkPrefix6.default)(trie, prefix), prefixFound = _checkPrefix2.prefixFound;
          return prefixFound;
        },
        /**
        * Get a list of all words in the trie with the given prefix
        * @returns Array
        */
        getPrefix: function getPrefix(strPrefix) {
          var sorted = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
          if (typeof strPrefix !== "string") {
            throw "Expected string prefix, received " + (typeof strPrefix === "undefined" ? "undefined" : _typeof(strPrefix));
          }
          if (typeof sorted !== "boolean") {
            throw "Expected sort parameter as boolean, received " + (typeof sorted === "undefined" ? "undefined" : _typeof(sorted));
          }
          if (!this.isPrefix(strPrefix)) {
            return [];
          }
          var prefixNode = strPrefix.length ? (0, _checkPrefix6.default)(trie, strPrefix).prefixNode : trie;
          return (0, _recursePrefix2.default)(prefixNode, strPrefix, sorted);
        },
        /**
        * Get a random word in the trie with the given prefix
        * @returns Array
        */
        getRandomWordWithPrefix: function getRandomWordWithPrefix(strPrefix) {
          if (typeof strPrefix !== "string") {
            throw "Expected string prefix, received " + (typeof strPrefix === "undefined" ? "undefined" : _typeof(strPrefix));
          }
          if (!this.isPrefix(strPrefix)) {
            return "";
          }
          var _checkPrefix3 = (0, _checkPrefix6.default)(trie, strPrefix), prefixNode = _checkPrefix3.prefixNode;
          return (0, _recurseRandomWord2.default)(prefixNode, strPrefix);
        },
        /**
        * Count the number of words with the given prefixSearch
        * @returns Number
        */
        countPrefix: function countPrefix(strPrefix) {
          var prefixes = this.getPrefix(strPrefix);
          return prefixes.length;
        },
        /**
        * Get all words in the trie
        * @returns Array
        */
        getWords: function getWords() {
          var sorted = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
          return this.getPrefix("", sorted);
        },
        /**
        * Check the existence of a word in the trie
        * @returns Boolean
        */
        hasWord: function hasWord(word) {
          if (typeof word !== "string") {
            throw "Expected string word, received " + (typeof word === "undefined" ? "undefined" : _typeof(word));
          }
          var _checkPrefix4 = (0, _checkPrefix6.default)(trie, word), prefixFound = _checkPrefix4.prefixFound, prefixNode = _checkPrefix4.prefixNode;
          if (prefixFound) {
            return prefixNode[_config2.default.END_WORD] === 1;
          }
          return false;
        },
        /**
        * Get a list of valid anagrams that can be made from the given letters
        * @returns Array
        */
        getAnagrams: function getAnagrams(letters) {
          if (typeof letters !== "string") {
            throw "Anagrams expected string letters, received " + (typeof letters === "undefined" ? "undefined" : _typeof(letters));
          }
          if (letters.length < PERMS_MIN_LEN) {
            throw "getAnagrams expects at least " + PERMS_MIN_LEN + " letters";
          }
          return (0, _permutations2.default)(letters, trie, {
            type: "anagram"
          });
        },
        /**
        * Get a list of all sub-anagrams that can be made from the given letters
        * @returns Array
        */
        getSubAnagrams: function getSubAnagrams(letters) {
          if (typeof letters !== "string") {
            throw "Expected string letters, received " + (typeof letters === "undefined" ? "undefined" : _typeof(letters));
          }
          if (letters.length < PERMS_MIN_LEN) {
            throw "getSubAnagrams expects at least " + PERMS_MIN_LEN + " letters";
          }
          return (0, _permutations2.default)(letters, trie, {
            type: "sub-anagram"
          });
        }
      };
    };
    var _create = require_create();
    var _create2 = _interopRequireDefault(_create);
    var _append = require_append();
    var _append2 = _interopRequireDefault(_append);
    var _checkPrefix5 = require_checkPrefix();
    var _checkPrefix6 = _interopRequireDefault(_checkPrefix5);
    var _recursePrefix = require_recursePrefix();
    var _recursePrefix2 = _interopRequireDefault(_recursePrefix);
    var _recurseRandomWord = require_recurseRandomWord();
    var _recurseRandomWord2 = _interopRequireDefault(_recurseRandomWord);
    var _utils = require_utils();
    var _utils2 = _interopRequireDefault(_utils);
    var _config = require_config();
    var _config2 = _interopRequireDefault(_config);
    var _permutations = require_permutations();
    var _permutations2 = _interopRequireDefault(_permutations);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _toConsumableArray(arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
          arr2[i] = arr[i];
        }
        return arr2;
      } else {
        return Array.from(arr);
      }
    }
    var PERMS_MIN_LEN = _config2.default.PERMS_MIN_LEN;
    module2.exports = exports["default"];
  }
});
var linebreak33 = Symbol("linebreak");
var ESCAPE33 = "\\";
function _printRaw33(node) {
  if (typeof node === "string") {
    return [node];
  }
  if (Array.isArray(node)) {
    return [].concat(
      ...node.map((n) => _printRaw33(n))
    );
  }
  let argsString, escape;
  switch (node.type) {
    case "root":
      return _printRaw33(node.content);
    case "argument":
      return [node.openMark, ..._printRaw33(node.content), node.closeMark];
    case "comment":
      var suffix = node.suffixParbreak ? "" : linebreak33;
      var leadingWhitespace = "";
      if (node.sameline && node.leadingWhitespace) {
        leadingWhitespace = " ";
      }
      if (node.sameline) {
        return [
          leadingWhitespace,
          "%",
          ..._printRaw33(node.content),
          suffix
        ];
      }
      return [linebreak33, "%", ..._printRaw33(node.content), suffix];
    case "environment":
    case "mathenv":
    case "verbatim":
      var env = _printRaw33(node.env);
      var envStart = [ESCAPE33 + "begin{", ...env, "}"];
      var envEnd = [ESCAPE33 + "end{", ...env, "}"];
      argsString = node.args == null ? [] : _printRaw33(node.args);
      return [
        ...envStart,
        ...argsString,
        ..._printRaw33(node.content),
        ...envEnd
      ];
    case "displaymath":
      return [ESCAPE33 + "[", ..._printRaw33(node.content), ESCAPE33 + "]"];
    case "group":
      return ["{", ..._printRaw33(node.content), "}"];
    case "inlinemath":
      return ["$", ..._printRaw33(node.content), "$"];
    case "macro":
      argsString = node.args == null ? [] : _printRaw33(node.args);
      escape = node.escapeToken == null ? ESCAPE33 : node.escapeToken;
      return [escape, ..._printRaw33(node.content), ...argsString];
    case "parbreak":
      return [linebreak33, linebreak33];
    case "string":
      return [node.content];
    case "verb":
      return [
        ESCAPE33,
        node.env,
        node.escape,
        ..._printRaw33(node.content),
        node.escape
      ];
    case "whitespace":
      return [" "];
    default:
      console.warn(
        "Cannot find render for node ",
        node,
        `(of type ${typeof node})`
      );
      return ["" + node];
  }
}
function printRaw33(node, options) {
  const asArray = options != null ? options.asArray : false;
  const printedTokens = _printRaw33(node);
  if (asArray) {
    return printedTokens;
  }
  return printedTokens.map((x) => x === linebreak33 ? "\n" : x).join("");
}
function createMacroMatcher33(macros15) {
  const macrosHash = Array.isArray(macros15) ? macros15.length > 0 ? typeof macros15[0] === "string" ? Object.fromEntries(
    macros15.map((macro2222) => {
      if (typeof macro2222 !== "string") {
        throw new Error("Wrong branch of map function");
      }
      return [macro2222, {}];
    })
  ) : Object.fromEntries(
    macros15.map((macro2222) => {
      if (typeof macro2222 === "string") {
        throw new Error("Wrong branch of map function");
      }
      if (macro2222.escapeToken != null) {
        return [
          macro2222.content,
          { escapeToken: macro2222.escapeToken }
        ];
      }
      return [macro2222.content, {}];
    })
  ) : {} : macros15;
  return function matchAgainstMacros(node) {
    if (node == null || node.type !== "macro") {
      return false;
    }
    const spec = macrosHash[node.content];
    if (!spec) {
      return false;
    }
    if (typeof spec === "object" && "escapeToken" in spec) {
      return spec.escapeToken == null || spec.escapeToken === node.escapeToken;
    }
    return true;
  };
}
function createEnvironmentMatcher33(macros15) {
  const environmentsHash = Array.isArray(macros15) ? Object.fromEntries(
    macros15.map((str) => {
      return [str, {}];
    })
  ) : macros15;
  return function matchAgainstEnvironments(node) {
    if (!match33.anyEnvironment(node)) {
      return false;
    }
    const envName = printRaw33(node.env);
    const spec = environmentsHash[envName];
    if (!spec) {
      return false;
    }
    return true;
  };
}
var match33 = {
  macro(node, macroName) {
    if (node == null) {
      return false;
    }
    return node.type === "macro" && (macroName == null || node.content === macroName);
  },
  anyMacro(node) {
    return match33.macro(node);
  },
  environment(node, envName) {
    if (node == null) {
      return false;
    }
    return (node.type === "environment" || node.type === "mathenv") && (envName == null || printRaw33(node.env) === envName);
  },
  anyEnvironment(node) {
    return match33.environment(node);
  },
  comment(node) {
    if (node == null) {
      return false;
    }
    return node.type === "comment";
  },
  parbreak(node) {
    if (node == null) {
      return false;
    }
    return node.type === "parbreak";
  },
  whitespace(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace";
  },
  /**
   * Matches whitespace or a comment with leading whitespace.
   */
  whitespaceLike(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace" || node.type === "whitespace" && node.leadingWhitespace === true;
  },
  string(node, value) {
    if (node == null) {
      return false;
    }
    return node.type === "string" && (value == null || node.content === value);
  },
  anyString(node) {
    return match33.string(node);
  },
  group(node) {
    if (node == null) {
      return false;
    }
    return node.type === "group";
  },
  argument(node) {
    if (node == null) {
      return false;
    }
    return node.type === "argument";
  },
  blankArgument(node) {
    if (!match33.argument(node)) {
      return false;
    }
    return node.openMark === "" && node.closeMark === "" && node.content.length === 0;
  },
  math(node) {
    if (node == null) {
      return false;
    }
    return node.type === "displaymath" || node.type === "inlinemath";
  },
  createMacroMatcher: createMacroMatcher33,
  createEnvironmentMatcher: createEnvironmentMatcher33
};
var {
  anyEnvironment: anyEnvironment33,
  anyMacro: anyMacro33,
  anyString: anyString33,
  argument: argument33,
  blankArgument: blankArgument33,
  comment: comment33,
  environment: environment33,
  group: group33,
  macro: macro33,
  math: math33,
  parbreak: parbreak33,
  string: string33,
  whitespace: whitespace33
} = match33;
var linebreak222 = Symbol("linebreak");
var ESCAPE222 = "\\";
function _printRaw222(node) {
  if (typeof node === "string") {
    return [node];
  }
  if (Array.isArray(node)) {
    return [].concat(
      ...node.map((n) => _printRaw222(n))
    );
  }
  let argsString, escape;
  switch (node.type) {
    case "root":
      return _printRaw222(node.content);
    case "argument":
      return [node.openMark, ..._printRaw222(node.content), node.closeMark];
    case "comment":
      var suffix = node.suffixParbreak ? "" : linebreak222;
      var leadingWhitespace = "";
      if (node.sameline && node.leadingWhitespace) {
        leadingWhitespace = " ";
      }
      if (node.sameline) {
        return [
          leadingWhitespace,
          "%",
          ..._printRaw222(node.content),
          suffix
        ];
      }
      return [linebreak222, "%", ..._printRaw222(node.content), suffix];
    case "environment":
    case "mathenv":
    case "verbatim":
      var env = _printRaw222(node.env);
      var envStart = [ESCAPE222 + "begin{", ...env, "}"];
      var envEnd = [ESCAPE222 + "end{", ...env, "}"];
      argsString = node.args == null ? [] : _printRaw222(node.args);
      return [
        ...envStart,
        ...argsString,
        ..._printRaw222(node.content),
        ...envEnd
      ];
    case "displaymath":
      return [ESCAPE222 + "[", ..._printRaw222(node.content), ESCAPE222 + "]"];
    case "group":
      return ["{", ..._printRaw222(node.content), "}"];
    case "inlinemath":
      return ["$", ..._printRaw222(node.content), "$"];
    case "macro":
      argsString = node.args == null ? [] : _printRaw222(node.args);
      escape = node.escapeToken == null ? ESCAPE222 : node.escapeToken;
      return [escape, ..._printRaw222(node.content), ...argsString];
    case "parbreak":
      return [linebreak222, linebreak222];
    case "string":
      return [node.content];
    case "verb":
      return [
        ESCAPE222,
        node.env,
        node.escape,
        ..._printRaw222(node.content),
        node.escape
      ];
    case "whitespace":
      return [" "];
    default:
      console.warn(
        "Cannot find render for node ",
        node,
        `(of type ${typeof node})`
      );
      return ["" + node];
  }
}
function printRaw222(node, options) {
  const asArray = options != null ? options.asArray : false;
  const printedTokens = _printRaw222(node);
  if (asArray) {
    return printedTokens;
  }
  return printedTokens.map((x) => x === linebreak222 ? "\n" : x).join("");
}
function scan(nodes, token, options) {
  const { startIndex, onlySkipWhitespaceAndComments, allowSubstringMatches } = options || {};
  if (typeof token === "string") {
    token = { type: "string", content: token };
  }
  for (let i = startIndex || 0; i < nodes.length; i++) {
    const node = nodes[i];
    if (node.type === token.type) {
      switch (node.type) {
        case "comment":
        case "displaymath":
        case "inlinemath":
        case "root":
        case "parbreak":
        case "whitespace":
        case "verb":
        case "verbatim":
        case "group":
          return i;
        case "macro":
          if (node.content === token.content) {
            return i;
          }
          break;
        case "environment":
        case "mathenv":
          if (printRaw222(node.env) === printRaw222(token.env)) {
            return i;
          }
          break;
        case "string":
          if (node.content === token.content) {
            return i;
          }
          if (allowSubstringMatches && node.content.indexOf(token.content) >= 0) {
            return i;
          }
          break;
      }
    }
    if (onlySkipWhitespaceAndComments && !match33.whitespace(node) && !match33.comment(node)) {
      return null;
    }
  }
  return null;
}
var import_trie_prefix_tree = __toESM22(require_dist(), 1);
var export_Trie = import_trie_prefix_tree.default;
function gobbleSingleArgument(nodes, argSpec, startPos = 0) {
  if (typeof argSpec === "string" || !argSpec.type) {
    throw new Error(
      `argSpec must be an already-parsed argument specification, not "${JSON.stringify(
        argSpec
      )}"`
    );
  }
  let argument622 = null;
  let currPos = startPos;
  const gobbleWhitespace = argSpec.noLeadingWhitespace ? () => {
  } : () => {
    while (currPos < nodes.length) {
      if (!match25.whitespace(nodes[currPos])) {
        break;
      }
      currPos++;
    }
  };
  const openMark = argSpec.openBrace || "";
  const closeMark = argSpec.closeBrace || "";
  const acceptGroup = (argSpec.type === "mandatory" || argSpec.type === "optional") && openMark === "{" && closeMark === "}";
  function findBracePositions() {
    let openMarkPos = null;
    if (openMark) {
      openMarkPos = nodes.findIndex(
        (node, i) => i >= currPos && match25.string(node, openMark)
      );
      if (openMarkPos < currPos) {
        openMarkPos = null;
      }
    }
    let closeMarkPos = null;
    if (openMarkPos != null) {
      closeMarkPos = nodes.findIndex(
        (node, i) => i >= openMarkPos + 1 && match25.string(node, closeMark)
      );
      if (closeMarkPos < openMarkPos + 1) {
        closeMarkPos = null;
      }
    }
    return [openMarkPos, closeMarkPos];
  }
  gobbleWhitespace();
  const currNode = nodes[currPos];
  if (currNode == null || match25.comment(currNode) || match25.parbreak(currNode)) {
    return { argument: argument622, nodesRemoved: 0 };
  }
  switch (argSpec.type) {
    case "mandatory":
      if (acceptGroup) {
        let content = [currNode];
        if (match25.group(currNode)) {
          content = currNode.content;
        }
        argument622 = arg2(content, {
          openMark,
          closeMark
        });
        currPos++;
        break;
      }
    case "optional":
      if (acceptGroup && match25.group(currNode)) {
        argument622 = arg2(currNode.content, {
          openMark,
          closeMark
        });
        currPos++;
        break;
      }
      if (match25.string(currNode, openMark)) {
        const [openMarkPos, closeMarkPos] = findBracePositions();
        if (openMarkPos != null && closeMarkPos != null) {
          argument622 = arg2(nodes.slice(openMarkPos + 1, closeMarkPos), {
            openMark,
            closeMark
          });
          currPos = closeMarkPos + 1;
          break;
        }
      }
      break;
    case "optionalStar":
    case "optionalToken":
      if (match25.string(
        currNode,
        argSpec.type === "optionalStar" ? "*" : argSpec.token
      )) {
        argument622 = arg2([currNode], { openMark: "", closeMark: "" });
        currPos++;
        break;
      }
      break;
    case "until": {
      if (argSpec.stopTokens.length > 1) {
        console.warn(
          `"until" matches with multi-token stop conditions are not yet implemented`
        );
        break;
      }
      const rawToken = argSpec.stopTokens[0];
      const stopToken = rawToken === " " ? { type: "whitespace" } : { type: "string", content: argSpec.stopTokens[0] };
      let matchPos = scan(nodes, stopToken, {
        startIndex: startPos,
        allowSubstringMatches: true
      });
      if (matchPos != null && partialStringMatch(nodes[matchPos], stopToken)) {
        console.warn(
          `"until" arguments that stop at non-punctuation symbols is not yet implemented`
        );
        break;
      }
      if (matchPos == null) {
        break;
      }
      argument622 = arg2(nodes.slice(startPos, matchPos), {
        openMark: "",
        closeMark: rawToken
      });
      currPos = matchPos;
      if (currPos < nodes.length) {
        currPos++;
      }
      break;
    }
    default:
      console.warn(
        `Don't know how to find an argument of argspec type "${argSpec.type}"`
      );
  }
  const nodesRemoved = argument622 ? currPos - startPos : 0;
  nodes.splice(startPos, nodesRemoved);
  return { argument: argument622, nodesRemoved };
}
function partialStringMatch(node, token) {
  return match25.anyString(node) && match25.anyString(token) && node.content.length > token.content.length;
}
function gobbleArguments(nodes, argSpec, startPos = 0) {
  if (typeof argSpec === "function") {
    return argSpec(nodes, startPos);
  }
  if (typeof argSpec === "string") {
    argSpec = parse(argSpec);
  }
  const args = [];
  let nodesRemoved = 0;
  for (const spec of argSpec) {
    const { argument: argument622, nodesRemoved: removed } = gobbleSingleArgument(
      nodes,
      spec,
      startPos
    );
    if (argument622) {
      args.push(argument622);
      nodesRemoved += removed;
    } else {
      args.push(arg2([], { openMark: "", closeMark: "" }));
    }
  }
  return { args, nodesRemoved };
}
var linebreak42 = Symbol("linebreak");
var ESCAPE42 = "\\";
function _printRaw42(node) {
  if (typeof node === "string") {
    return [node];
  }
  if (Array.isArray(node)) {
    return [].concat(
      ...node.map((n) => _printRaw42(n))
    );
  }
  let argsString, escape;
  switch (node.type) {
    case "root":
      return _printRaw42(node.content);
    case "argument":
      return [node.openMark, ..._printRaw42(node.content), node.closeMark];
    case "comment":
      var suffix = node.suffixParbreak ? "" : linebreak42;
      var leadingWhitespace = "";
      if (node.sameline && node.leadingWhitespace) {
        leadingWhitespace = " ";
      }
      if (node.sameline) {
        return [
          leadingWhitespace,
          "%",
          ..._printRaw42(node.content),
          suffix
        ];
      }
      return [linebreak42, "%", ..._printRaw42(node.content), suffix];
    case "environment":
    case "mathenv":
    case "verbatim":
      var env = _printRaw42(node.env);
      var envStart = [ESCAPE42 + "begin{", ...env, "}"];
      var envEnd = [ESCAPE42 + "end{", ...env, "}"];
      argsString = node.args == null ? [] : _printRaw42(node.args);
      return [
        ...envStart,
        ...argsString,
        ..._printRaw42(node.content),
        ...envEnd
      ];
    case "displaymath":
      return [ESCAPE42 + "[", ..._printRaw42(node.content), ESCAPE42 + "]"];
    case "group":
      return ["{", ..._printRaw42(node.content), "}"];
    case "inlinemath":
      return ["$", ..._printRaw42(node.content), "$"];
    case "macro":
      argsString = node.args == null ? [] : _printRaw42(node.args);
      escape = node.escapeToken == null ? ESCAPE42 : node.escapeToken;
      return [escape, ..._printRaw42(node.content), ...argsString];
    case "parbreak":
      return [linebreak42, linebreak42];
    case "string":
      return [node.content];
    case "verb":
      return [
        ESCAPE42,
        node.env,
        node.escape,
        ..._printRaw42(node.content),
        node.escape
      ];
    case "whitespace":
      return [" "];
    default:
      console.warn(
        "Cannot find render for node ",
        node,
        `(of type ${typeof node})`
      );
      return ["" + node];
  }
}
function printRaw42(node, options) {
  const asArray = options != null ? options.asArray : false;
  const printedTokens = _printRaw42(node);
  if (asArray) {
    return printedTokens;
  }
  return printedTokens.map((x) => x === linebreak42 ? "\n" : x).join("");
}
function createMacroMatcher42(macros15) {
  const macrosHash = Array.isArray(macros15) ? macros15.length > 0 ? typeof macros15[0] === "string" ? Object.fromEntries(
    macros15.map((macro2222) => {
      if (typeof macro2222 !== "string") {
        throw new Error("Wrong branch of map function");
      }
      return [macro2222, {}];
    })
  ) : Object.fromEntries(
    macros15.map((macro2222) => {
      if (typeof macro2222 === "string") {
        throw new Error("Wrong branch of map function");
      }
      if (macro2222.escapeToken != null) {
        return [
          macro2222.content,
          { escapeToken: macro2222.escapeToken }
        ];
      }
      return [macro2222.content, {}];
    })
  ) : {} : macros15;
  return function matchAgainstMacros(node) {
    if (node == null || node.type !== "macro") {
      return false;
    }
    const spec = macrosHash[node.content];
    if (!spec) {
      return false;
    }
    if (typeof spec === "object" && "escapeToken" in spec) {
      return spec.escapeToken == null || spec.escapeToken === node.escapeToken;
    }
    return true;
  };
}
function createEnvironmentMatcher42(macros15) {
  const environmentsHash = Array.isArray(macros15) ? Object.fromEntries(
    macros15.map((str) => {
      return [str, {}];
    })
  ) : macros15;
  return function matchAgainstEnvironments(node) {
    if (!match42.anyEnvironment(node)) {
      return false;
    }
    const envName = printRaw42(node.env);
    const spec = environmentsHash[envName];
    if (!spec) {
      return false;
    }
    return true;
  };
}
var match42 = {
  macro(node, macroName) {
    if (node == null) {
      return false;
    }
    return node.type === "macro" && (macroName == null || node.content === macroName);
  },
  anyMacro(node) {
    return match42.macro(node);
  },
  environment(node, envName) {
    if (node == null) {
      return false;
    }
    return (node.type === "environment" || node.type === "mathenv") && (envName == null || printRaw42(node.env) === envName);
  },
  anyEnvironment(node) {
    return match42.environment(node);
  },
  comment(node) {
    if (node == null) {
      return false;
    }
    return node.type === "comment";
  },
  parbreak(node) {
    if (node == null) {
      return false;
    }
    return node.type === "parbreak";
  },
  whitespace(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace";
  },
  /**
   * Matches whitespace or a comment with leading whitespace.
   */
  whitespaceLike(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace" || node.type === "whitespace" && node.leadingWhitespace === true;
  },
  string(node, value) {
    if (node == null) {
      return false;
    }
    return node.type === "string" && (value == null || node.content === value);
  },
  anyString(node) {
    return match42.string(node);
  },
  group(node) {
    if (node == null) {
      return false;
    }
    return node.type === "group";
  },
  argument(node) {
    if (node == null) {
      return false;
    }
    return node.type === "argument";
  },
  blankArgument(node) {
    if (!match42.argument(node)) {
      return false;
    }
    return node.openMark === "" && node.closeMark === "" && node.content.length === 0;
  },
  math(node) {
    if (node == null) {
      return false;
    }
    return node.type === "displaymath" || node.type === "inlinemath";
  },
  createMacroMatcher: createMacroMatcher42,
  createEnvironmentMatcher: createEnvironmentMatcher42
};
var {
  anyEnvironment: anyEnvironment42,
  anyMacro: anyMacro42,
  anyString: anyString42,
  argument: argument42,
  blankArgument: blankArgument42,
  comment: comment42,
  environment: environment42,
  group: group42,
  macro: macro42,
  math: math42,
  parbreak: parbreak42,
  string: string42,
  whitespace: whitespace42
} = match42;
var CONTINUE6 = Symbol("continue");
var SKIP6 = Symbol("skip");
var EXIT6 = Symbol("exit");
function updateRenderInfo2(node, renderInfo) {
  if (renderInfo != null) {
    node._renderInfo = { ...node._renderInfo || {}, ...renderInfo };
  }
  return node;
}
var linebreak52 = Symbol("linebreak");
var ESCAPE52 = "\\";
function _printRaw52(node) {
  if (typeof node === "string") {
    return [node];
  }
  if (Array.isArray(node)) {
    return [].concat(
      ...node.map((n) => _printRaw52(n))
    );
  }
  let argsString, escape;
  switch (node.type) {
    case "root":
      return _printRaw52(node.content);
    case "argument":
      return [node.openMark, ..._printRaw52(node.content), node.closeMark];
    case "comment":
      var suffix = node.suffixParbreak ? "" : linebreak52;
      var leadingWhitespace = "";
      if (node.sameline && node.leadingWhitespace) {
        leadingWhitespace = " ";
      }
      if (node.sameline) {
        return [
          leadingWhitespace,
          "%",
          ..._printRaw52(node.content),
          suffix
        ];
      }
      return [linebreak52, "%", ..._printRaw52(node.content), suffix];
    case "environment":
    case "mathenv":
    case "verbatim":
      var env = _printRaw52(node.env);
      var envStart = [ESCAPE52 + "begin{", ...env, "}"];
      var envEnd = [ESCAPE52 + "end{", ...env, "}"];
      argsString = node.args == null ? [] : _printRaw52(node.args);
      return [
        ...envStart,
        ...argsString,
        ..._printRaw52(node.content),
        ...envEnd
      ];
    case "displaymath":
      return [ESCAPE52 + "[", ..._printRaw52(node.content), ESCAPE52 + "]"];
    case "group":
      return ["{", ..._printRaw52(node.content), "}"];
    case "inlinemath":
      return ["$", ..._printRaw52(node.content), "$"];
    case "macro":
      argsString = node.args == null ? [] : _printRaw52(node.args);
      escape = node.escapeToken == null ? ESCAPE52 : node.escapeToken;
      return [escape, ..._printRaw52(node.content), ...argsString];
    case "parbreak":
      return [linebreak52, linebreak52];
    case "string":
      return [node.content];
    case "verb":
      return [
        ESCAPE52,
        node.env,
        node.escape,
        ..._printRaw52(node.content),
        node.escape
      ];
    case "whitespace":
      return [" "];
    default:
      console.warn(
        "Cannot find render for node ",
        node,
        `(of type ${typeof node})`
      );
      return ["" + node];
  }
}
function printRaw52(node, options) {
  const asArray = options != null ? options.asArray : false;
  const printedTokens = _printRaw52(node);
  if (asArray) {
    return printedTokens;
  }
  return printedTokens.map((x) => x === linebreak52 ? "\n" : x).join("");
}
function createMacroMatcher52(macros15) {
  const macrosHash = Array.isArray(macros15) ? macros15.length > 0 ? typeof macros15[0] === "string" ? Object.fromEntries(
    macros15.map((macro2222) => {
      if (typeof macro2222 !== "string") {
        throw new Error("Wrong branch of map function");
      }
      return [macro2222, {}];
    })
  ) : Object.fromEntries(
    macros15.map((macro2222) => {
      if (typeof macro2222 === "string") {
        throw new Error("Wrong branch of map function");
      }
      if (macro2222.escapeToken != null) {
        return [
          macro2222.content,
          { escapeToken: macro2222.escapeToken }
        ];
      }
      return [macro2222.content, {}];
    })
  ) : {} : macros15;
  return function matchAgainstMacros(node) {
    if (node == null || node.type !== "macro") {
      return false;
    }
    const spec = macrosHash[node.content];
    if (!spec) {
      return false;
    }
    if (typeof spec === "object" && "escapeToken" in spec) {
      return spec.escapeToken == null || spec.escapeToken === node.escapeToken;
    }
    return true;
  };
}
function createEnvironmentMatcher52(macros15) {
  const environmentsHash = Array.isArray(macros15) ? Object.fromEntries(
    macros15.map((str) => {
      return [str, {}];
    })
  ) : macros15;
  return function matchAgainstEnvironments(node) {
    if (!match52.anyEnvironment(node)) {
      return false;
    }
    const envName = printRaw52(node.env);
    const spec = environmentsHash[envName];
    if (!spec) {
      return false;
    }
    return true;
  };
}
var match52 = {
  macro(node, macroName) {
    if (node == null) {
      return false;
    }
    return node.type === "macro" && (macroName == null || node.content === macroName);
  },
  anyMacro(node) {
    return match52.macro(node);
  },
  environment(node, envName) {
    if (node == null) {
      return false;
    }
    return (node.type === "environment" || node.type === "mathenv") && (envName == null || printRaw52(node.env) === envName);
  },
  anyEnvironment(node) {
    return match52.environment(node);
  },
  comment(node) {
    if (node == null) {
      return false;
    }
    return node.type === "comment";
  },
  parbreak(node) {
    if (node == null) {
      return false;
    }
    return node.type === "parbreak";
  },
  whitespace(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace";
  },
  /**
   * Matches whitespace or a comment with leading whitespace.
   */
  whitespaceLike(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace" || node.type === "whitespace" && node.leadingWhitespace === true;
  },
  string(node, value) {
    if (node == null) {
      return false;
    }
    return node.type === "string" && (value == null || node.content === value);
  },
  anyString(node) {
    return match52.string(node);
  },
  group(node) {
    if (node == null) {
      return false;
    }
    return node.type === "group";
  },
  argument(node) {
    if (node == null) {
      return false;
    }
    return node.type === "argument";
  },
  blankArgument(node) {
    if (!match52.argument(node)) {
      return false;
    }
    return node.openMark === "" && node.closeMark === "" && node.content.length === 0;
  },
  math(node) {
    if (node == null) {
      return false;
    }
    return node.type === "displaymath" || node.type === "inlinemath";
  },
  createMacroMatcher: createMacroMatcher52,
  createEnvironmentMatcher: createEnvironmentMatcher52
};
var {
  anyEnvironment: anyEnvironment52,
  anyMacro: anyMacro52,
  anyString: anyString52,
  argument: argument52,
  blankArgument: blankArgument52,
  comment: comment52,
  environment: environment52,
  group: group52,
  macro: macro52,
  math: math52,
  parbreak: parbreak52,
  string: string52,
  whitespace: whitespace52
} = match52;
var CONTINUE23 = Symbol("continue");
var SKIP23 = Symbol("skip");
var EXIT23 = Symbol("exit");
function attachMacroArgsInArray(nodes, macros15) {
  let currIndex;
  const isRelevantMacro = match25.createMacroMatcher(macros15);
  function gobbleUntilMacro() {
    while (currIndex >= 0 && !isRelevantMacro(nodes[currIndex])) {
      currIndex--;
    }
  }
  currIndex = nodes.length - 1;
  while (currIndex >= 0) {
    gobbleUntilMacro();
    if (currIndex < 0) {
      return;
    }
    const macroIndex = currIndex;
    const macro622 = nodes[macroIndex];
    const macroName = macro622.content;
    const macroInfo2 = macros15[macroName];
    updateRenderInfo2(macro622, macroInfo2.renderInfo);
    const signatureOrParser = macroInfo2.argumentParser || macroInfo2.signature;
    if (signatureOrParser == null) {
      currIndex--;
      continue;
    }
    if (macro622.args != null) {
      currIndex = macroIndex - 1;
      continue;
    }
    currIndex++;
    const { args } = gobbleArguments(nodes, signatureOrParser, currIndex);
    macro622.args = args;
    currIndex = macroIndex - 1;
  }
}
var linebreak12 = Symbol("linebreak");
var ESCAPE11 = "\\";
function _printRaw11(node) {
  if (typeof node === "string") {
    return [node];
  }
  if (Array.isArray(node)) {
    return [].concat(
      ...node.map((n) => _printRaw11(n))
    );
  }
  let argsString, escape;
  switch (node.type) {
    case "root":
      return _printRaw11(node.content);
    case "argument":
      return [node.openMark, ..._printRaw11(node.content), node.closeMark];
    case "comment":
      var suffix = node.suffixParbreak ? "" : linebreak12;
      var leadingWhitespace = "";
      if (node.sameline && node.leadingWhitespace) {
        leadingWhitespace = " ";
      }
      if (node.sameline) {
        return [
          leadingWhitespace,
          "%",
          ..._printRaw11(node.content),
          suffix
        ];
      }
      return [linebreak12, "%", ..._printRaw11(node.content), suffix];
    case "environment":
    case "mathenv":
    case "verbatim":
      var env = _printRaw11(node.env);
      var envStart = [ESCAPE11 + "begin{", ...env, "}"];
      var envEnd = [ESCAPE11 + "end{", ...env, "}"];
      argsString = node.args == null ? [] : _printRaw11(node.args);
      return [
        ...envStart,
        ...argsString,
        ..._printRaw11(node.content),
        ...envEnd
      ];
    case "displaymath":
      return [ESCAPE11 + "[", ..._printRaw11(node.content), ESCAPE11 + "]"];
    case "group":
      return ["{", ..._printRaw11(node.content), "}"];
    case "inlinemath":
      return ["$", ..._printRaw11(node.content), "$"];
    case "macro":
      argsString = node.args == null ? [] : _printRaw11(node.args);
      escape = node.escapeToken == null ? ESCAPE11 : node.escapeToken;
      return [escape, ..._printRaw11(node.content), ...argsString];
    case "parbreak":
      return [linebreak12, linebreak12];
    case "string":
      return [node.content];
    case "verb":
      return [
        ESCAPE11,
        node.env,
        node.escape,
        ..._printRaw11(node.content),
        node.escape
      ];
    case "whitespace":
      return [" "];
    default:
      console.warn(
        "Cannot find render for node ",
        node,
        `(of type ${typeof node})`
      );
      return ["" + node];
  }
}
function printRaw12(node, options) {
  const asArray = options != null ? options.asArray : false;
  const printedTokens = _printRaw11(node);
  if (asArray) {
    return printedTokens;
  }
  return printedTokens.map((x) => x === linebreak12 ? "\n" : x).join("");
}
function createMacroMatcher11(macros15) {
  const macrosHash = Array.isArray(macros15) ? macros15.length > 0 ? typeof macros15[0] === "string" ? Object.fromEntries(
    macros15.map((macro262) => {
      if (typeof macro262 !== "string") {
        throw new Error("Wrong branch of map function");
      }
      return [macro262, {}];
    })
  ) : Object.fromEntries(
    macros15.map((macro262) => {
      if (typeof macro262 === "string") {
        throw new Error("Wrong branch of map function");
      }
      if (macro262.escapeToken != null) {
        return [
          macro262.content,
          { escapeToken: macro262.escapeToken }
        ];
      }
      return [macro262.content, {}];
    })
  ) : {} : macros15;
  return function matchAgainstMacros(node) {
    if (node == null || node.type !== "macro") {
      return false;
    }
    const spec = macrosHash[node.content];
    if (!spec) {
      return false;
    }
    if (typeof spec === "object" && "escapeToken" in spec) {
      return spec.escapeToken == null || spec.escapeToken === node.escapeToken;
    }
    return true;
  };
}
function createEnvironmentMatcher11(macros15) {
  const environmentsHash = Array.isArray(macros15) ? Object.fromEntries(
    macros15.map((str) => {
      return [str, {}];
    })
  ) : macros15;
  return function matchAgainstEnvironments(node) {
    if (!match11.anyEnvironment(node)) {
      return false;
    }
    const envName = printRaw12(node.env);
    const spec = environmentsHash[envName];
    if (!spec) {
      return false;
    }
    return true;
  };
}
var match11 = {
  macro(node, macroName) {
    if (node == null) {
      return false;
    }
    return node.type === "macro" && (macroName == null || node.content === macroName);
  },
  anyMacro(node) {
    return match11.macro(node);
  },
  environment(node, envName) {
    if (node == null) {
      return false;
    }
    return (node.type === "environment" || node.type === "mathenv") && (envName == null || printRaw12(node.env) === envName);
  },
  anyEnvironment(node) {
    return match11.environment(node);
  },
  comment(node) {
    if (node == null) {
      return false;
    }
    return node.type === "comment";
  },
  parbreak(node) {
    if (node == null) {
      return false;
    }
    return node.type === "parbreak";
  },
  whitespace(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace";
  },
  /**
   * Matches whitespace or a comment with leading whitespace.
   */
  whitespaceLike(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace" || node.type === "whitespace" && node.leadingWhitespace === true;
  },
  string(node, value) {
    if (node == null) {
      return false;
    }
    return node.type === "string" && (value == null || node.content === value);
  },
  anyString(node) {
    return match11.string(node);
  },
  group(node) {
    if (node == null) {
      return false;
    }
    return node.type === "group";
  },
  argument(node) {
    if (node == null) {
      return false;
    }
    return node.type === "argument";
  },
  blankArgument(node) {
    if (!match11.argument(node)) {
      return false;
    }
    return node.openMark === "" && node.closeMark === "" && node.content.length === 0;
  },
  math(node) {
    if (node == null) {
      return false;
    }
    return node.type === "displaymath" || node.type === "inlinemath";
  },
  createMacroMatcher: createMacroMatcher11,
  createEnvironmentMatcher: createEnvironmentMatcher11
};
var {
  anyEnvironment: anyEnvironment11,
  anyMacro: anyMacro11,
  anyString: anyString11,
  argument: argument11,
  blankArgument: blankArgument11,
  comment: comment11,
  environment: environment11,
  group: group11,
  macro: macro11,
  math: math11,
  parbreak: parbreak11,
  string: string11,
  whitespace: whitespace11
} = match11;
var latex_default3 = (
  // Generated by Peggy 2.0.1.
  //
  // https://peggyjs.org/
  function() {
    "use strict";
    function peg$subclass(child, parent) {
      function C() {
        this.constructor = child;
      }
      C.prototype = parent.prototype;
      child.prototype = new C();
    }
    function peg$SyntaxError(message, expected, found, location) {
      var self = Error.call(this, message);
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(self, peg$SyntaxError.prototype);
      }
      self.expected = expected;
      self.found = found;
      self.location = location;
      self.name = "SyntaxError";
      return self;
    }
    peg$subclass(peg$SyntaxError, Error);
    function peg$padEnd(str, targetLength, padString) {
      padString = padString || " ";
      if (str.length > targetLength) {
        return str;
      }
      targetLength -= str.length;
      padString += padString.repeat(targetLength);
      return str + padString.slice(0, targetLength);
    }
    peg$SyntaxError.prototype.format = function(sources) {
      var str = "Error: " + this.message;
      if (this.location) {
        var src = null;
        var k;
        for (k = 0; k < sources.length; k++) {
          if (sources[k].source === this.location.source) {
            src = sources[k].text.split(/\r\n|\n|\r/g);
            break;
          }
        }
        var s32 = this.location.start;
        var loc = this.location.source + ":" + s32.line + ":" + s32.column;
        if (src) {
          var e = this.location.end;
          var filler = peg$padEnd("", s32.line.toString().length, " ");
          var line = src[s32.line - 1];
          var last = s32.line === e.line ? e.column : line.length + 1;
          var hatLen = last - s32.column || 1;
          str += "\n --> " + loc + "\n" + filler + " |\n" + s32.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s32.column - 1, " ") + peg$padEnd("", hatLen, "^");
        } else {
          str += "\n at " + loc;
        }
      }
      return str;
    };
    peg$SyntaxError.buildMessage = function(expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        class: function(expectation) {
          var escapedParts = expectation.parts.map(function(part) {
            return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
          });
          return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
        },
        any: function() {
          return "any character";
        },
        end: function() {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        }
      };
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s32) {
        return s32.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function classEscape(s32) {
        return s32.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = expected2.map(describeExpectation);
        var i, j;
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {};
      var peg$source = options.grammarSource;
      var peg$startRuleFunctions = { document: peg$parsedocument, math: peg$parsemath };
      var peg$startRuleFunction = peg$parsedocument;
      var peg$c0 = "%";
      var peg$c1 = ".";
      var peg$c2 = "verb*";
      var peg$c3 = "verb";
      var peg$c4 = "verbatim*";
      var peg$c5 = "verbatim";
      var peg$c6 = "filecontents*";
      var peg$c7 = "filecontents";
      var peg$c8 = "comment";
      var peg$c9 = "lstlisting";
      var peg$c10 = "[";
      var peg$c11 = "]";
      var peg$c12 = "(";
      var peg$c13 = ")";
      var peg$c14 = "begin";
      var peg$c15 = "end";
      var peg$c16 = "equation*";
      var peg$c17 = "equation";
      var peg$c18 = "align*";
      var peg$c19 = "align";
      var peg$c20 = "alignat*";
      var peg$c21 = "alignat";
      var peg$c22 = "gather*";
      var peg$c23 = "gather";
      var peg$c24 = "multline*";
      var peg$c25 = "multline";
      var peg$c26 = "flalign*";
      var peg$c27 = "flalign";
      var peg$c28 = "split";
      var peg$c29 = "math";
      var peg$c30 = "displaymath";
      var peg$c31 = "\\";
      var peg$c32 = "{";
      var peg$c33 = "}";
      var peg$c34 = "$";
      var peg$c35 = "&";
      var peg$c36 = "\r";
      var peg$c37 = "\n";
      var peg$c38 = "\r\n";
      var peg$c39 = "#";
      var peg$c40 = "^";
      var peg$c41 = "_";
      var peg$c42 = "\0";
      var peg$r0 = /^[ \t]/;
      var peg$r1 = /^[a-zA-Z]/;
      var peg$r2 = /^[0-9]/;
      var peg$r3 = /^[.,;:\-*\/()!?=+<>[\]`'"~]/;
      var peg$e0 = peg$otherExpectation("document");
      var peg$e1 = peg$otherExpectation("math");
      var peg$e2 = peg$otherExpectation("token");
      var peg$e3 = peg$anyExpectation();
      var peg$e4 = peg$otherExpectation("parbreak");
      var peg$e5 = peg$otherExpectation("math token");
      var peg$e6 = peg$otherExpectation("nonchar token");
      var peg$e7 = peg$literalExpectation("%", false);
      var peg$e8 = peg$otherExpectation("whitespace");
      var peg$e9 = peg$otherExpectation("number");
      var peg$e10 = peg$literalExpectation(".", false);
      var peg$e11 = peg$otherExpectation("special macro");
      var peg$e12 = peg$literalExpectation("verb*", false);
      var peg$e13 = peg$literalExpectation("verb", false);
      var peg$e14 = peg$otherExpectation("verbatim environment");
      var peg$e15 = peg$literalExpectation("verbatim*", false);
      var peg$e16 = peg$literalExpectation("verbatim", false);
      var peg$e17 = peg$literalExpectation("filecontents*", false);
      var peg$e18 = peg$literalExpectation("filecontents", false);
      var peg$e19 = peg$literalExpectation("comment", false);
      var peg$e20 = peg$literalExpectation("lstlisting", false);
      var peg$e21 = peg$otherExpectation("macro");
      var peg$e22 = peg$otherExpectation("group");
      var peg$e23 = peg$otherExpectation("environment");
      var peg$e24 = peg$otherExpectation("math environment");
      var peg$e25 = peg$otherExpectation("math group");
      var peg$e26 = peg$literalExpectation("[", false);
      var peg$e27 = peg$literalExpectation("]", false);
      var peg$e28 = peg$literalExpectation("(", false);
      var peg$e29 = peg$literalExpectation(")", false);
      var peg$e30 = peg$literalExpectation("begin", false);
      var peg$e31 = peg$literalExpectation("end", false);
      var peg$e32 = peg$literalExpectation("equation*", false);
      var peg$e33 = peg$literalExpectation("equation", false);
      var peg$e34 = peg$literalExpectation("align*", false);
      var peg$e35 = peg$literalExpectation("align", false);
      var peg$e36 = peg$literalExpectation("alignat*", false);
      var peg$e37 = peg$literalExpectation("alignat", false);
      var peg$e38 = peg$literalExpectation("gather*", false);
      var peg$e39 = peg$literalExpectation("gather", false);
      var peg$e40 = peg$literalExpectation("multline*", false);
      var peg$e41 = peg$literalExpectation("multline", false);
      var peg$e42 = peg$literalExpectation("flalign*", false);
      var peg$e43 = peg$literalExpectation("flalign", false);
      var peg$e44 = peg$literalExpectation("split", false);
      var peg$e45 = peg$literalExpectation("math", false);
      var peg$e46 = peg$literalExpectation("displaymath", false);
      var peg$e47 = peg$otherExpectation("escape");
      var peg$e48 = peg$literalExpectation("\\", false);
      var peg$e49 = peg$literalExpectation("{", false);
      var peg$e50 = peg$literalExpectation("}", false);
      var peg$e51 = peg$literalExpectation("$", false);
      var peg$e52 = peg$literalExpectation("&", false);
      var peg$e53 = peg$otherExpectation("newline");
      var peg$e54 = peg$literalExpectation("\r", false);
      var peg$e55 = peg$literalExpectation("\n", false);
      var peg$e56 = peg$literalExpectation("\r\n", false);
      var peg$e57 = peg$literalExpectation("#", false);
      var peg$e58 = peg$literalExpectation("^", false);
      var peg$e59 = peg$literalExpectation("_", false);
      var peg$e60 = peg$literalExpectation("\0", false);
      var peg$e61 = peg$classExpectation([" ", "	"], false, false);
      var peg$e62 = peg$otherExpectation("letter");
      var peg$e63 = peg$classExpectation([["a", "z"], ["A", "Z"]], false, false);
      var peg$e64 = peg$otherExpectation("digit");
      var peg$e65 = peg$classExpectation([["0", "9"]], false, false);
      var peg$e66 = peg$otherExpectation("punctuation");
      var peg$e67 = peg$classExpectation([".", ",", ";", ":", "-", "*", "/", "(", ")", "!", "?", "=", "+", "<", ">", "[", "]", "`", "'", '"', "~"], false, false);
      var peg$e68 = peg$otherExpectation("full comment");
      var peg$e69 = peg$otherExpectation("comment");
      var peg$f0 = function(content) {
        return createNode("root", { content });
      };
      var peg$f1 = function(t) {
        return t;
      };
      var peg$f2 = function(eq) {
        return createNode("inlinemath", { content: eq });
      };
      var peg$f3 = function(s32) {
        return createNode("string", { content: s32 });
      };
      var peg$f4 = function(s32) {
        return createNode("string", { content: s32 });
      };
      var peg$f5 = function() {
        return createNode("parbreak");
      };
      var peg$f6 = function(x) {
        return x;
      };
      var peg$f7 = function(x) {
        return x;
      };
      var peg$f8 = function() {
        return createNode("macro", { content: "^", escapeToken: "" });
      };
      var peg$f9 = function() {
        return createNode("macro", { content: "_", escapeToken: "" });
      };
      var peg$f10 = function(s32) {
        return createNode("string", { content: s32 });
      };
      var peg$f11 = function() {
        return createNode("whitespace");
      };
      var peg$f12 = function(a, b) {
        return a.join("") + "." + b.join("");
      };
      var peg$f13 = function(b) {
        return "." + b.join("");
      };
      var peg$f14 = function(a) {
        return a.join("") + ".";
      };
      var peg$f15 = function(s32) {
        return createNode("string", { content: s32 });
      };
      var peg$f16 = function(env, e, end) {
        return end == e;
      };
      var peg$f17 = function(env, e, x) {
        return x;
      };
      var peg$f18 = function(env, e, x, end) {
        return end == e;
      };
      var peg$f19 = function(env, e, x) {
        return createNode("verb", {
          env,
          escape: e,
          content: x.join("")
        });
      };
      var peg$f20 = function(x) {
        return x;
      };
      var peg$f21 = function(x) {
        return createNode("displaymath", { content: x });
      };
      var peg$f22 = function(x) {
        return x;
      };
      var peg$f23 = function(x) {
        return createNode("inlinemath", { content: x });
      };
      var peg$f24 = function(x) {
        return x;
      };
      var peg$f25 = function(x) {
        return createNode("displaymath", { content: x });
      };
      var peg$f26 = function(env, end_env) {
        return compare_env({ content: [env] }, end_env);
      };
      var peg$f27 = function(env, x) {
        return x;
      };
      var peg$f28 = function(env, body) {
        return createNode("verbatim", {
          env,
          content: body.join("")
        });
      };
      var peg$f29 = function(n) {
        return n.join("");
      };
      var peg$f30 = function(n) {
        return n;
      };
      var peg$f31 = function(m) {
        return createNode("macro", { content: m });
      };
      var peg$f32 = function(c) {
        return c;
      };
      var peg$f33 = function(x) {
        return createNode("group", { content: x });
      };
      var peg$f34 = function(g) {
        return text().slice(1, -1);
      };
      var peg$f35 = function(env, env_comment, end_env) {
        return compare_env(env, end_env);
      };
      var peg$f36 = function(env, env_comment, x) {
        return x;
      };
      var peg$f37 = function(env, env_comment, body) {
        return createNode("environment", {
          env,
          content: env_comment ? [env_comment, ...body] : body
        });
      };
      var peg$f38 = function(env, env_comment, end_env) {
        return compare_env({ content: [env] }, end_env);
      };
      var peg$f39 = function(env, env_comment, x) {
        return x;
      };
      var peg$f40 = function(env, env_comment, body) {
        return createNode("mathenv", {
          env,
          content: env_comment ? [env_comment, ...body] : body
        });
      };
      var peg$f41 = function(c) {
        return c;
      };
      var peg$f42 = function(x) {
        return createNode("group", { content: x });
      };
      var peg$f43 = function(e) {
        return createNode("string", { content: e });
      };
      var peg$f44 = function() {
        return createNode("string", { content: "\\" });
      };
      var peg$f45 = function(s32) {
        return createNode("string", { content: s32 });
      };
      var peg$f46 = function(s32) {
        return createNode("string", { content: s32 });
      };
      var peg$f47 = function(s32) {
        return createNode("string", { content: s32 });
      };
      var peg$f48 = function(s32) {
        return createNode("string", { content: s32 });
      };
      var peg$f49 = function(s32) {
        return createNode("string", { content: s32 });
      };
      var peg$f50 = function(s32) {
        return createNode("string", { content: s32 });
      };
      var peg$f51 = function(s32) {
        return createNode("string", { content: s32 });
      };
      var peg$f52 = function() {
        return " ";
      };
      var peg$f53 = function(p) {
        return createNode("string", { content: p });
      };
      var peg$f54 = function(leading_sp, comment262) {
        return createNode("comment", {
          ...comment262,
          sameline: false,
          leadingWhitespace: leading_sp.length > 0
        });
      };
      var peg$f55 = function(spaces, x) {
        return createNode("comment", {
          ...x,
          sameline: true,
          leadingWhitespace: spaces.length > 0
        });
      };
      var peg$f56 = function(c) {
        return c;
      };
      var peg$f57 = function(c) {
        return { content: c.join(""), suffixParbreak: true };
      };
      var peg$f58 = function(c) {
        return c;
      };
      var peg$f59 = function(c) {
        return { content: c.join("") };
      };
      var peg$f60 = function() {
        var loc = location();
        return loc.start.column === 1;
      };
      var peg$currPos = 0;
      var peg$savedPos = 0;
      var peg$posDetailsCache = [{ line: 1, column: 1 }];
      var peg$maxFailPos = 0;
      var peg$maxFailExpected = [];
      var peg$silentFails = 0;
      var peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function offset() {
        return peg$savedPos;
      }
      function range() {
        return {
          source: peg$source,
          start: peg$savedPos,
          end: peg$currPos
        };
      }
      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError(
          [peg$otherExpectation(description)],
          input.substring(peg$savedPos, peg$currPos),
          location2
        );
      }
      function error(message, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location2);
      }
      function peg$literalExpectation(text2, ignoreCase) {
        return { type: "literal", text: text2, ignoreCase };
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts, inverted, ignoreCase };
      }
      function peg$anyExpectation() {
        return { type: "any" };
      }
      function peg$endExpectation() {
        return { type: "end" };
      }
      function peg$otherExpectation(description) {
        return { type: "other", description };
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p;
        if (details) {
          return details;
        } else {
          p = pos - 1;
          while (!peg$posDetailsCache[p]) {
            p--;
          }
          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };
          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos);
        var endPosDetails = peg$computePosDetails(endPos);
        return {
          source: peg$source,
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildSimpleError(message, location2) {
        return new peg$SyntaxError(message, null, null, location2);
      }
      function peg$buildStructuredError(expected2, found, location2) {
        return new peg$SyntaxError(
          peg$SyntaxError.buildMessage(expected2, found),
          expected2,
          found,
          location2
        );
      }
      function peg$parsedocument() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsetoken();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parsetoken();
        }
        peg$savedPos = s0;
        s1 = peg$f0(s1);
        s0 = s1;
        peg$silentFails--;
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e0);
        }
        return s0;
      }
      function peg$parsemath() {
        var s0, s1;
        peg$silentFails++;
        s0 = [];
        s1 = peg$parsemath_token();
        while (s1 !== peg$FAILED) {
          s0.push(s1);
          s1 = peg$parsemath_token();
        }
        peg$silentFails--;
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e1);
        }
        return s0;
      }
      function peg$parsetoken() {
        var s0, s1, s22, s32, s42, s5;
        peg$silentFails++;
        s0 = peg$parsespecial_macro();
        if (s0 === peg$FAILED) {
          s0 = peg$parsemacro();
          if (s0 === peg$FAILED) {
            s0 = peg$parsefull_comment();
            if (s0 === peg$FAILED) {
              s0 = peg$parsegroup();
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parsemath_shift();
                if (s1 !== peg$FAILED) {
                  s22 = [];
                  s32 = peg$currPos;
                  s42 = peg$currPos;
                  peg$silentFails++;
                  s5 = peg$parsemath_shift();
                  peg$silentFails--;
                  if (s5 === peg$FAILED) {
                    s42 = void 0;
                  } else {
                    peg$currPos = s42;
                    s42 = peg$FAILED;
                  }
                  if (s42 !== peg$FAILED) {
                    s5 = peg$parsemath_token();
                    if (s5 !== peg$FAILED) {
                      peg$savedPos = s32;
                      s32 = peg$f1(s5);
                    } else {
                      peg$currPos = s32;
                      s32 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s32;
                    s32 = peg$FAILED;
                  }
                  if (s32 !== peg$FAILED) {
                    while (s32 !== peg$FAILED) {
                      s22.push(s32);
                      s32 = peg$currPos;
                      s42 = peg$currPos;
                      peg$silentFails++;
                      s5 = peg$parsemath_shift();
                      peg$silentFails--;
                      if (s5 === peg$FAILED) {
                        s42 = void 0;
                      } else {
                        peg$currPos = s42;
                        s42 = peg$FAILED;
                      }
                      if (s42 !== peg$FAILED) {
                        s5 = peg$parsemath_token();
                        if (s5 !== peg$FAILED) {
                          peg$savedPos = s32;
                          s32 = peg$f1(s5);
                        } else {
                          peg$currPos = s32;
                          s32 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s32;
                        s32 = peg$FAILED;
                      }
                    }
                  } else {
                    s22 = peg$FAILED;
                  }
                  if (s22 !== peg$FAILED) {
                    s32 = peg$parsemath_shift();
                    if (s32 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s0 = peg$f2(s22);
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
                if (s0 === peg$FAILED) {
                  s0 = peg$parsealignment_tab();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parseparbreak();
                    if (s0 === peg$FAILED) {
                      s0 = peg$parsemacro_parameter();
                      if (s0 === peg$FAILED) {
                        s0 = peg$parseignore();
                        if (s0 === peg$FAILED) {
                          s0 = peg$parsenumber();
                          if (s0 === peg$FAILED) {
                            s0 = peg$parsewhitespace();
                            if (s0 === peg$FAILED) {
                              s0 = peg$parsepunctuation();
                              if (s0 === peg$FAILED) {
                                s0 = peg$currPos;
                                s1 = peg$currPos;
                                s22 = [];
                                s32 = peg$currPos;
                                s42 = peg$currPos;
                                peg$silentFails++;
                                s5 = peg$parsenonchar_token();
                                peg$silentFails--;
                                if (s5 === peg$FAILED) {
                                  s42 = void 0;
                                } else {
                                  peg$currPos = s42;
                                  s42 = peg$FAILED;
                                }
                                if (s42 !== peg$FAILED) {
                                  if (input.length > peg$currPos) {
                                    s5 = input.charAt(peg$currPos);
                                    peg$currPos++;
                                  } else {
                                    s5 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                      peg$fail(peg$e3);
                                    }
                                  }
                                  if (s5 !== peg$FAILED) {
                                    s42 = [s42, s5];
                                    s32 = s42;
                                  } else {
                                    peg$currPos = s32;
                                    s32 = peg$FAILED;
                                  }
                                } else {
                                  peg$currPos = s32;
                                  s32 = peg$FAILED;
                                }
                                if (s32 !== peg$FAILED) {
                                  while (s32 !== peg$FAILED) {
                                    s22.push(s32);
                                    s32 = peg$currPos;
                                    s42 = peg$currPos;
                                    peg$silentFails++;
                                    s5 = peg$parsenonchar_token();
                                    peg$silentFails--;
                                    if (s5 === peg$FAILED) {
                                      s42 = void 0;
                                    } else {
                                      peg$currPos = s42;
                                      s42 = peg$FAILED;
                                    }
                                    if (s42 !== peg$FAILED) {
                                      if (input.length > peg$currPos) {
                                        s5 = input.charAt(peg$currPos);
                                        peg$currPos++;
                                      } else {
                                        s5 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                          peg$fail(peg$e3);
                                        }
                                      }
                                      if (s5 !== peg$FAILED) {
                                        s42 = [s42, s5];
                                        s32 = s42;
                                      } else {
                                        peg$currPos = s32;
                                        s32 = peg$FAILED;
                                      }
                                    } else {
                                      peg$currPos = s32;
                                      s32 = peg$FAILED;
                                    }
                                  }
                                } else {
                                  s22 = peg$FAILED;
                                }
                                if (s22 !== peg$FAILED) {
                                  s1 = input.substring(s1, peg$currPos);
                                } else {
                                  s1 = s22;
                                }
                                if (s1 !== peg$FAILED) {
                                  peg$savedPos = s0;
                                  s1 = peg$f3(s1);
                                }
                                s0 = s1;
                                if (s0 === peg$FAILED) {
                                  s0 = peg$parsebegin_group();
                                  if (s0 === peg$FAILED) {
                                    s0 = peg$parseend_group();
                                    if (s0 === peg$FAILED) {
                                      s0 = peg$parsemath_shift();
                                      if (s0 === peg$FAILED) {
                                        s0 = peg$currPos;
                                        if (input.length > peg$currPos) {
                                          s1 = input.charAt(peg$currPos);
                                          peg$currPos++;
                                        } else {
                                          s1 = peg$FAILED;
                                          if (peg$silentFails === 0) {
                                            peg$fail(peg$e3);
                                          }
                                        }
                                        if (s1 !== peg$FAILED) {
                                          peg$savedPos = s0;
                                          s1 = peg$f4(s1);
                                        }
                                        s0 = s1;
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        return s0;
      }
      function peg$parseparbreak() {
        var s0, s1, s22, s32, s42, s5, s6, s7;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = [];
        s32 = peg$parsesp();
        while (s32 !== peg$FAILED) {
          s22.push(s32);
          s32 = peg$parsesp();
        }
        s32 = peg$parsenl();
        if (s32 !== peg$FAILED) {
          s42 = [];
          s5 = peg$currPos;
          s6 = [];
          s7 = peg$parsesp();
          while (s7 !== peg$FAILED) {
            s6.push(s7);
            s7 = peg$parsesp();
          }
          s7 = peg$parsenl();
          if (s7 !== peg$FAILED) {
            s6 = [s6, s7];
            s5 = s6;
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
          if (s5 !== peg$FAILED) {
            while (s5 !== peg$FAILED) {
              s42.push(s5);
              s5 = peg$currPos;
              s6 = [];
              s7 = peg$parsesp();
              while (s7 !== peg$FAILED) {
                s6.push(s7);
                s7 = peg$parsesp();
              }
              s7 = peg$parsenl();
              if (s7 !== peg$FAILED) {
                s6 = [s6, s7];
                s5 = s6;
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            }
          } else {
            s42 = peg$FAILED;
          }
          if (s42 !== peg$FAILED) {
            s5 = [];
            s6 = peg$parsesp();
            while (s6 !== peg$FAILED) {
              s5.push(s6);
              s6 = peg$parsesp();
            }
            s6 = peg$currPos;
            peg$silentFails++;
            s7 = peg$parsecomment_start();
            peg$silentFails--;
            if (s7 === peg$FAILED) {
              s6 = void 0;
            } else {
              peg$currPos = s6;
              s6 = peg$FAILED;
            }
            if (s6 !== peg$FAILED) {
              s22 = [s22, s32, s42, s5, s6];
              s1 = s22;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
          s1 = peg$currPos;
          s22 = [];
          s32 = peg$parsesp();
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parsesp();
          }
          s32 = peg$parsenl();
          if (s32 !== peg$FAILED) {
            s42 = [];
            s5 = peg$currPos;
            s6 = [];
            s7 = peg$parsesp();
            while (s7 !== peg$FAILED) {
              s6.push(s7);
              s7 = peg$parsesp();
            }
            s7 = peg$parsenl();
            if (s7 !== peg$FAILED) {
              s6 = [s6, s7];
              s5 = s6;
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
            if (s5 !== peg$FAILED) {
              while (s5 !== peg$FAILED) {
                s42.push(s5);
                s5 = peg$currPos;
                s6 = [];
                s7 = peg$parsesp();
                while (s7 !== peg$FAILED) {
                  s6.push(s7);
                  s7 = peg$parsesp();
                }
                s7 = peg$parsenl();
                if (s7 !== peg$FAILED) {
                  s6 = [s6, s7];
                  s5 = s6;
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              }
            } else {
              s42 = peg$FAILED;
            }
            if (s42 !== peg$FAILED) {
              s22 = [s22, s32, s42];
              s1 = s22;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f5();
        }
        s0 = s1;
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e4);
          }
        }
        return s0;
      }
      function peg$parsemath_token() {
        var s0, s1, s22, s32, s42;
        peg$silentFails++;
        s0 = peg$parsespecial_macro();
        if (s0 === peg$FAILED) {
          s0 = peg$parsemacro();
          if (s0 === peg$FAILED) {
            s0 = peg$parsefull_comment();
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = [];
              s22 = peg$parsewhitespace();
              while (s22 !== peg$FAILED) {
                s1.push(s22);
                s22 = peg$parsewhitespace();
              }
              s22 = peg$parsegroup();
              if (s22 !== peg$FAILED) {
                s32 = [];
                s42 = peg$parsewhitespace();
                while (s42 !== peg$FAILED) {
                  s32.push(s42);
                  s42 = peg$parsewhitespace();
                }
                peg$savedPos = s0;
                s0 = peg$f6(s22);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = [];
                s22 = peg$parsewhitespace();
                while (s22 !== peg$FAILED) {
                  s1.push(s22);
                  s22 = peg$parsewhitespace();
                }
                s22 = peg$parsealignment_tab();
                if (s22 !== peg$FAILED) {
                  s32 = [];
                  s42 = peg$parsewhitespace();
                  while (s42 !== peg$FAILED) {
                    s32.push(s42);
                    s42 = peg$parsewhitespace();
                  }
                  peg$savedPos = s0;
                  s0 = peg$f7(s22);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
                if (s0 === peg$FAILED) {
                  s0 = peg$parsemacro_parameter();
                  if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    s1 = [];
                    s22 = peg$parsewhitespace();
                    while (s22 !== peg$FAILED) {
                      s1.push(s22);
                      s22 = peg$parsewhitespace();
                    }
                    s22 = peg$parsesuperscript();
                    if (s22 !== peg$FAILED) {
                      s32 = [];
                      s42 = peg$parsewhitespace();
                      while (s42 !== peg$FAILED) {
                        s32.push(s42);
                        s42 = peg$parsewhitespace();
                      }
                      peg$savedPos = s0;
                      s0 = peg$f8();
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                    if (s0 === peg$FAILED) {
                      s0 = peg$currPos;
                      s1 = [];
                      s22 = peg$parsewhitespace();
                      while (s22 !== peg$FAILED) {
                        s1.push(s22);
                        s22 = peg$parsewhitespace();
                      }
                      s22 = peg$parsesubscript();
                      if (s22 !== peg$FAILED) {
                        s32 = [];
                        s42 = peg$parsewhitespace();
                        while (s42 !== peg$FAILED) {
                          s32.push(s42);
                          s42 = peg$parsewhitespace();
                        }
                        peg$savedPos = s0;
                        s0 = peg$f9();
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                      if (s0 === peg$FAILED) {
                        s0 = peg$parseignore();
                        if (s0 === peg$FAILED) {
                          s0 = peg$parsewhitespace();
                          if (s0 === peg$FAILED) {
                            s0 = peg$currPos;
                            if (input.length > peg$currPos) {
                              s1 = input.charAt(peg$currPos);
                              peg$currPos++;
                            } else {
                              s1 = peg$FAILED;
                              if (peg$silentFails === 0) {
                                peg$fail(peg$e3);
                              }
                            }
                            if (s1 !== peg$FAILED) {
                              peg$savedPos = s0;
                              s1 = peg$f10(s1);
                            }
                            s0 = s1;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e5);
          }
        }
        return s0;
      }
      function peg$parsenonchar_token() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parseescape();
        if (s0 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 37) {
            s0 = peg$c0;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e7);
            }
          }
          if (s0 === peg$FAILED) {
            s0 = peg$parsebegin_group();
            if (s0 === peg$FAILED) {
              s0 = peg$parseend_group();
              if (s0 === peg$FAILED) {
                s0 = peg$parsemath_shift();
                if (s0 === peg$FAILED) {
                  s0 = peg$parsealignment_tab();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parsenl();
                    if (s0 === peg$FAILED) {
                      s0 = peg$parsemacro_parameter();
                      if (s0 === peg$FAILED) {
                        s0 = peg$parseignore();
                        if (s0 === peg$FAILED) {
                          s0 = peg$parsesp();
                          if (s0 === peg$FAILED) {
                            s0 = peg$parsepunctuation();
                            if (s0 === peg$FAILED) {
                              s0 = peg$parseEOF();
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e6);
          }
        }
        return s0;
      }
      function peg$parsewhitespace() {
        var s0, s1, s22, s32, s42, s5, s6, s7;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$parsenl();
        if (s22 !== peg$FAILED) {
          s32 = [];
          s42 = peg$parsesp();
          while (s42 !== peg$FAILED) {
            s32.push(s42);
            s42 = peg$parsesp();
          }
          s22 = [s22, s32];
          s1 = s22;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
          s1 = peg$currPos;
          s22 = [];
          s32 = peg$parsesp();
          if (s32 !== peg$FAILED) {
            while (s32 !== peg$FAILED) {
              s22.push(s32);
              s32 = peg$parsesp();
            }
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s32 = peg$parsenl();
            if (s32 !== peg$FAILED) {
              s42 = peg$currPos;
              peg$silentFails++;
              s5 = peg$parsecomment_start();
              peg$silentFails--;
              if (s5 === peg$FAILED) {
                s42 = void 0;
              } else {
                peg$currPos = s42;
                s42 = peg$FAILED;
              }
              if (s42 !== peg$FAILED) {
                s5 = [];
                s6 = peg$parsesp();
                while (s6 !== peg$FAILED) {
                  s5.push(s6);
                  s6 = peg$parsesp();
                }
                s6 = peg$currPos;
                peg$silentFails++;
                s7 = peg$parsenl();
                peg$silentFails--;
                if (s7 === peg$FAILED) {
                  s6 = void 0;
                } else {
                  peg$currPos = s6;
                  s6 = peg$FAILED;
                }
                if (s6 !== peg$FAILED) {
                  s22 = [s22, s32, s42, s5, s6];
                  s1 = s22;
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 === peg$FAILED) {
            s1 = [];
            s22 = peg$parsesp();
            if (s22 !== peg$FAILED) {
              while (s22 !== peg$FAILED) {
                s1.push(s22);
                s22 = peg$parsesp();
              }
            } else {
              s1 = peg$FAILED;
            }
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f11();
        }
        s0 = s1;
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e8);
          }
        }
        return s0;
      }
      function peg$parsenumber() {
        var s0, s1, s22, s32, s42, s5;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = [];
        s32 = peg$parsenum();
        if (s32 !== peg$FAILED) {
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parsenum();
          }
        } else {
          s22 = peg$FAILED;
        }
        if (s22 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 46) {
            s32 = peg$c1;
            peg$currPos++;
          } else {
            s32 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e10);
            }
          }
          if (s32 !== peg$FAILED) {
            s42 = [];
            s5 = peg$parsenum();
            if (s5 !== peg$FAILED) {
              while (s5 !== peg$FAILED) {
                s42.push(s5);
                s5 = peg$parsenum();
              }
            } else {
              s42 = peg$FAILED;
            }
            if (s42 !== peg$FAILED) {
              peg$savedPos = s1;
              s1 = peg$f12(s22, s42);
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
          s1 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 46) {
            s22 = peg$c1;
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e10);
            }
          }
          if (s22 !== peg$FAILED) {
            s32 = [];
            s42 = peg$parsenum();
            if (s42 !== peg$FAILED) {
              while (s42 !== peg$FAILED) {
                s32.push(s42);
                s42 = peg$parsenum();
              }
            } else {
              s32 = peg$FAILED;
            }
            if (s32 !== peg$FAILED) {
              peg$savedPos = s1;
              s1 = peg$f13(s32);
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 === peg$FAILED) {
            s1 = peg$currPos;
            s22 = [];
            s32 = peg$parsenum();
            if (s32 !== peg$FAILED) {
              while (s32 !== peg$FAILED) {
                s22.push(s32);
                s32 = peg$parsenum();
              }
            } else {
              s22 = peg$FAILED;
            }
            if (s22 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 46) {
                s32 = peg$c1;
                peg$currPos++;
              } else {
                s32 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e10);
                }
              }
              if (s32 !== peg$FAILED) {
                peg$savedPos = s1;
                s1 = peg$f14(s22);
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f15(s1);
        }
        s0 = s1;
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e9);
          }
        }
        return s0;
      }
      function peg$parsespecial_macro() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8, s9;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parseescape();
        if (s1 !== peg$FAILED) {
          if (input.substr(peg$currPos, 5) === peg$c2) {
            s22 = peg$c2;
            peg$currPos += 5;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e12);
            }
          }
          if (s22 === peg$FAILED) {
            if (input.substr(peg$currPos, 4) === peg$c3) {
              s22 = peg$c3;
              peg$currPos += 4;
            } else {
              s22 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e13);
              }
            }
          }
          if (s22 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s32 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s32 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e3);
              }
            }
            if (s32 !== peg$FAILED) {
              s42 = [];
              s5 = peg$currPos;
              s6 = peg$currPos;
              peg$silentFails++;
              s7 = peg$currPos;
              if (input.length > peg$currPos) {
                s8 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s8 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e3);
                }
              }
              if (s8 !== peg$FAILED) {
                peg$savedPos = peg$currPos;
                s9 = peg$f16(s22, s32, s8);
                if (s9) {
                  s9 = void 0;
                } else {
                  s9 = peg$FAILED;
                }
                if (s9 !== peg$FAILED) {
                  s8 = [s8, s9];
                  s7 = s8;
                } else {
                  peg$currPos = s7;
                  s7 = peg$FAILED;
                }
              } else {
                peg$currPos = s7;
                s7 = peg$FAILED;
              }
              peg$silentFails--;
              if (s7 === peg$FAILED) {
                s6 = void 0;
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
              if (s6 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                  s7 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e3);
                  }
                }
                if (s7 !== peg$FAILED) {
                  peg$savedPos = s5;
                  s5 = peg$f17(s22, s32, s7);
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
              while (s5 !== peg$FAILED) {
                s42.push(s5);
                s5 = peg$currPos;
                s6 = peg$currPos;
                peg$silentFails++;
                s7 = peg$currPos;
                if (input.length > peg$currPos) {
                  s8 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s8 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e3);
                  }
                }
                if (s8 !== peg$FAILED) {
                  peg$savedPos = peg$currPos;
                  s9 = peg$f16(s22, s32, s8);
                  if (s9) {
                    s9 = void 0;
                  } else {
                    s9 = peg$FAILED;
                  }
                  if (s9 !== peg$FAILED) {
                    s8 = [s8, s9];
                    s7 = s8;
                  } else {
                    peg$currPos = s7;
                    s7 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s7;
                  s7 = peg$FAILED;
                }
                peg$silentFails--;
                if (s7 === peg$FAILED) {
                  s6 = void 0;
                } else {
                  peg$currPos = s6;
                  s6 = peg$FAILED;
                }
                if (s6 !== peg$FAILED) {
                  if (input.length > peg$currPos) {
                    s7 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e3);
                    }
                  }
                  if (s7 !== peg$FAILED) {
                    peg$savedPos = s5;
                    s5 = peg$f17(s22, s32, s7);
                  } else {
                    peg$currPos = s5;
                    s5 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              }
              s5 = peg$currPos;
              if (input.length > peg$currPos) {
                s6 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e3);
                }
              }
              if (s6 !== peg$FAILED) {
                peg$savedPos = peg$currPos;
                s7 = peg$f18(s22, s32, s42, s6);
                if (s7) {
                  s7 = void 0;
                } else {
                  s7 = peg$FAILED;
                }
                if (s7 !== peg$FAILED) {
                  s6 = [s6, s7];
                  s5 = s6;
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f19(s22, s32, s42);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$parseverbatim_environment();
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsebegin_display_math();
            if (s1 !== peg$FAILED) {
              s22 = [];
              s32 = peg$currPos;
              s42 = peg$currPos;
              peg$silentFails++;
              s5 = peg$parseend_display_math();
              peg$silentFails--;
              if (s5 === peg$FAILED) {
                s42 = void 0;
              } else {
                peg$currPos = s42;
                s42 = peg$FAILED;
              }
              if (s42 !== peg$FAILED) {
                s5 = peg$parsemath_token();
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s32;
                  s32 = peg$f20(s5);
                } else {
                  peg$currPos = s32;
                  s32 = peg$FAILED;
                }
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
              while (s32 !== peg$FAILED) {
                s22.push(s32);
                s32 = peg$currPos;
                s42 = peg$currPos;
                peg$silentFails++;
                s5 = peg$parseend_display_math();
                peg$silentFails--;
                if (s5 === peg$FAILED) {
                  s42 = void 0;
                } else {
                  peg$currPos = s42;
                  s42 = peg$FAILED;
                }
                if (s42 !== peg$FAILED) {
                  s5 = peg$parsemath_token();
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s32;
                    s32 = peg$f20(s5);
                  } else {
                    peg$currPos = s32;
                    s32 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s32;
                  s32 = peg$FAILED;
                }
              }
              s32 = peg$parseend_display_math();
              if (s32 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f21(s22);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parsebegin_inline_math();
              if (s1 !== peg$FAILED) {
                s22 = [];
                s32 = peg$currPos;
                s42 = peg$currPos;
                peg$silentFails++;
                s5 = peg$parseend_inline_math();
                peg$silentFails--;
                if (s5 === peg$FAILED) {
                  s42 = void 0;
                } else {
                  peg$currPos = s42;
                  s42 = peg$FAILED;
                }
                if (s42 !== peg$FAILED) {
                  s5 = peg$parsemath_token();
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s32;
                    s32 = peg$f22(s5);
                  } else {
                    peg$currPos = s32;
                    s32 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s32;
                  s32 = peg$FAILED;
                }
                while (s32 !== peg$FAILED) {
                  s22.push(s32);
                  s32 = peg$currPos;
                  s42 = peg$currPos;
                  peg$silentFails++;
                  s5 = peg$parseend_inline_math();
                  peg$silentFails--;
                  if (s5 === peg$FAILED) {
                    s42 = void 0;
                  } else {
                    peg$currPos = s42;
                    s42 = peg$FAILED;
                  }
                  if (s42 !== peg$FAILED) {
                    s5 = peg$parsemath_token();
                    if (s5 !== peg$FAILED) {
                      peg$savedPos = s32;
                      s32 = peg$f22(s5);
                    } else {
                      peg$currPos = s32;
                      s32 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s32;
                    s32 = peg$FAILED;
                  }
                }
                s32 = peg$parseend_inline_math();
                if (s32 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s0 = peg$f23(s22);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parsemath_shift();
                if (s1 !== peg$FAILED) {
                  s22 = peg$parsemath_shift();
                  if (s22 !== peg$FAILED) {
                    s32 = [];
                    s42 = peg$currPos;
                    s5 = peg$currPos;
                    peg$silentFails++;
                    s6 = peg$currPos;
                    s7 = peg$parsemath_shift();
                    if (s7 !== peg$FAILED) {
                      s8 = peg$parsemath_shift();
                      if (s8 !== peg$FAILED) {
                        s7 = [s7, s8];
                        s6 = s7;
                      } else {
                        peg$currPos = s6;
                        s6 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s6;
                      s6 = peg$FAILED;
                    }
                    peg$silentFails--;
                    if (s6 === peg$FAILED) {
                      s5 = void 0;
                    } else {
                      peg$currPos = s5;
                      s5 = peg$FAILED;
                    }
                    if (s5 !== peg$FAILED) {
                      s6 = peg$parsemath_token();
                      if (s6 !== peg$FAILED) {
                        peg$savedPos = s42;
                        s42 = peg$f24(s6);
                      } else {
                        peg$currPos = s42;
                        s42 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s42;
                      s42 = peg$FAILED;
                    }
                    while (s42 !== peg$FAILED) {
                      s32.push(s42);
                      s42 = peg$currPos;
                      s5 = peg$currPos;
                      peg$silentFails++;
                      s6 = peg$currPos;
                      s7 = peg$parsemath_shift();
                      if (s7 !== peg$FAILED) {
                        s8 = peg$parsemath_shift();
                        if (s8 !== peg$FAILED) {
                          s7 = [s7, s8];
                          s6 = s7;
                        } else {
                          peg$currPos = s6;
                          s6 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s6;
                        s6 = peg$FAILED;
                      }
                      peg$silentFails--;
                      if (s6 === peg$FAILED) {
                        s5 = void 0;
                      } else {
                        peg$currPos = s5;
                        s5 = peg$FAILED;
                      }
                      if (s5 !== peg$FAILED) {
                        s6 = peg$parsemath_token();
                        if (s6 !== peg$FAILED) {
                          peg$savedPos = s42;
                          s42 = peg$f24(s6);
                        } else {
                          peg$currPos = s42;
                          s42 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s42;
                        s42 = peg$FAILED;
                      }
                    }
                    s42 = peg$parsemath_shift();
                    if (s42 !== peg$FAILED) {
                      s5 = peg$parsemath_shift();
                      if (s5 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s0 = peg$f25(s32);
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
                if (s0 === peg$FAILED) {
                  s0 = peg$parsemath_environment();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parseenvironment();
                  }
                }
              }
            }
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e11);
          }
        }
        return s0;
      }
      function peg$parseverbatim_environment() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8, s9, s10, s11;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parsebegin_env();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsebegin_group();
          if (s22 !== peg$FAILED) {
            s32 = peg$parseverbatim_env_name();
            if (s32 !== peg$FAILED) {
              s42 = peg$parseend_group();
              if (s42 !== peg$FAILED) {
                s5 = [];
                s6 = peg$currPos;
                s7 = peg$currPos;
                peg$silentFails++;
                s8 = peg$currPos;
                s9 = peg$parseend_env();
                if (s9 !== peg$FAILED) {
                  s10 = peg$parsegroup();
                  if (s10 !== peg$FAILED) {
                    peg$savedPos = peg$currPos;
                    s11 = peg$f26(s32, s10);
                    if (s11) {
                      s11 = void 0;
                    } else {
                      s11 = peg$FAILED;
                    }
                    if (s11 !== peg$FAILED) {
                      s9 = [s9, s10, s11];
                      s8 = s9;
                    } else {
                      peg$currPos = s8;
                      s8 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s8;
                    s8 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s8;
                  s8 = peg$FAILED;
                }
                peg$silentFails--;
                if (s8 === peg$FAILED) {
                  s7 = void 0;
                } else {
                  peg$currPos = s7;
                  s7 = peg$FAILED;
                }
                if (s7 !== peg$FAILED) {
                  if (input.length > peg$currPos) {
                    s8 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s8 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e3);
                    }
                  }
                  if (s8 !== peg$FAILED) {
                    peg$savedPos = s6;
                    s6 = peg$f27(s32, s8);
                  } else {
                    peg$currPos = s6;
                    s6 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s6;
                  s6 = peg$FAILED;
                }
                while (s6 !== peg$FAILED) {
                  s5.push(s6);
                  s6 = peg$currPos;
                  s7 = peg$currPos;
                  peg$silentFails++;
                  s8 = peg$currPos;
                  s9 = peg$parseend_env();
                  if (s9 !== peg$FAILED) {
                    s10 = peg$parsegroup();
                    if (s10 !== peg$FAILED) {
                      peg$savedPos = peg$currPos;
                      s11 = peg$f26(s32, s10);
                      if (s11) {
                        s11 = void 0;
                      } else {
                        s11 = peg$FAILED;
                      }
                      if (s11 !== peg$FAILED) {
                        s9 = [s9, s10, s11];
                        s8 = s9;
                      } else {
                        peg$currPos = s8;
                        s8 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s8;
                      s8 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s8;
                    s8 = peg$FAILED;
                  }
                  peg$silentFails--;
                  if (s8 === peg$FAILED) {
                    s7 = void 0;
                  } else {
                    peg$currPos = s7;
                    s7 = peg$FAILED;
                  }
                  if (s7 !== peg$FAILED) {
                    if (input.length > peg$currPos) {
                      s8 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s8 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e3);
                      }
                    }
                    if (s8 !== peg$FAILED) {
                      peg$savedPos = s6;
                      s6 = peg$f27(s32, s8);
                    } else {
                      peg$currPos = s6;
                      s6 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s6;
                    s6 = peg$FAILED;
                  }
                }
                s6 = peg$parseend_env();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parsebegin_group();
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parseverbatim_env_name();
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parseend_group();
                      if (s9 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s0 = peg$f28(s32, s5);
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e14);
          }
        }
        return s0;
      }
      function peg$parseverbatim_env_name() {
        var s0;
        if (input.substr(peg$currPos, 9) === peg$c4) {
          s0 = peg$c4;
          peg$currPos += 9;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e15);
          }
        }
        if (s0 === peg$FAILED) {
          if (input.substr(peg$currPos, 8) === peg$c5) {
            s0 = peg$c5;
            peg$currPos += 8;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e16);
            }
          }
          if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 13) === peg$c6) {
              s0 = peg$c6;
              peg$currPos += 13;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e17);
              }
            }
            if (s0 === peg$FAILED) {
              if (input.substr(peg$currPos, 12) === peg$c7) {
                s0 = peg$c7;
                peg$currPos += 12;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e18);
                }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 7) === peg$c8) {
                  s0 = peg$c8;
                  peg$currPos += 7;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e19);
                  }
                }
                if (s0 === peg$FAILED) {
                  if (input.substr(peg$currPos, 10) === peg$c9) {
                    s0 = peg$c9;
                    peg$currPos += 10;
                  } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e20);
                    }
                  }
                }
              }
            }
          }
        }
        return s0;
      }
      function peg$parsemacro() {
        var s0, s1, s22, s32, s42;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$parseescape();
        if (s22 !== peg$FAILED) {
          s32 = [];
          s42 = peg$parsechar();
          if (s42 !== peg$FAILED) {
            while (s42 !== peg$FAILED) {
              s32.push(s42);
              s42 = peg$parsechar();
            }
          } else {
            s32 = peg$FAILED;
          }
          if (s32 !== peg$FAILED) {
            peg$savedPos = s1;
            s1 = peg$f29(s32);
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
          s1 = peg$currPos;
          s22 = peg$parseescape();
          if (s22 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s32 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s32 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e3);
              }
            }
            if (s32 !== peg$FAILED) {
              peg$savedPos = s1;
              s1 = peg$f30(s32);
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f31(s1);
        }
        s0 = s1;
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e21);
          }
        }
        return s0;
      }
      function peg$parsegroup() {
        var s0, s1, s22, s32, s42, s5;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parsebegin_group();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$currPos;
          s42 = peg$currPos;
          peg$silentFails++;
          s5 = peg$parseend_group();
          peg$silentFails--;
          if (s5 === peg$FAILED) {
            s42 = void 0;
          } else {
            peg$currPos = s42;
            s42 = peg$FAILED;
          }
          if (s42 !== peg$FAILED) {
            s5 = peg$parsetoken();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s32;
              s32 = peg$f32(s5);
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          } else {
            peg$currPos = s32;
            s32 = peg$FAILED;
          }
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$currPos;
            s42 = peg$currPos;
            peg$silentFails++;
            s5 = peg$parseend_group();
            peg$silentFails--;
            if (s5 === peg$FAILED) {
              s42 = void 0;
            } else {
              peg$currPos = s42;
              s42 = peg$FAILED;
            }
            if (s42 !== peg$FAILED) {
              s5 = peg$parsetoken();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s32;
                s32 = peg$f32(s5);
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          }
          s32 = peg$parseend_group();
          if (s32 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f33(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e22);
          }
        }
        return s0;
      }
      function peg$parsegroup_contents_as_string() {
        var s0, s1;
        s0 = peg$currPos;
        s1 = peg$parsegroup();
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f34(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parseenvironment() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8, s9, s10;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parsebegin_env();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsegroup_contents_as_string();
          if (s22 !== peg$FAILED) {
            s32 = peg$parsesameline_comment();
            if (s32 === peg$FAILED) {
              s32 = null;
            }
            s42 = [];
            s5 = peg$currPos;
            s6 = peg$currPos;
            peg$silentFails++;
            s7 = peg$currPos;
            s8 = peg$parseend_env();
            if (s8 !== peg$FAILED) {
              s9 = peg$parsegroup_contents_as_string();
              if (s9 !== peg$FAILED) {
                peg$savedPos = peg$currPos;
                s10 = peg$f35(s22, s32, s9);
                if (s10) {
                  s10 = void 0;
                } else {
                  s10 = peg$FAILED;
                }
                if (s10 !== peg$FAILED) {
                  s8 = [s8, s9, s10];
                  s7 = s8;
                } else {
                  peg$currPos = s7;
                  s7 = peg$FAILED;
                }
              } else {
                peg$currPos = s7;
                s7 = peg$FAILED;
              }
            } else {
              peg$currPos = s7;
              s7 = peg$FAILED;
            }
            peg$silentFails--;
            if (s7 === peg$FAILED) {
              s6 = void 0;
            } else {
              peg$currPos = s6;
              s6 = peg$FAILED;
            }
            if (s6 !== peg$FAILED) {
              s7 = peg$parsetoken();
              if (s7 !== peg$FAILED) {
                peg$savedPos = s5;
                s5 = peg$f36(s22, s32, s7);
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
            while (s5 !== peg$FAILED) {
              s42.push(s5);
              s5 = peg$currPos;
              s6 = peg$currPos;
              peg$silentFails++;
              s7 = peg$currPos;
              s8 = peg$parseend_env();
              if (s8 !== peg$FAILED) {
                s9 = peg$parsegroup_contents_as_string();
                if (s9 !== peg$FAILED) {
                  peg$savedPos = peg$currPos;
                  s10 = peg$f35(s22, s32, s9);
                  if (s10) {
                    s10 = void 0;
                  } else {
                    s10 = peg$FAILED;
                  }
                  if (s10 !== peg$FAILED) {
                    s8 = [s8, s9, s10];
                    s7 = s8;
                  } else {
                    peg$currPos = s7;
                    s7 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s7;
                  s7 = peg$FAILED;
                }
              } else {
                peg$currPos = s7;
                s7 = peg$FAILED;
              }
              peg$silentFails--;
              if (s7 === peg$FAILED) {
                s6 = void 0;
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
              if (s6 !== peg$FAILED) {
                s7 = peg$parsetoken();
                if (s7 !== peg$FAILED) {
                  peg$savedPos = s5;
                  s5 = peg$f36(s22, s32, s7);
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            }
            s5 = peg$parseend_env();
            if (s5 !== peg$FAILED) {
              s6 = peg$parsegroup_contents_as_string();
              if (s6 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f37(s22, s32, s42);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e23);
          }
        }
        return s0;
      }
      function peg$parsemath_environment() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8, s9, s10, s11, s12;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parsebegin_env();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsebegin_group();
          if (s22 !== peg$FAILED) {
            s32 = peg$parsemath_env_name();
            if (s32 !== peg$FAILED) {
              s42 = peg$parseend_group();
              if (s42 !== peg$FAILED) {
                s5 = peg$parsesameline_comment();
                if (s5 === peg$FAILED) {
                  s5 = null;
                }
                s6 = [];
                s7 = peg$currPos;
                s8 = peg$currPos;
                peg$silentFails++;
                s9 = peg$currPos;
                s10 = peg$parseend_env();
                if (s10 !== peg$FAILED) {
                  s11 = peg$parsegroup();
                  if (s11 !== peg$FAILED) {
                    peg$savedPos = peg$currPos;
                    s12 = peg$f38(s32, s5, s11);
                    if (s12) {
                      s12 = void 0;
                    } else {
                      s12 = peg$FAILED;
                    }
                    if (s12 !== peg$FAILED) {
                      s10 = [s10, s11, s12];
                      s9 = s10;
                    } else {
                      peg$currPos = s9;
                      s9 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s9;
                    s9 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s9;
                  s9 = peg$FAILED;
                }
                peg$silentFails--;
                if (s9 === peg$FAILED) {
                  s8 = void 0;
                } else {
                  peg$currPos = s8;
                  s8 = peg$FAILED;
                }
                if (s8 !== peg$FAILED) {
                  s9 = peg$parsemath_token();
                  if (s9 !== peg$FAILED) {
                    peg$savedPos = s7;
                    s7 = peg$f39(s32, s5, s9);
                  } else {
                    peg$currPos = s7;
                    s7 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s7;
                  s7 = peg$FAILED;
                }
                while (s7 !== peg$FAILED) {
                  s6.push(s7);
                  s7 = peg$currPos;
                  s8 = peg$currPos;
                  peg$silentFails++;
                  s9 = peg$currPos;
                  s10 = peg$parseend_env();
                  if (s10 !== peg$FAILED) {
                    s11 = peg$parsegroup();
                    if (s11 !== peg$FAILED) {
                      peg$savedPos = peg$currPos;
                      s12 = peg$f38(s32, s5, s11);
                      if (s12) {
                        s12 = void 0;
                      } else {
                        s12 = peg$FAILED;
                      }
                      if (s12 !== peg$FAILED) {
                        s10 = [s10, s11, s12];
                        s9 = s10;
                      } else {
                        peg$currPos = s9;
                        s9 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s9;
                      s9 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s9;
                    s9 = peg$FAILED;
                  }
                  peg$silentFails--;
                  if (s9 === peg$FAILED) {
                    s8 = void 0;
                  } else {
                    peg$currPos = s8;
                    s8 = peg$FAILED;
                  }
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parsemath_token();
                    if (s9 !== peg$FAILED) {
                      peg$savedPos = s7;
                      s7 = peg$f39(s32, s5, s9);
                    } else {
                      peg$currPos = s7;
                      s7 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s7;
                    s7 = peg$FAILED;
                  }
                }
                s7 = peg$parseend_env();
                if (s7 !== peg$FAILED) {
                  s8 = peg$parsebegin_group();
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parsemath_env_name();
                    if (s9 !== peg$FAILED) {
                      s10 = peg$parseend_group();
                      if (s10 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s0 = peg$f40(s32, s5, s6);
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e24);
          }
        }
        return s0;
      }
      function peg$parsemath_group() {
        var s0, s1, s22, s32, s42, s5;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parsebegin_group();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$currPos;
          s42 = peg$currPos;
          peg$silentFails++;
          s5 = peg$parseend_group();
          peg$silentFails--;
          if (s5 === peg$FAILED) {
            s42 = void 0;
          } else {
            peg$currPos = s42;
            s42 = peg$FAILED;
          }
          if (s42 !== peg$FAILED) {
            s5 = peg$parsemath_token();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s32;
              s32 = peg$f41(s5);
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          } else {
            peg$currPos = s32;
            s32 = peg$FAILED;
          }
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$currPos;
            s42 = peg$currPos;
            peg$silentFails++;
            s5 = peg$parseend_group();
            peg$silentFails--;
            if (s5 === peg$FAILED) {
              s42 = void 0;
            } else {
              peg$currPos = s42;
              s42 = peg$FAILED;
            }
            if (s42 !== peg$FAILED) {
              s5 = peg$parsemath_token();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s32;
                s32 = peg$f41(s5);
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          }
          s32 = peg$parseend_group();
          if (s32 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f42(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e25);
          }
        }
        return s0;
      }
      function peg$parsebegin_display_math() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parseescape();
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 91) {
            s22 = peg$c10;
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e26);
            }
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseend_display_math() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parseescape();
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 93) {
            s22 = peg$c11;
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e27);
            }
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsebegin_inline_math() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parseescape();
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 40) {
            s22 = peg$c12;
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e28);
            }
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseend_inline_math() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parseescape();
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 41) {
            s22 = peg$c13;
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e29);
            }
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsebegin_env() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parseescape();
        if (s1 !== peg$FAILED) {
          if (input.substr(peg$currPos, 5) === peg$c14) {
            s22 = peg$c14;
            peg$currPos += 5;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e30);
            }
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseend_env() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parseescape();
        if (s1 !== peg$FAILED) {
          if (input.substr(peg$currPos, 3) === peg$c15) {
            s22 = peg$c15;
            peg$currPos += 3;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e31);
            }
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsemath_env_name() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 9) === peg$c16) {
          s1 = peg$c16;
          peg$currPos += 9;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e32);
          }
        }
        if (s1 === peg$FAILED) {
          if (input.substr(peg$currPos, 8) === peg$c17) {
            s1 = peg$c17;
            peg$currPos += 8;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e33);
            }
          }
          if (s1 === peg$FAILED) {
            if (input.substr(peg$currPos, 6) === peg$c18) {
              s1 = peg$c18;
              peg$currPos += 6;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e34);
              }
            }
            if (s1 === peg$FAILED) {
              if (input.substr(peg$currPos, 5) === peg$c19) {
                s1 = peg$c19;
                peg$currPos += 5;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e35);
                }
              }
              if (s1 === peg$FAILED) {
                if (input.substr(peg$currPos, 8) === peg$c20) {
                  s1 = peg$c20;
                  peg$currPos += 8;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e36);
                  }
                }
                if (s1 === peg$FAILED) {
                  if (input.substr(peg$currPos, 7) === peg$c21) {
                    s1 = peg$c21;
                    peg$currPos += 7;
                  } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e37);
                    }
                  }
                  if (s1 === peg$FAILED) {
                    if (input.substr(peg$currPos, 7) === peg$c22) {
                      s1 = peg$c22;
                      peg$currPos += 7;
                    } else {
                      s1 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e38);
                      }
                    }
                    if (s1 === peg$FAILED) {
                      if (input.substr(peg$currPos, 6) === peg$c23) {
                        s1 = peg$c23;
                        peg$currPos += 6;
                      } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$e39);
                        }
                      }
                      if (s1 === peg$FAILED) {
                        if (input.substr(peg$currPos, 9) === peg$c24) {
                          s1 = peg$c24;
                          peg$currPos += 9;
                        } else {
                          s1 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$e40);
                          }
                        }
                        if (s1 === peg$FAILED) {
                          if (input.substr(peg$currPos, 8) === peg$c25) {
                            s1 = peg$c25;
                            peg$currPos += 8;
                          } else {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) {
                              peg$fail(peg$e41);
                            }
                          }
                          if (s1 === peg$FAILED) {
                            if (input.substr(peg$currPos, 8) === peg$c26) {
                              s1 = peg$c26;
                              peg$currPos += 8;
                            } else {
                              s1 = peg$FAILED;
                              if (peg$silentFails === 0) {
                                peg$fail(peg$e42);
                              }
                            }
                            if (s1 === peg$FAILED) {
                              if (input.substr(peg$currPos, 7) === peg$c27) {
                                s1 = peg$c27;
                                peg$currPos += 7;
                              } else {
                                s1 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                  peg$fail(peg$e43);
                                }
                              }
                              if (s1 === peg$FAILED) {
                                if (input.substr(peg$currPos, 5) === peg$c28) {
                                  s1 = peg$c28;
                                  peg$currPos += 5;
                                } else {
                                  s1 = peg$FAILED;
                                  if (peg$silentFails === 0) {
                                    peg$fail(peg$e44);
                                  }
                                }
                                if (s1 === peg$FAILED) {
                                  if (input.substr(peg$currPos, 4) === peg$c29) {
                                    s1 = peg$c29;
                                    peg$currPos += 4;
                                  } else {
                                    s1 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                      peg$fail(peg$e45);
                                    }
                                  }
                                  if (s1 === peg$FAILED) {
                                    if (input.substr(peg$currPos, 11) === peg$c30) {
                                      s1 = peg$c30;
                                      peg$currPos += 11;
                                    } else {
                                      s1 = peg$FAILED;
                                      if (peg$silentFails === 0) {
                                        peg$fail(peg$e46);
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f43(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parseescape() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 92) {
          s1 = peg$c31;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e48);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f44();
        }
        s0 = s1;
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e47);
          }
        }
        return s0;
      }
      function peg$parsebegin_group() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 123) {
          s1 = peg$c32;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e49);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f45(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parseend_group() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 125) {
          s1 = peg$c33;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e50);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f46(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parsemath_shift() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 36) {
          s1 = peg$c34;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e51);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f47(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parsealignment_tab() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 38) {
          s1 = peg$c35;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e52);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f48(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parsenl() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 13) {
          s22 = peg$c36;
          peg$currPos++;
        } else {
          s22 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e54);
          }
        }
        peg$silentFails--;
        if (s22 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 10) {
            s22 = peg$c37;
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e55);
            }
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 13) {
            s0 = peg$c36;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e54);
            }
          }
          if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c38) {
              s0 = peg$c38;
              peg$currPos += 2;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e56);
              }
            }
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e53);
          }
        }
        return s0;
      }
      function peg$parsemacro_parameter() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 35) {
          s1 = peg$c39;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e57);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f49(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parsesuperscript() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 94) {
          s1 = peg$c40;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e58);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f50(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parsesubscript() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 95) {
          s1 = peg$c41;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e59);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f51(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parseignore() {
        var s0;
        if (input.charCodeAt(peg$currPos) === 0) {
          s0 = peg$c42;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e60);
          }
        }
        return s0;
      }
      function peg$parsesp() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        if (peg$r0.test(input.charAt(peg$currPos))) {
          s22 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s22 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e61);
          }
        }
        if (s22 !== peg$FAILED) {
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            if (peg$r0.test(input.charAt(peg$currPos))) {
              s22 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s22 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e61);
              }
            }
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f52();
        }
        s0 = s1;
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e8);
          }
        }
        return s0;
      }
      function peg$parsechar() {
        var s0, s1;
        peg$silentFails++;
        if (peg$r1.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e63);
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e62);
          }
        }
        return s0;
      }
      function peg$parsenum() {
        var s0, s1;
        peg$silentFails++;
        if (peg$r2.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e65);
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e64);
          }
        }
        return s0;
      }
      function peg$parsepunctuation() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$currPos;
        if (peg$r3.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e67);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f53(s1);
        }
        s0 = s1;
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e66);
          }
        }
        return s0;
      }
      function peg$parsecomment_start() {
        var s0;
        if (input.charCodeAt(peg$currPos) === 37) {
          s0 = peg$c0;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e7);
          }
        }
        return s0;
      }
      function peg$parsefull_comment() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parseownline_comment();
        if (s0 === peg$FAILED) {
          s0 = peg$parsesameline_comment();
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e68);
          }
        }
        return s0;
      }
      function peg$parseownline_comment() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = [];
        s32 = peg$parsesp();
        while (s32 !== peg$FAILED) {
          s22.push(s32);
          s32 = peg$parsesp();
        }
        s32 = peg$parsenl();
        if (s32 !== peg$FAILED) {
          s22 = [s22, s32];
          s1 = s22;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
          s1 = null;
        }
        s22 = peg$parseleading_sp();
        if (s22 !== peg$FAILED) {
          s32 = peg$parsecomment();
          if (s32 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f54(s22, s32);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsesameline_comment() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsesp();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parsesp();
        }
        s22 = peg$parsecomment();
        if (s22 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f55(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecomment() {
        var s0, s1, s22, s32, s42, s5, s6, s7;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parsecomment_start();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$currPos;
          s42 = peg$currPos;
          peg$silentFails++;
          s5 = peg$parsenl();
          peg$silentFails--;
          if (s5 === peg$FAILED) {
            s42 = void 0;
          } else {
            peg$currPos = s42;
            s42 = peg$FAILED;
          }
          if (s42 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s5 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e3);
              }
            }
            if (s5 !== peg$FAILED) {
              peg$savedPos = s32;
              s32 = peg$f56(s5);
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          } else {
            peg$currPos = s32;
            s32 = peg$FAILED;
          }
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$currPos;
            s42 = peg$currPos;
            peg$silentFails++;
            s5 = peg$parsenl();
            peg$silentFails--;
            if (s5 === peg$FAILED) {
              s42 = void 0;
            } else {
              peg$currPos = s42;
              s42 = peg$FAILED;
            }
            if (s42 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s5 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e3);
                }
              }
              if (s5 !== peg$FAILED) {
                peg$savedPos = s32;
                s32 = peg$f56(s5);
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          }
          s32 = peg$currPos;
          peg$silentFails++;
          s42 = peg$parseparbreak();
          peg$silentFails--;
          if (s42 !== peg$FAILED) {
            peg$currPos = s32;
            s32 = void 0;
          } else {
            s32 = peg$FAILED;
          }
          if (s32 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f57(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsecomment_start();
          if (s1 !== peg$FAILED) {
            s22 = [];
            s32 = peg$currPos;
            s42 = peg$currPos;
            peg$silentFails++;
            s5 = peg$parsenl();
            peg$silentFails--;
            if (s5 === peg$FAILED) {
              s42 = void 0;
            } else {
              peg$currPos = s42;
              s42 = peg$FAILED;
            }
            if (s42 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s5 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e3);
                }
              }
              if (s5 !== peg$FAILED) {
                peg$savedPos = s32;
                s32 = peg$f58(s5);
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
            while (s32 !== peg$FAILED) {
              s22.push(s32);
              s32 = peg$currPos;
              s42 = peg$currPos;
              peg$silentFails++;
              s5 = peg$parsenl();
              peg$silentFails--;
              if (s5 === peg$FAILED) {
                s42 = void 0;
              } else {
                peg$currPos = s42;
                s42 = peg$FAILED;
              }
              if (s42 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                  s5 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e3);
                  }
                }
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s32;
                  s32 = peg$f58(s5);
                } else {
                  peg$currPos = s32;
                  s32 = peg$FAILED;
                }
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
            }
            s32 = peg$currPos;
            s42 = peg$parsenl();
            if (s42 !== peg$FAILED) {
              s5 = [];
              s6 = peg$parsesp();
              while (s6 !== peg$FAILED) {
                s5.push(s6);
                s6 = peg$parsesp();
              }
              s6 = peg$currPos;
              peg$silentFails++;
              s7 = peg$parsecomment_start();
              peg$silentFails--;
              if (s7 === peg$FAILED) {
                s6 = void 0;
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
              if (s6 !== peg$FAILED) {
                s42 = [s42, s5, s6];
                s32 = s42;
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
            if (s32 === peg$FAILED) {
              s32 = peg$parsenl();
              if (s32 === peg$FAILED) {
                s32 = peg$parseEOF();
              }
            }
            if (s32 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f59(s22);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e69);
          }
        }
        return s0;
      }
      function peg$parseleading_sp() {
        var s0, s1, s22, s32, s42;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$parsestart_of_line();
        if (s22 !== peg$FAILED) {
          s32 = [];
          s42 = peg$parsesp();
          while (s42 !== peg$FAILED) {
            s32.push(s42);
            s42 = peg$parsesp();
          }
          s22 = [s22, s32];
          s1 = s22;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }
        return s0;
      }
      function peg$parsestart_of_line() {
        var s0;
        peg$savedPos = peg$currPos;
        s0 = peg$f60();
        if (s0) {
          s0 = void 0;
        } else {
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseEOF() {
        var s0, s1;
        s0 = peg$currPos;
        peg$silentFails++;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        peg$silentFails--;
        if (s1 === peg$FAILED) {
          s0 = void 0;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function toString(e) {
        if (typeof e === "string") {
          return e;
        }
        if (typeof e.content === "string") {
          return e.content;
        }
        if (e && e.type === "whitespace") {
          return " ";
        }
        return e;
      }
      function compare_env(g1, g2) {
        const g1Name = typeof g1 === "string" ? g1 : g1.content.map(toString).join("");
        const g2Name = typeof g2 === "string" ? g2 : g2.content.map(toString).join("");
        return g1Name === g2Name;
      }
      function createNode(type, extra = {}) {
        return { type, ...extra, position: location() };
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(
          peg$maxFailExpected,
          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
      }
    }
    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }()
);
var align_environment_default3 = (
  // Generated by Peggy 2.0.1.
  //
  // https://peggyjs.org/
  function() {
    "use strict";
    function peg$subclass(child, parent) {
      function C() {
        this.constructor = child;
      }
      C.prototype = parent.prototype;
      child.prototype = new C();
    }
    function peg$SyntaxError(message, expected, found, location) {
      var self = Error.call(this, message);
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(self, peg$SyntaxError.prototype);
      }
      self.expected = expected;
      self.found = found;
      self.location = location;
      self.name = "SyntaxError";
      return self;
    }
    peg$subclass(peg$SyntaxError, Error);
    function peg$padEnd(str, targetLength, padString) {
      padString = padString || " ";
      if (str.length > targetLength) {
        return str;
      }
      targetLength -= str.length;
      padString += padString.repeat(targetLength);
      return str + padString.slice(0, targetLength);
    }
    peg$SyntaxError.prototype.format = function(sources) {
      var str = "Error: " + this.message;
      if (this.location) {
        var src = null;
        var k;
        for (k = 0; k < sources.length; k++) {
          if (sources[k].source === this.location.source) {
            src = sources[k].text.split(/\r\n|\n|\r/g);
            break;
          }
        }
        var s32 = this.location.start;
        var loc = this.location.source + ":" + s32.line + ":" + s32.column;
        if (src) {
          var e = this.location.end;
          var filler = peg$padEnd("", s32.line.toString().length, " ");
          var line = src[s32.line - 1];
          var last = s32.line === e.line ? e.column : line.length + 1;
          var hatLen = last - s32.column || 1;
          str += "\n --> " + loc + "\n" + filler + " |\n" + s32.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s32.column - 1, " ") + peg$padEnd("", hatLen, "^");
        } else {
          str += "\n at " + loc;
        }
      }
      return str;
    };
    peg$SyntaxError.buildMessage = function(expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        class: function(expectation) {
          var escapedParts = expectation.parts.map(function(part) {
            return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
          });
          return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
        },
        any: function() {
          return "any character";
        },
        end: function() {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        }
      };
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s32) {
        return s32.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function classEscape(s32) {
        return s32.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = expected2.map(describeExpectation);
        var i, j;
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {};
      var peg$source = options.grammarSource;
      var peg$startRuleFunctions = { body: peg$parsebody };
      var peg$startRuleFunction = peg$parsebody;
      var peg$e0 = peg$anyExpectation();
      var peg$f0 = function() {
        return [];
      };
      var peg$f1 = function(x) {
        return { cells: [], colSeps: [], ...x };
      };
      var peg$f2 = function(rowItems, rowSep, trailingComment) {
        return { ...rowItems, rowSep, trailingComment };
      };
      var peg$f3 = function(rowItems, trailingComment) {
        return { ...rowItems, rowSep: null, trailingComment };
      };
      var peg$f4 = function(x) {
        return x;
      };
      var peg$f5 = function(x) {
        return {
          cells: [],
          colSeps: [],
          rowSep: null,
          trailingComment: x
        };
      };
      var peg$f6 = function(x) {
        return x;
      };
      var peg$f7 = function(colSep, cell) {
        return { colSep, cell };
      };
      var peg$f8 = function(colSep) {
        return { colSep };
      };
      var peg$f9 = function(a, b) {
        return processRow(a, b);
      };
      var peg$f10 = function(b) {
        return processRow(null, b);
      };
      var peg$f11 = function(tok) {
        return options.isSameLineComment(tok);
      };
      var peg$f12 = function(tok) {
        return tok;
      };
      var peg$f13 = function(tok) {
        return options.isOwnLineComment(tok);
      };
      var peg$f14 = function(tok) {
        return tok;
      };
      var peg$f15 = function(tok) {
        return options.isWhitespace(tok);
      };
      var peg$f16 = function(tok) {
        return tok;
      };
      var peg$f17 = function(tok) {
        return options.isRowSep(tok);
      };
      var peg$f18 = function(tok) {
        return tok;
      };
      var peg$f19 = function(tok) {
        return options.isColSep(tok);
      };
      var peg$f20 = function(tok) {
        return tok;
      };
      var peg$currPos = 0;
      var peg$savedPos = 0;
      var peg$posDetailsCache = [{ line: 1, column: 1 }];
      var peg$maxFailPos = 0;
      var peg$maxFailExpected = [];
      var peg$silentFails = 0;
      var peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function offset() {
        return peg$savedPos;
      }
      function range() {
        return {
          source: peg$source,
          start: peg$savedPos,
          end: peg$currPos
        };
      }
      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError(
          [peg$otherExpectation(description)],
          input.substring(peg$savedPos, peg$currPos),
          location2
        );
      }
      function error(message, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location2);
      }
      function peg$literalExpectation(text2, ignoreCase) {
        return { type: "literal", text: text2, ignoreCase };
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts, inverted, ignoreCase };
      }
      function peg$anyExpectation() {
        return { type: "any" };
      }
      function peg$endExpectation() {
        return { type: "end" };
      }
      function peg$otherExpectation(description) {
        return { type: "other", description };
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p;
        if (details) {
          return details;
        } else {
          p = pos - 1;
          while (!peg$posDetailsCache[p]) {
            p--;
          }
          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };
          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos);
        var endPosDetails = peg$computePosDetails(endPos);
        return {
          source: peg$source,
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildSimpleError(message, location2) {
        return new peg$SyntaxError(message, null, null, location2);
      }
      function peg$buildStructuredError(expected2, found, location2) {
        return new peg$SyntaxError(
          peg$SyntaxError.buildMessage(expected2, found),
          expected2,
          found,
          location2
        );
      }
      function peg$parsebody() {
        var s0, s1;
        s0 = [];
        s1 = peg$parsecomment_only_line();
        if (s1 === peg$FAILED) {
          s1 = peg$parserow_with_end();
          if (s1 === peg$FAILED) {
            s1 = peg$parserow_without_end();
          }
        }
        if (s1 !== peg$FAILED) {
          while (s1 !== peg$FAILED) {
            s0.push(s1);
            s1 = peg$parsecomment_only_line();
            if (s1 === peg$FAILED) {
              s1 = peg$parserow_with_end();
              if (s1 === peg$FAILED) {
                s1 = peg$parserow_without_end();
              }
            }
          }
        } else {
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseEOL();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f0();
          }
          s0 = s1;
        }
        return s0;
      }
      function peg$parserow_with_end() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$parserow_items();
        if (s22 === peg$FAILED) {
          s22 = null;
        }
        peg$savedPos = s1;
        s22 = peg$f1(s22);
        s1 = s22;
        s22 = peg$parserow_sep();
        if (s22 !== peg$FAILED) {
          s32 = peg$parsetrailing_comment();
          if (s32 === peg$FAILED) {
            s32 = null;
          }
          peg$savedPos = s0;
          s0 = peg$f2(s1, s22, s32);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parserow_without_end() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parserow_items();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsetrailing_comment();
          if (s22 === peg$FAILED) {
            s22 = null;
          }
          peg$savedPos = s0;
          s0 = peg$f3(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsetrailing_comment() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsewhitespace();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parsewhitespace();
        }
        s22 = peg$parsesame_line_comment();
        if (s22 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f4(s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecomment_only_line() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsewhitespace();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parsewhitespace();
        }
        s22 = peg$parseown_line_comment();
        if (s22 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f5(s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsetoken() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        s22 = peg$parserow_sep();
        if (s22 === peg$FAILED) {
          s22 = peg$parsecol_sep();
          if (s22 === peg$FAILED) {
            s22 = peg$parsetrailing_comment();
            if (s22 === peg$FAILED) {
              s22 = peg$parseown_line_comment();
            }
          }
        }
        peg$silentFails--;
        if (s22 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s22 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f6(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecell() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsetoken();
        if (s22 !== peg$FAILED) {
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            s22 = peg$parsetoken();
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }
        return s0;
      }
      function peg$parseseparated_cell() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parsecol_sep();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsecell();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f7(s1, s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsecol_sep();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f8(s1);
          }
          s0 = s1;
        }
        return s0;
      }
      function peg$parserow_items() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$parsecell();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$parseseparated_cell();
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parseseparated_cell();
          }
          peg$savedPos = s0;
          s0 = peg$f9(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = [];
          s22 = peg$parseseparated_cell();
          if (s22 !== peg$FAILED) {
            while (s22 !== peg$FAILED) {
              s1.push(s22);
              s22 = peg$parseseparated_cell();
            }
          } else {
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f10(s1);
          }
          s0 = s1;
        }
        return s0;
      }
      function peg$parsesame_line_comment() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f11(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f12(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseown_line_comment() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f13(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f14(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsewhitespace() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f15(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f16(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parserow_sep() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f17(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f18(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecol_sep() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f19(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f20(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseEOL() {
        var s0, s1;
        s0 = peg$currPos;
        peg$silentFails++;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        peg$silentFails--;
        if (s1 === peg$FAILED) {
          s0 = void 0;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function processRow(leadCell, otherCells) {
        const cells = [leadCell || []];
        const seps = [];
        for (const x of otherCells) {
          cells.push(x.cell || []);
          seps.push(x.colSep);
        }
        return { cells, colSeps: seps };
      }
      if (!options.isWhitespace) {
        try {
          Object.assign(
            options,
            createMatchers(["\\", "hline", "cr"], ["&"])
          );
        } catch (e) {
          console.warn("Error when initializing parser", e);
        }
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(
          peg$maxFailExpected,
          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
      }
    }
    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }()
);
var xparse_argspec_default3 = (
  // Generated by Peggy 2.0.1.
  //
  // https://peggyjs.org/
  function() {
    "use strict";
    function peg$subclass(child, parent) {
      function C() {
        this.constructor = child;
      }
      C.prototype = parent.prototype;
      child.prototype = new C();
    }
    function peg$SyntaxError(message, expected, found, location) {
      var self = Error.call(this, message);
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(self, peg$SyntaxError.prototype);
      }
      self.expected = expected;
      self.found = found;
      self.location = location;
      self.name = "SyntaxError";
      return self;
    }
    peg$subclass(peg$SyntaxError, Error);
    function peg$padEnd(str, targetLength, padString) {
      padString = padString || " ";
      if (str.length > targetLength) {
        return str;
      }
      targetLength -= str.length;
      padString += padString.repeat(targetLength);
      return str + padString.slice(0, targetLength);
    }
    peg$SyntaxError.prototype.format = function(sources) {
      var str = "Error: " + this.message;
      if (this.location) {
        var src = null;
        var k;
        for (k = 0; k < sources.length; k++) {
          if (sources[k].source === this.location.source) {
            src = sources[k].text.split(/\r\n|\n|\r/g);
            break;
          }
        }
        var s32 = this.location.start;
        var loc = this.location.source + ":" + s32.line + ":" + s32.column;
        if (src) {
          var e = this.location.end;
          var filler = peg$padEnd("", s32.line.toString().length, " ");
          var line = src[s32.line - 1];
          var last = s32.line === e.line ? e.column : line.length + 1;
          var hatLen = last - s32.column || 1;
          str += "\n --> " + loc + "\n" + filler + " |\n" + s32.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s32.column - 1, " ") + peg$padEnd("", hatLen, "^");
        } else {
          str += "\n at " + loc;
        }
      }
      return str;
    };
    peg$SyntaxError.buildMessage = function(expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        class: function(expectation) {
          var escapedParts = expectation.parts.map(function(part) {
            return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
          });
          return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
        },
        any: function() {
          return "any character";
        },
        end: function() {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        }
      };
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s32) {
        return s32.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function classEscape(s32) {
        return s32.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = expected2.map(describeExpectation);
        var i, j;
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {};
      var peg$source = options.grammarSource;
      var peg$startRuleFunctions = { args_spec_list: peg$parseargs_spec_list };
      var peg$startRuleFunction = peg$parseargs_spec_list;
      var peg$c0 = "+";
      var peg$c1 = "v";
      var peg$c2 = "b";
      var peg$c3 = "!";
      var peg$c4 = "D";
      var peg$c5 = "d";
      var peg$c6 = "s";
      var peg$c7 = "O";
      var peg$c8 = "o";
      var peg$c9 = "e";
      var peg$c10 = "E";
      var peg$c11 = "t";
      var peg$c12 = "R";
      var peg$c13 = "r";
      var peg$c14 = "u";
      var peg$c15 = "m";
      var peg$c16 = "{";
      var peg$c17 = "}";
      var peg$c18 = " ";
      var peg$c19 = "\n";
      var peg$c20 = "\r";
      var peg$r0 = /^[{ ]/;
      var peg$e0 = peg$literalExpectation("+", false);
      var peg$e1 = peg$literalExpectation("v", false);
      var peg$e2 = peg$anyExpectation();
      var peg$e3 = peg$literalExpectation("b", false);
      var peg$e4 = peg$literalExpectation("!", false);
      var peg$e5 = peg$literalExpectation("D", false);
      var peg$e6 = peg$literalExpectation("d", false);
      var peg$e7 = peg$literalExpectation("s", false);
      var peg$e8 = peg$literalExpectation("O", false);
      var peg$e9 = peg$literalExpectation("o", false);
      var peg$e10 = peg$literalExpectation("e", false);
      var peg$e11 = peg$literalExpectation("E", false);
      var peg$e12 = peg$literalExpectation("t", false);
      var peg$e13 = peg$literalExpectation("R", false);
      var peg$e14 = peg$literalExpectation("r", false);
      var peg$e15 = peg$literalExpectation("u", false);
      var peg$e16 = peg$classExpectation(["{", " "], false, false);
      var peg$e17 = peg$literalExpectation("m", false);
      var peg$e18 = peg$literalExpectation("{", false);
      var peg$e19 = peg$literalExpectation("}", false);
      var peg$e20 = peg$literalExpectation(" ", false);
      var peg$e21 = peg$literalExpectation("\n", false);
      var peg$e22 = peg$literalExpectation("\r", false);
      var peg$f0 = function(x) {
        return x;
      };
      var peg$f1 = function(spec) {
        return spec;
      };
      var peg$f2 = function(spec) {
        return spec;
      };
      var peg$f3 = function(openBrace) {
        return createNode("verbatim", { openBrace, closeBrace: openBrace });
      };
      var peg$f4 = function() {
        return createNode("body");
      };
      var peg$f5 = function(leading_bang, spec) {
        return leading_bang ? { ...spec, noLeadingWhitespace: true } : spec;
      };
      var peg$f6 = function(braceSpec, defaultArg) {
        return createNode("optional", { ...braceSpec, defaultArg });
      };
      var peg$f7 = function(braceSpec) {
        return createNode("optional", braceSpec);
      };
      var peg$f8 = function() {
        return createNode("optionalStar");
      };
      var peg$f9 = function(g) {
        return createNode("optional", { defaultArg: g });
      };
      var peg$f10 = function() {
        return createNode("optional");
      };
      var peg$f11 = function(args) {
        return createNode("embellishment", {
          embellishmentTokens: args.content
        });
      };
      var peg$f12 = function(args, g) {
        return createNode("embellishment", {
          embellishmentTokens: args.content,
          defaultArg: g
        });
      };
      var peg$f13 = function(tok) {
        return createNode("optionalToken", { token: tok });
      };
      var peg$f14 = function(braceSpec, defaultArg) {
        return createNode("mandatory", { ...braceSpec, defaultArg });
      };
      var peg$f15 = function(braceSpec) {
        return createNode("mandatory", braceSpec);
      };
      var peg$f16 = function(stopTokens) {
        return createNode("until", { stopTokens });
      };
      var peg$f17 = function(x) {
        return [x];
      };
      var peg$f18 = function(g) {
        return g.content;
      };
      var peg$f19 = function() {
        return createNode("mandatory");
      };
      var peg$f20 = function(openBrace, closeBrace) {
        return { openBrace, closeBrace };
      };
      var peg$f21 = function(content) {
        return { type: "group", content };
      };
      var peg$f22 = function() {
        return "";
      };
      var peg$currPos = 0;
      var peg$savedPos = 0;
      var peg$posDetailsCache = [{ line: 1, column: 1 }];
      var peg$maxFailPos = 0;
      var peg$maxFailExpected = [];
      var peg$silentFails = 0;
      var peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function offset() {
        return peg$savedPos;
      }
      function range() {
        return {
          source: peg$source,
          start: peg$savedPos,
          end: peg$currPos
        };
      }
      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError(
          [peg$otherExpectation(description)],
          input.substring(peg$savedPos, peg$currPos),
          location2
        );
      }
      function error(message, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location2);
      }
      function peg$literalExpectation(text2, ignoreCase) {
        return { type: "literal", text: text2, ignoreCase };
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts, inverted, ignoreCase };
      }
      function peg$anyExpectation() {
        return { type: "any" };
      }
      function peg$endExpectation() {
        return { type: "end" };
      }
      function peg$otherExpectation(description) {
        return { type: "other", description };
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p;
        if (details) {
          return details;
        } else {
          p = pos - 1;
          while (!peg$posDetailsCache[p]) {
            p--;
          }
          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };
          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos);
        var endPosDetails = peg$computePosDetails(endPos);
        return {
          source: peg$source,
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildSimpleError(message, location2) {
        return new peg$SyntaxError(message, null, null, location2);
      }
      function peg$buildStructuredError(expected2, found, location2) {
        return new peg$SyntaxError(
          peg$SyntaxError.buildMessage(expected2, found),
          expected2,
          found,
          location2
        );
      }
      function peg$parseargs_spec_list() {
        var s0, s1, s22, s32, s42;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$currPos;
        s32 = peg$parsewhitespace();
        s42 = peg$parsearg_spec();
        if (s42 !== peg$FAILED) {
          peg$savedPos = s22;
          s22 = peg$f0(s42);
        } else {
          peg$currPos = s22;
          s22 = peg$FAILED;
        }
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$currPos;
          s32 = peg$parsewhitespace();
          s42 = peg$parsearg_spec();
          if (s42 !== peg$FAILED) {
            peg$savedPos = s22;
            s22 = peg$f0(s42);
          } else {
            peg$currPos = s22;
            s22 = peg$FAILED;
          }
        }
        s22 = peg$parsewhitespace();
        peg$savedPos = s0;
        s0 = peg$f1(s1);
        return s0;
      }
      function peg$parsearg_spec() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 43) {
          s1 = peg$c0;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 === peg$FAILED) {
          s1 = null;
        }
        s22 = peg$parseoptional();
        if (s22 === peg$FAILED) {
          s22 = peg$parsemandatory();
          if (s22 === peg$FAILED) {
            s22 = peg$parseverbatim();
            if (s22 === peg$FAILED) {
              s22 = peg$parserequired();
              if (s22 === peg$FAILED) {
                s22 = peg$parsebody();
                if (s22 === peg$FAILED) {
                  s22 = peg$parseuntil();
                }
              }
            }
          }
        }
        if (s22 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f2(s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseverbatim() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 118) {
          s1 = peg$c1;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e1);
          }
        }
        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s22 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f3(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsebody() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 98) {
          s1 = peg$c2;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f4();
        }
        s0 = s1;
        return s0;
      }
      function peg$parseoptional() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 33) {
          s1 = peg$c3;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e4);
          }
        }
        if (s1 === peg$FAILED) {
          s1 = null;
        }
        s22 = peg$parseoptional_star();
        if (s22 === peg$FAILED) {
          s22 = peg$parseoptional_standard();
          if (s22 === peg$FAILED) {
            s22 = peg$parseoptional_delimited();
            if (s22 === peg$FAILED) {
              s22 = peg$parseoptional_embellishment();
              if (s22 === peg$FAILED) {
                s22 = peg$parseoptional_token();
              }
            }
          }
        }
        if (s22 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f5(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseoptional_delimited() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 68) {
          s1 = peg$c4;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e5);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parsebrace_spec();
          s32 = peg$parsebraced_group();
          if (s32 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f6(s22, s32);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 100) {
            s1 = peg$c5;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e6);
            }
          }
          if (s1 !== peg$FAILED) {
            s22 = peg$parsebrace_spec();
            peg$savedPos = s0;
            s0 = peg$f7(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        return s0;
      }
      function peg$parseoptional_star() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 115) {
          s1 = peg$c6;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e7);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f8();
        }
        s0 = s1;
        return s0;
      }
      function peg$parseoptional_standard() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 79) {
          s1 = peg$c7;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e8);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parsebraced_group();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f9(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 111) {
            s1 = peg$c8;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e9);
            }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f10();
          }
          s0 = s1;
        }
        return s0;
      }
      function peg$parseoptional_embellishment() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 101) {
          s1 = peg$c9;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e10);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parsebraced_group();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f11(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 69) {
            s1 = peg$c10;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e11);
            }
          }
          if (s1 !== peg$FAILED) {
            s22 = peg$parsebraced_group();
            if (s22 !== peg$FAILED) {
              s32 = peg$parsebraced_group();
              if (s32 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f12(s22, s32);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        return s0;
      }
      function peg$parseoptional_token() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 116) {
          s1 = peg$c11;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e12);
          }
        }
        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s22 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f13(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parserequired() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 82) {
          s1 = peg$c12;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e13);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parsebrace_spec();
          s32 = peg$parsebraced_group();
          if (s32 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f14(s22, s32);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 114) {
            s1 = peg$c13;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e14);
            }
          }
          if (s1 !== peg$FAILED) {
            s22 = peg$parsebrace_spec();
            peg$savedPos = s0;
            s0 = peg$f15(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        return s0;
      }
      function peg$parseuntil() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 117) {
          s1 = peg$c14;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e15);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parseuntil_stop_token();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f16(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseuntil_stop_token() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        if (peg$r0.test(input.charAt(peg$currPos))) {
          s22 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s22 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e16);
          }
        }
        peg$silentFails--;
        if (s22 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s22 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f17(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsebraced_group();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f18(s1);
          }
          s0 = s1;
        }
        return s0;
      }
      function peg$parsemandatory() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 109) {
          s1 = peg$c15;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e17);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f19();
        }
        s0 = s1;
        return s0;
      }
      function peg$parsebrace_spec() {
        var s0, s1, s22, s32, s42, s5;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$currPos;
        s32 = peg$currPos;
        peg$silentFails++;
        s42 = peg$parsewhitespace_token();
        peg$silentFails--;
        if (s42 === peg$FAILED) {
          s32 = void 0;
        } else {
          peg$currPos = s32;
          s32 = peg$FAILED;
        }
        if (s32 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s42 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s42 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          if (s42 !== peg$FAILED) {
            s32 = [s32, s42];
            s22 = s32;
          } else {
            peg$currPos = s22;
            s22 = peg$FAILED;
          }
        } else {
          peg$currPos = s22;
          s22 = peg$FAILED;
        }
        if (s22 === peg$FAILED) {
          s22 = null;
        }
        s1 = input.substring(s1, peg$currPos);
        s22 = peg$currPos;
        s32 = peg$currPos;
        s42 = peg$currPos;
        peg$silentFails++;
        s5 = peg$parsewhitespace_token();
        peg$silentFails--;
        if (s5 === peg$FAILED) {
          s42 = void 0;
        } else {
          peg$currPos = s42;
          s42 = peg$FAILED;
        }
        if (s42 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          if (s5 !== peg$FAILED) {
            s42 = [s42, s5];
            s32 = s42;
          } else {
            peg$currPos = s32;
            s32 = peg$FAILED;
          }
        } else {
          peg$currPos = s32;
          s32 = peg$FAILED;
        }
        if (s32 === peg$FAILED) {
          s32 = null;
        }
        s22 = input.substring(s22, peg$currPos);
        peg$savedPos = s0;
        s0 = peg$f20(s1, s22);
        return s0;
      }
      function peg$parsebraced_group() {
        var s0, s1, s22, s32, s42, s5, s6, s7;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 123) {
          s1 = peg$c16;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e18);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$currPos;
          s42 = peg$currPos;
          s5 = peg$currPos;
          peg$silentFails++;
          if (input.charCodeAt(peg$currPos) === 125) {
            s6 = peg$c17;
            peg$currPos++;
          } else {
            s6 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e19);
            }
          }
          peg$silentFails--;
          if (s6 === peg$FAILED) {
            s5 = void 0;
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$currPos;
            peg$silentFails++;
            s7 = peg$parsebraced_group();
            peg$silentFails--;
            if (s7 === peg$FAILED) {
              s6 = void 0;
            } else {
              peg$currPos = s6;
              s6 = peg$FAILED;
            }
            if (s6 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s7 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s7 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e2);
                }
              }
              if (s7 !== peg$FAILED) {
                s5 = [s5, s6, s7];
                s42 = s5;
              } else {
                peg$currPos = s42;
                s42 = peg$FAILED;
              }
            } else {
              peg$currPos = s42;
              s42 = peg$FAILED;
            }
          } else {
            peg$currPos = s42;
            s42 = peg$FAILED;
          }
          if (s42 !== peg$FAILED) {
            s32 = input.substring(s32, peg$currPos);
          } else {
            s32 = s42;
          }
          if (s32 === peg$FAILED) {
            s32 = peg$parsebraced_group();
          }
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$currPos;
            s42 = peg$currPos;
            s5 = peg$currPos;
            peg$silentFails++;
            if (input.charCodeAt(peg$currPos) === 125) {
              s6 = peg$c17;
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e19);
              }
            }
            peg$silentFails--;
            if (s6 === peg$FAILED) {
              s5 = void 0;
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$currPos;
              peg$silentFails++;
              s7 = peg$parsebraced_group();
              peg$silentFails--;
              if (s7 === peg$FAILED) {
                s6 = void 0;
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
              if (s6 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                  s7 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e2);
                  }
                }
                if (s7 !== peg$FAILED) {
                  s5 = [s5, s6, s7];
                  s42 = s5;
                } else {
                  peg$currPos = s42;
                  s42 = peg$FAILED;
                }
              } else {
                peg$currPos = s42;
                s42 = peg$FAILED;
              }
            } else {
              peg$currPos = s42;
              s42 = peg$FAILED;
            }
            if (s42 !== peg$FAILED) {
              s32 = input.substring(s32, peg$currPos);
            } else {
              s32 = s42;
            }
            if (s32 === peg$FAILED) {
              s32 = peg$parsebraced_group();
            }
          }
          if (input.charCodeAt(peg$currPos) === 125) {
            s32 = peg$c17;
            peg$currPos++;
          } else {
            s32 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e19);
            }
          }
          if (s32 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f21(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsewhitespace() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsewhitespace_token();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parsewhitespace_token();
        }
        peg$savedPos = s0;
        s1 = peg$f22();
        s0 = s1;
        return s0;
      }
      function peg$parsewhitespace_token() {
        var s0;
        if (input.charCodeAt(peg$currPos) === 32) {
          s0 = peg$c18;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e20);
          }
        }
        if (s0 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 10) {
            s0 = peg$c19;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e21);
            }
          }
          if (s0 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 13) {
              s0 = peg$c20;
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e22);
              }
            }
          }
        }
        return s0;
      }
      const DEFAULT_OPTIONS = {
        optional: { openBrace: "[", closeBrace: "]" },
        mandatory: { openBrace: "{", closeBrace: "}" }
      };
      function createNode(type, options2) {
        const computedOptions = DEFAULT_OPTIONS[type] || {};
        return { type, ...computedOptions, ...options2 };
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(
          peg$maxFailExpected,
          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
      }
    }
    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }()
);
var pgfkeys_default3 = (
  // Generated by Peggy 2.0.1.
  //
  // https://peggyjs.org/
  function() {
    "use strict";
    function peg$subclass(child, parent) {
      function C() {
        this.constructor = child;
      }
      C.prototype = parent.prototype;
      child.prototype = new C();
    }
    function peg$SyntaxError(message, expected, found, location) {
      var self = Error.call(this, message);
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(self, peg$SyntaxError.prototype);
      }
      self.expected = expected;
      self.found = found;
      self.location = location;
      self.name = "SyntaxError";
      return self;
    }
    peg$subclass(peg$SyntaxError, Error);
    function peg$padEnd(str, targetLength, padString) {
      padString = padString || " ";
      if (str.length > targetLength) {
        return str;
      }
      targetLength -= str.length;
      padString += padString.repeat(targetLength);
      return str + padString.slice(0, targetLength);
    }
    peg$SyntaxError.prototype.format = function(sources) {
      var str = "Error: " + this.message;
      if (this.location) {
        var src = null;
        var k;
        for (k = 0; k < sources.length; k++) {
          if (sources[k].source === this.location.source) {
            src = sources[k].text.split(/\r\n|\n|\r/g);
            break;
          }
        }
        var s32 = this.location.start;
        var loc = this.location.source + ":" + s32.line + ":" + s32.column;
        if (src) {
          var e = this.location.end;
          var filler = peg$padEnd("", s32.line.toString().length, " ");
          var line = src[s32.line - 1];
          var last = s32.line === e.line ? e.column : line.length + 1;
          var hatLen = last - s32.column || 1;
          str += "\n --> " + loc + "\n" + filler + " |\n" + s32.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s32.column - 1, " ") + peg$padEnd("", hatLen, "^");
        } else {
          str += "\n at " + loc;
        }
      }
      return str;
    };
    peg$SyntaxError.buildMessage = function(expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        class: function(expectation) {
          var escapedParts = expectation.parts.map(function(part) {
            return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
          });
          return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
        },
        any: function() {
          return "any character";
        },
        end: function() {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        }
      };
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s32) {
        return s32.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function classEscape(s32) {
        return s32.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = expected2.map(describeExpectation);
        var i, j;
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {};
      var peg$source = options.grammarSource;
      var peg$startRuleFunctions = { body: peg$parsebody };
      var peg$startRuleFunction = peg$parsebody;
      var peg$e0 = peg$anyExpectation();
      var peg$f0 = function() {
        return [];
      };
      var peg$f1 = function(rowItems, trailingComment) {
        return {
          itemParts: [],
          ...rowItems,
          trailingComment,
          trailingComma: true
        };
      };
      var peg$f2 = function(rowItems, trailingComment) {
        return { ...rowItems, trailingComment };
      };
      var peg$f3 = function(a, b) {
        return processItem(a, b);
      };
      var peg$f4 = function(b) {
        return processItem(null, b);
      };
      var peg$f5 = function(cell) {
        return { cell };
      };
      var peg$f6 = function() {
        return {};
      };
      var peg$f7 = function(part) {
        return part;
      };
      var peg$f8 = function(x) {
        return x;
      };
      var peg$f9 = function(space, x) {
        return {
          trailingComment: x,
          leadingParbreak: space.parbreak > 0
        };
      };
      var peg$f10 = function(list) {
        return {
          whitespace: list.filter((x) => options.isWhitespace(x)).length,
          parbreak: list.filter((x) => options.isParbreak(x)).length
        };
      };
      var peg$f11 = function() {
        return !options.allowParenGroups;
      };
      var peg$f12 = function(tok) {
        return options.isSameLineComment(tok);
      };
      var peg$f13 = function(tok) {
        return tok;
      };
      var peg$f14 = function(tok) {
        return options.isOwnLineComment(tok);
      };
      var peg$f15 = function(tok) {
        return tok;
      };
      var peg$f16 = function(tok) {
        return options.isWhitespace(tok);
      };
      var peg$f17 = function(tok) {
        return tok;
      };
      var peg$f18 = function(tok) {
        return options.isParbreak(tok);
      };
      var peg$f19 = function(tok) {
        return tok;
      };
      var peg$f20 = function(tok) {
        return options.isComma(tok);
      };
      var peg$f21 = function(tok) {
        return tok;
      };
      var peg$f22 = function(tok) {
        return options.isEquals(tok);
      };
      var peg$f23 = function(tok) {
        return tok;
      };
      var peg$f24 = function(tok) {
        return options.isChar(tok, "(");
      };
      var peg$f25 = function(tok) {
        return tok;
      };
      var peg$f26 = function(tok) {
        return options.isChar(tok, ")");
      };
      var peg$f27 = function(tok) {
        return tok;
      };
      var peg$currPos = 0;
      var peg$savedPos = 0;
      var peg$posDetailsCache = [{ line: 1, column: 1 }];
      var peg$maxFailPos = 0;
      var peg$maxFailExpected = [];
      var peg$silentFails = 0;
      var peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function offset() {
        return peg$savedPos;
      }
      function range() {
        return {
          source: peg$source,
          start: peg$savedPos,
          end: peg$currPos
        };
      }
      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError(
          [peg$otherExpectation(description)],
          input.substring(peg$savedPos, peg$currPos),
          location2
        );
      }
      function error(message, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location2);
      }
      function peg$literalExpectation(text2, ignoreCase) {
        return { type: "literal", text: text2, ignoreCase };
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts, inverted, ignoreCase };
      }
      function peg$anyExpectation() {
        return { type: "any" };
      }
      function peg$endExpectation() {
        return { type: "end" };
      }
      function peg$otherExpectation(description) {
        return { type: "other", description };
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p;
        if (details) {
          return details;
        } else {
          p = pos - 1;
          while (!peg$posDetailsCache[p]) {
            p--;
          }
          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };
          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos);
        var endPosDetails = peg$computePosDetails(endPos);
        return {
          source: peg$source,
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildSimpleError(message, location2) {
        return new peg$SyntaxError(message, null, null, location2);
      }
      function peg$buildStructuredError(expected2, found, location2) {
        return new peg$SyntaxError(
          peg$SyntaxError.buildMessage(expected2, found),
          expected2,
          found,
          location2
        );
      }
      function peg$parsebody() {
        var s0, s1, s22;
        s0 = [];
        s1 = peg$parsecomment_only_line();
        if (s1 === peg$FAILED) {
          s1 = peg$parseitem_with_end();
          if (s1 === peg$FAILED) {
            s1 = peg$parseitem_without_end();
          }
        }
        if (s1 !== peg$FAILED) {
          while (s1 !== peg$FAILED) {
            s0.push(s1);
            s1 = peg$parsecomment_only_line();
            if (s1 === peg$FAILED) {
              s1 = peg$parseitem_with_end();
              if (s1 === peg$FAILED) {
                s1 = peg$parseitem_without_end();
              }
            }
          }
        } else {
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = [];
          s22 = peg$parsewhitespace();
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            s22 = peg$parsewhitespace();
          }
          s22 = peg$parseEOL();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f0();
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        return s0;
      }
      function peg$parseitem_with_end() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8;
        s0 = peg$currPos;
        s1 = peg$parsewhitespace_or_parbreaks();
        s22 = peg$parserow_items();
        if (s22 === peg$FAILED) {
          s22 = null;
        }
        s32 = peg$parsewhitespace_or_parbreaks();
        s42 = peg$parseitem_sep();
        if (s42 !== peg$FAILED) {
          s5 = [];
          s6 = peg$parsewhitespace();
          while (s6 !== peg$FAILED) {
            s5.push(s6);
            s6 = peg$parsewhitespace();
          }
          s6 = peg$parsetrailing_comment();
          if (s6 === peg$FAILED) {
            s6 = null;
          }
          s7 = [];
          s8 = peg$parsewhitespace();
          while (s8 !== peg$FAILED) {
            s7.push(s8);
            s8 = peg$parsewhitespace();
          }
          peg$savedPos = s0;
          s0 = peg$f1(s22, s6);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseitem_without_end() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$parsewhitespace_or_parbreaks();
        s22 = peg$parserow_items();
        if (s22 !== peg$FAILED) {
          s32 = peg$parsetrailing_comment();
          if (s32 === peg$FAILED) {
            s32 = null;
          }
          peg$savedPos = s0;
          s0 = peg$f2(s22, s32);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parserow_items() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$parseitem_part();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$parseseparated_part();
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parseseparated_part();
          }
          peg$savedPos = s0;
          s0 = peg$f3(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = [];
          s22 = peg$parseseparated_part();
          if (s22 !== peg$FAILED) {
            while (s22 !== peg$FAILED) {
              s1.push(s22);
              s22 = peg$parseseparated_part();
            }
          } else {
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f4(s1);
          }
          s0 = s1;
        }
        return s0;
      }
      function peg$parseseparated_part() {
        var s0, s1, s22, s32, s42;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parseparbreak();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parseparbreak();
        }
        s22 = peg$parseequals();
        if (s22 !== peg$FAILED) {
          s32 = [];
          s42 = peg$parseparbreak();
          while (s42 !== peg$FAILED) {
            s32.push(s42);
            s42 = peg$parseparbreak();
          }
          s42 = peg$parseitem_part();
          if (s42 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f5(s42);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = [];
          s22 = peg$parseparbreak();
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            s22 = peg$parseparbreak();
          }
          s22 = peg$parseequals();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f6();
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        return s0;
      }
      function peg$parseitem_part() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8, s9;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsewhitespace();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parsewhitespace();
        }
        s22 = peg$currPos;
        s32 = [];
        s42 = peg$parsenon_whitespace_non_parbreak_token();
        if (s42 === peg$FAILED) {
          s42 = peg$currPos;
          s5 = peg$parsewhitespace();
          if (s5 === peg$FAILED) {
            s5 = peg$parseparbreak();
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$currPos;
            peg$silentFails++;
            s7 = peg$currPos;
            s8 = [];
            s9 = peg$parsewhitespace();
            if (s9 === peg$FAILED) {
              s9 = peg$parseparbreak();
            }
            while (s9 !== peg$FAILED) {
              s8.push(s9);
              s9 = peg$parsewhitespace();
              if (s9 === peg$FAILED) {
                s9 = peg$parseparbreak();
              }
            }
            s9 = peg$parsenon_whitespace_non_parbreak_token();
            if (s9 !== peg$FAILED) {
              s8 = [s8, s9];
              s7 = s8;
            } else {
              peg$currPos = s7;
              s7 = peg$FAILED;
            }
            peg$silentFails--;
            if (s7 !== peg$FAILED) {
              peg$currPos = s6;
              s6 = void 0;
            } else {
              s6 = peg$FAILED;
            }
            if (s6 !== peg$FAILED) {
              s5 = [s5, s6];
              s42 = s5;
            } else {
              peg$currPos = s42;
              s42 = peg$FAILED;
            }
          } else {
            peg$currPos = s42;
            s42 = peg$FAILED;
          }
        }
        if (s42 !== peg$FAILED) {
          while (s42 !== peg$FAILED) {
            s32.push(s42);
            s42 = peg$parsenon_whitespace_non_parbreak_token();
            if (s42 === peg$FAILED) {
              s42 = peg$currPos;
              s5 = peg$parsewhitespace();
              if (s5 === peg$FAILED) {
                s5 = peg$parseparbreak();
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$currPos;
                peg$silentFails++;
                s7 = peg$currPos;
                s8 = [];
                s9 = peg$parsewhitespace();
                if (s9 === peg$FAILED) {
                  s9 = peg$parseparbreak();
                }
                while (s9 !== peg$FAILED) {
                  s8.push(s9);
                  s9 = peg$parsewhitespace();
                  if (s9 === peg$FAILED) {
                    s9 = peg$parseparbreak();
                  }
                }
                s9 = peg$parsenon_whitespace_non_parbreak_token();
                if (s9 !== peg$FAILED) {
                  s8 = [s8, s9];
                  s7 = s8;
                } else {
                  peg$currPos = s7;
                  s7 = peg$FAILED;
                }
                peg$silentFails--;
                if (s7 !== peg$FAILED) {
                  peg$currPos = s6;
                  s6 = void 0;
                } else {
                  s6 = peg$FAILED;
                }
                if (s6 !== peg$FAILED) {
                  s5 = [s5, s6];
                  s42 = s5;
                } else {
                  peg$currPos = s42;
                  s42 = peg$FAILED;
                }
              } else {
                peg$currPos = s42;
                s42 = peg$FAILED;
              }
            }
          }
        } else {
          s32 = peg$FAILED;
        }
        if (s32 !== peg$FAILED) {
          s22 = input.substring(s22, peg$currPos);
        } else {
          s22 = s32;
        }
        if (s22 !== peg$FAILED) {
          s32 = [];
          s42 = peg$parsewhitespace();
          while (s42 !== peg$FAILED) {
            s32.push(s42);
            s42 = peg$parsewhitespace();
          }
          peg$savedPos = s0;
          s0 = peg$f7(s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsetrailing_comment() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsewhitespace();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parsewhitespace();
        }
        s22 = peg$parsesame_line_comment();
        if (s22 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f8(s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecomment_only_line() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parsewhitespace_or_parbreaks();
        s22 = peg$parseown_line_comment();
        if (s22 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f9(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsetoken() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$currPos;
        peg$silentFails++;
        s32 = peg$parsenon_token();
        peg$silentFails--;
        if (s32 === peg$FAILED) {
          s22 = void 0;
        } else {
          peg$currPos = s22;
          s22 = peg$FAILED;
        }
        if (s22 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s32 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s32 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s32 !== peg$FAILED) {
            s22 = [s22, s32];
            s1 = s22;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }
        return s0;
      }
      function peg$parsenon_whitespace_non_parbreak_token() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$currPos;
        peg$silentFails++;
        s32 = peg$parsewhitespace();
        if (s32 === peg$FAILED) {
          s32 = peg$parseparbreak();
        }
        peg$silentFails--;
        if (s32 === peg$FAILED) {
          s22 = void 0;
        } else {
          peg$currPos = s22;
          s22 = peg$FAILED;
        }
        if (s22 !== peg$FAILED) {
          s32 = peg$parseparen_block();
          if (s32 === peg$FAILED) {
            s32 = peg$parsetoken();
          }
          if (s32 !== peg$FAILED) {
            s22 = [s22, s32];
            s1 = s22;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }
        return s0;
      }
      function peg$parsenon_token() {
        var s0;
        s0 = peg$parseitem_sep();
        if (s0 === peg$FAILED) {
          s0 = peg$parseequals();
          if (s0 === peg$FAILED) {
            s0 = peg$parsetrailing_comment();
            if (s0 === peg$FAILED) {
              s0 = peg$parseown_line_comment();
            }
          }
        }
        return s0;
      }
      function peg$parsewhitespace_or_parbreaks() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsewhitespace();
        if (s22 === peg$FAILED) {
          s22 = peg$parseparbreak();
        }
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parsewhitespace();
          if (s22 === peg$FAILED) {
            s22 = peg$parseparbreak();
          }
        }
        peg$savedPos = s0;
        s1 = peg$f10(s1);
        s0 = s1;
        return s0;
      }
      function peg$parseparen_block() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8;
        s0 = peg$currPos;
        peg$savedPos = peg$currPos;
        s1 = peg$f11();
        if (s1) {
          s1 = peg$FAILED;
        } else {
          s1 = void 0;
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$currPos;
          s32 = peg$currPos;
          s42 = peg$parseopen_paren();
          if (s42 !== peg$FAILED) {
            s5 = [];
            s6 = peg$currPos;
            s7 = peg$currPos;
            peg$silentFails++;
            s8 = peg$parseclose_paren();
            peg$silentFails--;
            if (s8 === peg$FAILED) {
              s7 = void 0;
            } else {
              peg$currPos = s7;
              s7 = peg$FAILED;
            }
            if (s7 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s8 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s8 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              if (s8 !== peg$FAILED) {
                s7 = [s7, s8];
                s6 = s7;
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
            } else {
              peg$currPos = s6;
              s6 = peg$FAILED;
            }
            while (s6 !== peg$FAILED) {
              s5.push(s6);
              s6 = peg$currPos;
              s7 = peg$currPos;
              peg$silentFails++;
              s8 = peg$parseclose_paren();
              peg$silentFails--;
              if (s8 === peg$FAILED) {
                s7 = void 0;
              } else {
                peg$currPos = s7;
                s7 = peg$FAILED;
              }
              if (s7 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                  s8 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s8 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e0);
                  }
                }
                if (s8 !== peg$FAILED) {
                  s7 = [s7, s8];
                  s6 = s7;
                } else {
                  peg$currPos = s6;
                  s6 = peg$FAILED;
                }
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
            }
            s6 = peg$parseclose_paren();
            if (s6 !== peg$FAILED) {
              s42 = [s42, s5, s6];
              s32 = s42;
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          } else {
            peg$currPos = s32;
            s32 = peg$FAILED;
          }
          if (s32 !== peg$FAILED) {
            s22 = input.substring(s22, peg$currPos);
          } else {
            s22 = s32;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsesame_line_comment() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f12(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f13(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseown_line_comment() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f14(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f15(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsewhitespace() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f16(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f17(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseparbreak() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f18(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f19(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseitem_sep() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f20(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f21(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseequals() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f22(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f23(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseopen_paren() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f24(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f25(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseclose_paren() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f26(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f27(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseEOL() {
        var s0, s1;
        s0 = peg$currPos;
        peg$silentFails++;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        peg$silentFails--;
        if (s1 === peg$FAILED) {
          s0 = void 0;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function processItem(leadCell, otherCells) {
        const cells = [leadCell || []];
        for (const x of otherCells) {
          cells.push(x.cell || []);
        }
        return { itemParts: cells };
      }
      if (!options.isWhitespace) {
        try {
          Object.assign(options, {
            isChar: (node, char) => node.type === "string" && node.content === char,
            isComma(node) {
              return node.type === "string" && node.content === ",";
            },
            isEquals(node) {
              return node.type === "string" && node.content === "=";
            },
            isParbreak(node) {
              return node.type === "parbreak";
            },
            isWhitespace(node) {
              return node.type === "whitespace";
            },
            isSameLineComment: (node) => node.type === "comment" && node.sameline,
            isOwnLineComment: (node) => node.type === "comment" && !node.sameline,
            isComment: (node) => node.type === "comment",
            allowParenGroups: true
          });
        } catch (e) {
          console.warn("Error when initializing parser", e);
        }
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(
          peg$maxFailExpected,
          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
      }
    }
    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }()
);
var macro_substitutions_default3 = (
  // Generated by Peggy 2.0.1.
  //
  // https://peggyjs.org/
  function() {
    "use strict";
    function peg$subclass(child, parent) {
      function C() {
        this.constructor = child;
      }
      C.prototype = parent.prototype;
      child.prototype = new C();
    }
    function peg$SyntaxError(message, expected, found, location) {
      var self = Error.call(this, message);
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(self, peg$SyntaxError.prototype);
      }
      self.expected = expected;
      self.found = found;
      self.location = location;
      self.name = "SyntaxError";
      return self;
    }
    peg$subclass(peg$SyntaxError, Error);
    function peg$padEnd(str, targetLength, padString) {
      padString = padString || " ";
      if (str.length > targetLength) {
        return str;
      }
      targetLength -= str.length;
      padString += padString.repeat(targetLength);
      return str + padString.slice(0, targetLength);
    }
    peg$SyntaxError.prototype.format = function(sources) {
      var str = "Error: " + this.message;
      if (this.location) {
        var src = null;
        var k;
        for (k = 0; k < sources.length; k++) {
          if (sources[k].source === this.location.source) {
            src = sources[k].text.split(/\r\n|\n|\r/g);
            break;
          }
        }
        var s32 = this.location.start;
        var loc = this.location.source + ":" + s32.line + ":" + s32.column;
        if (src) {
          var e = this.location.end;
          var filler = peg$padEnd("", s32.line.toString().length, " ");
          var line = src[s32.line - 1];
          var last = s32.line === e.line ? e.column : line.length + 1;
          var hatLen = last - s32.column || 1;
          str += "\n --> " + loc + "\n" + filler + " |\n" + s32.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s32.column - 1, " ") + peg$padEnd("", hatLen, "^");
        } else {
          str += "\n at " + loc;
        }
      }
      return str;
    };
    peg$SyntaxError.buildMessage = function(expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        class: function(expectation) {
          var escapedParts = expectation.parts.map(function(part) {
            return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
          });
          return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
        },
        any: function() {
          return "any character";
        },
        end: function() {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        }
      };
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s32) {
        return s32.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function classEscape(s32) {
        return s32.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = expected2.map(describeExpectation);
        var i, j;
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {};
      var peg$source = options.grammarSource;
      var peg$startRuleFunctions = { body: peg$parsebody };
      var peg$startRuleFunction = peg$parsebody;
      var peg$e0 = peg$anyExpectation();
      var peg$f0 = function(e) {
        return [].concat(...e).filter((n) => !!n);
      };
      var peg$f1 = function() {
        return [];
      };
      var peg$f2 = function(tok) {
        return options.isHash(tok);
      };
      var peg$f3 = function(tok) {
        return tok;
      };
      var peg$f4 = function(tok) {
        return options.isNumber(tok);
      };
      var peg$f5 = function(tok) {
        return tok;
      };
      var peg$f6 = function() {
        return { type: "string", content: "#" };
      };
      var peg$f7 = function(num) {
        const split = options.splitNumber(num);
        return [{ type: "hash_number", number: split.number }, split.rest];
      };
      var peg$currPos = 0;
      var peg$savedPos = 0;
      var peg$posDetailsCache = [{ line: 1, column: 1 }];
      var peg$maxFailPos = 0;
      var peg$maxFailExpected = [];
      var peg$silentFails = 0;
      var peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function offset() {
        return peg$savedPos;
      }
      function range() {
        return {
          source: peg$source,
          start: peg$savedPos,
          end: peg$currPos
        };
      }
      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError(
          [peg$otherExpectation(description)],
          input.substring(peg$savedPos, peg$currPos),
          location2
        );
      }
      function error(message, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location2);
      }
      function peg$literalExpectation(text2, ignoreCase) {
        return { type: "literal", text: text2, ignoreCase };
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts, inverted, ignoreCase };
      }
      function peg$anyExpectation() {
        return { type: "any" };
      }
      function peg$endExpectation() {
        return { type: "end" };
      }
      function peg$otherExpectation(description) {
        return { type: "other", description };
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p;
        if (details) {
          return details;
        } else {
          p = pos - 1;
          while (!peg$posDetailsCache[p]) {
            p--;
          }
          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };
          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos);
        var endPosDetails = peg$computePosDetails(endPos);
        return {
          source: peg$source,
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildSimpleError(message, location2) {
        return new peg$SyntaxError(message, null, null, location2);
      }
      function peg$buildStructuredError(expected2, found, location2) {
        return new peg$SyntaxError(
          peg$SyntaxError.buildMessage(expected2, found),
          expected2,
          found,
          location2
        );
      }
      function peg$parsebody() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsedouble_hash();
        if (s22 === peg$FAILED) {
          s22 = peg$parsehash_number();
          if (s22 === peg$FAILED) {
            if (input.length > peg$currPos) {
              s22 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s22 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
          }
        }
        if (s22 !== peg$FAILED) {
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            s22 = peg$parsedouble_hash();
            if (s22 === peg$FAILED) {
              s22 = peg$parsehash_number();
              if (s22 === peg$FAILED) {
                if (input.length > peg$currPos) {
                  s22 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s22 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e0);
                  }
                }
              }
            }
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f0(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseEOL();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f1();
          }
          s0 = s1;
        }
        return s0;
      }
      function peg$parsehash() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f2(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f3(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsenumber() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f4(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f5(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsedouble_hash() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parsehash();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsehash();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f6();
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsehash_number() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parsehash();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsenumber();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f7(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseEOL() {
        var s0, s1;
        s0 = peg$currPos;
        peg$silentFails++;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        peg$silentFails--;
        if (s1 === peg$FAILED) {
          s0 = void 0;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      if (!options.isHash) {
        try {
          Object.assign(options, {
            isHash: (node) => node.type === "string" && node.content === "#",
            isNumber: (node) => node.type === "string" && 0 < +node.content.charAt(0),
            splitNumber: (node) => {
              const number = +node.content.charAt(0);
              if (node.content.length > 1) {
                return {
                  number,
                  rest: {
                    type: "string",
                    content: node.content.slice(1)
                  }
                };
              }
              return { number };
            }
          });
        } catch (e) {
          console.warn("Error when initializing parser", e);
        }
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(
          peg$maxFailExpected,
          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
      }
    }
    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }()
);
var ligatures_default3 = (
  // Generated by Peggy 2.0.1.
  //
  // https://peggyjs.org/
  function() {
    "use strict";
    function peg$subclass(child, parent) {
      function C() {
        this.constructor = child;
      }
      C.prototype = parent.prototype;
      child.prototype = new C();
    }
    function peg$SyntaxError(message, expected, found, location) {
      var self = Error.call(this, message);
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(self, peg$SyntaxError.prototype);
      }
      self.expected = expected;
      self.found = found;
      self.location = location;
      self.name = "SyntaxError";
      return self;
    }
    peg$subclass(peg$SyntaxError, Error);
    function peg$padEnd(str, targetLength, padString) {
      padString = padString || " ";
      if (str.length > targetLength) {
        return str;
      }
      targetLength -= str.length;
      padString += padString.repeat(targetLength);
      return str + padString.slice(0, targetLength);
    }
    peg$SyntaxError.prototype.format = function(sources) {
      var str = "Error: " + this.message;
      if (this.location) {
        var src = null;
        var k;
        for (k = 0; k < sources.length; k++) {
          if (sources[k].source === this.location.source) {
            src = sources[k].text.split(/\r\n|\n|\r/g);
            break;
          }
        }
        var s32 = this.location.start;
        var loc = this.location.source + ":" + s32.line + ":" + s32.column;
        if (src) {
          var e = this.location.end;
          var filler = peg$padEnd("", s32.line.toString().length, " ");
          var line = src[s32.line - 1];
          var last = s32.line === e.line ? e.column : line.length + 1;
          var hatLen = last - s32.column || 1;
          str += "\n --> " + loc + "\n" + filler + " |\n" + s32.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s32.column - 1, " ") + peg$padEnd("", hatLen, "^");
        } else {
          str += "\n at " + loc;
        }
      }
      return str;
    };
    peg$SyntaxError.buildMessage = function(expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        class: function(expectation) {
          var escapedParts = expectation.parts.map(function(part) {
            return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
          });
          return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
        },
        any: function() {
          return "any character";
        },
        end: function() {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        }
      };
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s32) {
        return s32.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function classEscape(s32) {
        return s32.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = expected2.map(describeExpectation);
        var i, j;
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {};
      var peg$source = options.grammarSource;
      var peg$startRuleFunctions = { body: peg$parsebody };
      var peg$startRuleFunction = peg$parsebody;
      var peg$e0 = peg$anyExpectation();
      var peg$f0 = function(e) {
        return [].concat(...e).filter((n) => !!n);
      };
      var peg$f1 = function() {
        return [];
      };
      var peg$f2 = function(toks) {
        return options.isRecognized(toks);
      };
      var peg$f3 = function(toks) {
        return options.isRecognized(toks);
      };
      var peg$f4 = function(tok1, tok2) {
        const split = options.split(tok2);
        return options.isRecognized([tok1, split[0]]);
      };
      var peg$f5 = function(tok1, tok2) {
        const split = options.split(tok2);
        return [options.isRecognized([tok1, split[0]]), split[1]];
      };
      var peg$f6 = function(tok1, tok2) {
        return options.isRecognized([tok1, tok2]);
      };
      var peg$f7 = function(tok1, tok2) {
        return options.isRecognized([tok1, tok2]);
      };
      var peg$f8 = function(toks) {
        return options.isRecognized(toks);
      };
      var peg$f9 = function(toks) {
        return options.isRecognized(toks);
      };
      var peg$f10 = function(tok) {
        return options.isRecognized([tok]);
      };
      var peg$f11 = function(tok) {
        return options.isRecognized([tok]);
      };
      var peg$f12 = function(tok) {
        return options.isMacro(tok);
      };
      var peg$f13 = function(tok) {
        return tok;
      };
      var peg$f14 = function(tok) {
        return options.isWhitespace(tok);
      };
      var peg$f15 = function(tok) {
        return tok;
      };
      var peg$f16 = function(tok) {
        return options.isSplitable(tok);
      };
      var peg$f17 = function(tok) {
        return tok;
      };
      var peg$currPos = 0;
      var peg$savedPos = 0;
      var peg$posDetailsCache = [{ line: 1, column: 1 }];
      var peg$maxFailPos = 0;
      var peg$maxFailExpected = [];
      var peg$silentFails = 0;
      var peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function offset() {
        return peg$savedPos;
      }
      function range() {
        return {
          source: peg$source,
          start: peg$savedPos,
          end: peg$currPos
        };
      }
      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError(
          [peg$otherExpectation(description)],
          input.substring(peg$savedPos, peg$currPos),
          location2
        );
      }
      function error(message, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location2);
      }
      function peg$literalExpectation(text2, ignoreCase) {
        return { type: "literal", text: text2, ignoreCase };
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts, inverted, ignoreCase };
      }
      function peg$anyExpectation() {
        return { type: "any" };
      }
      function peg$endExpectation() {
        return { type: "end" };
      }
      function peg$otherExpectation(description) {
        return { type: "other", description };
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p;
        if (details) {
          return details;
        } else {
          p = pos - 1;
          while (!peg$posDetailsCache[p]) {
            p--;
          }
          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };
          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos);
        var endPosDetails = peg$computePosDetails(endPos);
        return {
          source: peg$source,
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildSimpleError(message, location2) {
        return new peg$SyntaxError(message, null, null, location2);
      }
      function peg$buildStructuredError(expected2, found, location2) {
        return new peg$SyntaxError(
          peg$SyntaxError.buildMessage(expected2, found),
          expected2,
          found,
          location2
        );
      }
      function peg$parsebody() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsetriple_ligature();
        if (s22 === peg$FAILED) {
          s22 = peg$parsedouble_ligature();
          if (s22 === peg$FAILED) {
            s22 = peg$parsemono_ligature();
            if (s22 === peg$FAILED) {
              if (input.length > peg$currPos) {
                s22 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s22 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
            }
          }
        }
        if (s22 !== peg$FAILED) {
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            s22 = peg$parsetriple_ligature();
            if (s22 === peg$FAILED) {
              s22 = peg$parsedouble_ligature();
              if (s22 === peg$FAILED) {
                s22 = peg$parsemono_ligature();
                if (s22 === peg$FAILED) {
                  if (input.length > peg$currPos) {
                    s22 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s22 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e0);
                    }
                  }
                }
              }
            }
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f0(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseEOL();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f1();
          }
          s0 = s1;
        }
        return s0;
      }
      function peg$parsetriple_ligature() {
        var s0, s1, s22, s32, s42;
        s0 = peg$currPos;
        s1 = peg$currPos;
        if (input.length > peg$currPos) {
          s22 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s22 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s22 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s32 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s32 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s32 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s42 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s42 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            if (s42 !== peg$FAILED) {
              s22 = [s22, s32, s42];
              s1 = s22;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f2(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f3(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsedouble_ligature() {
        var s0;
        s0 = peg$parsedouble_macro_ligature();
        if (s0 === peg$FAILED) {
          s0 = peg$parsedouble_macro_ligature_extracted();
          if (s0 === peg$FAILED) {
            s0 = peg$parsedouble_char_ligature();
          }
        }
        return s0;
      }
      function peg$parsedouble_macro_ligature_extracted() {
        var s0, s1, s22, s32, s42;
        s0 = peg$currPos;
        s1 = peg$parsemacro();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$parsewhitespace();
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parsewhitespace();
          }
          s32 = peg$parsesplitable();
          if (s32 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s42 = peg$f4(s1, s32);
            if (s42) {
              s42 = void 0;
            } else {
              s42 = peg$FAILED;
            }
            if (s42 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f5(s1, s32);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsedouble_macro_ligature() {
        var s0, s1, s22, s32, s42;
        s0 = peg$currPos;
        s1 = peg$parsemacro();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$parsewhitespace();
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parsewhitespace();
          }
          if (input.length > peg$currPos) {
            s32 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s32 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s32 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s42 = peg$f6(s1, s32);
            if (s42) {
              s42 = void 0;
            } else {
              s42 = peg$FAILED;
            }
            if (s42 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f7(s1, s32);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsedouble_char_ligature() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$currPos;
        if (input.length > peg$currPos) {
          s22 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s22 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s22 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s32 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s32 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s32 !== peg$FAILED) {
            s22 = [s22, s32];
            s1 = s22;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f8(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f9(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsemono_ligature() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f10(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f11(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsemacro() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f12(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f13(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsewhitespace() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f14(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f15(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsesplitable() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f16(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f17(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseEOL() {
        var s0, s1;
        s0 = peg$currPos;
        peg$silentFails++;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        peg$silentFails--;
        if (s1 === peg$FAILED) {
          s0 = void 0;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      if (!options.isWhitespace) {
        try {
          Object.assign(options, {
            isMacro: (node) => node.type === "macro",
            isWhitespace: (node) => node.type === "whitespace",
            isRecognized: (nodes) => {
              if (nodes.length == 2 && nodes[0].content === "^" && nodes[1].content === "o") {
                return { type: "string", content: "\xF4" };
              }
              return null;
            },
            isSplitable: (node) => node.type === "string" && node.content.length > 1,
            split: (node) => [
              { type: "string", content: node.content.charAt(0) },
              { type: "string", content: node.content.slice(1) }
            ]
          });
        } catch (e) {
          console.warn("Error when initializing parser", e);
        }
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(
          peg$maxFailExpected,
          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
      }
    }
    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }()
);
var xcolor_expressions_default3 = (
  // Generated by Peggy 2.0.1.
  //
  // https://peggyjs.org/
  function() {
    "use strict";
    function peg$subclass(child, parent) {
      function C() {
        this.constructor = child;
      }
      C.prototype = parent.prototype;
      child.prototype = new C();
    }
    function peg$SyntaxError(message, expected, found, location) {
      var self = Error.call(this, message);
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(self, peg$SyntaxError.prototype);
      }
      self.expected = expected;
      self.found = found;
      self.location = location;
      self.name = "SyntaxError";
      return self;
    }
    peg$subclass(peg$SyntaxError, Error);
    function peg$padEnd(str, targetLength, padString) {
      padString = padString || " ";
      if (str.length > targetLength) {
        return str;
      }
      targetLength -= str.length;
      padString += padString.repeat(targetLength);
      return str + padString.slice(0, targetLength);
    }
    peg$SyntaxError.prototype.format = function(sources) {
      var str = "Error: " + this.message;
      if (this.location) {
        var src = null;
        var k;
        for (k = 0; k < sources.length; k++) {
          if (sources[k].source === this.location.source) {
            src = sources[k].text.split(/\r\n|\n|\r/g);
            break;
          }
        }
        var s32 = this.location.start;
        var loc = this.location.source + ":" + s32.line + ":" + s32.column;
        if (src) {
          var e = this.location.end;
          var filler = peg$padEnd("", s32.line.toString().length, " ");
          var line = src[s32.line - 1];
          var last = s32.line === e.line ? e.column : line.length + 1;
          var hatLen = last - s32.column || 1;
          str += "\n --> " + loc + "\n" + filler + " |\n" + s32.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s32.column - 1, " ") + peg$padEnd("", hatLen, "^");
        } else {
          str += "\n at " + loc;
        }
      }
      return str;
    };
    peg$SyntaxError.buildMessage = function(expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        class: function(expectation) {
          var escapedParts = expectation.parts.map(function(part) {
            return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
          });
          return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
        },
        any: function() {
          return "any character";
        },
        end: function() {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        }
      };
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s32) {
        return s32.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function classEscape(s32) {
        return s32.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = expected2.map(describeExpectation);
        var i, j;
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {};
      var peg$source = options.grammarSource;
      var peg$startRuleFunctions = { start: peg$parsestart };
      var peg$startRuleFunction = peg$parsestart;
      var peg$c0 = ";";
      var peg$c1 = ",";
      var peg$c2 = ":";
      var peg$c3 = "/";
      var peg$c4 = ">";
      var peg$c5 = "!";
      var peg$c6 = ".";
      var peg$c7 = "!![";
      var peg$c8 = "]";
      var peg$c9 = "!!";
      var peg$c10 = "+";
      var peg$c11 = "-";
      var peg$r0 = /^[a-zA-Z0-9]/;
      var peg$r1 = /^[0-9]/;
      var peg$r2 = /^[ \t\n\r]/;
      var peg$r3 = /^[0-9a-fA-F]/;
      var peg$e0 = peg$anyExpectation();
      var peg$e1 = peg$literalExpectation(";", false);
      var peg$e2 = peg$literalExpectation(",", false);
      var peg$e3 = peg$otherExpectation("model list");
      var peg$e4 = peg$literalExpectation(":", false);
      var peg$e5 = peg$literalExpectation("/", false);
      var peg$e6 = peg$otherExpectation("model");
      var peg$e7 = peg$otherExpectation("color spec list");
      var peg$e8 = peg$otherExpectation("color spec");
      var peg$e9 = peg$otherExpectation("color");
      var peg$e10 = peg$otherExpectation("function expression");
      var peg$e11 = peg$literalExpectation(">", false);
      var peg$e12 = peg$otherExpectation("function");
      var peg$e13 = peg$otherExpectation("extended expression");
      var peg$e14 = peg$otherExpectation("core model");
      var peg$e15 = peg$otherExpectation("expr");
      var peg$e16 = peg$literalExpectation("!", false);
      var peg$e17 = peg$otherExpectation("mix expr");
      var peg$e18 = peg$otherExpectation("name");
      var peg$e19 = peg$literalExpectation(".", false);
      var peg$e20 = peg$classExpectation([["a", "z"], ["A", "Z"], ["0", "9"]], false, false);
      var peg$e21 = peg$otherExpectation("postfix");
      var peg$e22 = peg$literalExpectation("!![", false);
      var peg$e23 = peg$literalExpectation("]", false);
      var peg$e24 = peg$literalExpectation("!!", false);
      var peg$e25 = peg$otherExpectation("prefix");
      var peg$e26 = peg$otherExpectation("plus");
      var peg$e27 = peg$literalExpectation("+", false);
      var peg$e28 = peg$otherExpectation("minus");
      var peg$e29 = peg$literalExpectation("-", false);
      var peg$e30 = peg$otherExpectation("num");
      var peg$e31 = peg$classExpectation([["0", "9"]], false, false);
      var peg$e32 = peg$otherExpectation("positive float");
      var peg$e33 = peg$otherExpectation("divisor");
      var peg$e34 = peg$otherExpectation("int");
      var peg$e35 = peg$otherExpectation("whitespace");
      var peg$e36 = peg$classExpectation([" ", "	", "\n", "\r"], false, false);
      var peg$e37 = peg$classExpectation([["0", "9"], ["a", "f"], ["A", "F"]], false, false);
      var peg$f0 = function(m) {
        return m;
      };
      var peg$f1 = function(m) {
        return m;
      };
      var peg$f2 = function(m) {
        return m;
      };
      var peg$f3 = function(m) {
        return m;
      };
      var peg$f4 = function(m) {
        return m;
      };
      var peg$f5 = function(a) {
        return { type: "invalid_spec", content: a };
      };
      var peg$f6 = function(f, c) {
        return c;
      };
      var peg$f7 = function(f, r) {
        return { type: "color_set", content: [f].concat(r) };
      };
      var peg$f8 = function(n, s32) {
        return { type: "color_set_item", name: n, spec_list: s32 };
      };
      var peg$f9 = function(c, m) {
        return { type: "model_list", contents: m, core_model: c };
      };
      var peg$f10 = function(m) {
        return { type: "model_list", contents: m, core_model: null };
      };
      var peg$f11 = function(m, a) {
        return a;
      };
      var peg$f12 = function(m, r) {
        return [m].concat(r);
      };
      var peg$f13 = function(s32, a) {
        return a;
      };
      var peg$f14 = function(s32, r) {
        return { type: "spec_list", content: [s32].concat(r) };
      };
      var peg$f15 = function(c) {
        return { type: "hex_spec", content: [c] };
      };
      var peg$f16 = function(c, d) {
        return d;
      };
      var peg$f17 = function(c, d) {
        return d;
      };
      var peg$f18 = function(c, r) {
        return { type: "num_spec", content: r ? [c].concat(r) : [c] };
      };
      var peg$f19 = function(c, fs) {
        return { type: "color", color: c, functions: fs };
      };
      var peg$f20 = function(f, n) {
        return n;
      };
      var peg$f21 = function(f, args) {
        return { type: "function", name: f, args };
      };
      var peg$f22 = function(core, d, e, es) {
        return {
          type: "extended_expr",
          core_model: core,
          div: d,
          expressions: [e].concat(es)
        };
      };
      var peg$f23 = function(core, e, es) {
        return {
          type: "extended_expr",
          core_model: core,
          div: null,
          expressions: [e].concat(es)
        };
      };
      var peg$f24 = function(e, d) {
        return { type: "weighted_expr", color: e, weight: d };
      };
      var peg$f25 = function(e) {
        return e;
      };
      var peg$f26 = function(p, n, e, po) {
        return {
          type: "expr",
          prefix: p,
          name: n,
          mix_expr: e,
          postfix: po
        };
      };
      var peg$f27 = function(p, n) {
        return { type: "complete_mix", mix_percent: p, name: n };
      };
      var peg$f28 = function(p) {
        return { type: "partial_mix", mix_percent: p };
      };
      var peg$f29 = function(c, p) {
        return c.concat(p || []);
      };
      var peg$f30 = function(n) {
        return { type: "postfix", num: n };
      };
      var peg$f31 = function(p) {
        return { type: "postfix", plusses: p };
      };
      var peg$f32 = function(n) {
        return parseInt(n, 10);
      };
      var peg$f33 = function(n) {
        return parseFloat(n);
      };
      var peg$f34 = function(n) {
        return n;
      };
      var peg$f35 = function(n) {
        return -n;
      };
      var peg$f36 = function(m, n) {
        return m ? -n : n;
      };
      var peg$f37 = function(h) {
        return h.toUpperCase();
      };
      var peg$currPos = 0;
      var peg$savedPos = 0;
      var peg$posDetailsCache = [{ line: 1, column: 1 }];
      var peg$maxFailPos = 0;
      var peg$maxFailExpected = [];
      var peg$silentFails = 0;
      var peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function offset() {
        return peg$savedPos;
      }
      function range() {
        return {
          source: peg$source,
          start: peg$savedPos,
          end: peg$currPos
        };
      }
      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError(
          [peg$otherExpectation(description)],
          input.substring(peg$savedPos, peg$currPos),
          location2
        );
      }
      function error(message, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location2);
      }
      function peg$literalExpectation(text2, ignoreCase) {
        return { type: "literal", text: text2, ignoreCase };
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts, inverted, ignoreCase };
      }
      function peg$anyExpectation() {
        return { type: "any" };
      }
      function peg$endExpectation() {
        return { type: "end" };
      }
      function peg$otherExpectation(description) {
        return { type: "other", description };
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p;
        if (details) {
          return details;
        } else {
          p = pos - 1;
          while (!peg$posDetailsCache[p]) {
            p--;
          }
          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };
          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos);
        var endPosDetails = peg$computePosDetails(endPos);
        return {
          source: peg$source,
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildSimpleError(message, location2) {
        return new peg$SyntaxError(message, null, null, location2);
      }
      function peg$buildStructuredError(expected2, found, location2) {
        return new peg$SyntaxError(
          peg$SyntaxError.buildMessage(expected2, found),
          expected2,
          found,
          location2
        );
      }
      function peg$parsestart() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$parsespec();
        if (s1 !== peg$FAILED) {
          s22 = peg$parseEOL();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f0(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsespec_list();
          if (s1 !== peg$FAILED) {
            s22 = peg$parseEOL();
            if (s22 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f1(s1);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsecolor();
            if (s1 !== peg$FAILED) {
              s22 = peg$parseEOL();
              if (s22 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f2(s1);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parsemodel_list();
              if (s1 !== peg$FAILED) {
                s22 = peg$parseEOL();
                if (s22 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s0 = peg$f3(s1);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parsecolor_set_spec();
                if (s1 !== peg$FAILED) {
                  s22 = peg$parseEOL();
                  if (s22 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s0 = peg$f4(s1);
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  s1 = peg$currPos;
                  s22 = [];
                  if (input.length > peg$currPos) {
                    s32 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s32 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e0);
                    }
                  }
                  while (s32 !== peg$FAILED) {
                    s22.push(s32);
                    if (input.length > peg$currPos) {
                      s32 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s32 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e0);
                      }
                    }
                  }
                  s1 = input.substring(s1, peg$currPos);
                  peg$savedPos = s0;
                  s1 = peg$f5(s1);
                  s0 = s1;
                }
              }
            }
          }
        }
        return s0;
      }
      function peg$parsecolor_set_spec() {
        var s0, s1, s22, s32, s42, s5;
        s0 = peg$currPos;
        s1 = peg$parsecolor_set_item();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 59) {
            s42 = peg$c0;
            peg$currPos++;
          } else {
            s42 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e1);
            }
          }
          if (s42 !== peg$FAILED) {
            s5 = peg$parsecolor_set_item();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s32;
              s32 = peg$f6(s1, s5);
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          } else {
            peg$currPos = s32;
            s32 = peg$FAILED;
          }
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 59) {
              s42 = peg$c0;
              peg$currPos++;
            } else {
              s42 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e1);
              }
            }
            if (s42 !== peg$FAILED) {
              s5 = peg$parsecolor_set_item();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s32;
                s32 = peg$f6(s1, s5);
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          }
          peg$savedPos = s0;
          s0 = peg$f7(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecolor_set_item() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$parsename();
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 44) {
            s22 = peg$c1;
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          if (s22 !== peg$FAILED) {
            s32 = peg$parsespec_list();
            if (s32 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f8(s1, s32);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsemodel_list() {
        var s0, s1, s22, s32;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parsecore_model();
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 58) {
            s22 = peg$c2;
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e4);
            }
          }
          if (s22 !== peg$FAILED) {
            s32 = peg$parsemodel_list_tail();
            if (s32 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f9(s1, s32);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsemodel_list_tail();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f10(s1);
          }
          s0 = s1;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        return s0;
      }
      function peg$parsemodel_list_tail() {
        var s0, s1, s22, s32, s42, s5;
        s0 = peg$currPos;
        s1 = peg$parsemodel();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 47) {
            s42 = peg$c3;
            peg$currPos++;
          } else {
            s42 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e5);
            }
          }
          if (s42 !== peg$FAILED) {
            s5 = peg$parsemodel();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s32;
              s32 = peg$f11(s1, s5);
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          } else {
            peg$currPos = s32;
            s32 = peg$FAILED;
          }
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 47) {
              s42 = peg$c3;
              peg$currPos++;
            } else {
              s42 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e5);
              }
            }
            if (s42 !== peg$FAILED) {
              s5 = peg$parsemodel();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s32;
                s32 = peg$f11(s1, s5);
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          }
          peg$savedPos = s0;
          s0 = peg$f12(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsemodel() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parsecore_model();
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e6);
          }
        }
        return s0;
      }
      function peg$parsespec_list() {
        var s0, s1, s22, s32, s42, s5;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parsespec();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 47) {
            s42 = peg$c3;
            peg$currPos++;
          } else {
            s42 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e5);
            }
          }
          if (s42 !== peg$FAILED) {
            s5 = peg$parsespec();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s32;
              s32 = peg$f13(s1, s5);
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          } else {
            peg$currPos = s32;
            s32 = peg$FAILED;
          }
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 47) {
              s42 = peg$c3;
              peg$currPos++;
            } else {
              s42 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e5);
              }
            }
            if (s42 !== peg$FAILED) {
              s5 = peg$parsespec();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s32;
                s32 = peg$f13(s1, s5);
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          }
          peg$savedPos = s0;
          s0 = peg$f14(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e7);
          }
        }
        return s0;
      }
      function peg$parsespec() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$currPos;
        s32 = peg$parsehex();
        if (s32 !== peg$FAILED) {
          s42 = peg$parsehex();
          if (s42 !== peg$FAILED) {
            s5 = peg$parsehex();
            if (s5 !== peg$FAILED) {
              s6 = peg$parsehex();
              if (s6 !== peg$FAILED) {
                s7 = peg$parsehex();
                if (s7 !== peg$FAILED) {
                  s8 = peg$parsehex();
                  if (s8 !== peg$FAILED) {
                    s32 = [s32, s42, s5, s6, s7, s8];
                    s22 = s32;
                  } else {
                    peg$currPos = s22;
                    s22 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s22;
                  s22 = peg$FAILED;
                }
              } else {
                peg$currPos = s22;
                s22 = peg$FAILED;
              }
            } else {
              peg$currPos = s22;
              s22 = peg$FAILED;
            }
          } else {
            peg$currPos = s22;
            s22 = peg$FAILED;
          }
        } else {
          peg$currPos = s22;
          s22 = peg$FAILED;
        }
        if (s22 !== peg$FAILED) {
          s1 = input.substring(s1, peg$currPos);
        } else {
          s1 = s22;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f15(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsedec();
          if (s1 !== peg$FAILED) {
            s22 = [];
            s32 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 44) {
              s42 = peg$c1;
              peg$currPos++;
            } else {
              s42 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e2);
              }
            }
            if (s42 !== peg$FAILED) {
              s5 = peg$parsedec();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s32;
                s32 = peg$f16(s1, s5);
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
            if (s32 !== peg$FAILED) {
              while (s32 !== peg$FAILED) {
                s22.push(s32);
                s32 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 44) {
                  s42 = peg$c1;
                  peg$currPos++;
                } else {
                  s42 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e2);
                  }
                }
                if (s42 !== peg$FAILED) {
                  s5 = peg$parsedec();
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s32;
                    s32 = peg$f16(s1, s5);
                  } else {
                    peg$currPos = s32;
                    s32 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s32;
                  s32 = peg$FAILED;
                }
              }
            } else {
              s22 = peg$FAILED;
            }
            if (s22 === peg$FAILED) {
              s22 = [];
              s32 = peg$currPos;
              s42 = peg$parsesp();
              if (s42 !== peg$FAILED) {
                s5 = peg$parsedec();
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s32;
                  s32 = peg$f17(s1, s5);
                } else {
                  peg$currPos = s32;
                  s32 = peg$FAILED;
                }
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
              if (s32 !== peg$FAILED) {
                while (s32 !== peg$FAILED) {
                  s22.push(s32);
                  s32 = peg$currPos;
                  s42 = peg$parsesp();
                  if (s42 !== peg$FAILED) {
                    s5 = peg$parsedec();
                    if (s5 !== peg$FAILED) {
                      peg$savedPos = s32;
                      s32 = peg$f17(s1, s5);
                    } else {
                      peg$currPos = s32;
                      s32 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s32;
                    s32 = peg$FAILED;
                  }
                }
              } else {
                s22 = peg$FAILED;
              }
            }
            if (s22 === peg$FAILED) {
              s22 = null;
            }
            peg$savedPos = s0;
            s0 = peg$f18(s1, s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e8);
          }
        }
        return s0;
      }
      function peg$parsecolor() {
        var s0, s1, s22, s32;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parsecolor_expr();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$parsefunc_expr();
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parsefunc_expr();
          }
          peg$savedPos = s0;
          s0 = peg$f19(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e9);
          }
        }
        return s0;
      }
      function peg$parsecolor_expr() {
        var s0;
        s0 = peg$parseext_expr();
        if (s0 === peg$FAILED) {
          s0 = peg$parseexpr();
          if (s0 === peg$FAILED) {
            s0 = peg$parsename();
          }
        }
        return s0;
      }
      function peg$parsefunc_expr() {
        var s0, s1, s22, s32, s42, s5, s6;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 62) {
          s1 = peg$c4;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e11);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parsefunction();
          if (s22 !== peg$FAILED) {
            s32 = [];
            s42 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 44) {
              s5 = peg$c1;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e2);
              }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parseint();
              if (s6 !== peg$FAILED) {
                peg$savedPos = s42;
                s42 = peg$f20(s22, s6);
              } else {
                peg$currPos = s42;
                s42 = peg$FAILED;
              }
            } else {
              peg$currPos = s42;
              s42 = peg$FAILED;
            }
            while (s42 !== peg$FAILED) {
              s32.push(s42);
              s42 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 44) {
                s5 = peg$c1;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e2);
                }
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parseint();
                if (s6 !== peg$FAILED) {
                  peg$savedPos = s42;
                  s42 = peg$f20(s22, s6);
                } else {
                  peg$currPos = s42;
                  s42 = peg$FAILED;
                }
              } else {
                peg$currPos = s42;
                s42 = peg$FAILED;
              }
            }
            peg$savedPos = s0;
            s0 = peg$f21(s22, s32);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e10);
          }
        }
        return s0;
      }
      function peg$parsefunction() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parsename();
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e12);
          }
        }
        return s0;
      }
      function peg$parseext_expr() {
        var s0, s1, s22, s32, s42, s5, s6, s7;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parsecore_model();
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 44) {
            s22 = peg$c1;
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          if (s22 !== peg$FAILED) {
            s32 = peg$parsediv();
            if (s32 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 58) {
                s42 = peg$c2;
                peg$currPos++;
              } else {
                s42 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e4);
                }
              }
              if (s42 !== peg$FAILED) {
                s5 = peg$parseweighted_expr();
                if (s5 !== peg$FAILED) {
                  s6 = [];
                  s7 = peg$parseadditional_weighted_expr();
                  while (s7 !== peg$FAILED) {
                    s6.push(s7);
                    s7 = peg$parseadditional_weighted_expr();
                  }
                  peg$savedPos = s0;
                  s0 = peg$f22(s1, s32, s5, s6);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsecore_model();
          if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 58) {
              s22 = peg$c2;
              peg$currPos++;
            } else {
              s22 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e4);
              }
            }
            if (s22 !== peg$FAILED) {
              s32 = peg$parseweighted_expr();
              if (s32 !== peg$FAILED) {
                s42 = [];
                s5 = peg$parseadditional_weighted_expr();
                while (s5 !== peg$FAILED) {
                  s42.push(s5);
                  s5 = peg$parseadditional_weighted_expr();
                }
                peg$savedPos = s0;
                s0 = peg$f23(s1, s32, s42);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e13);
          }
        }
        return s0;
      }
      function peg$parseweighted_expr() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$parseexpr();
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 44) {
            s22 = peg$c1;
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          if (s22 !== peg$FAILED) {
            s32 = peg$parsedec();
            if (s32 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f24(s1, s32);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseadditional_weighted_expr() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 59) {
          s1 = peg$c0;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e1);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parseweighted_expr();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f25(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecore_model() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parsename();
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e14);
          }
        }
        return s0;
      }
      function peg$parseexpr() {
        var s0, s1, s22, s32, s42;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parseprefix();
        s22 = peg$parsename();
        if (s22 !== peg$FAILED) {
          s32 = peg$parsemix_expr();
          s42 = peg$parsepostfix();
          if (s42 === peg$FAILED) {
            s42 = null;
          }
          peg$savedPos = s0;
          s0 = peg$f26(s1, s22, s32, s42);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e15);
          }
        }
        return s0;
      }
      function peg$parsecomplete_mix() {
        var s0, s1, s22, s32, s42;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 33) {
          s1 = peg$c5;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e16);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parsepct();
          if (s22 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 33) {
              s32 = peg$c5;
              peg$currPos++;
            } else {
              s32 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e16);
              }
            }
            if (s32 !== peg$FAILED) {
              s42 = peg$parsename();
              if (s42 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f27(s22, s42);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsepartial_mix() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 33) {
          s1 = peg$c5;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e16);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parsepct();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f28(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsemix_expr() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsecomplete_mix();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parsecomplete_mix();
        }
        s22 = peg$parsepartial_mix();
        if (s22 === peg$FAILED) {
          s22 = null;
        }
        peg$savedPos = s0;
        s0 = peg$f29(s1, s22);
        peg$silentFails--;
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e17);
        }
        return s0;
      }
      function peg$parsename() {
        var s0, s1, s22;
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 46) {
          s0 = peg$c6;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e19);
          }
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = [];
          if (peg$r0.test(input.charAt(peg$currPos))) {
            s22 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e20);
            }
          }
          if (s22 !== peg$FAILED) {
            while (s22 !== peg$FAILED) {
              s1.push(s22);
              if (peg$r0.test(input.charAt(peg$currPos))) {
                s22 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s22 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e20);
                }
              }
            }
          } else {
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            s0 = input.substring(s0, peg$currPos);
          } else {
            s0 = s1;
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e18);
          }
        }
        return s0;
      }
      function peg$parsepostfix() {
        var s0, s1, s22, s32, s42;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 3) === peg$c7) {
          s1 = peg$c7;
          peg$currPos += 3;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e22);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parsenum();
          if (s22 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 93) {
              s32 = peg$c8;
              peg$currPos++;
            } else {
              s32 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e23);
              }
            }
            if (s32 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f30(s22);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c9) {
            s1 = peg$c9;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e24);
            }
          }
          if (s1 !== peg$FAILED) {
            s22 = peg$currPos;
            s32 = [];
            s42 = peg$parseplus();
            if (s42 !== peg$FAILED) {
              while (s42 !== peg$FAILED) {
                s32.push(s42);
                s42 = peg$parseplus();
              }
            } else {
              s32 = peg$FAILED;
            }
            if (s32 !== peg$FAILED) {
              s22 = input.substring(s22, peg$currPos);
            } else {
              s22 = s32;
            }
            if (s22 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f31(s22);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e21);
          }
        }
        return s0;
      }
      function peg$parseprefix() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parseminus();
        if (s0 === peg$FAILED) {
          s0 = null;
        }
        peg$silentFails--;
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e25);
        }
        return s0;
      }
      function peg$parseplus() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        if (input.charCodeAt(peg$currPos) === 43) {
          s22 = peg$c10;
          peg$currPos++;
        } else {
          s22 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e27);
          }
        }
        if (s22 !== peg$FAILED) {
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            if (input.charCodeAt(peg$currPos) === 43) {
              s22 = peg$c10;
              peg$currPos++;
            } else {
              s22 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e27);
              }
            }
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e26);
          }
        }
        return s0;
      }
      function peg$parseminus() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        if (input.charCodeAt(peg$currPos) === 45) {
          s22 = peg$c11;
          peg$currPos++;
        } else {
          s22 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e29);
          }
        }
        if (s22 !== peg$FAILED) {
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            if (input.charCodeAt(peg$currPos) === 45) {
              s22 = peg$c11;
              peg$currPos++;
            } else {
              s22 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e29);
              }
            }
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e28);
          }
        }
        return s0;
      }
      function peg$parsenum() {
        var s0, s1, s22, s32;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = [];
        if (peg$r1.test(input.charAt(peg$currPos))) {
          s32 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s32 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e31);
          }
        }
        if (s32 !== peg$FAILED) {
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            if (peg$r1.test(input.charAt(peg$currPos))) {
              s32 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s32 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e31);
              }
            }
          }
        } else {
          s22 = peg$FAILED;
        }
        if (s22 !== peg$FAILED) {
          s1 = input.substring(s1, peg$currPos);
        } else {
          s1 = s22;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f32(s1);
        }
        s0 = s1;
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e30);
          }
        }
        return s0;
      }
      function peg$parsepct() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8, s9;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$currPos;
        s32 = peg$currPos;
        s42 = [];
        if (peg$r1.test(input.charAt(peg$currPos))) {
          s5 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e31);
          }
        }
        if (s5 !== peg$FAILED) {
          while (s5 !== peg$FAILED) {
            s42.push(s5);
            if (peg$r1.test(input.charAt(peg$currPos))) {
              s5 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e31);
              }
            }
          }
        } else {
          s42 = peg$FAILED;
        }
        if (s42 !== peg$FAILED) {
          s32 = input.substring(s32, peg$currPos);
        } else {
          s32 = s42;
        }
        if (s32 !== peg$FAILED) {
          s42 = peg$currPos;
          s5 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 46) {
            s6 = peg$c6;
            peg$currPos++;
          } else {
            s6 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e19);
            }
          }
          if (s6 !== peg$FAILED) {
            s7 = peg$currPos;
            s8 = [];
            if (peg$r1.test(input.charAt(peg$currPos))) {
              s9 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s9 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e31);
              }
            }
            while (s9 !== peg$FAILED) {
              s8.push(s9);
              if (peg$r1.test(input.charAt(peg$currPos))) {
                s9 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s9 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e31);
                }
              }
            }
            s7 = input.substring(s7, peg$currPos);
            s6 = [s6, s7];
            s5 = s6;
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
          if (s5 === peg$FAILED) {
            s5 = null;
          }
          s42 = input.substring(s42, peg$currPos);
          s32 = [s32, s42];
          s22 = s32;
        } else {
          peg$currPos = s22;
          s22 = peg$FAILED;
        }
        if (s22 !== peg$FAILED) {
          s1 = input.substring(s1, peg$currPos);
        } else {
          s1 = s22;
        }
        if (s1 === peg$FAILED) {
          s1 = peg$currPos;
          s22 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 46) {
            s32 = peg$c6;
            peg$currPos++;
          } else {
            s32 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e19);
            }
          }
          if (s32 !== peg$FAILED) {
            s42 = peg$currPos;
            s5 = [];
            if (peg$r1.test(input.charAt(peg$currPos))) {
              s6 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e31);
              }
            }
            if (s6 !== peg$FAILED) {
              while (s6 !== peg$FAILED) {
                s5.push(s6);
                if (peg$r1.test(input.charAt(peg$currPos))) {
                  s6 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e31);
                  }
                }
              }
            } else {
              s5 = peg$FAILED;
            }
            if (s5 !== peg$FAILED) {
              s42 = input.substring(s42, peg$currPos);
            } else {
              s42 = s5;
            }
            if (s42 !== peg$FAILED) {
              s32 = [s32, s42];
              s22 = s32;
            } else {
              peg$currPos = s22;
              s22 = peg$FAILED;
            }
          } else {
            peg$currPos = s22;
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = input.substring(s1, peg$currPos);
          } else {
            s1 = s22;
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f33(s1);
        }
        s0 = s1;
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e32);
          }
        }
        return s0;
      }
      function peg$parsediv() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parsepct();
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e33);
          }
        }
        return s0;
      }
      function peg$parsedec() {
        var s0, s1, s22;
        s0 = peg$parsepct();
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 43) {
            s1 = peg$c10;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e27);
            }
          }
          if (s1 !== peg$FAILED) {
            s22 = peg$parsepct();
            if (s22 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f34(s22);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 45) {
              s1 = peg$c11;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e29);
              }
            }
            if (s1 !== peg$FAILED) {
              s22 = peg$parsepct();
              if (s22 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f35(s22);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
        }
        return s0;
      }
      function peg$parseint() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parseminus();
        if (s1 === peg$FAILED) {
          s1 = null;
        }
        s22 = peg$parsenum();
        if (s22 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f36(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e34);
          }
        }
        return s0;
      }
      function peg$parse_() {
        var s0, s1;
        peg$silentFails++;
        s0 = [];
        if (peg$r2.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e36);
          }
        }
        while (s1 !== peg$FAILED) {
          s0.push(s1);
          if (peg$r2.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e36);
            }
          }
        }
        peg$silentFails--;
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e35);
        }
        return s0;
      }
      function peg$parsesp() {
        var s0, s1;
        s0 = [];
        if (peg$r2.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e36);
          }
        }
        if (s1 !== peg$FAILED) {
          while (s1 !== peg$FAILED) {
            s0.push(s1);
            if (peg$r2.test(input.charAt(peg$currPos))) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e36);
              }
            }
          }
        } else {
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsehex() {
        var s0, s1;
        s0 = peg$currPos;
        if (peg$r3.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e37);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f37(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parseEOL() {
        var s0, s1;
        s0 = peg$currPos;
        peg$silentFails++;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        peg$silentFails--;
        if (s1 === peg$FAILED) {
          s0 = void 0;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(
          peg$maxFailExpected,
          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
      }
    }
    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }()
);
var tabular_spec_default3 = (
  // Generated by Peggy 2.0.1.
  //
  // https://peggyjs.org/
  function() {
    "use strict";
    function peg$subclass(child, parent) {
      function C() {
        this.constructor = child;
      }
      C.prototype = parent.prototype;
      child.prototype = new C();
    }
    function peg$SyntaxError(message, expected, found, location) {
      var self = Error.call(this, message);
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(self, peg$SyntaxError.prototype);
      }
      self.expected = expected;
      self.found = found;
      self.location = location;
      self.name = "SyntaxError";
      return self;
    }
    peg$subclass(peg$SyntaxError, Error);
    function peg$padEnd(str, targetLength, padString) {
      padString = padString || " ";
      if (str.length > targetLength) {
        return str;
      }
      targetLength -= str.length;
      padString += padString.repeat(targetLength);
      return str + padString.slice(0, targetLength);
    }
    peg$SyntaxError.prototype.format = function(sources) {
      var str = "Error: " + this.message;
      if (this.location) {
        var src = null;
        var k;
        for (k = 0; k < sources.length; k++) {
          if (sources[k].source === this.location.source) {
            src = sources[k].text.split(/\r\n|\n|\r/g);
            break;
          }
        }
        var s32 = this.location.start;
        var loc = this.location.source + ":" + s32.line + ":" + s32.column;
        if (src) {
          var e = this.location.end;
          var filler = peg$padEnd("", s32.line.toString().length, " ");
          var line = src[s32.line - 1];
          var last = s32.line === e.line ? e.column : line.length + 1;
          var hatLen = last - s32.column || 1;
          str += "\n --> " + loc + "\n" + filler + " |\n" + s32.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s32.column - 1, " ") + peg$padEnd("", hatLen, "^");
        } else {
          str += "\n at " + loc;
        }
      }
      return str;
    };
    peg$SyntaxError.buildMessage = function(expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        class: function(expectation) {
          var escapedParts = expectation.parts.map(function(part) {
            return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
          });
          return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
        },
        any: function() {
          return "any character";
        },
        end: function() {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        }
      };
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s32) {
        return s32.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function classEscape(s32) {
        return s32.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = expected2.map(describeExpectation);
        var i, j;
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {};
      var peg$source = options.grammarSource;
      var peg$startRuleFunctions = { body: peg$parsebody };
      var peg$startRuleFunction = peg$parsebody;
      var peg$e0 = peg$otherExpectation("decl_start");
      var peg$e1 = peg$otherExpectation("decl_end");
      var peg$e2 = peg$otherExpectation("vert");
      var peg$e3 = peg$anyExpectation();
      var peg$e4 = peg$otherExpectation("l");
      var peg$e5 = peg$otherExpectation("r");
      var peg$e6 = peg$otherExpectation("c");
      var peg$e7 = peg$otherExpectation("p");
      var peg$e8 = peg$otherExpectation("m");
      var peg$e9 = peg$otherExpectation("b");
      var peg$e10 = peg$otherExpectation("w");
      var peg$e11 = peg$otherExpectation("W");
      var peg$e12 = peg$otherExpectation("X");
      var peg$e13 = peg$otherExpectation("!");
      var peg$e14 = peg$otherExpectation("@");
      var peg$e15 = peg$otherExpectation("<");
      var peg$e16 = peg$otherExpectation(">");
      var peg$e17 = peg$otherExpectation("group");
      var peg$e18 = peg$otherExpectation("whitespace");
      var peg$f0 = function(c) {
        return c;
      };
      var peg$f1 = function(cols) {
        return cols;
      };
      var peg$f2 = function() {
        return [];
      };
      var peg$f3 = function(divs1, start, a, end, divs2) {
        return {
          type: "column",
          pre_dividers: divs1,
          post_dividers: divs2,
          before_start_code: start,
          before_end_code: end,
          alignment: a
        };
      };
      var peg$f4 = function() {
        return {
          type: "vert_divider"
        };
      };
      var peg$f5 = function(b, g) {
        return {
          type: "bang_divider",
          content: g[0].content
        };
      };
      var peg$f6 = function(g) {
        return {
          type: "at_divider",
          content: g[0].content
        };
      };
      var peg$f7 = function(div) {
        return div;
      };
      var peg$f8 = function(g) {
        return { type: "decl_code", code: g[0].content };
      };
      var peg$f9 = function(g) {
        return { type: "decl_code", code: g[0].content };
      };
      var peg$f10 = function() {
        return { type: "alignment", alignment: "left" };
      };
      var peg$f11 = function() {
        return { type: "alignment", alignment: "center" };
      };
      var peg$f12 = function() {
        return { type: "alignment", alignment: "right" };
      };
      var peg$f13 = function() {
        return { type: "alignment", alignment: "X" };
      };
      var peg$f14 = function() {
        return "top";
      };
      var peg$f15 = function() {
        return "default";
      };
      var peg$f16 = function() {
        return "bottom";
      };
      var peg$f17 = function(a, g) {
        return {
          type: "alignment",
          alignment: "parbox",
          baseline: a,
          size: g[0].content
        };
      };
      var peg$f18 = function(g1, g2) {
        return {
          type: "alignment",
          alignment: "parbox",
          baseline: g1[0].content,
          size: g2[0].content
        };
      };
      var peg$f19 = function(tok) {
        return options.matchChar(tok, "|");
      };
      var peg$f20 = function(tok) {
        return options.matchChar(tok, "l");
      };
      var peg$f21 = function(tok) {
        return options.matchChar(tok, "r");
      };
      var peg$f22 = function(tok) {
        return options.matchChar(tok, "c");
      };
      var peg$f23 = function(tok) {
        return options.matchChar(tok, "p");
      };
      var peg$f24 = function(tok) {
        return options.matchChar(tok, "m");
      };
      var peg$f25 = function(tok) {
        return options.matchChar(tok, "b");
      };
      var peg$f26 = function(tok) {
        return options.matchChar(tok, "w");
      };
      var peg$f27 = function(tok) {
        return options.matchChar(tok, "W");
      };
      var peg$f28 = function(tok) {
        return options.matchChar(tok, "X");
      };
      var peg$f29 = function(tok) {
        return options.matchChar(tok, "!");
      };
      var peg$f30 = function(tok) {
        return options.matchChar(tok, "@");
      };
      var peg$f31 = function(tok) {
        return options.matchChar(tok, "<");
      };
      var peg$f32 = function(tok) {
        return options.matchChar(tok, ">");
      };
      var peg$f33 = function(tok) {
        return options.isGroup(tok);
      };
      var peg$f34 = function(tok) {
        return options.isWhitespace(tok);
      };
      var peg$currPos = 0;
      var peg$savedPos = 0;
      var peg$posDetailsCache = [{ line: 1, column: 1 }];
      var peg$maxFailPos = 0;
      var peg$maxFailExpected = [];
      var peg$silentFails = 0;
      var peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function offset() {
        return peg$savedPos;
      }
      function range() {
        return {
          source: peg$source,
          start: peg$savedPos,
          end: peg$currPos
        };
      }
      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError(
          [peg$otherExpectation(description)],
          input.substring(peg$savedPos, peg$currPos),
          location2
        );
      }
      function error(message, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location2);
      }
      function peg$literalExpectation(text2, ignoreCase) {
        return { type: "literal", text: text2, ignoreCase };
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts, inverted, ignoreCase };
      }
      function peg$anyExpectation() {
        return { type: "any" };
      }
      function peg$endExpectation() {
        return { type: "end" };
      }
      function peg$otherExpectation(description) {
        return { type: "other", description };
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p;
        if (details) {
          return details;
        } else {
          p = pos - 1;
          while (!peg$posDetailsCache[p]) {
            p--;
          }
          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };
          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos);
        var endPosDetails = peg$computePosDetails(endPos);
        return {
          source: peg$source,
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildSimpleError(message, location2) {
        return new peg$SyntaxError(message, null, null, location2);
      }
      function peg$buildStructuredError(expected2, found, location2) {
        return new peg$SyntaxError(
          peg$SyntaxError.buildMessage(expected2, found),
          expected2,
          found,
          location2
        );
      }
      function peg$parsebody() {
        var s0, s1, s22, s32, s42, s5;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$currPos;
        s32 = peg$parsecolumn();
        if (s32 !== peg$FAILED) {
          s42 = [];
          s5 = peg$parse_();
          while (s5 !== peg$FAILED) {
            s42.push(s5);
            s5 = peg$parse_();
          }
          peg$savedPos = s22;
          s22 = peg$f0(s32);
        } else {
          peg$currPos = s22;
          s22 = peg$FAILED;
        }
        if (s22 !== peg$FAILED) {
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            s22 = peg$currPos;
            s32 = peg$parsecolumn();
            if (s32 !== peg$FAILED) {
              s42 = [];
              s5 = peg$parse_();
              while (s5 !== peg$FAILED) {
                s42.push(s5);
                s5 = peg$parse_();
              }
              peg$savedPos = s22;
              s22 = peg$f0(s32);
            } else {
              peg$currPos = s22;
              s22 = peg$FAILED;
            }
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f1(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseEOL();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f2();
          }
          s0 = s1;
        }
        return s0;
      }
      function peg$parsecolumn() {
        var s0, s1, s22, s32, s42, s5, s6;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsecolumn_divider();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parsecolumn_divider();
        }
        s22 = peg$parsedecl_start();
        if (s22 === peg$FAILED) {
          s22 = null;
        }
        s32 = peg$parsealignment();
        if (s32 !== peg$FAILED) {
          s42 = peg$parsedecl_end();
          if (s42 === peg$FAILED) {
            s42 = null;
          }
          s5 = [];
          s6 = peg$parsecolumn_divider();
          while (s6 !== peg$FAILED) {
            s5.push(s6);
            s6 = peg$parsecolumn_divider();
          }
          peg$savedPos = s0;
          s0 = peg$f3(s1, s22, s32, s42, s5);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecolumn_divider() {
        var s0, s1, s22, s32, s42;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parse_();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parse_();
        }
        s22 = peg$currPos;
        s32 = peg$parsevert();
        if (s32 !== peg$FAILED) {
          peg$savedPos = s22;
          s32 = peg$f4();
        }
        s22 = s32;
        if (s22 === peg$FAILED) {
          s22 = peg$currPos;
          s32 = peg$parsebang();
          if (s32 !== peg$FAILED) {
            s42 = peg$parsegroup();
            if (s42 !== peg$FAILED) {
              peg$savedPos = s22;
              s22 = peg$f5(s32, s42);
            } else {
              peg$currPos = s22;
              s22 = peg$FAILED;
            }
          } else {
            peg$currPos = s22;
            s22 = peg$FAILED;
          }
          if (s22 === peg$FAILED) {
            s22 = peg$currPos;
            s32 = peg$parseat();
            if (s32 !== peg$FAILED) {
              s42 = peg$parsegroup();
              if (s42 !== peg$FAILED) {
                peg$savedPos = s22;
                s22 = peg$f6(s42);
              } else {
                peg$currPos = s22;
                s22 = peg$FAILED;
              }
            } else {
              peg$currPos = s22;
              s22 = peg$FAILED;
            }
          }
        }
        if (s22 !== peg$FAILED) {
          s32 = [];
          s42 = peg$parse_();
          while (s42 !== peg$FAILED) {
            s32.push(s42);
            s42 = peg$parse_();
          }
          peg$savedPos = s0;
          s0 = peg$f7(s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsedecl_start() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parsegreater();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsegroup();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f8(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        return s0;
      }
      function peg$parsedecl_end() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parseless();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsegroup();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f9(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e1);
          }
        }
        return s0;
      }
      function peg$parsealignment() {
        var s0, s1, s22, s32, s42, s5;
        s0 = peg$currPos;
        s1 = peg$parsel();
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f10();
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsec();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f11();
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parser();
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$f12();
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parseX();
              if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$f13();
              }
              s0 = s1;
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$currPos;
                s22 = peg$parsep();
                if (s22 !== peg$FAILED) {
                  peg$savedPos = s1;
                  s22 = peg$f14();
                }
                s1 = s22;
                if (s1 === peg$FAILED) {
                  s1 = peg$currPos;
                  s22 = peg$parsem();
                  if (s22 !== peg$FAILED) {
                    peg$savedPos = s1;
                    s22 = peg$f15();
                  }
                  s1 = s22;
                  if (s1 === peg$FAILED) {
                    s1 = peg$currPos;
                    s22 = peg$parseb();
                    if (s22 !== peg$FAILED) {
                      peg$savedPos = s1;
                      s22 = peg$f16();
                    }
                    s1 = s22;
                  }
                }
                if (s1 !== peg$FAILED) {
                  s22 = [];
                  s32 = peg$parse_();
                  while (s32 !== peg$FAILED) {
                    s22.push(s32);
                    s32 = peg$parse_();
                  }
                  s32 = peg$parsegroup();
                  if (s32 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s0 = peg$f17(s1, s32);
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  s1 = peg$parsew();
                  if (s1 === peg$FAILED) {
                    s1 = peg$parseW();
                  }
                  if (s1 !== peg$FAILED) {
                    s22 = [];
                    s32 = peg$parse_();
                    while (s32 !== peg$FAILED) {
                      s22.push(s32);
                      s32 = peg$parse_();
                    }
                    s32 = peg$parsegroup();
                    if (s32 !== peg$FAILED) {
                      s42 = [];
                      s5 = peg$parse_();
                      while (s5 !== peg$FAILED) {
                        s42.push(s5);
                        s5 = peg$parse_();
                      }
                      s5 = peg$parsegroup();
                      if (s5 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s0 = peg$f18(s32, s5);
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                }
              }
            }
          }
        }
        return s0;
      }
      function peg$parsevert() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f19(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        return s0;
      }
      function peg$parsel() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f20(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e4);
          }
        }
        return s0;
      }
      function peg$parser() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f21(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e5);
          }
        }
        return s0;
      }
      function peg$parsec() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f22(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e6);
          }
        }
        return s0;
      }
      function peg$parsep() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f23(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e7);
          }
        }
        return s0;
      }
      function peg$parsem() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f24(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e8);
          }
        }
        return s0;
      }
      function peg$parseb() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f25(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e9);
          }
        }
        return s0;
      }
      function peg$parsew() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f26(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e10);
          }
        }
        return s0;
      }
      function peg$parseW() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f27(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e11);
          }
        }
        return s0;
      }
      function peg$parseX() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f28(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e12);
          }
        }
        return s0;
      }
      function peg$parsebang() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f29(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e13);
          }
        }
        return s0;
      }
      function peg$parseat() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f30(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e14);
          }
        }
        return s0;
      }
      function peg$parseless() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f31(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e15);
          }
        }
        return s0;
      }
      function peg$parsegreater() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f32(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e16);
          }
        }
        return s0;
      }
      function peg$parsegroup() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f33(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e17);
          }
        }
        return s0;
      }
      function peg$parse_() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f34(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e18);
          }
        }
        return s0;
      }
      function peg$parseEOL() {
        var s0, s1;
        s0 = peg$currPos;
        peg$silentFails++;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        peg$silentFails--;
        if (s1 === peg$FAILED) {
          s0 = void 0;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      if (!options.isHash) {
        try {
          Object.assign(options, {
            matchChar: (node, char) => node.type === "string" && node.content === char,
            isGroup: (node) => node.type === "group",
            isWhitespace: (node) => node.type === "whitespace"
          });
        } catch (e) {
          console.warn("Error when initializing parser", e);
        }
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(
          peg$maxFailExpected,
          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
      }
    }
    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }()
);
var systeme_environment_default3 = (
  // Generated by Peggy 2.0.1.
  //
  // https://peggyjs.org/
  function() {
    "use strict";
    function peg$subclass(child, parent) {
      function C() {
        this.constructor = child;
      }
      C.prototype = parent.prototype;
      child.prototype = new C();
    }
    function peg$SyntaxError(message, expected, found, location) {
      var self = Error.call(this, message);
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(self, peg$SyntaxError.prototype);
      }
      self.expected = expected;
      self.found = found;
      self.location = location;
      self.name = "SyntaxError";
      return self;
    }
    peg$subclass(peg$SyntaxError, Error);
    function peg$padEnd(str, targetLength, padString) {
      padString = padString || " ";
      if (str.length > targetLength) {
        return str;
      }
      targetLength -= str.length;
      padString += padString.repeat(targetLength);
      return str + padString.slice(0, targetLength);
    }
    peg$SyntaxError.prototype.format = function(sources) {
      var str = "Error: " + this.message;
      if (this.location) {
        var src = null;
        var k;
        for (k = 0; k < sources.length; k++) {
          if (sources[k].source === this.location.source) {
            src = sources[k].text.split(/\r\n|\n|\r/g);
            break;
          }
        }
        var s32 = this.location.start;
        var loc = this.location.source + ":" + s32.line + ":" + s32.column;
        if (src) {
          var e = this.location.end;
          var filler = peg$padEnd("", s32.line.toString().length, " ");
          var line = src[s32.line - 1];
          var last = s32.line === e.line ? e.column : line.length + 1;
          var hatLen = last - s32.column || 1;
          str += "\n --> " + loc + "\n" + filler + " |\n" + s32.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s32.column - 1, " ") + peg$padEnd("", hatLen, "^");
        } else {
          str += "\n at " + loc;
        }
      }
      return str;
    };
    peg$SyntaxError.buildMessage = function(expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        class: function(expectation) {
          var escapedParts = expectation.parts.map(function(part) {
            return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
          });
          return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
        },
        any: function() {
          return "any character";
        },
        end: function() {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        }
      };
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s32) {
        return s32.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function classEscape(s32) {
        return s32.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = expected2.map(describeExpectation);
        var i, j;
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {};
      var peg$source = options.grammarSource;
      var peg$startRuleFunctions = { body: peg$parsebody };
      var peg$startRuleFunction = peg$parsebody;
      var peg$e0 = peg$otherExpectation("partial item");
      var peg$e1 = peg$otherExpectation("item");
      var peg$e2 = peg$anyExpectation();
      var peg$e3 = peg$otherExpectation("equation");
      var peg$e4 = peg$otherExpectation("trailing comment");
      var peg$e5 = peg$otherExpectation("comment only line");
      var peg$e6 = peg$otherExpectation("non-var token");
      var peg$e7 = peg$otherExpectation("token");
      var peg$e8 = peg$otherExpectation("same line comment");
      var peg$e9 = peg$otherExpectation("own line comment");
      var peg$e10 = peg$otherExpectation(",");
      var peg$e11 = peg$otherExpectation("@");
      var peg$e12 = peg$otherExpectation("variable token");
      var peg$e13 = peg$otherExpectation("+/-");
      var peg$e14 = peg$otherExpectation("=");
      var peg$f0 = function(a, b) {
        return a.concat(b ? b : []);
      };
      var peg$f1 = function() {
        return [];
      };
      var peg$f2 = function(a, b, c) {
        return a.concat(b, c);
      };
      var peg$f3 = function(op, a, b, c) {
        return { type: "item", op, variable: b, content: a.concat(b, c) };
      };
      var peg$f4 = function(op, a) {
        return { type: "item", op, variable: null, content: a };
      };
      var peg$f5 = function(line, sep, comment262) {
        return { ...line, sep: [].concat(sep), trailingComment: comment262 };
      };
      var peg$f6 = function(line, comment262) {
        return { ...line, trailingComment: comment262 };
      };
      var peg$f7 = function(eq, ann) {
        return {
          type: "line",
          equation: eq,
          annotation: ann,
          sep: null
        };
      };
      var peg$f8 = function(at, ann) {
        return at ? { type: "annotation", marker: at, content: ann } : null;
      };
      var peg$f9 = function(left, eq, right) {
        return { type: "equation", left, right, equals: eq };
      };
      var peg$f10 = function(x) {
        return x;
      };
      var peg$f11 = function(x) {
        return {
          type: "line",
          trailingComment: x
        };
      };
      var peg$f12 = function(v, s32) {
        return [v].concat(s32 ? s32 : []);
      };
      var peg$f13 = function(t) {
        return t;
      };
      var peg$f14 = function(x) {
        return x;
      };
      var peg$f15 = function(x) {
        return x;
      };
      var peg$f16 = function(tok) {
        return options.isSameLineComment(tok);
      };
      var peg$f17 = function(tok) {
        return tok;
      };
      var peg$f18 = function(tok) {
        return options.isOwnLineComment(tok);
      };
      var peg$f19 = function(tok) {
        return tok;
      };
      var peg$f20 = function(tok) {
        return options.isWhitespace(tok);
      };
      var peg$f21 = function(tok) {
        return tok;
      };
      var peg$f22 = function(tok) {
        return options.isSep(tok);
      };
      var peg$f23 = function(tok) {
        return tok;
      };
      var peg$f24 = function(tok) {
        return options.isAt(tok);
      };
      var peg$f25 = function(tok) {
        return tok;
      };
      var peg$f26 = function(tok) {
        return options.isVar(tok);
      };
      var peg$f27 = function(tok) {
        return tok;
      };
      var peg$f28 = function(tok) {
        return options.isOperation(tok);
      };
      var peg$f29 = function(tok) {
        return tok;
      };
      var peg$f30 = function(tok) {
        return options.isEquals(tok);
      };
      var peg$f31 = function(tok) {
        return tok;
      };
      var peg$f32 = function(tok) {
        return options.isSubscript(tok);
      };
      var peg$f33 = function(tok) {
        return tok;
      };
      var peg$currPos = 0;
      var peg$savedPos = 0;
      var peg$posDetailsCache = [{ line: 1, column: 1 }];
      var peg$maxFailPos = 0;
      var peg$maxFailExpected = [];
      var peg$silentFails = 0;
      var peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function offset() {
        return peg$savedPos;
      }
      function range() {
        return {
          source: peg$source,
          start: peg$savedPos,
          end: peg$currPos
        };
      }
      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError(
          [peg$otherExpectation(description)],
          input.substring(peg$savedPos, peg$currPos),
          location2
        );
      }
      function error(message, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location2);
      }
      function peg$literalExpectation(text2, ignoreCase) {
        return { type: "literal", text: text2, ignoreCase };
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts, inverted, ignoreCase };
      }
      function peg$anyExpectation() {
        return { type: "any" };
      }
      function peg$endExpectation() {
        return { type: "end" };
      }
      function peg$otherExpectation(description) {
        return { type: "other", description };
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p;
        if (details) {
          return details;
        } else {
          p = pos - 1;
          while (!peg$posDetailsCache[p]) {
            p--;
          }
          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };
          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos);
        var endPosDetails = peg$computePosDetails(endPos);
        return {
          source: peg$source,
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildSimpleError(message, location2) {
        return new peg$SyntaxError(message, null, null, location2);
      }
      function peg$buildStructuredError(expected2, found, location2) {
        return new peg$SyntaxError(
          peg$SyntaxError.buildMessage(expected2, found),
          expected2,
          found,
          location2
        );
      }
      function peg$parsebody() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsecomment_only_line();
        if (s22 === peg$FAILED) {
          s22 = peg$parseline_with_sep();
          if (s22 === peg$FAILED) {
            s22 = peg$parsepartial_line_with_comment();
          }
        }
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parsecomment_only_line();
          if (s22 === peg$FAILED) {
            s22 = peg$parseline_with_sep();
            if (s22 === peg$FAILED) {
              s22 = peg$parsepartial_line_with_comment();
            }
          }
        }
        s22 = peg$parseline_without_sep();
        if (s22 === peg$FAILED) {
          s22 = peg$parseEOL();
        }
        if (s22 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f0(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseEOL();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f1();
          }
          s0 = s1;
        }
        return s0;
      }
      function peg$parsepartial_item() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parse_();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parse_();
        }
        s22 = [];
        s32 = peg$parsenon_var_token();
        while (s32 !== peg$FAILED) {
          s22.push(s32);
          s32 = peg$parsenon_var_token();
        }
        s32 = [];
        s42 = peg$parse_();
        while (s42 !== peg$FAILED) {
          s32.push(s42);
          s42 = peg$parse_();
        }
        s42 = peg$parsevar();
        if (s42 !== peg$FAILED) {
          s5 = [];
          s6 = peg$parse_();
          while (s6 !== peg$FAILED) {
            s5.push(s6);
            s6 = peg$parse_();
          }
          s6 = [];
          s7 = peg$parsetoken();
          while (s7 !== peg$FAILED) {
            s6.push(s7);
            s7 = peg$parsetoken();
          }
          s7 = [];
          s8 = peg$parse_();
          while (s8 !== peg$FAILED) {
            s7.push(s8);
            s8 = peg$parse_();
          }
          peg$savedPos = s0;
          s0 = peg$f2(s22, s42, s6);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        return s0;
      }
      function peg$parseitem() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8, s9;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parseoperation();
        if (s1 === peg$FAILED) {
          s1 = null;
        }
        s22 = [];
        s32 = peg$parse_();
        while (s32 !== peg$FAILED) {
          s22.push(s32);
          s32 = peg$parse_();
        }
        s32 = [];
        s42 = peg$parsenon_var_token();
        while (s42 !== peg$FAILED) {
          s32.push(s42);
          s42 = peg$parsenon_var_token();
        }
        s42 = [];
        s5 = peg$parse_();
        while (s5 !== peg$FAILED) {
          s42.push(s5);
          s5 = peg$parse_();
        }
        s5 = peg$parsevar();
        if (s5 !== peg$FAILED) {
          s6 = [];
          s7 = peg$parse_();
          while (s7 !== peg$FAILED) {
            s6.push(s7);
            s7 = peg$parse_();
          }
          s7 = [];
          s8 = peg$parsetoken();
          while (s8 !== peg$FAILED) {
            s7.push(s8);
            s8 = peg$parsetoken();
          }
          s8 = [];
          s9 = peg$parse_();
          while (s9 !== peg$FAILED) {
            s8.push(s9);
            s9 = peg$parse_();
          }
          peg$savedPos = s0;
          s0 = peg$f3(s1, s32, s5, s7);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseoperation();
          if (s1 === peg$FAILED) {
            s1 = null;
          }
          s22 = [];
          s32 = peg$parse_();
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parse_();
          }
          s32 = [];
          s42 = peg$parsenon_var_token();
          if (s42 !== peg$FAILED) {
            while (s42 !== peg$FAILED) {
              s32.push(s42);
              s42 = peg$parsenon_var_token();
            }
          } else {
            s32 = peg$FAILED;
          }
          if (s32 !== peg$FAILED) {
            s42 = [];
            s5 = peg$parse_();
            while (s5 !== peg$FAILED) {
              s42.push(s5);
              s5 = peg$parse_();
            }
            peg$savedPos = s0;
            s0 = peg$f4(s1, s32);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e1);
          }
        }
        return s0;
      }
      function peg$parseline_with_sep() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$parseline_without_sep();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsesep();
          if (s22 !== peg$FAILED) {
            s32 = peg$parsetrailing_comment();
            if (s32 === peg$FAILED) {
              s32 = null;
            }
            peg$savedPos = s0;
            s0 = peg$f5(s1, s22, s32);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsepartial_line_with_comment() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parseline_without_sep();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsetrailing_comment();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f6(s1, s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseline_without_sep() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        if (input.length > peg$currPos) {
          s22 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s22 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        peg$silentFails--;
        if (s22 !== peg$FAILED) {
          peg$currPos = s1;
          s1 = void 0;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parseequation();
          s32 = peg$parseannotation();
          if (s32 === peg$FAILED) {
            s32 = null;
          }
          peg$savedPos = s0;
          s0 = peg$f7(s22, s32);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseannotation() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$parseat();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$parsenon_sep_token();
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parsenon_sep_token();
          }
          peg$savedPos = s0;
          s0 = peg$f8(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseequation() {
        var s0, s1, s22, s32, s42;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parseitem();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parseitem();
        }
        s22 = peg$parseequals();
        if (s22 === peg$FAILED) {
          s22 = null;
        }
        s32 = [];
        s42 = peg$parsetoken();
        if (s42 === peg$FAILED) {
          s42 = peg$parseoperation();
        }
        while (s42 !== peg$FAILED) {
          s32.push(s42);
          s42 = peg$parsetoken();
          if (s42 === peg$FAILED) {
            s42 = peg$parseoperation();
          }
        }
        peg$savedPos = s0;
        s0 = peg$f9(s1, s22, s32);
        peg$silentFails--;
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e3);
        }
        return s0;
      }
      function peg$parsetrailing_comment() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parse_();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parse_();
        }
        s22 = peg$parsesame_line_comment();
        if (s22 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f10(s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e4);
          }
        }
        return s0;
      }
      function peg$parsecomment_only_line() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parse_();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parse_();
        }
        s22 = peg$parseown_line_comment();
        if (s22 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f11(s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e5);
          }
        }
        return s0;
      }
      function peg$parsevar() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$parsevar_token();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$parse_();
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parse_();
          }
          s32 = peg$parsesubscript();
          if (s32 === peg$FAILED) {
            s32 = null;
          }
          peg$savedPos = s0;
          s0 = peg$f12(s1, s32);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsenon_var_token() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        s22 = peg$parsevar();
        peg$silentFails--;
        if (s22 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parsetoken();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f13(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e6);
          }
        }
        return s0;
      }
      function peg$parsenon_sep_token() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        s22 = peg$parsesep();
        if (s22 === peg$FAILED) {
          s22 = peg$parsetrailing_comment();
          if (s22 === peg$FAILED) {
            s22 = peg$parseown_line_comment();
          }
        }
        peg$silentFails--;
        if (s22 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s22 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f14(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsetoken() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        s22 = peg$parsesep();
        if (s22 === peg$FAILED) {
          s22 = peg$parseat();
          if (s22 === peg$FAILED) {
            s22 = peg$parseoperation();
            if (s22 === peg$FAILED) {
              s22 = peg$parseequals();
              if (s22 === peg$FAILED) {
                s22 = peg$parsetrailing_comment();
                if (s22 === peg$FAILED) {
                  s22 = peg$parseown_line_comment();
                }
              }
            }
          }
        }
        peg$silentFails--;
        if (s22 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s22 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f15(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e7);
          }
        }
        return s0;
      }
      function peg$parsesame_line_comment() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f16(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f17(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e8);
          }
        }
        return s0;
      }
      function peg$parseown_line_comment() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f18(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f19(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e9);
          }
        }
        return s0;
      }
      function peg$parse_() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f20(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f21(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsesep() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f22(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f23(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e10);
          }
        }
        return s0;
      }
      function peg$parseat() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f24(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f25(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e11);
          }
        }
        return s0;
      }
      function peg$parsevar_token() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f26(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f27(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e12);
          }
        }
        return s0;
      }
      function peg$parseoperation() {
        var s0, s1, s22, s32, s42;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parse_();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parse_();
        }
        if (input.length > peg$currPos) {
          s22 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s22 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        if (s22 !== peg$FAILED) {
          s32 = [];
          s42 = peg$parse_();
          while (s42 !== peg$FAILED) {
            s32.push(s42);
            s42 = peg$parse_();
          }
          peg$savedPos = peg$currPos;
          s42 = peg$f28(s22);
          if (s42) {
            s42 = void 0;
          } else {
            s42 = peg$FAILED;
          }
          if (s42 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f29(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e13);
          }
        }
        return s0;
      }
      function peg$parseequals() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f30(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f31(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e14);
          }
        }
        return s0;
      }
      function peg$parsesubscript() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f32(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f33(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseEOL() {
        var s0, s1;
        s0 = peg$currPos;
        peg$silentFails++;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        peg$silentFails--;
        if (s1 === peg$FAILED) {
          s0 = void 0;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      if (!options.isWhitespace) {
        try {
          Object.assign(options, {
            isSep: (node) => node.type === "string" && node.content === ",",
            isVar: (node) => node.type === "string" && node.content.match(/[a-zA-Z]/),
            isOperation: (node) => node.type === "string" && node.content.match(/[+-]/),
            isEquals: (node) => node.type === "string" && node.content === "=",
            isAt: (node) => node.type === "string" && node.content === "@",
            isSubscript: (node) => node.content === "_",
            isWhitespace: (node) => node.type === "whitespace",
            isSameLineComment: (node) => node.type === "comment" && node.sameline,
            isOwnLineComment: (node) => node.type === "comment" && !node.sameline
          });
        } catch (e) {
          console.warn("Error when initializing parser", e);
        }
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(
          peg$maxFailExpected,
          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
      }
    }
    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }()
);
var tex_glue_default3 = (
  // Generated by Peggy 2.0.1.
  //
  // https://peggyjs.org/
  function() {
    "use strict";
    function peg$subclass(child, parent) {
      function C() {
        this.constructor = child;
      }
      C.prototype = parent.prototype;
      child.prototype = new C();
    }
    function peg$SyntaxError(message, expected, found, location) {
      var self = Error.call(this, message);
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(self, peg$SyntaxError.prototype);
      }
      self.expected = expected;
      self.found = found;
      self.location = location;
      self.name = "SyntaxError";
      return self;
    }
    peg$subclass(peg$SyntaxError, Error);
    function peg$padEnd(str, targetLength, padString) {
      padString = padString || " ";
      if (str.length > targetLength) {
        return str;
      }
      targetLength -= str.length;
      padString += padString.repeat(targetLength);
      return str + padString.slice(0, targetLength);
    }
    peg$SyntaxError.prototype.format = function(sources) {
      var str = "Error: " + this.message;
      if (this.location) {
        var src = null;
        var k;
        for (k = 0; k < sources.length; k++) {
          if (sources[k].source === this.location.source) {
            src = sources[k].text.split(/\r\n|\n|\r/g);
            break;
          }
        }
        var s32 = this.location.start;
        var loc = this.location.source + ":" + s32.line + ":" + s32.column;
        if (src) {
          var e = this.location.end;
          var filler = peg$padEnd("", s32.line.toString().length, " ");
          var line = src[s32.line - 1];
          var last = s32.line === e.line ? e.column : line.length + 1;
          var hatLen = last - s32.column || 1;
          str += "\n --> " + loc + "\n" + filler + " |\n" + s32.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s32.column - 1, " ") + peg$padEnd("", hatLen, "^");
        } else {
          str += "\n at " + loc;
        }
      }
      return str;
    };
    peg$SyntaxError.buildMessage = function(expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        class: function(expectation) {
          var escapedParts = expectation.parts.map(function(part) {
            return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
          });
          return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
        },
        any: function() {
          return "any character";
        },
        end: function() {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        }
      };
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s32) {
        return s32.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function classEscape(s32) {
        return s32.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = expected2.map(describeExpectation);
        var i, j;
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {};
      var peg$source = options.grammarSource;
      var peg$startRuleFunctions = { root: peg$parseroot };
      var peg$startRuleFunction = peg$parseroot;
      var peg$c0 = "plus";
      var peg$c1 = "minus";
      var peg$c2 = "pt";
      var peg$c3 = "mm";
      var peg$c4 = "cm";
      var peg$c5 = "in";
      var peg$c6 = "ex";
      var peg$c7 = "em";
      var peg$c8 = "bp";
      var peg$c9 = "pc";
      var peg$c10 = "dd";
      var peg$c11 = "cc";
      var peg$c12 = "nd";
      var peg$c13 = "nc";
      var peg$c14 = "sp";
      var peg$c15 = "filll";
      var peg$c16 = "fill";
      var peg$c17 = "fil";
      var peg$c18 = ".";
      var peg$c19 = "+";
      var peg$c20 = "-";
      var peg$r0 = /^[0-9]/;
      var peg$e0 = peg$anyExpectation();
      var peg$e1 = peg$literalExpectation("plus", false);
      var peg$e2 = peg$literalExpectation("minus", false);
      var peg$e3 = peg$literalExpectation("pt", false);
      var peg$e4 = peg$literalExpectation("mm", false);
      var peg$e5 = peg$literalExpectation("cm", false);
      var peg$e6 = peg$literalExpectation("in", false);
      var peg$e7 = peg$literalExpectation("ex", false);
      var peg$e8 = peg$literalExpectation("em", false);
      var peg$e9 = peg$literalExpectation("bp", false);
      var peg$e10 = peg$literalExpectation("pc", false);
      var peg$e11 = peg$literalExpectation("dd", false);
      var peg$e12 = peg$literalExpectation("cc", false);
      var peg$e13 = peg$literalExpectation("nd", false);
      var peg$e14 = peg$literalExpectation("nc", false);
      var peg$e15 = peg$literalExpectation("sp", false);
      var peg$e16 = peg$literalExpectation("filll", false);
      var peg$e17 = peg$literalExpectation("fill", false);
      var peg$e18 = peg$literalExpectation("fil", false);
      var peg$e19 = peg$otherExpectation("number");
      var peg$e20 = peg$classExpectation([["0", "9"]], false, false);
      var peg$e21 = peg$literalExpectation(".", false);
      var peg$e22 = peg$literalExpectation("+", false);
      var peg$e23 = peg$literalExpectation("-", false);
      var peg$f0 = function(b, st, sh) {
        return {
          type: "glue",
          fixed: b,
          stretchable: st,
          shrinkable: sh,
          position: location()
        };
      };
      var peg$f1 = function(glue) {
        return glue;
      };
      var peg$f2 = function(n, u) {
        return { type: "dim", value: n, unit: u };
      };
      var peg$f3 = function(n, u) {
        return { type: "dim", value: n, unit: u };
      };
      var peg$f4 = function(n, u) {
        return { type: "dim", value: n, unit: u };
      };
      var peg$f5 = function(n) {
        return parseFloat(n);
      };
      var peg$currPos = 0;
      var peg$savedPos = 0;
      var peg$posDetailsCache = [{ line: 1, column: 1 }];
      var peg$maxFailPos = 0;
      var peg$maxFailExpected = [];
      var peg$silentFails = 0;
      var peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function offset() {
        return peg$savedPos;
      }
      function range() {
        return {
          source: peg$source,
          start: peg$savedPos,
          end: peg$currPos
        };
      }
      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError(
          [peg$otherExpectation(description)],
          input.substring(peg$savedPos, peg$currPos),
          location2
        );
      }
      function error(message, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location2);
      }
      function peg$literalExpectation(text2, ignoreCase) {
        return { type: "literal", text: text2, ignoreCase };
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts, inverted, ignoreCase };
      }
      function peg$anyExpectation() {
        return { type: "any" };
      }
      function peg$endExpectation() {
        return { type: "end" };
      }
      function peg$otherExpectation(description) {
        return { type: "other", description };
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p;
        if (details) {
          return details;
        } else {
          p = pos - 1;
          while (!peg$posDetailsCache[p]) {
            p--;
          }
          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };
          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos);
        var endPosDetails = peg$computePosDetails(endPos);
        return {
          source: peg$source,
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildSimpleError(message, location2) {
        return new peg$SyntaxError(message, null, null, location2);
      }
      function peg$buildStructuredError(expected2, found, location2) {
        return new peg$SyntaxError(
          peg$SyntaxError.buildMessage(expected2, found),
          expected2,
          found,
          location2
        );
      }
      function peg$parseroot() {
        var s0, s1, s22, s32, s42;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$parsebase();
        if (s22 !== peg$FAILED) {
          s32 = peg$parsestretchable();
          if (s32 === peg$FAILED) {
            s32 = null;
          }
          s42 = peg$parseshrinkable();
          if (s42 === peg$FAILED) {
            s42 = null;
          }
          peg$savedPos = s1;
          s1 = peg$f0(s22, s32, s42);
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s22 = [];
          if (input.length > peg$currPos) {
            s32 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s32 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            if (input.length > peg$currPos) {
              s32 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s32 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
          }
          peg$savedPos = s0;
          s0 = peg$f1(s1);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsebase() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parsenumber();
        if (s1 !== peg$FAILED) {
          s22 = peg$parseunit();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f2(s1, s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsestretchable() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 4) === peg$c0) {
          s1 = peg$c0;
          peg$currPos += 4;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e1);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parsenumber();
          if (s22 !== peg$FAILED) {
            s32 = peg$parserubber_unit();
            if (s32 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f3(s22, s32);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseshrinkable() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 5) === peg$c1) {
          s1 = peg$c1;
          peg$currPos += 5;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parsenumber();
          if (s22 !== peg$FAILED) {
            s32 = peg$parserubber_unit();
            if (s32 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f4(s22, s32);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseunit() {
        var s0;
        if (input.substr(peg$currPos, 2) === peg$c2) {
          s0 = peg$c2;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s0 === peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c3) {
            s0 = peg$c3;
            peg$currPos += 2;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e4);
            }
          }
          if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c4) {
              s0 = peg$c4;
              peg$currPos += 2;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e5);
              }
            }
            if (s0 === peg$FAILED) {
              if (input.substr(peg$currPos, 2) === peg$c5) {
                s0 = peg$c5;
                peg$currPos += 2;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e6);
                }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 2) === peg$c6) {
                  s0 = peg$c6;
                  peg$currPos += 2;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e7);
                  }
                }
                if (s0 === peg$FAILED) {
                  if (input.substr(peg$currPos, 2) === peg$c7) {
                    s0 = peg$c7;
                    peg$currPos += 2;
                  } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e8);
                    }
                  }
                  if (s0 === peg$FAILED) {
                    if (input.substr(peg$currPos, 2) === peg$c8) {
                      s0 = peg$c8;
                      peg$currPos += 2;
                    } else {
                      s0 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e9);
                      }
                    }
                    if (s0 === peg$FAILED) {
                      if (input.substr(peg$currPos, 2) === peg$c9) {
                        s0 = peg$c9;
                        peg$currPos += 2;
                      } else {
                        s0 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$e10);
                        }
                      }
                      if (s0 === peg$FAILED) {
                        if (input.substr(peg$currPos, 2) === peg$c10) {
                          s0 = peg$c10;
                          peg$currPos += 2;
                        } else {
                          s0 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$e11);
                          }
                        }
                        if (s0 === peg$FAILED) {
                          if (input.substr(peg$currPos, 2) === peg$c11) {
                            s0 = peg$c11;
                            peg$currPos += 2;
                          } else {
                            s0 = peg$FAILED;
                            if (peg$silentFails === 0) {
                              peg$fail(peg$e12);
                            }
                          }
                          if (s0 === peg$FAILED) {
                            if (input.substr(peg$currPos, 2) === peg$c12) {
                              s0 = peg$c12;
                              peg$currPos += 2;
                            } else {
                              s0 = peg$FAILED;
                              if (peg$silentFails === 0) {
                                peg$fail(peg$e13);
                              }
                            }
                            if (s0 === peg$FAILED) {
                              if (input.substr(peg$currPos, 2) === peg$c13) {
                                s0 = peg$c13;
                                peg$currPos += 2;
                              } else {
                                s0 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                  peg$fail(peg$e14);
                                }
                              }
                              if (s0 === peg$FAILED) {
                                if (input.substr(peg$currPos, 2) === peg$c14) {
                                  s0 = peg$c14;
                                  peg$currPos += 2;
                                } else {
                                  s0 = peg$FAILED;
                                  if (peg$silentFails === 0) {
                                    peg$fail(peg$e15);
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return s0;
      }
      function peg$parserubber_unit() {
        var s0;
        s0 = peg$parseunit();
        if (s0 === peg$FAILED) {
          if (input.substr(peg$currPos, 5) === peg$c15) {
            s0 = peg$c15;
            peg$currPos += 5;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e16);
            }
          }
          if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 4) === peg$c16) {
              s0 = peg$c16;
              peg$currPos += 4;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e17);
              }
            }
            if (s0 === peg$FAILED) {
              if (input.substr(peg$currPos, 3) === peg$c17) {
                s0 = peg$c17;
                peg$currPos += 3;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e18);
                }
              }
            }
          }
        }
        return s0;
      }
      function peg$parsenumber() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$currPos;
        s32 = peg$parsesign();
        if (s32 === peg$FAILED) {
          s32 = null;
        }
        s42 = peg$currPos;
        s5 = [];
        if (peg$r0.test(input.charAt(peg$currPos))) {
          s6 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s6 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e20);
          }
        }
        while (s6 !== peg$FAILED) {
          s5.push(s6);
          if (peg$r0.test(input.charAt(peg$currPos))) {
            s6 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s6 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e20);
            }
          }
        }
        if (input.charCodeAt(peg$currPos) === 46) {
          s6 = peg$c18;
          peg$currPos++;
        } else {
          s6 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e21);
          }
        }
        if (s6 !== peg$FAILED) {
          s7 = [];
          if (peg$r0.test(input.charAt(peg$currPos))) {
            s8 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s8 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e20);
            }
          }
          if (s8 !== peg$FAILED) {
            while (s8 !== peg$FAILED) {
              s7.push(s8);
              if (peg$r0.test(input.charAt(peg$currPos))) {
                s8 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s8 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e20);
                }
              }
            }
          } else {
            s7 = peg$FAILED;
          }
          if (s7 !== peg$FAILED) {
            s5 = [s5, s6, s7];
            s42 = s5;
          } else {
            peg$currPos = s42;
            s42 = peg$FAILED;
          }
        } else {
          peg$currPos = s42;
          s42 = peg$FAILED;
        }
        if (s42 === peg$FAILED) {
          s42 = [];
          if (peg$r0.test(input.charAt(peg$currPos))) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e20);
            }
          }
          if (s5 !== peg$FAILED) {
            while (s5 !== peg$FAILED) {
              s42.push(s5);
              if (peg$r0.test(input.charAt(peg$currPos))) {
                s5 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e20);
                }
              }
            }
          } else {
            s42 = peg$FAILED;
          }
        }
        if (s42 !== peg$FAILED) {
          s32 = [s32, s42];
          s22 = s32;
        } else {
          peg$currPos = s22;
          s22 = peg$FAILED;
        }
        if (s22 !== peg$FAILED) {
          s1 = input.substring(s1, peg$currPos);
        } else {
          s1 = s22;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f5(s1);
        }
        s0 = s1;
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e19);
          }
        }
        return s0;
      }
      function peg$parsesign() {
        var s0;
        if (input.charCodeAt(peg$currPos) === 43) {
          s0 = peg$c19;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e22);
          }
        }
        if (s0 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 45) {
            s0 = peg$c20;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e23);
            }
          }
        }
        return s0;
      }
      function peg$parseEOL() {
        var s0, s1;
        s0 = peg$currPos;
        peg$silentFails++;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        peg$silentFails--;
        if (s1 === peg$FAILED) {
          s0 = void 0;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(
          peg$maxFailExpected,
          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
      }
    }
    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }()
);
var tikz_default3 = (
  // Generated by Peggy 2.0.1.
  //
  // https://peggyjs.org/
  function() {
    "use strict";
    function peg$subclass(child, parent) {
      function C() {
        this.constructor = child;
      }
      C.prototype = parent.prototype;
      child.prototype = new C();
    }
    function peg$SyntaxError(message, expected, found, location) {
      var self = Error.call(this, message);
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(self, peg$SyntaxError.prototype);
      }
      self.expected = expected;
      self.found = found;
      self.location = location;
      self.name = "SyntaxError";
      return self;
    }
    peg$subclass(peg$SyntaxError, Error);
    function peg$padEnd(str, targetLength, padString) {
      padString = padString || " ";
      if (str.length > targetLength) {
        return str;
      }
      targetLength -= str.length;
      padString += padString.repeat(targetLength);
      return str + padString.slice(0, targetLength);
    }
    peg$SyntaxError.prototype.format = function(sources) {
      var str = "Error: " + this.message;
      if (this.location) {
        var src = null;
        var k;
        for (k = 0; k < sources.length; k++) {
          if (sources[k].source === this.location.source) {
            src = sources[k].text.split(/\r\n|\n|\r/g);
            break;
          }
        }
        var s32 = this.location.start;
        var loc = this.location.source + ":" + s32.line + ":" + s32.column;
        if (src) {
          var e = this.location.end;
          var filler = peg$padEnd("", s32.line.toString().length, " ");
          var line = src[s32.line - 1];
          var last = s32.line === e.line ? e.column : line.length + 1;
          var hatLen = last - s32.column || 1;
          str += "\n --> " + loc + "\n" + filler + " |\n" + s32.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s32.column - 1, " ") + peg$padEnd("", hatLen, "^");
        } else {
          str += "\n at " + loc;
        }
      }
      return str;
    };
    peg$SyntaxError.buildMessage = function(expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        class: function(expectation) {
          var escapedParts = expectation.parts.map(function(part) {
            return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
          });
          return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
        },
        any: function() {
          return "any character";
        },
        end: function() {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        }
      };
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s32) {
        return s32.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function classEscape(s32) {
        return s32.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = expected2.map(describeExpectation);
        var i, j;
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {};
      var peg$source = options.grammarSource;
      var peg$startRuleFunctions = { path_spec: peg$parsepath_spec, foreach_body: peg$parseforeach_body };
      var peg$startRuleFunction = peg$parsepath_spec;
      var peg$e0 = peg$anyExpectation();
      var peg$e1 = peg$otherExpectation("same line comment");
      var peg$e2 = peg$otherExpectation("own line comment");
      var peg$e3 = peg$otherExpectation("comment");
      var peg$e4 = peg$otherExpectation("floating comment");
      var peg$e5 = peg$otherExpectation("operation");
      var peg$e6 = peg$otherExpectation("=");
      var peg$f0 = function(v) {
        return v;
      };
      var peg$f1 = function(ops) {
        return { type: "path_spec", content: ops };
      };
      var peg$f2 = function(c1, op, comment262) {
        return { op, comment: comment262 };
      };
      var peg$f3 = function(c1, ops, c2, body) {
        const comments = [c1, ...ops.map((x) => x.comment), c2].filter(
          (x) => x
        );
        const attribute = ops.map((x) => x.op.content.content).join(" ");
        return {
          type: "animation",
          comments,
          attribute,
          content: body.content
        };
      };
      var peg$f4 = function(start, b) {
        return { ...b, start, type: "foreach" };
      };
      var peg$f5 = function(c1, variables, options2, c2, c3, list, c4, command) {
        const comments = [c1, c2, c3, c4].filter((x) => x);
        return {
          type: "foreach_body",
          variables,
          options: options2 && options2.content,
          list,
          command,
          comments
        };
      };
      var peg$f6 = function(c1, options2, c2, body) {
        const comments = [c1, c2].filter((x) => x);
        return {
          type: "svg_operation",
          options: options2 && options2.content,
          content: body,
          comments
        };
      };
      var peg$f7 = function(c1, c2, coord, c3, c4, x) {
        return { coord: x, comment: c4 };
      };
      var peg$f8 = function(c1, c2, coord, c3, a, c5) {
        const comments = [c1, c2, c3, a && a.comment, c5].filter((x) => x);
        return {
          type: "curve_to",
          controls: a ? [coord, a.coord] : [coord],
          comments
        };
      };
      var peg$f9 = function() {
        return { type: "line_to", command: "|-" };
      };
      var peg$f10 = function() {
        return { type: "line_to", command: "-|" };
      };
      var peg$f11 = function() {
        return { type: "line_to", command: "--" };
      };
      var peg$f12 = function(prefix, content) {
        return { type: "coordinate", content, prefix };
      };
      var peg$f13 = function(content) {
        return { type: "square_brace_group", content };
      };
      var peg$f14 = function(v) {
        return { type: "unknown", content: v };
      };
      var peg$f15 = function(tok) {
        return options.isSameLineComment(tok);
      };
      var peg$f16 = function(tok) {
        return tok;
      };
      var peg$f17 = function(tok) {
        return options.isOwnLineComment(tok);
      };
      var peg$f18 = function(tok) {
        return tok;
      };
      var peg$f19 = function(tok) {
        return options.isComment(tok);
      };
      var peg$f20 = function(tok) {
        return tok;
      };
      var peg$f21 = function(tok) {
        return options.isWhitespace(tok);
      };
      var peg$f22 = function(tok) {
        return tok;
      };
      var peg$f23 = function(c) {
        return c;
      };
      var peg$f24 = function(tok) {
        return options.isOperation(tok);
      };
      var peg$f25 = function(tok) {
        return { type: "operation", content: tok };
      };
      var peg$f26 = function(tok) {
        return options.isChar(tok, "=");
      };
      var peg$f27 = function(tok) {
        return tok;
      };
      var peg$f28 = function(tok) {
        return options.isChar(tok, "[");
      };
      var peg$f29 = function(tok) {
        return tok;
      };
      var peg$f30 = function(tok) {
        return options.isChar(tok, "]");
      };
      var peg$f31 = function(tok) {
        return tok;
      };
      var peg$f32 = function(tok) {
        return options.isChar(tok, "(");
      };
      var peg$f33 = function(tok) {
        return tok;
      };
      var peg$f34 = function(tok) {
        return options.isChar(tok, ")");
      };
      var peg$f35 = function(tok) {
        return tok;
      };
      var peg$f36 = function(tok) {
        return options.isChar(tok, "+");
      };
      var peg$f37 = function(tok) {
        return tok;
      };
      var peg$f38 = function(tok) {
        return options.isChar(tok, "-");
      };
      var peg$f39 = function(tok) {
        return tok;
      };
      var peg$f40 = function(tok) {
        return options.isChar(tok, "|");
      };
      var peg$f41 = function(tok) {
        return tok;
      };
      var peg$f42 = function(tok) {
        return options.isChar(tok, ".");
      };
      var peg$f43 = function(tok) {
        return tok;
      };
      var peg$f44 = function(tok) {
        return options.isChar(tok, "controls");
      };
      var peg$f45 = function(tok) {
        return tok;
      };
      var peg$f46 = function(tok) {
        return options.isChar(tok, "and");
      };
      var peg$f47 = function(tok) {
        return tok;
      };
      var peg$f48 = function(tok) {
        return options.isChar(tok, "svg");
      };
      var peg$f49 = function(tok) {
        return tok;
      };
      var peg$f50 = function(tok) {
        return options.isGroup(tok);
      };
      var peg$f51 = function(tok) {
        return tok;
      };
      var peg$f52 = function(tok) {
        return options.isAnyMacro(tok);
      };
      var peg$f53 = function(tok) {
        return tok;
      };
      var peg$f54 = function(tok) {
        return options.isChar(tok, "foreach");
      };
      var peg$f55 = function(tok) {
        return tok;
      };
      var peg$f56 = function(tok) {
        return options.isMacro(tok, "foreach");
      };
      var peg$f57 = function(tok) {
        return tok;
      };
      var peg$f58 = function(tok) {
        return options.isChar(tok, "in");
      };
      var peg$f59 = function(tok) {
        return tok;
      };
      var peg$f60 = function(tok) {
        return options.isChar(tok, ":");
      };
      var peg$f61 = function(tok) {
        return tok;
      };
      var peg$currPos = 0;
      var peg$savedPos = 0;
      var peg$posDetailsCache = [{ line: 1, column: 1 }];
      var peg$maxFailPos = 0;
      var peg$maxFailExpected = [];
      var peg$silentFails = 0;
      var peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function offset() {
        return peg$savedPos;
      }
      function range() {
        return {
          source: peg$source,
          start: peg$savedPos,
          end: peg$currPos
        };
      }
      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError(
          [peg$otherExpectation(description)],
          input.substring(peg$savedPos, peg$currPos),
          location2
        );
      }
      function error(message, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location2);
      }
      function peg$literalExpectation(text2, ignoreCase) {
        return { type: "literal", text: text2, ignoreCase };
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts, inverted, ignoreCase };
      }
      function peg$anyExpectation() {
        return { type: "any" };
      }
      function peg$endExpectation() {
        return { type: "end" };
      }
      function peg$otherExpectation(description) {
        return { type: "other", description };
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p;
        if (details) {
          return details;
        } else {
          p = pos - 1;
          while (!peg$posDetailsCache[p]) {
            p--;
          }
          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };
          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos);
        var endPosDetails = peg$computePosDetails(endPos);
        return {
          source: peg$source,
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildSimpleError(message, location2) {
        return new peg$SyntaxError(message, null, null, location2);
      }
      function peg$buildStructuredError(expected2, found, location2) {
        return new peg$SyntaxError(
          peg$SyntaxError.buildMessage(expected2, found),
          expected2,
          found,
          location2
        );
      }
      function peg$parsepath_spec() {
        var s0, s1, s22, s32, s42, s5;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$currPos;
        s32 = peg$parsesquare_brace_group();
        if (s32 === peg$FAILED) {
          s32 = peg$parsecoordinate();
          if (s32 === peg$FAILED) {
            s32 = peg$parsecurve_to();
            if (s32 === peg$FAILED) {
              s32 = peg$parseline_to();
              if (s32 === peg$FAILED) {
                s32 = peg$parsesvg();
                if (s32 === peg$FAILED) {
                  s32 = peg$parseforeach();
                  if (s32 === peg$FAILED) {
                    s32 = peg$parseoperation();
                    if (s32 === peg$FAILED) {
                      s32 = peg$parsecomment();
                      if (s32 === peg$FAILED) {
                        s32 = peg$parseanimation();
                        if (s32 === peg$FAILED) {
                          s32 = peg$parseunknown();
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (s32 !== peg$FAILED) {
          s42 = [];
          s5 = peg$parse_();
          while (s5 !== peg$FAILED) {
            s42.push(s5);
            s5 = peg$parse_();
          }
          peg$savedPos = s22;
          s22 = peg$f0(s32);
        } else {
          peg$currPos = s22;
          s22 = peg$FAILED;
        }
        if (s22 !== peg$FAILED) {
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            s22 = peg$currPos;
            s32 = peg$parsesquare_brace_group();
            if (s32 === peg$FAILED) {
              s32 = peg$parsecoordinate();
              if (s32 === peg$FAILED) {
                s32 = peg$parsecurve_to();
                if (s32 === peg$FAILED) {
                  s32 = peg$parseline_to();
                  if (s32 === peg$FAILED) {
                    s32 = peg$parsesvg();
                    if (s32 === peg$FAILED) {
                      s32 = peg$parseforeach();
                      if (s32 === peg$FAILED) {
                        s32 = peg$parseoperation();
                        if (s32 === peg$FAILED) {
                          s32 = peg$parsecomment();
                          if (s32 === peg$FAILED) {
                            s32 = peg$parseanimation();
                            if (s32 === peg$FAILED) {
                              s32 = peg$parseunknown();
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            if (s32 !== peg$FAILED) {
              s42 = [];
              s5 = peg$parse_();
              while (s5 !== peg$FAILED) {
                s42.push(s5);
                s5 = peg$parse_();
              }
              peg$savedPos = s22;
              s22 = peg$f0(s32);
            } else {
              peg$currPos = s22;
              s22 = peg$FAILED;
            }
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f1(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parseanimation() {
        var s0, s1, s22, s32, s42, s5, s6;
        s0 = peg$currPos;
        s1 = peg$parsecolon();
        if (s1 !== peg$FAILED) {
          s22 = peg$parse_comment_();
          s32 = [];
          s42 = peg$currPos;
          s5 = peg$parseoperation();
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_comment_();
            peg$savedPos = s42;
            s42 = peg$f2(s22, s5, s6);
          } else {
            peg$currPos = s42;
            s42 = peg$FAILED;
          }
          if (s42 !== peg$FAILED) {
            while (s42 !== peg$FAILED) {
              s32.push(s42);
              s42 = peg$currPos;
              s5 = peg$parseoperation();
              if (s5 !== peg$FAILED) {
                s6 = peg$parse_comment_();
                peg$savedPos = s42;
                s42 = peg$f2(s22, s5, s6);
              } else {
                peg$currPos = s42;
                s42 = peg$FAILED;
              }
            }
          } else {
            s32 = peg$FAILED;
          }
          if (s32 !== peg$FAILED) {
            s42 = peg$parseequals();
            if (s42 !== peg$FAILED) {
              s5 = peg$parse_comment_();
              s6 = peg$parsegroup();
              if (s6 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f3(s22, s32, s5, s6);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseforeach() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parseforeach_keyword();
        if (s1 === peg$FAILED) {
          s1 = peg$parseforeach_macro();
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parseforeach_body();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f4(s1, s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseforeach_body() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8, s9;
        s0 = peg$currPos;
        s1 = peg$parse_comment_();
        s22 = peg$currPos;
        s32 = [];
        s42 = peg$currPos;
        s5 = peg$currPos;
        peg$silentFails++;
        s6 = peg$parsein_keyword();
        if (s6 === peg$FAILED) {
          s6 = peg$parsesquare_brace_group();
        }
        peg$silentFails--;
        if (s6 === peg$FAILED) {
          s5 = void 0;
        } else {
          peg$currPos = s5;
          s5 = peg$FAILED;
        }
        if (s5 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s6 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s6 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s6 !== peg$FAILED) {
            s5 = [s5, s6];
            s42 = s5;
          } else {
            peg$currPos = s42;
            s42 = peg$FAILED;
          }
        } else {
          peg$currPos = s42;
          s42 = peg$FAILED;
        }
        while (s42 !== peg$FAILED) {
          s32.push(s42);
          s42 = peg$currPos;
          s5 = peg$currPos;
          peg$silentFails++;
          s6 = peg$parsein_keyword();
          if (s6 === peg$FAILED) {
            s6 = peg$parsesquare_brace_group();
          }
          peg$silentFails--;
          if (s6 === peg$FAILED) {
            s5 = void 0;
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
          if (s5 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s6 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            if (s6 !== peg$FAILED) {
              s5 = [s5, s6];
              s42 = s5;
            } else {
              peg$currPos = s42;
              s42 = peg$FAILED;
            }
          } else {
            peg$currPos = s42;
            s42 = peg$FAILED;
          }
        }
        s22 = input.substring(s22, peg$currPos);
        s32 = peg$parsesquare_brace_group();
        if (s32 === peg$FAILED) {
          s32 = null;
        }
        s42 = peg$parse_comment_();
        s5 = peg$parsein_keyword();
        if (s5 !== peg$FAILED) {
          s6 = peg$parse_comment_();
          s7 = peg$parsegroup();
          if (s7 === peg$FAILED) {
            s7 = peg$parsemacro();
          }
          if (s7 !== peg$FAILED) {
            s8 = peg$parse_comment_();
            s9 = peg$parseforeach();
            if (s9 === peg$FAILED) {
              s9 = peg$parsegroup();
              if (s9 === peg$FAILED) {
                s9 = peg$parsemacro();
              }
            }
            if (s9 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f5(s1, s22, s32, s42, s6, s7, s8, s9);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsesvg() {
        var s0, s1, s22, s32, s42, s5;
        s0 = peg$currPos;
        s1 = peg$parsesvg_keyword();
        if (s1 !== peg$FAILED) {
          s22 = peg$parse_comment_();
          s32 = peg$parsesquare_brace_group();
          if (s32 === peg$FAILED) {
            s32 = null;
          }
          s42 = peg$parse_comment_();
          s5 = peg$parsegroup();
          if (s5 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f6(s22, s32, s42, s5);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecurve_to() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8, s9, s10;
        s0 = peg$currPos;
        s1 = peg$parsedotdot();
        if (s1 !== peg$FAILED) {
          s22 = peg$parse_comment_();
          s32 = peg$parsecontrols_keyword();
          if (s32 !== peg$FAILED) {
            s42 = peg$parse_comment_();
            s5 = peg$parsecoordinate();
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_comment_();
              s7 = peg$currPos;
              s8 = peg$parseand_keyword();
              if (s8 !== peg$FAILED) {
                s9 = peg$parse_comment_();
                s10 = peg$parsecoordinate();
                if (s10 !== peg$FAILED) {
                  peg$savedPos = s7;
                  s7 = peg$f7(s22, s42, s5, s6, s9, s10);
                } else {
                  peg$currPos = s7;
                  s7 = peg$FAILED;
                }
              } else {
                peg$currPos = s7;
                s7 = peg$FAILED;
              }
              if (s7 === peg$FAILED) {
                s7 = null;
              }
              s8 = peg$parse_comment_();
              s9 = peg$parsedotdot();
              if (s9 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f8(s22, s42, s5, s6, s7, s8);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseline_to() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parsepipe();
        if (s1 !== peg$FAILED) {
          s22 = peg$parseminus();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f9();
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseminus();
          if (s1 !== peg$FAILED) {
            s22 = peg$parsepipe();
            if (s22 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f10();
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseminus();
            if (s1 !== peg$FAILED) {
              s22 = peg$parseminus();
              if (s22 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f11();
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
        }
        return s0;
      }
      function peg$parsecoordinate() {
        var s0, s1, s22, s32, s42, s5, s6, s7;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$currPos;
        s32 = peg$parseplus();
        if (s32 !== peg$FAILED) {
          s42 = peg$parseplus();
          if (s42 === peg$FAILED) {
            s42 = null;
          }
          s32 = [s32, s42];
          s22 = s32;
        } else {
          peg$currPos = s22;
          s22 = peg$FAILED;
        }
        if (s22 === peg$FAILED) {
          s22 = null;
        }
        s1 = input.substring(s1, peg$currPos);
        s22 = peg$parseopen_paren();
        if (s22 !== peg$FAILED) {
          s32 = peg$currPos;
          s42 = [];
          s5 = peg$currPos;
          s6 = peg$currPos;
          peg$silentFails++;
          s7 = peg$parseclose_paren();
          peg$silentFails--;
          if (s7 === peg$FAILED) {
            s6 = void 0;
          } else {
            peg$currPos = s6;
            s6 = peg$FAILED;
          }
          if (s6 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s7 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s7 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            if (s7 !== peg$FAILED) {
              s6 = [s6, s7];
              s5 = s6;
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
          while (s5 !== peg$FAILED) {
            s42.push(s5);
            s5 = peg$currPos;
            s6 = peg$currPos;
            peg$silentFails++;
            s7 = peg$parseclose_paren();
            peg$silentFails--;
            if (s7 === peg$FAILED) {
              s6 = void 0;
            } else {
              peg$currPos = s6;
              s6 = peg$FAILED;
            }
            if (s6 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s7 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s7 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              if (s7 !== peg$FAILED) {
                s6 = [s6, s7];
                s5 = s6;
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
          }
          s32 = input.substring(s32, peg$currPos);
          s42 = peg$parseclose_paren();
          if (s42 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f12(s1, s32);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsesquare_brace_group() {
        var s0, s1, s22, s32, s42, s5, s6;
        s0 = peg$currPos;
        s1 = peg$parseopen_square_brace();
        if (s1 !== peg$FAILED) {
          s22 = peg$currPos;
          s32 = [];
          s42 = peg$currPos;
          s5 = peg$currPos;
          peg$silentFails++;
          s6 = peg$parseclose_square_brace();
          peg$silentFails--;
          if (s6 === peg$FAILED) {
            s5 = void 0;
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
          if (s5 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s6 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            if (s6 !== peg$FAILED) {
              s5 = [s5, s6];
              s42 = s5;
            } else {
              peg$currPos = s42;
              s42 = peg$FAILED;
            }
          } else {
            peg$currPos = s42;
            s42 = peg$FAILED;
          }
          while (s42 !== peg$FAILED) {
            s32.push(s42);
            s42 = peg$currPos;
            s5 = peg$currPos;
            peg$silentFails++;
            s6 = peg$parseclose_square_brace();
            peg$silentFails--;
            if (s6 === peg$FAILED) {
              s5 = void 0;
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
            if (s5 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s6 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              if (s6 !== peg$FAILED) {
                s5 = [s5, s6];
                s42 = s5;
              } else {
                peg$currPos = s42;
                s42 = peg$FAILED;
              }
            } else {
              peg$currPos = s42;
              s42 = peg$FAILED;
            }
          }
          s22 = input.substring(s22, peg$currPos);
          s32 = peg$parseclose_square_brace();
          if (s32 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f13(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsedotdot() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parsedot();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsedot();
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseunknown() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f14(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parsesame_line_comment() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f15(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f16(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e1);
          }
        }
        return s0;
      }
      function peg$parseown_line_comment() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f17(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f18(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        return s0;
      }
      function peg$parsecomment() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f19(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f20(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        return s0;
      }
      function peg$parse_() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f21(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f22(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parse_comment_() {
        var s0, s1, s22, s32, s42;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parse_();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parse_();
        }
        s22 = peg$parsecomment();
        if (s22 === peg$FAILED) {
          s22 = null;
        }
        s32 = [];
        s42 = peg$parse_();
        while (s42 !== peg$FAILED) {
          s32.push(s42);
          s42 = peg$parse_();
        }
        peg$savedPos = s0;
        s0 = peg$f23(s22);
        peg$silentFails--;
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e4);
        }
        return s0;
      }
      function peg$parseoperation() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f24(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f25(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e5);
          }
        }
        return s0;
      }
      function peg$parseequals() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f26(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f27(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e6);
          }
        }
        return s0;
      }
      function peg$parseopen_square_brace() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f28(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f29(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseclose_square_brace() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f30(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f31(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseopen_paren() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f32(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f33(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseclose_paren() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f34(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f35(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseplus() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f36(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f37(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseminus() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f38(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f39(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsepipe() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f40(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f41(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsedot() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f42(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f43(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecontrols_keyword() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f44(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f45(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseand_keyword() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f46(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f47(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsesvg_keyword() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f48(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f49(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsegroup() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f50(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f51(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsemacro() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f52(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f53(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseforeach_keyword() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f54(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f55(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseforeach_macro() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f56(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f57(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsein_keyword() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f58(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f59(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecolon() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f60(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f61(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseEOL() {
        var s0, s1;
        s0 = peg$currPos;
        peg$silentFails++;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        peg$silentFails--;
        if (s1 === peg$FAILED) {
          s0 = void 0;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      if (!options.isWhitespace) {
        try {
          Object.assign(options, {
            isChar: (node, char) => node.type === "string" && node.content === char,
            isOperation: (node) => node.type === "string" && node.content.match(/[a-zA-Z]/),
            isWhitespace: (node) => node.type === "whitespace" || node.type === "parbreak",
            isSameLineComment: (node) => node.type === "comment" && node.sameline,
            isOwnLineComment: (node) => node.type === "comment" && !node.sameline,
            isComment: (node) => node.type === "comment",
            isGroup: (node) => node.type === "group",
            isMacro: (node, name) => node.type === "macro" && node.content === name,
            isAnyMacro: (node) => node.type === "macro"
          });
        } catch (e) {
          console.warn("Error when initializing parser", e);
        }
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(
          peg$maxFailExpected,
          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
      }
    }
    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }()
);
var ArgSpecPegParser2 = xparse_argspec_default3;
var parseCache2 = {};
function parse3(str = "") {
  parseCache2[str] = parseCache2[str] || ArgSpecPegParser2.parse(str);
  return parseCache2[str];
}
var __create3 = Object.create;
var __defProp3 = Object.defineProperty;
var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames3 = Object.getOwnPropertyNames;
var __getProtoOf3 = Object.getPrototypeOf;
var __hasOwnProp3 = Object.prototype.hasOwnProperty;
var __commonJS3 = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames3(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps3 = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames3(from))
      if (!__hasOwnProp3.call(to, key) && key !== except)
        __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc3(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM3 = (mod, isNodeMode, target) => (target = mod != null ? __create3(__getProtoOf3(mod)) : {}, __copyProps3(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp3(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var require_config2 = __commonJS3({
  "../../node_modules/trie-prefix-tree/dist/config.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = {
      END_WORD: "$",
      END_WORD_REPLACER: "9a219a89-91cd-42e2-abd5-eb113af08ca8",
      PERMS_MIN_LEN: 2
    };
    module2.exports = exports["default"];
  }
});
var require_append2 = __commonJS3({
  "../../node_modules/trie-prefix-tree/dist/append.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = append;
    var _config = require_config2();
    var _config2 = _interopRequireDefault(_config);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function append(trie, letter, index2, array) {
      var isEndWordLetter = letter === _config2.default.END_WORD;
      var isLastLetter = index2 === array.length - 1;
      if (isEndWordLetter && !isLastLetter) {
        trie[_config2.default.END_WORD] = 1;
        trie[_config2.default.END_WORD_REPLACER] = {};
        trie = trie[_config2.default.END_WORD_REPLACER];
      } else {
        trie[letter] = trie[letter] || {};
        trie = trie[letter];
      }
      if (isLastLetter) {
        trie[_config2.default.END_WORD] = 1;
      }
      return trie;
    }
    module2.exports = exports["default"];
  }
});
var require_create2 = __commonJS3({
  "../../node_modules/trie-prefix-tree/dist/create.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
      return typeof obj;
    } : function(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    exports.default = create;
    var _append = require_append2();
    var _append2 = _interopRequireDefault(_append);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function create(input) {
      if (!Array.isArray(input)) {
        throw "Expected parameter Array, received " + (typeof input === "undefined" ? "undefined" : _typeof(input));
      }
      var trie = input.reduce(function(accumulator, item) {
        item.toLowerCase().split("").reduce(_append2.default, accumulator);
        return accumulator;
      }, {});
      return trie;
    }
    module2.exports = exports["default"];
  }
});
var require_utils2 = __commonJS3({
  "../../node_modules/trie-prefix-tree/dist/utils.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = {
      objectCopy: function objectCopy(obj) {
        if (typeof obj === "undefined") {
          return {};
        }
        return JSON.parse(JSON.stringify(obj));
      },
      stringify: function stringify(obj) {
        var spacer = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2;
        if (typeof obj === "undefined") {
          return "";
        }
        return JSON.stringify(obj, null, spacer);
      }
    };
    module2.exports = exports["default"];
  }
});
var require_checkPrefix2 = __commonJS3({
  "../../node_modules/trie-prefix-tree/dist/checkPrefix.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = checkPrefix;
    var _utils = require_utils2();
    var _utils2 = _interopRequireDefault(_utils);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function checkPrefix(prefixNode, prefix) {
      var input = prefix.toLowerCase().split("");
      var prefixFound = input.every(function(letter, index2) {
        if (!prefixNode[letter]) {
          return false;
        }
        return prefixNode = prefixNode[letter];
      });
      return {
        prefixFound,
        prefixNode
      };
    }
    module2.exports = exports["default"];
  }
});
var require_recursePrefix2 = __commonJS3({
  "../../node_modules/trie-prefix-tree/dist/recursePrefix.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = recursePrefix;
    var _config = require_config2();
    var _config2 = _interopRequireDefault(_config);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var pushInOrder = function pushInOrder2(word, prefixes) {
      var i = 0;
      while (i < prefixes.length) {
        if (word < prefixes[i]) {
          break;
        }
        i += 1;
      }
      prefixes.splice(i, 0, word);
      return prefixes;
    };
    function recursePrefix(node, prefix, sorted) {
      var prefixes = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [];
      var word = prefix;
      for (var branch in node) {
        var currentLetter = branch;
        if (branch === _config2.default.END_WORD && typeof node[branch] === "number") {
          if (sorted) {
            pushInOrder(word, prefixes);
          } else {
            prefixes.push(word);
          }
          word = "";
        } else if (branch === _config2.default.END_WORD_REPLACER) {
          currentLetter = _config2.default.END_WORD;
        }
        recursePrefix(node[branch], prefix + currentLetter, sorted, prefixes);
      }
      return prefixes;
    }
    module2.exports = exports["default"];
  }
});
var require_recurseRandomWord2 = __commonJS3({
  "../../node_modules/trie-prefix-tree/dist/recurseRandomWord.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = recurseRandomWord;
    var _config = require_config2();
    var _config2 = _interopRequireDefault(_config);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function recurseRandomWord(node, prefix) {
      var word = prefix;
      var branches = Object.keys(node);
      var branch = branches[Math.floor(Math.random() * branches.length)];
      if (branch === _config2.default.END_WORD) {
        return word;
      }
      return recurseRandomWord(node[branch], prefix + branch);
    }
    module2.exports = exports["default"];
  }
});
var require_permutations2 = __commonJS3({
  "../../node_modules/trie-prefix-tree/dist/permutations.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
      return typeof obj;
    } : function(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    exports.default = permutations;
    var _config = require_config2();
    var _config2 = _interopRequireDefault(_config);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function permutations(letters, trie) {
      var opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
        type: "anagram"
      };
      if (typeof letters !== "string") {
        throw "Permutations expects string letters, received " + (typeof letters === "undefined" ? "undefined" : _typeof(letters));
      }
      var words = [];
      var permute = function permute2(word, node) {
        var prefix = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
        var wordIsEmpty = word.length === 0;
        var wordFound = words.indexOf(prefix) !== -1;
        var endWordFound = node[_config2.default.END_WORD] === 1;
        if (wordIsEmpty && endWordFound && !wordFound) {
          words.push(prefix);
        }
        for (var i = 0, len = word.length; i < len; i++) {
          var letter = word[i];
          if (opts.type === "sub-anagram") {
            if (endWordFound && !(words.indexOf(prefix) !== -1)) {
              words.push(prefix);
            }
          }
          if (node[letter]) {
            var remaining = word.substring(0, i) + word.substring(i + 1, len);
            permute2(remaining, node[letter], prefix + letter, words);
          }
        }
        return words.sort();
      };
      return permute(letters, trie);
    }
    module2.exports = exports["default"];
  }
});
var require_dist2 = __commonJS3({
  "../../node_modules/trie-prefix-tree/dist/index.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
      return typeof obj;
    } : function(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    exports.default = function(input) {
      if (!Array.isArray(input)) {
        throw "Expected parameter Array, received " + (typeof input === "undefined" ? "undefined" : _typeof(input));
      }
      var trie = (0, _create2.default)([].concat(_toConsumableArray(input)));
      return {
        /**
         * Get the generated raw trie object
        */
        tree: function tree() {
          return trie;
        },
        /**
         * Get a string representation of the trie
        */
        dump: function dump() {
          var spacer = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
          return _utils2.default.stringify(trie, spacer);
        },
        /**
         * Add a new word to the trie
         */
        addWord: function addWord(word) {
          if (typeof word !== "string" || word === "") {
            throw "Expected parameter string, received " + (typeof word === "undefined" ? "undefined" : _typeof(word));
          }
          var reducer = function reducer2() {
            return _append2.default.apply(void 0, arguments);
          };
          var input2 = word.toLowerCase().split("");
          input2.reduce(reducer, trie);
          return this;
        },
        /**
         * Remove an existing word from the trie
         */
        removeWord: function removeWord(word) {
          if (typeof word !== "string" || word === "") {
            throw "Expected parameter string, received " + (typeof word === "undefined" ? "undefined" : _typeof(word));
          }
          var _checkPrefix = (0, _checkPrefix6.default)(trie, word), prefixFound = _checkPrefix.prefixFound, prefixNode = _checkPrefix.prefixNode;
          if (prefixFound) {
            delete prefixNode[_config2.default.END_WORD];
          }
          return this;
        },
        /**
         * Check a prefix is valid
         * @returns Boolean
        */
        isPrefix: function isPrefix(prefix) {
          if (typeof prefix !== "string") {
            throw "Expected string prefix, received " + (typeof prefix === "undefined" ? "undefined" : _typeof(prefix));
          }
          var _checkPrefix2 = (0, _checkPrefix6.default)(trie, prefix), prefixFound = _checkPrefix2.prefixFound;
          return prefixFound;
        },
        /**
        * Get a list of all words in the trie with the given prefix
        * @returns Array
        */
        getPrefix: function getPrefix(strPrefix) {
          var sorted = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
          if (typeof strPrefix !== "string") {
            throw "Expected string prefix, received " + (typeof strPrefix === "undefined" ? "undefined" : _typeof(strPrefix));
          }
          if (typeof sorted !== "boolean") {
            throw "Expected sort parameter as boolean, received " + (typeof sorted === "undefined" ? "undefined" : _typeof(sorted));
          }
          if (!this.isPrefix(strPrefix)) {
            return [];
          }
          var prefixNode = strPrefix.length ? (0, _checkPrefix6.default)(trie, strPrefix).prefixNode : trie;
          return (0, _recursePrefix2.default)(prefixNode, strPrefix, sorted);
        },
        /**
        * Get a random word in the trie with the given prefix
        * @returns Array
        */
        getRandomWordWithPrefix: function getRandomWordWithPrefix(strPrefix) {
          if (typeof strPrefix !== "string") {
            throw "Expected string prefix, received " + (typeof strPrefix === "undefined" ? "undefined" : _typeof(strPrefix));
          }
          if (!this.isPrefix(strPrefix)) {
            return "";
          }
          var _checkPrefix3 = (0, _checkPrefix6.default)(trie, strPrefix), prefixNode = _checkPrefix3.prefixNode;
          return (0, _recurseRandomWord2.default)(prefixNode, strPrefix);
        },
        /**
        * Count the number of words with the given prefixSearch
        * @returns Number
        */
        countPrefix: function countPrefix(strPrefix) {
          var prefixes = this.getPrefix(strPrefix);
          return prefixes.length;
        },
        /**
        * Get all words in the trie
        * @returns Array
        */
        getWords: function getWords() {
          var sorted = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
          return this.getPrefix("", sorted);
        },
        /**
        * Check the existence of a word in the trie
        * @returns Boolean
        */
        hasWord: function hasWord(word) {
          if (typeof word !== "string") {
            throw "Expected string word, received " + (typeof word === "undefined" ? "undefined" : _typeof(word));
          }
          var _checkPrefix4 = (0, _checkPrefix6.default)(trie, word), prefixFound = _checkPrefix4.prefixFound, prefixNode = _checkPrefix4.prefixNode;
          if (prefixFound) {
            return prefixNode[_config2.default.END_WORD] === 1;
          }
          return false;
        },
        /**
        * Get a list of valid anagrams that can be made from the given letters
        * @returns Array
        */
        getAnagrams: function getAnagrams(letters) {
          if (typeof letters !== "string") {
            throw "Anagrams expected string letters, received " + (typeof letters === "undefined" ? "undefined" : _typeof(letters));
          }
          if (letters.length < PERMS_MIN_LEN) {
            throw "getAnagrams expects at least " + PERMS_MIN_LEN + " letters";
          }
          return (0, _permutations2.default)(letters, trie, {
            type: "anagram"
          });
        },
        /**
        * Get a list of all sub-anagrams that can be made from the given letters
        * @returns Array
        */
        getSubAnagrams: function getSubAnagrams(letters) {
          if (typeof letters !== "string") {
            throw "Expected string letters, received " + (typeof letters === "undefined" ? "undefined" : _typeof(letters));
          }
          if (letters.length < PERMS_MIN_LEN) {
            throw "getSubAnagrams expects at least " + PERMS_MIN_LEN + " letters";
          }
          return (0, _permutations2.default)(letters, trie, {
            type: "sub-anagram"
          });
        }
      };
    };
    var _create = require_create2();
    var _create2 = _interopRequireDefault(_create);
    var _append = require_append2();
    var _append2 = _interopRequireDefault(_append);
    var _checkPrefix5 = require_checkPrefix2();
    var _checkPrefix6 = _interopRequireDefault(_checkPrefix5);
    var _recursePrefix = require_recursePrefix2();
    var _recursePrefix2 = _interopRequireDefault(_recursePrefix);
    var _recurseRandomWord = require_recurseRandomWord2();
    var _recurseRandomWord2 = _interopRequireDefault(_recurseRandomWord);
    var _utils = require_utils2();
    var _utils2 = _interopRequireDefault(_utils);
    var _config = require_config2();
    var _config2 = _interopRequireDefault(_config);
    var _permutations = require_permutations2();
    var _permutations2 = _interopRequireDefault(_permutations);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _toConsumableArray(arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
          arr2[i] = arr[i];
        }
        return arr2;
      } else {
        return Array.from(arr);
      }
    }
    var PERMS_MIN_LEN = _config2.default.PERMS_MIN_LEN;
    module2.exports = exports["default"];
  }
});
var linebreak13 = Symbol("linebreak");
var ESCAPE12 = "\\";
function _printRaw12(node) {
  if (typeof node === "string") {
    return [node];
  }
  if (Array.isArray(node)) {
    return [].concat(
      ...node.map((n) => _printRaw12(n))
    );
  }
  let argsString, escape;
  switch (node.type) {
    case "root":
      return _printRaw12(node.content);
    case "argument":
      return [node.openMark, ..._printRaw12(node.content), node.closeMark];
    case "comment":
      var suffix = node.suffixParbreak ? "" : linebreak13;
      var leadingWhitespace = "";
      if (node.sameline && node.leadingWhitespace) {
        leadingWhitespace = " ";
      }
      if (node.sameline) {
        return [
          leadingWhitespace,
          "%",
          ..._printRaw12(node.content),
          suffix
        ];
      }
      return [linebreak13, "%", ..._printRaw12(node.content), suffix];
    case "environment":
    case "mathenv":
    case "verbatim":
      var env = _printRaw12(node.env);
      var envStart = [ESCAPE12 + "begin{", ...env, "}"];
      var envEnd = [ESCAPE12 + "end{", ...env, "}"];
      argsString = node.args == null ? [] : _printRaw12(node.args);
      return [
        ...envStart,
        ...argsString,
        ..._printRaw12(node.content),
        ...envEnd
      ];
    case "displaymath":
      return [ESCAPE12 + "[", ..._printRaw12(node.content), ESCAPE12 + "]"];
    case "group":
      return ["{", ..._printRaw12(node.content), "}"];
    case "inlinemath":
      return ["$", ..._printRaw12(node.content), "$"];
    case "macro":
      argsString = node.args == null ? [] : _printRaw12(node.args);
      escape = node.escapeToken == null ? ESCAPE12 : node.escapeToken;
      return [escape, ..._printRaw12(node.content), ...argsString];
    case "parbreak":
      return [linebreak13, linebreak13];
    case "string":
      return [node.content];
    case "verb":
      return [
        ESCAPE12,
        node.env,
        node.escape,
        ..._printRaw12(node.content),
        node.escape
      ];
    case "whitespace":
      return [" "];
    default:
      console.warn(
        "Cannot find render for node ",
        node,
        `(of type ${typeof node})`
      );
      return ["" + node];
  }
}
function printRaw13(node, options) {
  const asArray = options != null ? options.asArray : false;
  const printedTokens = _printRaw12(node);
  if (asArray) {
    return printedTokens;
  }
  return printedTokens.map((x) => x === linebreak13 ? "\n" : x).join("");
}
function createMacroMatcher12(macros15) {
  const macrosHash = Array.isArray(macros15) ? macros15.length > 0 ? typeof macros15[0] === "string" ? Object.fromEntries(
    macros15.map((macro262) => {
      if (typeof macro262 !== "string") {
        throw new Error("Wrong branch of map function");
      }
      return [macro262, {}];
    })
  ) : Object.fromEntries(
    macros15.map((macro262) => {
      if (typeof macro262 === "string") {
        throw new Error("Wrong branch of map function");
      }
      if (macro262.escapeToken != null) {
        return [
          macro262.content,
          { escapeToken: macro262.escapeToken }
        ];
      }
      return [macro262.content, {}];
    })
  ) : {} : macros15;
  return function matchAgainstMacros(node) {
    if (node == null || node.type !== "macro") {
      return false;
    }
    const spec = macrosHash[node.content];
    if (!spec) {
      return false;
    }
    if (typeof spec === "object" && "escapeToken" in spec) {
      return spec.escapeToken == null || spec.escapeToken === node.escapeToken;
    }
    return true;
  };
}
function createEnvironmentMatcher12(macros15) {
  const environmentsHash = Array.isArray(macros15) ? Object.fromEntries(
    macros15.map((str) => {
      return [str, {}];
    })
  ) : macros15;
  return function matchAgainstEnvironments(node) {
    if (!match12.anyEnvironment(node)) {
      return false;
    }
    const envName = printRaw13(node.env);
    const spec = environmentsHash[envName];
    if (!spec) {
      return false;
    }
    return true;
  };
}
var match12 = {
  macro(node, macroName) {
    if (node == null) {
      return false;
    }
    return node.type === "macro" && (macroName == null || node.content === macroName);
  },
  anyMacro(node) {
    return match12.macro(node);
  },
  environment(node, envName) {
    if (node == null) {
      return false;
    }
    return (node.type === "environment" || node.type === "mathenv") && (envName == null || printRaw13(node.env) === envName);
  },
  anyEnvironment(node) {
    return match12.environment(node);
  },
  comment(node) {
    if (node == null) {
      return false;
    }
    return node.type === "comment";
  },
  parbreak(node) {
    if (node == null) {
      return false;
    }
    return node.type === "parbreak";
  },
  whitespace(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace";
  },
  /**
   * Matches whitespace or a comment with leading whitespace.
   */
  whitespaceLike(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace" || node.type === "whitespace" && node.leadingWhitespace === true;
  },
  string(node, value) {
    if (node == null) {
      return false;
    }
    return node.type === "string" && (value == null || node.content === value);
  },
  anyString(node) {
    return match12.string(node);
  },
  group(node) {
    if (node == null) {
      return false;
    }
    return node.type === "group";
  },
  argument(node) {
    if (node == null) {
      return false;
    }
    return node.type === "argument";
  },
  blankArgument(node) {
    if (!match12.argument(node)) {
      return false;
    }
    return node.openMark === "" && node.closeMark === "" && node.content.length === 0;
  },
  math(node) {
    if (node == null) {
      return false;
    }
    return node.type === "displaymath" || node.type === "inlinemath";
  },
  createMacroMatcher: createMacroMatcher12,
  createEnvironmentMatcher: createEnvironmentMatcher12
};
var {
  anyEnvironment: anyEnvironment12,
  anyMacro: anyMacro12,
  anyString: anyString12,
  argument: argument12,
  blankArgument: blankArgument12,
  comment: comment12,
  environment: environment12,
  group: group12,
  macro: macro12,
  math: math12,
  parbreak: parbreak12,
  string: string12,
  whitespace: whitespace12
} = match12;
var linebreak26 = Symbol("linebreak");
var ESCAPE26 = "\\";
function _printRaw26(node) {
  if (typeof node === "string") {
    return [node];
  }
  if (Array.isArray(node)) {
    return [].concat(
      ...node.map((n) => _printRaw26(n))
    );
  }
  let argsString, escape;
  switch (node.type) {
    case "root":
      return _printRaw26(node.content);
    case "argument":
      return [node.openMark, ..._printRaw26(node.content), node.closeMark];
    case "comment":
      var suffix = node.suffixParbreak ? "" : linebreak26;
      var leadingWhitespace = "";
      if (node.sameline && node.leadingWhitespace) {
        leadingWhitespace = " ";
      }
      if (node.sameline) {
        return [
          leadingWhitespace,
          "%",
          ..._printRaw26(node.content),
          suffix
        ];
      }
      return [linebreak26, "%", ..._printRaw26(node.content), suffix];
    case "environment":
    case "mathenv":
    case "verbatim":
      var env = _printRaw26(node.env);
      var envStart = [ESCAPE26 + "begin{", ...env, "}"];
      var envEnd = [ESCAPE26 + "end{", ...env, "}"];
      argsString = node.args == null ? [] : _printRaw26(node.args);
      return [
        ...envStart,
        ...argsString,
        ..._printRaw26(node.content),
        ...envEnd
      ];
    case "displaymath":
      return [ESCAPE26 + "[", ..._printRaw26(node.content), ESCAPE26 + "]"];
    case "group":
      return ["{", ..._printRaw26(node.content), "}"];
    case "inlinemath":
      return ["$", ..._printRaw26(node.content), "$"];
    case "macro":
      argsString = node.args == null ? [] : _printRaw26(node.args);
      escape = node.escapeToken == null ? ESCAPE26 : node.escapeToken;
      return [escape, ..._printRaw26(node.content), ...argsString];
    case "parbreak":
      return [linebreak26, linebreak26];
    case "string":
      return [node.content];
    case "verb":
      return [
        ESCAPE26,
        node.env,
        node.escape,
        ..._printRaw26(node.content),
        node.escape
      ];
    case "whitespace":
      return [" "];
    default:
      console.warn(
        "Cannot find render for node ",
        node,
        `(of type ${typeof node})`
      );
      return ["" + node];
  }
}
function printRaw26(node, options) {
  const asArray = options != null ? options.asArray : false;
  const printedTokens = _printRaw26(node);
  if (asArray) {
    return printedTokens;
  }
  return printedTokens.map((x) => x === linebreak26 ? "\n" : x).join("");
}
function scan2(nodes, token, options) {
  const { startIndex, onlySkipWhitespaceAndComments, allowSubstringMatches } = options || {};
  if (typeof token === "string") {
    token = { type: "string", content: token };
  }
  for (let i = startIndex || 0; i < nodes.length; i++) {
    const node = nodes[i];
    if (node.type === token.type) {
      switch (node.type) {
        case "comment":
        case "displaymath":
        case "inlinemath":
        case "root":
        case "parbreak":
        case "whitespace":
        case "verb":
        case "verbatim":
        case "group":
          return i;
        case "macro":
          if (node.content === token.content) {
            return i;
          }
          break;
        case "environment":
        case "mathenv":
          if (printRaw26(node.env) === printRaw26(token.env)) {
            return i;
          }
          break;
        case "string":
          if (node.content === token.content) {
            return i;
          }
          if (allowSubstringMatches && node.content.indexOf(token.content) >= 0) {
            return i;
          }
          break;
      }
    }
    if (onlySkipWhitespaceAndComments && !match12.whitespace(node) && !match12.comment(node)) {
      return null;
    }
  }
  return null;
}
var import_trie_prefix_tree2 = __toESM3(require_dist2(), 1);
var export_Trie2 = import_trie_prefix_tree2.default;
var OPTIONAL_ARGUMENT_ARG_SPEC = parse3("o")[0];
function blankArg() {
  return arg([], { openMark: "", closeMark: "" });
}
var tikzCommandArgumentParser = (nodes, startPos) => {
  const origStartPos = startPos;
  let pos = startPos;
  let nodesRemoved = 0;
  const cursorPosAfterAnimations = eatAllAnimationSpecs(nodes, pos);
  let animationArg = blankArg();
  if (cursorPosAfterAnimations !== pos) {
    const argContent = nodes.splice(pos, cursorPosAfterAnimations - pos);
    trim(argContent);
    animationArg = arg(argContent, {
      openMark: " ",
      closeMark: " "
    });
  }
  nodesRemoved += cursorPosAfterAnimations - pos;
  const {
    argument: _optionalArgument,
    nodesRemoved: optionalArgumentNodesRemoved
  } = gobbleSingleArgument(nodes, OPTIONAL_ARGUMENT_ARG_SPEC, pos);
  nodesRemoved += optionalArgumentNodesRemoved;
  const optionalArg = _optionalArgument || blankArg();
  while (match.whitespace(nodes[pos])) {
    pos++;
  }
  const firstNode = nodes[pos];
  if (!firstNode) {
    return {
      args: [animationArg, optionalArg, blankArg()],
      nodesRemoved: 0
    };
  }
  if (match.group(firstNode)) {
    const args = [animationArg, optionalArg, arg(firstNode.content)];
    nodes.splice(origStartPos, pos - origStartPos + 1);
    return { args, nodesRemoved: pos - origStartPos + 1 + nodesRemoved };
  }
  const semicolonPosition = scan2(nodes, ";", { startIndex: pos });
  if (semicolonPosition != null) {
    const argNodes = nodes.splice(
      origStartPos,
      semicolonPosition - origStartPos + 1
    );
    trim(argNodes);
    const args = [animationArg, optionalArg, arg(argNodes)];
    return {
      args,
      nodesRemoved: origStartPos - semicolonPosition + 1 + nodesRemoved
    };
  }
  return {
    args: [animationArg, optionalArg, blankArg()],
    nodesRemoved: 0
  };
};
function eatAllAnimationSpecs(nodes, startPos) {
  const colonPos = scan2(nodes, ":", {
    startIndex: startPos,
    allowSubstringMatches: true,
    onlySkipWhitespaceAndComments: true
  });
  if (!colonPos) {
    return startPos;
  }
  let lastMatchPos = startPos;
  let i = colonPos + 1;
  for (; i < nodes.length; i++) {
    const node = nodes[i];
    if (match.string(node, "[")) {
      break;
    }
    if (match.string(node, "=")) {
      i++;
      while (match.whitespace(nodes[i]) || match.comment(nodes[i])) {
        i++;
      }
      if (!match.group(nodes[i])) {
        break;
      }
      lastMatchPos = i + 1;
      const colonPos2 = scan2(nodes, ":", {
        startIndex: lastMatchPos,
        allowSubstringMatches: true,
        onlySkipWhitespaceAndComments: true
      });
      if (colonPos2 == null) {
        break;
      }
      i = colonPos2 + 1;
    }
  }
  return lastMatchPos;
}
var macros10 = {
  pgfkeys: {
    signature: "m",
    renderInfo: { breakAround: true, pgfkeysArgs: true }
  },
  tikzoption: {
    signature: "m",
    renderInfo: { breakAround: true, pgfkeysArgs: true }
  },
  tikzstyle: {
    signature: "m",
    renderInfo: { breakAround: true, pgfkeysArgs: true }
  },
  usetikzlibrary: {
    signature: "m",
    renderInfo: { breakAround: true, pgfkeysArgs: true }
  },
  usepgfmodule: { signature: "m", renderInfo: { pgfkeysArgs: true } },
  usepgflibrary: { signature: "m", renderInfo: { pgfkeysArgs: true } },
  pgfplotsset: {
    signature: "m",
    renderInfo: { breakAround: true, pgfkeysArgs: true }
  },
  pgfplotstabletypeset: {
    signature: "o m",
    renderInfo: { breakAround: true, pgfkeysArgs: true }
  },
  tikz: {
    signature: "o o m",
    argumentParser: tikzCommandArgumentParser,
    renderInfo: { namedArguments: ["animation", "options", "command"] }
  }
};
var environments10 = {
  tikzpicture: {
    signature: "o",
    renderInfo: { pgfkeysArgs: true, tikzEnvironment: true },
    processContent: processTikzEnvironmentContent
  },
  axis: {
    signature: "o",
    renderInfo: { pgfkeysArgs: true, tikzEnvironment: true },
    processContent: processTikzEnvironmentContent
  },
  scope: {
    signature: "o",
    renderInfo: { pgfkeysArgs: true, tikzEnvironment: true },
    processContent: processTikzEnvironmentContent
  },
  pgfonlayer: {
    signature: "m",
    renderInfo: { tikzEnvironment: true },
    processContent: processTikzEnvironmentContent
  },
  pgflowlevelscope: {
    signature: "m",
    renderInfo: { tikzEnvironment: true },
    processContent: processTikzEnvironmentContent
  },
  pgfviewboxscope: {
    signature: "m m m m m",
    renderInfo: { tikzEnvironment: true },
    processContent: processTikzEnvironmentContent
  },
  pgftransparencygroup: {
    signature: "o",
    renderInfo: { pgfkeysArgs: true, tikzEnvironment: true },
    processContent: processTikzEnvironmentContent
  },
  behindforegroundpath: {
    signature: "m",
    processContent: processTikzEnvironmentContent
  },
  pgfmetadecoration: {
    signature: "m",
    processContent: processTikzEnvironmentContent
  },
  colormixin: { signature: "m", renderInfo: { pgfkeysArgs: true } }
};
function processTikzEnvironmentContent(nodes) {
  attachMacroArgsInArray(nodes, conditionalMacros);
  return nodes;
}
var conditionalMacros = {
  pgfextra: { signature: "m" },
  beginpgfgraphicnamed: { signature: "m" },
  pgfrealjobname: { signature: "m" },
  pgfplotstreampoint: { signature: "m" },
  pgfplotstreampointoutlier: { signature: "m" },
  pgfplotstreamspecial: { signature: "m" },
  pgfplotxyfile: { signature: "m" },
  pgfplotxyzfile: { signature: "m" },
  pgfplotfunction: { signature: "mmm" },
  pgfplotgnuplot: { signature: "o m" },
  pgfplothandlerrecord: { signature: "m" },
  pgfdeclareplothandler: { signature: "m m m" },
  pgfdeclarelayer: { signature: "m" },
  pgfsetlayers: { signature: "m", renderInfo: { pgfkeysArgs: true } },
  pgfonlayer: { signature: "m" },
  startpgfonlayer: { signature: "m" },
  pgfdeclarehorizontalshading: { signature: "o m m m " },
  pgfdeclareradialshading: { signature: "o m m m" },
  pgfdeclarefunctionalshading: { signature: "o m m m m m" },
  pgfshadecolortorgb: { signature: "m m" },
  pgfshadecolortocmyk: { signature: "m m" },
  pgfshadecolortogray: { signature: "m m" },
  pgfuseshading: { signature: "m" },
  pgfshadepath: { signature: "m m" },
  pgfsetadditionalshadetransform: { signature: "m" },
  pgfsetstrokeopacity: { signature: "m" },
  pgfsetfillopacity: { signature: "m" },
  pgfsetblendmode: { signature: "m" },
  pgfdeclarefading: { signature: "m m" },
  pgfsetfading: { signature: "m m" },
  pgfsetfadingforcurrentpath: { signature: "m m" },
  pgfsetfadingforcurrentpathstroked: { signature: "m m" },
  pgfanimateattribute: { signature: "m m" },
  pgfsnapshot: { signature: "m" },
  pgfqpoint: { signature: "m m" },
  pgfqpointxy: { signature: "m m" },
  pgfqpointxyz: { signature: "m m m" },
  pgfqpointscale: { signature: "m m" },
  pgfpathqmoveto: { signature: "m m" },
  pgfpathqlineto: { signature: "m m" },
  pgfpathqcurveto: { signature: "m m m m m m" },
  pgfpathqcircle: { signature: "m" },
  pgfqbox: { signature: "m" },
  pgfqboxsynced: { signature: "m" },
  pgfaliasimage: { signature: "m m" },
  pgfuseimage: { signature: "m" },
  pgfimage: { signature: "o m", renderInfo: { pgfkeysArgs: true } },
  pgfdeclaremask: { signature: "o m m", renderInfo: { pgfkeysArgs: true } },
  pgfdeclarepatternformonly: { signature: "o m m m m m" },
  pgfdeclarepatterninherentlycolored: { signature: "o m m m m m" },
  pgfsetfillpattern: { signature: "m m" },
  // Coordinate canvas and nonlinear transformations
  pgftransformshift: { signature: "m" },
  pgftransformxshift: { signature: "m" },
  pgftransformyshift: { signature: "m" },
  pgftransformscale: { signature: "m" },
  pgftransformxscale: { signature: "m" },
  pgftransformyscale: { signature: "m" },
  pgftransformxslant: { signature: "m" },
  pgftransformyslant: { signature: "m" },
  pgftransformrotate: { signature: "m" },
  pgftransformtriangle: { signature: "m m m" },
  pgftransformcm: { signature: "m m m m m" },
  pgftransformarrow: { signature: "m m" },
  pgftransformlineattime: { signature: "m m m" },
  pgftransformcurveattime: { signature: "m m m m m" },
  pgftransformarcaxesattime: { signature: "m m m m m m" },
  pgfgettransform: { signature: "m" },
  pgfsettransform: { signature: "m" },
  pgfgettransformentries: { signature: "m m m m m m" },
  pgfsettransformentries: { signature: "m m m m m m" },
  pgfpointtransformed: { signature: "m" },
  pgflowlevel: { signature: "m" },
  pgflowlevelobj: { signature: "m m" },
  pgflowlevelscope: { signature: "m" },
  startpgflowlevelscope: { signature: "m" },
  pgfviewboxscope: { signature: "m m m m m" },
  startpgfviewboxscope: { signature: "m m m m m" },
  pgftransformnonlinear: { signature: "m" },
  pgfpointtransformednonlinear: { signature: "m" },
  pgfsetcurvilinearbeziercurve: { signature: "m m m m" },
  pgfcurvilineardistancetotime: { signature: "m" },
  pgfpointcurvilinearbezierorthogonal: { signature: "m m" },
  pgfpointcurvilinearbezierpolar: { signature: "m m" },
  // Matrices
  pgfmatrix: { signature: "m m m m m m m" },
  pgfsetmatrixcolumnsep: { signature: "m" },
  pgfmatrixnextcell: { signature: "o" },
  pgfsetmatrixrowsep: { signature: "m" },
  pgfmatrixendrow: { signature: "o" },
  // Nodes and shapes
  pgfnode: { signature: "m m m m m" },
  pgfmultipartnode: { signature: "m m m m" },
  pgfcoordinate: { signature: "m m" },
  pgfnodealias: { signature: "m m" },
  pgfnoderename: { signature: "m m" },
  pgfpositionnodelater: { signature: "m" },
  pgfpositionnodenow: { signature: "m" },
  pgfnodepostsetupcode: { signature: "m m" },
  pgfpointanchor: { signature: "m m" },
  pgfpointshapeborder: { signature: "m m" },
  pgfdeclareshape: { signature: "m m" },
  saveddimen: { signature: "m m" },
  savedmacro: { signature: " m" },
  anchor: { signature: "m m" },
  deferredanchor: { signature: "m m" },
  anchorborder: { signature: "m" },
  backgroundpath: { signature: "m" },
  foregroundpath: { signature: "m" },
  behindbackgroundpath: { signature: "m" },
  beforebackgroundpath: { signature: "m" },
  beforeforegroundpath: { signature: "m" },
  behindforegroundpath: { signature: "m" },
  // Arrows
  pgfdeclarearrow: { signature: "m" },
  pgfarrowssettipend: { signature: "m" },
  pgfarrowssetbackend: { signature: "m" },
  pgfarrowssetlineend: { signature: "m" },
  pgfarrowssetvisualbackend: { signature: "m" },
  pgfarrowssetvisualtipend: { signature: "m" },
  pgfarrowshullpoint: { signature: "m m" },
  pgfarrowsupperhullpoint: { signature: "m m" },
  pgfarrowssave: { signature: "m" },
  pgfarrowssavethe: { signature: "m" },
  pgfarrowsaddtooptions: { signature: "m" },
  pgfarrowsaddtolateoptions: { signature: "m" },
  pgfarrowsaddtolengthscalelist: { signature: "m" },
  pgfarrowsaddtowidthscalelist: { signature: "m" },
  pgfarrowsthreeparameters: { signature: "m" },
  pgfarrowslinewidthdependent: { signature: "m m m" },
  pgfarrowslengthdependent: { signature: "m" },
  // Path
  pgfusepath: { signature: "m" },
  pgfsetlinewidth: { signature: "m" },
  pgfsetmiterlimit: { signature: "m" },
  pgfsetdash: { signature: "m m" },
  pgfsetstrokecolor: { signature: "m" },
  pgfsetcolor: { signature: "m" },
  pgfsetinnerlinewidth: { signature: "m" },
  pgfsetinnerstrokecolor: { signature: "m" },
  pgfsetarrowsstart: { signature: "m" },
  pgfsetarrowsend: { signature: "m" },
  pgfsetarrows: { signature: "m" },
  pgfsetshortenstart: { signature: "m" },
  pgfsetshortenend: { signature: "m" },
  pgfsetfillcolor: { signature: "m" },
  // Decorations
  pgfdeclaredecoration: { signature: "m m m" },
  state: { signature: "m o m" },
  pgfdecoratepath: { signature: "m m" },
  startpgfdecoration: { signature: "m" },
  pgfdecoration: { signature: "m" },
  pgfdecoratecurrentpath: { signature: "m" },
  pgfsetdecorationsegmenttransformation: { signature: "m" },
  pgfdeclaremetadecorate: { signature: "m m m" },
  pgfmetadecoration: { signature: "m" },
  startpgfmetadecoration: { signature: "m" },
  // Constructing paths
  pgfpathmoveto: { signature: "m" },
  pgfpathlineto: { signature: "m" },
  pgfpathcurveto: { signature: "m m m" },
  pgfpathquadraticcurveto: { signature: "m m" },
  pgfpathcurvebetweentime: { signature: "m m m m m m" },
  pgfpathcurvebetweentimecontinue: { signature: "m m m m m m" },
  pgfpatharc: { signature: "m m m" },
  pgfpatharcaxes: { signature: "m m m m" },
  pgfpatharcto: { signature: "m m m m m m" },
  pgfpatharctoprecomputed: { signature: "m m m m m m m m" },
  pgfpathellipse: { signature: "m m m" },
  pgfpathcircle: { signature: "m m" },
  pgfpathrectangle: { signature: "m m" },
  pgfpathrectanglecorners: { signature: "m m" },
  pgfpathgrid: { signature: " o m m" },
  pgfpathparabola: { signature: "m m" },
  pgfpathsine: { signature: "m" },
  pgfpathcosine: { signature: "m" },
  pgfsetcornersarced: { signature: "m" },
  "pgf@protocolsizes": { signature: "m m" },
  // Specifying coordinates
  pgfpoint: { signature: "m m" },
  pgfpointpolar: { signature: "m m m" },
  pgfpointxy: { signature: "m m" },
  pgfsetxvec: { signature: "m" },
  pgfsetyvec: { signature: "m" },
  pgfpointpolarxy: { signature: "m m" },
  pgfpointxyz: { signature: "m m m" },
  pgfsetzvec: { signature: "m" },
  pgfpointcylindrical: { signature: "m m m" },
  pgfpointspherical: { signature: "m m m" },
  pgfpointadd: { signature: "m m" },
  pgfpointscale: { signature: "m m" },
  pgfpointdiff: { signature: "m m" },
  pgfpointnormalised: { signature: "m" },
  pgfpointlineattime: { signature: "m m m" },
  pgfpointlineatdistance: { signature: "m m m" },
  pgfpointarcaxesattime: { signature: "m m m m m m" },
  pgfpointcurveattime: { signature: "m m m m m" },
  pgfpointborderrectangle: { signature: "m m" },
  pgfpointborderellipse: { signature: "m m" },
  pgfpointintersectionoflines: { signature: "m m m m" },
  pgfpointintersectionofcircles: { signature: "m m m m m" },
  pgfintersectionofpaths: { signature: "m m" },
  pgfpointintersectionsolution: { signature: "m" },
  pgfextractx: { signature: "m m" },
  pgfextracty: { signature: "m m" },
  pgfgetlastxy: { signature: "m m" },
  "pgf@process": { signature: "m" },
  // Heirarchical structres ...
  pgfsetbaseline: { signature: "m" },
  pgfsetbaselinepointnow: { signature: "m" },
  pgfsetbaselinepointlater: { signature: "m" },
  pgftext: { signature: "o m", renderInfo: { pgfkeysArgs: true } },
  pgfuseid: { signature: "m" },
  pgfusetype: { signature: "m" },
  pgfidrefnextuse: { signature: "m m" },
  pgfidrefprevuse: { signature: "m m" },
  pgfaliasid: { signature: "m m" },
  pgfgaliasid: { signature: "m m" },
  pgfifidreferenced: { signature: "m m m" },
  pgfrdfabout: { signature: "m" },
  pgfrdfcontent: { signature: "m" },
  pgfrdfdatatype: { signature: "m" },
  pgfrdfhref: { signature: "m" },
  pgfrdfprefix: { signature: "m" },
  pgfrdfproperty: { signature: "m" },
  pgfrdfrel: { signature: "m" },
  pgfrdfresource: { signature: "m" },
  pgfrdfrev: { signature: "m" },
  pgfrdfsrc: { signature: "m" },
  pgfrdftypeof: { signature: "m" },
  pgfrdfvocab: { signature: "m" },
  pgferror: { signature: "m" },
  pgfwarning: { signature: "m" },
  path: {
    signature: "u;",
    renderInfo: { breakAround: true, tikzPathCommand: true }
  },
  draw: {
    signature: "u;",
    renderInfo: { breakAround: true, tikzPathCommand: true }
  },
  fill: {
    signature: "u;",
    renderInfo: { breakAround: true, tikzPathCommand: true }
  },
  filldraw: {
    signature: "u;",
    renderInfo: { breakAround: true, tikzPathCommand: true }
  },
  pattern: {
    signature: "u;",
    renderInfo: { breakAround: true, tikzPathCommand: true }
  },
  shade: {
    signature: "u;",
    renderInfo: { breakAround: true, tikzPathCommand: true }
  },
  clip: {
    signature: "u;",
    renderInfo: { breakAround: true, tikzPathCommand: true }
  },
  useasboundingbox: {
    signature: "u;",
    renderInfo: { breakAround: true, tikzPathCommand: true }
  },
  node: {
    signature: "u;",
    renderInfo: { breakAround: true, tikzPathCommand: true }
  },
  coordinate: {
    signature: "u;",
    renderInfo: { breakAround: true, tikzPathCommand: true }
  },
  graph: {
    signature: "u;",
    renderInfo: { breakAround: true, tikzPathCommand: true }
  },
  scoped: {
    signature: "o o m",
    argumentParser: tikzCommandArgumentParser,
    renderInfo: {
      namedArguments: ["animation", "options", "command"],
      breakAround: true
    }
  }
};
function createMatchers2() {
  return {
    isChar: match.string,
    isTerminal: (node) => match.string(node, ";"),
    isOperation: (node) => match.anyString(node) && node.content.match(/[a-zA-Z]/),
    isWhitespace: (node) => match.whitespace(node) || match.parbreak(node),
    isComment: match.comment,
    isGroup: match.group,
    isMacro: match.macro,
    isAnyMacro: match.anyMacro
  };
}
var matchers = createMatchers2();
var macros11 = {
  substitutecolormodel: {
    signature: "m m",
    renderInfo: { breakAround: true }
  },
  selectcolormodel: {
    signature: "m",
    renderInfo: { breakAround: true }
  },
  definecolor: {
    signature: "o m m m",
    renderInfo: { breakAround: true }
  },
  providecolor: {
    signature: "o m m m",
    renderInfo: { breakAround: true }
  },
  colorlet: {
    signature: "o m o m",
    renderInfo: { breakAround: true }
  },
  definecolorset: {
    signature: "o m m m",
    renderInfo: { breakAround: true }
  },
  providecolorset: {
    signature: "o m m m m",
    renderInfo: { breakAround: true }
  },
  preparecolor: {
    signature: "o m m m",
    renderInfo: { breakAround: true }
  },
  preparecolorset: {
    signature: "o m m m m",
    renderInfo: { breakAround: true }
  },
  DefineNamedColor: {
    signature: "m m m m",
    renderInfo: { breakAround: true }
  },
  definecolors: {
    signature: "m",
    renderInfo: { breakAround: true }
  },
  providecolors: {
    signature: "m",
    renderInfo: { breakAround: true }
  },
  color: { signature: "o m", renderInfo: { breakAround: true } },
  textcolor: { signature: "o m m", renderInfo: { inParMode: true } },
  pagecolor: { signature: "o m" },
  colorbox: { signature: "o m m" },
  fcolorbox: { signature: "o m o m m" },
  boxframe: { signature: "o m" },
  testcolor: { signature: "o m" },
  blendcolors: { signature: "s m" },
  maskcolors: { signature: "o m" },
  definecolorseries: {
    signature: "m m m o m o m",
    renderInfo: { breakAround: true }
  },
  resetcolorseries: {
    signature: "o m",
    renderInfo: { breakAround: true }
  },
  rowcolors: { signature: "s o m m m" },
  extractcolorspec: { signature: "m m" },
  extractcolorspecs: { signature: "m m m" },
  convertcolorspec: { signature: "m m m m" }
};
var environments11 = {
  testcolors: { signature: "o", renderInfo: { pgfkeysArgs: true } }
};
var import_color2 = __toESM2(require_color(), 1);
var import_color = __toESM2(require_color(), 1);
var fromRgb = ([r, g, b]) => (0, import_color.default)([r * 255, g * 255, b * 255], "rgb");
var DVI_PS_NAMES = {
  Apricot: (0, import_color.default)("#FBB982"),
  Aquamarine: (0, import_color.default)("#00B5BE"),
  Bittersweet: (0, import_color.default)("#C04F17"),
  Black: (0, import_color.default)("#221E1F"),
  Blue: (0, import_color.default)("#2D2F92"),
  BlueGreen: (0, import_color.default)("#00B3B8"),
  BlueViolet: (0, import_color.default)("#473992"),
  BrickRed: (0, import_color.default)("#B6321C"),
  Brown: (0, import_color.default)("#792500"),
  BurntOrange: (0, import_color.default)("#F7921D"),
  CadetBlue: (0, import_color.default)("#74729A"),
  CarnationPink: (0, import_color.default)("#F282B4"),
  Cerulean: (0, import_color.default)("#00A2E3"),
  CornflowerBlue: (0, import_color.default)("#41B0E4"),
  Cyan: (0, import_color.default)("#00AEEF"),
  Dandelion: (0, import_color.default)("#FDBC42"),
  DarkOrchid: (0, import_color.default)("#A4538A"),
  Emerald: (0, import_color.default)("#00A99D"),
  ForestGreen: (0, import_color.default)("#009B55"),
  Fuchsia: (0, import_color.default)("#8C368C"),
  Goldenrod: (0, import_color.default)("#FFDF42"),
  Gray: (0, import_color.default)("#949698"),
  Green: (0, import_color.default)("#00A64F"),
  GreenYellow: (0, import_color.default)("#DFE674"),
  JungleGreen: (0, import_color.default)("#00A99A"),
  Lavender: (0, import_color.default)("#F49EC4"),
  LimeGreen: (0, import_color.default)("#8DC73E"),
  Magenta: (0, import_color.default)("#EC008C"),
  Mahogany: (0, import_color.default)("#A9341F"),
  Maroon: (0, import_color.default)("#AF3235"),
  Melon: (0, import_color.default)("#F89E7B"),
  MidnightBlue: (0, import_color.default)("#006795"),
  Mulberry: (0, import_color.default)("#A93C93"),
  NavyBlue: (0, import_color.default)("#006EB8"),
  OliveGreen: (0, import_color.default)("#3C8031"),
  Orange: (0, import_color.default)("#F58137"),
  OrangeRed: (0, import_color.default)("#ED135A"),
  Orchid: (0, import_color.default)("#AF72B0"),
  Peach: (0, import_color.default)("#F7965A"),
  Periwinkle: (0, import_color.default)("#7977B8"),
  PineGreen: (0, import_color.default)("#008B72"),
  Plum: (0, import_color.default)("#92268F"),
  ProcessBlue: (0, import_color.default)("#00B0F0"),
  Purple: (0, import_color.default)("#99479B"),
  RawSienna: (0, import_color.default)("#974006"),
  Red: (0, import_color.default)("#ED1B23"),
  RedOrange: (0, import_color.default)("#F26035"),
  RedViolet: (0, import_color.default)("#A1246B"),
  Rhodamine: (0, import_color.default)("#EF559F"),
  RoyalBlue: (0, import_color.default)("#0071BC"),
  RoyalPurple: (0, import_color.default)("#613F99"),
  RubineRed: (0, import_color.default)("#ED017D"),
  Salmon: (0, import_color.default)("#F69289"),
  SeaGreen: (0, import_color.default)("#3FBC9D"),
  Sepia: (0, import_color.default)("#671800"),
  SkyBlue: (0, import_color.default)("#46C5DD"),
  SpringGreen: (0, import_color.default)("#C6DC67"),
  Tan: (0, import_color.default)("#DA9D76"),
  TealBlue: (0, import_color.default)("#00AEB3"),
  Thistle: (0, import_color.default)("#D883B7"),
  Turquoise: (0, import_color.default)("#00B4CE"),
  Violet: (0, import_color.default)("#58429B"),
  VioletRed: (0, import_color.default)("#EF58A0"),
  White: (0, import_color.default)("#FFFFFF"),
  WildStrawberry: (0, import_color.default)("#EE2967"),
  Yellow: (0, import_color.default)("#FFF200"),
  YellowGreen: (0, import_color.default)("#98CC70"),
  YellowOrange: (0, import_color.default)("#FAA21A")
};
var SVG_NAMES = {
  AliceBlue: fromRgb([0.94, 0.972, 1]),
  AntiqueWhite: fromRgb([0.98, 0.92, 0.844]),
  Aqua: fromRgb([0, 1, 1]),
  Aquamarine: fromRgb([0.498, 1, 0.83]),
  Azure: fromRgb([0.94, 1, 1]),
  Beige: fromRgb([0.96, 0.96, 0.864]),
  Bisque: fromRgb([1, 0.894, 0.77]),
  Black: fromRgb([0, 0, 0]),
  BlanchedAlmond: fromRgb([1, 0.92, 0.804]),
  Blue: fromRgb([0, 0, 1]),
  BlueViolet: fromRgb([0.54, 0.17, 0.888]),
  Brown: fromRgb([0.648, 0.165, 0.165]),
  BurlyWood: fromRgb([0.87, 0.72, 0.53]),
  CadetBlue: fromRgb([0.372, 0.62, 0.628]),
  Chartreuse: fromRgb([0.498, 1, 0]),
  Chocolate: fromRgb([0.824, 0.41, 0.116]),
  Coral: fromRgb([1, 0.498, 0.312]),
  CornflowerBlue: fromRgb([0.392, 0.585, 0.93]),
  Cornsilk: fromRgb([1, 0.972, 0.864]),
  Crimson: fromRgb([0.864, 0.08, 0.235]),
  Cyan: fromRgb([0, 1, 1]),
  DarkBlue: fromRgb([0, 0, 0.545]),
  DarkCyan: fromRgb([0, 0.545, 0.545]),
  DarkGoldenrod: fromRgb([0.72, 0.525, 0.044]),
  DarkGray: fromRgb([0.664, 0.664, 0.664]),
  DarkGreen: fromRgb([0, 0.392, 0]),
  DarkGrey: fromRgb([0.664, 0.664, 0.664]),
  DarkKhaki: fromRgb([0.74, 0.716, 0.42]),
  DarkMagenta: fromRgb([0.545, 0, 0.545]),
  DarkOliveGreen: fromRgb([0.332, 0.42, 0.185]),
  DarkOrange: fromRgb([1, 0.55, 0]),
  DarkOrchid: fromRgb([0.6, 0.196, 0.8]),
  DarkRed: fromRgb([0.545, 0, 0]),
  DarkSalmon: fromRgb([0.912, 0.59, 0.48]),
  DarkSeaGreen: fromRgb([0.56, 0.736, 0.56]),
  DarkSlateBlue: fromRgb([0.284, 0.24, 0.545]),
  DarkSlateGray: fromRgb([0.185, 0.31, 0.31]),
  DarkSlateGrey: fromRgb([0.185, 0.31, 0.31]),
  DarkTurquoise: fromRgb([0, 0.808, 0.82]),
  DarkViolet: fromRgb([0.58, 0, 0.828]),
  DeepPink: fromRgb([1, 0.08, 0.576]),
  DeepSkyBlue: fromRgb([0, 0.75, 1]),
  DimGray: fromRgb([0.41, 0.41, 0.41]),
  DimGrey: fromRgb([0.41, 0.41, 0.41]),
  DodgerBlue: fromRgb([0.116, 0.565, 1]),
  FireBrick: fromRgb([0.698, 0.132, 0.132]),
  FloralWhite: fromRgb([1, 0.98, 0.94]),
  ForestGreen: fromRgb([0.132, 0.545, 0.132]),
  Fuchsia: fromRgb([1, 0, 1]),
  Gainsboro: fromRgb([0.864, 0.864, 0.864]),
  GhostWhite: fromRgb([0.972, 0.972, 1]),
  Gold: fromRgb([1, 0.844, 0]),
  Goldenrod: fromRgb([0.855, 0.648, 0.125]),
  Gray: fromRgb([0.5, 0.5, 0.5]),
  Green: fromRgb([0, 0.5, 0]),
  GreenYellow: fromRgb([0.68, 1, 0.185]),
  Grey: fromRgb([0.5, 0.5, 0.5]),
  Honeydew: fromRgb([0.94, 1, 0.94]),
  HotPink: fromRgb([1, 0.41, 0.705]),
  IndianRed: fromRgb([0.804, 0.36, 0.36]),
  Indigo: fromRgb([0.294, 0, 0.51]),
  Ivory: fromRgb([1, 1, 0.94]),
  Khaki: fromRgb([0.94, 0.9, 0.55]),
  Lavender: fromRgb([0.9, 0.9, 0.98]),
  LavenderBlush: fromRgb([1, 0.94, 0.96]),
  LawnGreen: fromRgb([0.488, 0.99, 0]),
  LemonChiffon: fromRgb([1, 0.98, 0.804]),
  LightBlue: fromRgb([0.68, 0.848, 0.9]),
  LightCoral: fromRgb([0.94, 0.5, 0.5]),
  LightCyan: fromRgb([0.88, 1, 1]),
  LightGoldenrod: fromRgb([0.933, 0.867, 0.51]),
  LightGoldenrodYellow: fromRgb([0.98, 0.98, 0.824]),
  LightGray: fromRgb([0.828, 0.828, 0.828]),
  LightGreen: fromRgb([0.565, 0.932, 0.565]),
  LightGrey: fromRgb([0.828, 0.828, 0.828]),
  LightPink: fromRgb([1, 0.712, 0.756]),
  LightSalmon: fromRgb([1, 0.628, 0.48]),
  LightSeaGreen: fromRgb([0.125, 0.698, 0.668]),
  LightSkyBlue: fromRgb([0.53, 0.808, 0.98]),
  LightSlateBlue: fromRgb([0.518, 0.44, 1]),
  LightSlateGray: fromRgb([0.468, 0.532, 0.6]),
  LightSlateGrey: fromRgb([0.468, 0.532, 0.6]),
  LightSteelBlue: fromRgb([0.69, 0.77, 0.87]),
  LightYellow: fromRgb([1, 1, 0.88]),
  Lime: fromRgb([0, 1, 0]),
  LimeGreen: fromRgb([0.196, 0.804, 0.196]),
  Linen: fromRgb([0.98, 0.94, 0.9]),
  Magenta: fromRgb([1, 0, 1]),
  Maroon: fromRgb([0.5, 0, 0]),
  MediumAquamarine: fromRgb([0.4, 0.804, 0.668]),
  MediumBlue: fromRgb([0, 0, 0.804]),
  MediumOrchid: fromRgb([0.73, 0.332, 0.828]),
  MediumPurple: fromRgb([0.576, 0.44, 0.86]),
  MediumSeaGreen: fromRgb([0.235, 0.7, 0.444]),
  MediumSlateBlue: fromRgb([0.484, 0.408, 0.932]),
  MediumSpringGreen: fromRgb([0, 0.98, 0.604]),
  MediumTurquoise: fromRgb([0.284, 0.82, 0.8]),
  MediumVioletRed: fromRgb([0.78, 0.084, 0.52]),
  MidnightBlue: fromRgb([0.098, 0.098, 0.44]),
  MintCream: fromRgb([0.96, 1, 0.98]),
  MistyRose: fromRgb([1, 0.894, 0.884]),
  Moccasin: fromRgb([1, 0.894, 0.71]),
  NavajoWhite: fromRgb([1, 0.87, 0.68]),
  Navy: fromRgb([0, 0, 0.5]),
  NavyBlue: fromRgb([0, 0, 0.5]),
  OldLace: fromRgb([0.992, 0.96, 0.9]),
  Olive: fromRgb([0.5, 0.5, 0]),
  OliveDrab: fromRgb([0.42, 0.556, 0.136]),
  Orange: fromRgb([1, 0.648, 0]),
  OrangeRed: fromRgb([1, 0.27, 0]),
  Orchid: fromRgb([0.855, 0.44, 0.84]),
  PaleGoldenrod: fromRgb([0.932, 0.91, 0.668]),
  PaleGreen: fromRgb([0.596, 0.985, 0.596]),
  PaleTurquoise: fromRgb([0.688, 0.932, 0.932]),
  PaleVioletRed: fromRgb([0.86, 0.44, 0.576]),
  PapayaWhip: fromRgb([1, 0.936, 0.835]),
  PeachPuff: fromRgb([1, 0.855, 0.725]),
  Peru: fromRgb([0.804, 0.52, 0.248]),
  Pink: fromRgb([1, 0.752, 0.796]),
  Plum: fromRgb([0.868, 0.628, 0.868]),
  PowderBlue: fromRgb([0.69, 0.88, 0.9]),
  Purple: fromRgb([0.5, 0, 0.5]),
  Red: fromRgb([1, 0, 0]),
  RosyBrown: fromRgb([0.736, 0.56, 0.56]),
  RoyalBlue: fromRgb([0.255, 0.41, 0.884]),
  SaddleBrown: fromRgb([0.545, 0.27, 0.075]),
  Salmon: fromRgb([0.98, 0.5, 0.448]),
  SandyBrown: fromRgb([0.956, 0.644, 0.376]),
  SeaGreen: fromRgb([0.18, 0.545, 0.34]),
  Seashell: fromRgb([1, 0.96, 0.932]),
  Sienna: fromRgb([0.628, 0.32, 0.176]),
  Silver: fromRgb([0.752, 0.752, 0.752]),
  SkyBlue: fromRgb([0.53, 0.808, 0.92]),
  SlateBlue: fromRgb([0.415, 0.352, 0.804]),
  SlateGray: fromRgb([0.44, 0.5, 0.565]),
  SlateGrey: fromRgb([0.44, 0.5, 0.565]),
  Snow: fromRgb([1, 0.98, 0.98]),
  SpringGreen: fromRgb([0, 1, 0.498]),
  SteelBlue: fromRgb([0.275, 0.51, 0.705]),
  Tan: fromRgb([0.824, 0.705, 0.55]),
  Teal: fromRgb([0, 0.5, 0.5]),
  Thistle: fromRgb([0.848, 0.75, 0.848]),
  Tomato: fromRgb([1, 0.39, 0.28]),
  Turquoise: fromRgb([0.25, 0.88, 0.815]),
  Violet: fromRgb([0.932, 0.51, 0.932]),
  VioletRed: fromRgb([0.816, 0.125, 0.565]),
  Wheat: fromRgb([0.96, 0.87, 0.7]),
  White: fromRgb([1, 1, 1]),
  WhiteSmoke: fromRgb([0.96, 0.96, 0.96]),
  Yellow: fromRgb([1, 1, 0]),
  YellowGreen: fromRgb([0.604, 0.804, 0.196])
};
var X11_NAMES = {
  AntiqueWhite1: fromRgb([1, 0.936, 0.86]),
  AntiqueWhite2: fromRgb([0.932, 0.875, 0.8]),
  AntiqueWhite3: fromRgb([0.804, 0.752, 0.69]),
  AntiqueWhite4: fromRgb([0.545, 0.512, 0.47]),
  Aquamarine1: fromRgb([0.498, 1, 0.83]),
  Aquamarine2: fromRgb([0.464, 0.932, 0.776]),
  Aquamarine3: fromRgb([0.4, 0.804, 0.668]),
  Aquamarine4: fromRgb([0.27, 0.545, 0.455]),
  Azure1: fromRgb([0.94, 1, 1]),
  Azure2: fromRgb([0.88, 0.932, 0.932]),
  Azure3: fromRgb([0.756, 0.804, 0.804]),
  Azure4: fromRgb([0.512, 0.545, 0.545]),
  Bisque1: fromRgb([1, 0.894, 0.77]),
  Bisque2: fromRgb([0.932, 0.835, 0.716]),
  Bisque3: fromRgb([0.804, 0.716, 0.62]),
  Bisque4: fromRgb([0.545, 0.49, 0.42]),
  Blue1: fromRgb([0, 0, 1]),
  Blue2: fromRgb([0, 0, 0.932]),
  Blue3: fromRgb([0, 0, 0.804]),
  Blue4: fromRgb([0, 0, 0.545]),
  Brown1: fromRgb([1, 0.25, 0.25]),
  Brown2: fromRgb([0.932, 0.23, 0.23]),
  Brown3: fromRgb([0.804, 0.2, 0.2]),
  Brown4: fromRgb([0.545, 0.136, 0.136]),
  Burlywood1: fromRgb([1, 0.828, 0.608]),
  Burlywood2: fromRgb([0.932, 0.772, 0.57]),
  Burlywood3: fromRgb([0.804, 0.668, 0.49]),
  Burlywood4: fromRgb([0.545, 0.45, 0.332]),
  CadetBlue1: fromRgb([0.596, 0.96, 1]),
  CadetBlue2: fromRgb([0.556, 0.898, 0.932]),
  CadetBlue3: fromRgb([0.48, 0.772, 0.804]),
  CadetBlue4: fromRgb([0.325, 0.525, 0.545]),
  Chartreuse1: fromRgb([0.498, 1, 0]),
  Chartreuse2: fromRgb([0.464, 0.932, 0]),
  Chartreuse3: fromRgb([0.4, 0.804, 0]),
  Chartreuse4: fromRgb([0.27, 0.545, 0]),
  Chocolate1: fromRgb([1, 0.498, 0.14]),
  Chocolate2: fromRgb([0.932, 0.464, 0.13]),
  Chocolate3: fromRgb([0.804, 0.4, 0.112]),
  Chocolate4: fromRgb([0.545, 0.27, 0.075]),
  Coral1: fromRgb([1, 0.448, 0.336]),
  Coral2: fromRgb([0.932, 0.415, 0.312]),
  Coral3: fromRgb([0.804, 0.356, 0.27]),
  Coral4: fromRgb([0.545, 0.244, 0.185]),
  Cornsilk1: fromRgb([1, 0.972, 0.864]),
  Cornsilk2: fromRgb([0.932, 0.91, 0.804]),
  Cornsilk3: fromRgb([0.804, 0.785, 0.694]),
  Cornsilk4: fromRgb([0.545, 0.532, 0.47]),
  Cyan1: fromRgb([0, 1, 1]),
  Cyan2: fromRgb([0, 0.932, 0.932]),
  Cyan3: fromRgb([0, 0.804, 0.804]),
  Cyan4: fromRgb([0, 0.545, 0.545]),
  DarkGoldenrod1: fromRgb([1, 0.725, 0.06]),
  DarkGoldenrod2: fromRgb([0.932, 0.68, 0.055]),
  DarkGoldenrod3: fromRgb([0.804, 0.585, 0.048]),
  DarkGoldenrod4: fromRgb([0.545, 0.396, 0.03]),
  DarkOliveGreen1: fromRgb([0.792, 1, 0.44]),
  DarkOliveGreen2: fromRgb([0.736, 0.932, 0.408]),
  DarkOliveGreen3: fromRgb([0.635, 0.804, 0.352]),
  DarkOliveGreen4: fromRgb([0.43, 0.545, 0.24]),
  DarkOrange1: fromRgb([1, 0.498, 0]),
  DarkOrange2: fromRgb([0.932, 0.464, 0]),
  DarkOrange3: fromRgb([0.804, 0.4, 0]),
  DarkOrange4: fromRgb([0.545, 0.27, 0]),
  DarkOrchid1: fromRgb([0.75, 0.244, 1]),
  DarkOrchid2: fromRgb([0.698, 0.228, 0.932]),
  DarkOrchid3: fromRgb([0.604, 0.196, 0.804]),
  DarkOrchid4: fromRgb([0.408, 0.132, 0.545]),
  DarkSeaGreen1: fromRgb([0.756, 1, 0.756]),
  DarkSeaGreen2: fromRgb([0.705, 0.932, 0.705]),
  DarkSeaGreen3: fromRgb([0.608, 0.804, 0.608]),
  DarkSeaGreen4: fromRgb([0.41, 0.545, 0.41]),
  DarkSlateGray1: fromRgb([0.592, 1, 1]),
  DarkSlateGray2: fromRgb([0.552, 0.932, 0.932]),
  DarkSlateGray3: fromRgb([0.475, 0.804, 0.804]),
  DarkSlateGray4: fromRgb([0.32, 0.545, 0.545]),
  DeepPink1: fromRgb([1, 0.08, 0.576]),
  DeepPink2: fromRgb([0.932, 0.07, 0.536]),
  DeepPink3: fromRgb([0.804, 0.064, 0.464]),
  DeepPink4: fromRgb([0.545, 0.04, 0.312]),
  DeepSkyBlue1: fromRgb([0, 0.75, 1]),
  DeepSkyBlue2: fromRgb([0, 0.698, 0.932]),
  DeepSkyBlue3: fromRgb([0, 0.604, 0.804]),
  DeepSkyBlue4: fromRgb([0, 0.408, 0.545]),
  DodgerBlue1: fromRgb([0.116, 0.565, 1]),
  DodgerBlue2: fromRgb([0.11, 0.525, 0.932]),
  DodgerBlue3: fromRgb([0.094, 0.455, 0.804]),
  DodgerBlue4: fromRgb([0.064, 0.305, 0.545]),
  Firebrick1: fromRgb([1, 0.19, 0.19]),
  Firebrick2: fromRgb([0.932, 0.172, 0.172]),
  Firebrick3: fromRgb([0.804, 0.15, 0.15]),
  Firebrick4: fromRgb([0.545, 0.1, 0.1]),
  Gold1: fromRgb([1, 0.844, 0]),
  Gold2: fromRgb([0.932, 0.79, 0]),
  Gold3: fromRgb([0.804, 0.68, 0]),
  Gold4: fromRgb([0.545, 0.46, 0]),
  Goldenrod1: fromRgb([1, 0.756, 0.145]),
  Goldenrod2: fromRgb([0.932, 0.705, 0.132]),
  Goldenrod3: fromRgb([0.804, 0.608, 0.112]),
  Goldenrod4: fromRgb([0.545, 0.41, 0.08]),
  Green1: fromRgb([0, 1, 0]),
  Green2: fromRgb([0, 0.932, 0]),
  Green3: fromRgb([0, 0.804, 0]),
  Green4: fromRgb([0, 0.545, 0]),
  Honeydew1: fromRgb([0.94, 1, 0.94]),
  Honeydew2: fromRgb([0.88, 0.932, 0.88]),
  Honeydew3: fromRgb([0.756, 0.804, 0.756]),
  Honeydew4: fromRgb([0.512, 0.545, 0.512]),
  HotPink1: fromRgb([1, 0.43, 0.705]),
  HotPink2: fromRgb([0.932, 0.415, 0.655]),
  HotPink3: fromRgb([0.804, 0.376, 0.565]),
  HotPink4: fromRgb([0.545, 0.228, 0.385]),
  IndianRed1: fromRgb([1, 0.415, 0.415]),
  IndianRed2: fromRgb([0.932, 0.39, 0.39]),
  IndianRed3: fromRgb([0.804, 0.332, 0.332]),
  IndianRed4: fromRgb([0.545, 0.228, 0.228]),
  Ivory1: fromRgb([1, 1, 0.94]),
  Ivory2: fromRgb([0.932, 0.932, 0.88]),
  Ivory3: fromRgb([0.804, 0.804, 0.756]),
  Ivory4: fromRgb([0.545, 0.545, 0.512]),
  Khaki1: fromRgb([1, 0.965, 0.56]),
  Khaki2: fromRgb([0.932, 0.9, 0.52]),
  Khaki3: fromRgb([0.804, 0.776, 0.45]),
  Khaki4: fromRgb([0.545, 0.525, 0.305]),
  LavenderBlush1: fromRgb([1, 0.94, 0.96]),
  LavenderBlush2: fromRgb([0.932, 0.88, 0.898]),
  LavenderBlush3: fromRgb([0.804, 0.756, 0.772]),
  LavenderBlush4: fromRgb([0.545, 0.512, 0.525]),
  LemonChiffon1: fromRgb([1, 0.98, 0.804]),
  LemonChiffon2: fromRgb([0.932, 0.912, 0.75]),
  LemonChiffon3: fromRgb([0.804, 0.79, 0.648]),
  LemonChiffon4: fromRgb([0.545, 0.536, 0.44]),
  LightBlue1: fromRgb([0.75, 0.936, 1]),
  LightBlue2: fromRgb([0.698, 0.875, 0.932]),
  LightBlue3: fromRgb([0.604, 0.752, 0.804]),
  LightBlue4: fromRgb([0.408, 0.512, 0.545]),
  LightCyan1: fromRgb([0.88, 1, 1]),
  LightCyan2: fromRgb([0.82, 0.932, 0.932]),
  LightCyan3: fromRgb([0.705, 0.804, 0.804]),
  LightCyan4: fromRgb([0.48, 0.545, 0.545]),
  LightGoldenrod1: fromRgb([1, 0.925, 0.545]),
  LightGoldenrod2: fromRgb([0.932, 0.864, 0.51]),
  LightGoldenrod3: fromRgb([0.804, 0.745, 0.44]),
  LightGoldenrod4: fromRgb([0.545, 0.505, 0.298]),
  LightPink1: fromRgb([1, 0.684, 0.725]),
  LightPink2: fromRgb([0.932, 0.635, 0.68]),
  LightPink3: fromRgb([0.804, 0.55, 0.585]),
  LightPink4: fromRgb([0.545, 0.372, 0.396]),
  LightSalmon1: fromRgb([1, 0.628, 0.48]),
  LightSalmon2: fromRgb([0.932, 0.585, 0.448]),
  LightSalmon3: fromRgb([0.804, 0.505, 0.385]),
  LightSalmon4: fromRgb([0.545, 0.34, 0.26]),
  LightSkyBlue1: fromRgb([0.69, 0.888, 1]),
  LightSkyBlue2: fromRgb([0.644, 0.828, 0.932]),
  LightSkyBlue3: fromRgb([0.552, 0.712, 0.804]),
  LightSkyBlue4: fromRgb([0.376, 0.484, 0.545]),
  LightSteelBlue1: fromRgb([0.792, 0.884, 1]),
  LightSteelBlue2: fromRgb([0.736, 0.824, 0.932]),
  LightSteelBlue3: fromRgb([0.635, 0.71, 0.804]),
  LightSteelBlue4: fromRgb([0.43, 0.484, 0.545]),
  LightYellow1: fromRgb([1, 1, 0.88]),
  LightYellow2: fromRgb([0.932, 0.932, 0.82]),
  LightYellow3: fromRgb([0.804, 0.804, 0.705]),
  LightYellow4: fromRgb([0.545, 0.545, 0.48]),
  Magenta1: fromRgb([1, 0, 1]),
  Magenta2: fromRgb([0.932, 0, 0.932]),
  Magenta3: fromRgb([0.804, 0, 0.804]),
  Magenta4: fromRgb([0.545, 0, 0.545]),
  Maroon1: fromRgb([1, 0.204, 0.7]),
  Maroon2: fromRgb([0.932, 0.19, 0.655]),
  Maroon3: fromRgb([0.804, 0.16, 0.565]),
  Maroon4: fromRgb([0.545, 0.11, 0.385]),
  MediumOrchid1: fromRgb([0.88, 0.4, 1]),
  MediumOrchid2: fromRgb([0.82, 0.372, 0.932]),
  MediumOrchid3: fromRgb([0.705, 0.32, 0.804]),
  MediumOrchid4: fromRgb([0.48, 0.215, 0.545]),
  MediumPurple1: fromRgb([0.67, 0.51, 1]),
  MediumPurple2: fromRgb([0.624, 0.475, 0.932]),
  MediumPurple3: fromRgb([0.536, 0.408, 0.804]),
  MediumPurple4: fromRgb([0.365, 0.28, 0.545]),
  MistyRose1: fromRgb([1, 0.894, 0.884]),
  MistyRose2: fromRgb([0.932, 0.835, 0.824]),
  MistyRose3: fromRgb([0.804, 0.716, 0.71]),
  MistyRose4: fromRgb([0.545, 0.49, 0.484]),
  NavajoWhite1: fromRgb([1, 0.87, 0.68]),
  NavajoWhite2: fromRgb([0.932, 0.81, 0.63]),
  NavajoWhite3: fromRgb([0.804, 0.7, 0.545]),
  NavajoWhite4: fromRgb([0.545, 0.475, 0.37]),
  OliveDrab1: fromRgb([0.752, 1, 0.244]),
  OliveDrab2: fromRgb([0.7, 0.932, 0.228]),
  OliveDrab3: fromRgb([0.604, 0.804, 0.196]),
  OliveDrab4: fromRgb([0.41, 0.545, 0.132]),
  Orange1: fromRgb([1, 0.648, 0]),
  Orange2: fromRgb([0.932, 0.604, 0]),
  Orange3: fromRgb([0.804, 0.52, 0]),
  Orange4: fromRgb([0.545, 0.352, 0]),
  OrangeRed1: fromRgb([1, 0.27, 0]),
  OrangeRed2: fromRgb([0.932, 0.25, 0]),
  OrangeRed3: fromRgb([0.804, 0.215, 0]),
  OrangeRed4: fromRgb([0.545, 0.145, 0]),
  Orchid1: fromRgb([1, 0.512, 0.98]),
  Orchid2: fromRgb([0.932, 0.48, 0.912]),
  Orchid3: fromRgb([0.804, 0.41, 0.79]),
  Orchid4: fromRgb([0.545, 0.28, 0.536]),
  PaleGreen1: fromRgb([0.604, 1, 0.604]),
  PaleGreen2: fromRgb([0.565, 0.932, 0.565]),
  PaleGreen3: fromRgb([0.488, 0.804, 0.488]),
  PaleGreen4: fromRgb([0.33, 0.545, 0.33]),
  PaleTurquoise1: fromRgb([0.732, 1, 1]),
  PaleTurquoise2: fromRgb([0.684, 0.932, 0.932]),
  PaleTurquoise3: fromRgb([0.59, 0.804, 0.804]),
  PaleTurquoise4: fromRgb([0.4, 0.545, 0.545]),
  PaleVioletRed1: fromRgb([1, 0.51, 0.67]),
  PaleVioletRed2: fromRgb([0.932, 0.475, 0.624]),
  PaleVioletRed3: fromRgb([0.804, 0.408, 0.536]),
  PaleVioletRed4: fromRgb([0.545, 0.28, 0.365]),
  PeachPuff1: fromRgb([1, 0.855, 0.725]),
  PeachPuff2: fromRgb([0.932, 0.796, 0.68]),
  PeachPuff3: fromRgb([0.804, 0.688, 0.585]),
  PeachPuff4: fromRgb([0.545, 0.468, 0.396]),
  Pink1: fromRgb([1, 0.71, 0.772]),
  Pink2: fromRgb([0.932, 0.664, 0.72]),
  Pink3: fromRgb([0.804, 0.57, 0.62]),
  Pink4: fromRgb([0.545, 0.39, 0.424]),
  Plum1: fromRgb([1, 0.732, 1]),
  Plum2: fromRgb([0.932, 0.684, 0.932]),
  Plum3: fromRgb([0.804, 0.59, 0.804]),
  Plum4: fromRgb([0.545, 0.4, 0.545]),
  Purple1: fromRgb([0.608, 0.19, 1]),
  Purple2: fromRgb([0.57, 0.172, 0.932]),
  Purple3: fromRgb([0.49, 0.15, 0.804]),
  Purple4: fromRgb([0.332, 0.1, 0.545]),
  Red1: fromRgb([1, 0, 0]),
  Red2: fromRgb([0.932, 0, 0]),
  Red3: fromRgb([0.804, 0, 0]),
  Red4: fromRgb([0.545, 0, 0]),
  RosyBrown1: fromRgb([1, 0.756, 0.756]),
  RosyBrown2: fromRgb([0.932, 0.705, 0.705]),
  RosyBrown3: fromRgb([0.804, 0.608, 0.608]),
  RosyBrown4: fromRgb([0.545, 0.41, 0.41]),
  RoyalBlue1: fromRgb([0.284, 0.464, 1]),
  RoyalBlue2: fromRgb([0.264, 0.43, 0.932]),
  RoyalBlue3: fromRgb([0.228, 0.372, 0.804]),
  RoyalBlue4: fromRgb([0.152, 0.25, 0.545]),
  Salmon1: fromRgb([1, 0.55, 0.41]),
  Salmon2: fromRgb([0.932, 0.51, 0.385]),
  Salmon3: fromRgb([0.804, 0.44, 0.33]),
  Salmon4: fromRgb([0.545, 0.298, 0.224]),
  SeaGreen1: fromRgb([0.33, 1, 0.624]),
  SeaGreen2: fromRgb([0.305, 0.932, 0.58]),
  SeaGreen3: fromRgb([0.264, 0.804, 0.5]),
  SeaGreen4: fromRgb([0.18, 0.545, 0.34]),
  Seashell1: fromRgb([1, 0.96, 0.932]),
  Seashell2: fromRgb([0.932, 0.898, 0.87]),
  Seashell3: fromRgb([0.804, 0.772, 0.75]),
  Seashell4: fromRgb([0.545, 0.525, 0.51]),
  Sienna1: fromRgb([1, 0.51, 0.28]),
  Sienna2: fromRgb([0.932, 0.475, 0.26]),
  Sienna3: fromRgb([0.804, 0.408, 0.224]),
  Sienna4: fromRgb([0.545, 0.28, 0.15]),
  SkyBlue1: fromRgb([0.53, 0.808, 1]),
  SkyBlue2: fromRgb([0.494, 0.752, 0.932]),
  SkyBlue3: fromRgb([0.424, 0.65, 0.804]),
  SkyBlue4: fromRgb([0.29, 0.44, 0.545]),
  SlateBlue1: fromRgb([0.512, 0.435, 1]),
  SlateBlue2: fromRgb([0.48, 0.404, 0.932]),
  SlateBlue3: fromRgb([0.41, 0.35, 0.804]),
  SlateBlue4: fromRgb([0.28, 0.235, 0.545]),
  SlateGray1: fromRgb([0.776, 0.888, 1]),
  SlateGray2: fromRgb([0.725, 0.828, 0.932]),
  SlateGray3: fromRgb([0.624, 0.712, 0.804]),
  SlateGray4: fromRgb([0.424, 0.484, 0.545]),
  Snow1: fromRgb([1, 0.98, 0.98]),
  Snow2: fromRgb([0.932, 0.912, 0.912]),
  Snow3: fromRgb([0.804, 0.79, 0.79]),
  Snow4: fromRgb([0.545, 0.536, 0.536]),
  SpringGreen1: fromRgb([0, 1, 0.498]),
  SpringGreen2: fromRgb([0, 0.932, 0.464]),
  SpringGreen3: fromRgb([0, 0.804, 0.4]),
  SpringGreen4: fromRgb([0, 0.545, 0.27]),
  SteelBlue1: fromRgb([0.39, 0.72, 1]),
  SteelBlue2: fromRgb([0.36, 0.675, 0.932]),
  SteelBlue3: fromRgb([0.31, 0.58, 0.804]),
  SteelBlue4: fromRgb([0.21, 0.392, 0.545]),
  Tan1: fromRgb([1, 0.648, 0.31]),
  Tan2: fromRgb([0.932, 0.604, 0.288]),
  Tan3: fromRgb([0.804, 0.52, 0.248]),
  Tan4: fromRgb([0.545, 0.352, 0.17]),
  Thistle1: fromRgb([1, 0.884, 1]),
  Thistle2: fromRgb([0.932, 0.824, 0.932]),
  Thistle3: fromRgb([0.804, 0.71, 0.804]),
  Thistle4: fromRgb([0.545, 0.484, 0.545]),
  Tomato1: fromRgb([1, 0.39, 0.28]),
  Tomato2: fromRgb([0.932, 0.36, 0.26]),
  Tomato3: fromRgb([0.804, 0.31, 0.224]),
  Tomato4: fromRgb([0.545, 0.21, 0.15]),
  Turquoise1: fromRgb([0, 0.96, 1]),
  Turquoise2: fromRgb([0, 0.898, 0.932]),
  Turquoise3: fromRgb([0, 0.772, 0.804]),
  Turquoise4: fromRgb([0, 0.525, 0.545]),
  VioletRed1: fromRgb([1, 0.244, 0.59]),
  VioletRed2: fromRgb([0.932, 0.228, 0.55]),
  VioletRed3: fromRgb([0.804, 0.196, 0.47]),
  VioletRed4: fromRgb([0.545, 0.132, 0.32]),
  Wheat1: fromRgb([1, 0.905, 0.73]),
  Wheat2: fromRgb([0.932, 0.848, 0.684]),
  Wheat3: fromRgb([0.804, 0.73, 0.59]),
  Wheat4: fromRgb([0.545, 0.494, 0.4]),
  Yellow1: fromRgb([1, 1, 0]),
  Yellow2: fromRgb([0.932, 0.932, 0]),
  Yellow3: fromRgb([0.804, 0.804, 0]),
  Yellow4: fromRgb([0.545, 0.545, 0]),
  Gray0: fromRgb([0.745, 0.745, 0.745]),
  Green0: fromRgb([0, 1, 0]),
  Grey0: fromRgb([0.745, 0.745, 0.745]),
  Maroon0: fromRgb([0.69, 0.19, 0.376]),
  Purple0: fromRgb([0.628, 0.125, 0.94])
};
var XColorCoreModelToColor = {
  rgb: ([r, g, b]) => (0, import_color2.default)([r * 255, g * 255, b * 255], "rgb"),
  cmy: ([c, m, y]) => XColorCoreModelToColor.rgb([1 - c, 1 - m, 1 - y]),
  cmyk: ([c, m, y, k]) => (0, import_color2.default)([c * 255, m * 255, y * 255, k * 100], "cmyk"),
  hsb: ([h, s32, b]) => (0, import_color2.default)([h * 360, s32 * 100, b * 100], "hsv"),
  gray: ([v]) => (0, import_color2.default)([v * 255, v * 255, v * 255], "rgb")
};
var XColorModelToColor = {
  wave: ([lambda]) => {
    const gamma = 0.8;
    let baseRgb = [0, 0, 0];
    if (380 <= lambda && lambda < 440) {
      baseRgb = [(440 - lambda) / (440 - 380), 0, 1];
    }
    if (440 <= lambda && lambda < 490) {
      baseRgb = [0, (lambda - 440) / (490 - 440), 1];
    }
    if (490 <= lambda && lambda < 510) {
      baseRgb = [0, 1, (510 - lambda) / (510 - 490)];
    }
    if (510 <= lambda && lambda < 580) {
      baseRgb = [(lambda - 510) / (580 - 510), 1, 0];
    }
    if (580 <= lambda && lambda < 6450) {
      baseRgb = [1, (645 - lambda) / (645 - 580), 0];
    }
    if (645 <= lambda && lambda <= 780) {
      baseRgb = [1, 0, 0];
    }
    let f = 1;
    if (380 <= lambda && 420 < lambda) {
      f = 0.3 + 0.7 * (lambda - 380) / (420 - 380);
    }
    if (700 < lambda && lambda <= 780) {
      f = 0.3 + 0.7 * (780 - lambda) / (780 - 700);
    }
    const rgb = [
      Math.pow(baseRgb[0] * f, gamma),
      Math.pow(baseRgb[1] * f, gamma),
      Math.pow(baseRgb[2] * f, gamma)
    ];
    return (0, import_color2.default)([rgb[0] * 255, rgb[1] * 255, rgb[2] * 255], "rgb");
  },
  Hsb: ([h, s32, b]) => XColorCoreModelToColor.hsb([h / 360, s32, b]),
  HSB: ([h, s32, b]) => XColorCoreModelToColor.hsb([h / 240, s32 / 240, b / 240]),
  HTML: ([v]) => v.startsWith("#") ? (0, import_color2.default)(v) : (0, import_color2.default)(`#${v}`),
  RGB: ([r, g, b]) => (0, import_color2.default)([r, g, b], "rgb"),
  Gray: ([v]) => XColorCoreModelToColor.gray([v / 15]),
  ...XColorCoreModelToColor
};
var PREDEFINED_XCOLOR_COLORS = {
  // Core colors
  red: XColorCoreModelToColor.rgb([1, 0, 0]),
  green: XColorCoreModelToColor.rgb([0, 1, 0]),
  blue: XColorCoreModelToColor.rgb([0, 0, 1]),
  brown: XColorCoreModelToColor.rgb([0.75, 0.5, 0.25]),
  lime: XColorCoreModelToColor.rgb([0.75, 1, 0]),
  orange: XColorCoreModelToColor.rgb([1, 0.5, 0]),
  pink: XColorCoreModelToColor.rgb([1, 0.75, 0.75]),
  purple: XColorCoreModelToColor.rgb([0.75, 0, 0.25]),
  teal: XColorCoreModelToColor.rgb([0, 0.5, 0.5]),
  violet: XColorCoreModelToColor.rgb([0.5, 0, 0.5]),
  cyan: XColorCoreModelToColor.rgb([0, 1, 1]),
  magenta: XColorCoreModelToColor.rgb([1, 0, 1]),
  yellow: XColorCoreModelToColor.rgb([1, 1, 0]),
  olive: XColorCoreModelToColor.rgb([0.5, 0.5, 0]),
  black: XColorCoreModelToColor.rgb([0, 0, 0]),
  darkgray: XColorCoreModelToColor.rgb([0.25, 0.25, 0.25]),
  gray: XColorCoreModelToColor.rgb([0.5, 0.5, 0.5]),
  lightgray: XColorCoreModelToColor.rgb([0.75, 0.75, 0.75]),
  white: XColorCoreModelToColor.rgb([1, 1, 1]),
  ...DVI_PS_NAMES,
  ...SVG_NAMES,
  ...X11_NAMES
};
var macros12 = {
  NewDocumentCommand: {
    signature: "m m m",
    renderInfo: { breakAround: true }
  },
  RenewDocumentCommand: {
    signature: "m m m",
    renderInfo: { breakAround: true }
  },
  ProvideDocumentCommand: {
    signature: "m m m",
    renderInfo: { breakAround: true }
  },
  DeclareDocumentCommand: {
    signature: "m m m",
    renderInfo: { breakAround: true }
  },
  NewDocumentEnvironment: {
    signature: "m m m m",
    renderInfo: { breakAround: true }
  },
  RenewDocumentEnvironment: {
    signature: "m m m m",
    renderInfo: { breakAround: true }
  },
  ProvideDocumentEnvironment: {
    signature: "m m m m",
    renderInfo: { breakAround: true }
  },
  DeclareDocumentEnvironment: {
    signature: "m m m m",
    renderInfo: { breakAround: true }
  },
  NewExpandableDocumentCommand: {
    signature: "m m m",
    renderInfo: { breakAround: true }
  },
  RenewExpandableDocumentCommand: {
    signature: "m m m",
    renderInfo: { breakAround: true }
  },
  ProvideExpandableDocumentCommand: {
    signature: "m m m",
    renderInfo: { breakAround: true }
  },
  DeclareExpandableDocumentCommand: {
    signature: "m m m",
    renderInfo: { breakAround: true }
  },
  RequirePackage: {
    signature: "o m",
    renderInfo: { pgfkeysArgs: true, breakAround: true }
  },
  DeclareOption: { signature: "m m", renderInfo: { breakAround: true } }
};
var environments12 = {};
var macros13 = {
  mode: { signature: "s d<> d{}", renderInfo: { breakAround: true } },
  insertnavigation: { signature: "m", renderInfo: { breakAround: true } },
  insertsectionnavigation: {
    signature: "m",
    renderInfo: { breakAround: true }
  },
  insertsectionnavigationhorizontal: {
    signature: "m m m",
    renderInfo: { breakAround: true }
  },
  insertauthor: { signature: "o", renderInfo: { breakAround: true } },
  insertshortauthor: { signature: "o", renderInfo: { breakAround: true } },
  insertshortdate: { signature: "o", renderInfo: { breakAround: true } },
  insertshortinstitute: { signature: "o", renderInfo: { breakAround: true } },
  insertshortpart: { signature: "o", renderInfo: { breakAround: true } },
  insertshorttitle: { signature: "o", renderInfo: { breakAround: true } },
  insertsubsectionnavigation: {
    signature: "m",
    renderInfo: { breakAround: true }
  },
  insertsubsectionnavigationhorizontal: {
    signature: "m m m",
    renderInfo: { breakAround: true }
  },
  insertverticalnavigation: {
    signature: "m",
    renderInfo: { breakAround: true }
  },
  usebeamercolor: { signature: "s m", renderInfo: { breakAround: true } },
  usebeamertemplate: { signature: "s m", renderInfo: { breakAround: true } },
  setbeamercolor: {
    signature: "m m",
    renderInfo: { breakAround: true, pgfkeysArgs: true }
  },
  setbeamersize: {
    signature: "m o o",
    renderInfo: { breakAround: true, pgfkeysArgs: true }
  },
  setbeamertemplate: {
    signature: "m o o d{}",
    renderInfo: { breakAround: true, pgfkeysArgs: true }
  },
  newcommand: {
    signature: "s d<> +m o +o +m",
    renderInfo: {
      breakAround: true,
      namedArguments: [
        "starred",
        null,
        "name",
        "numArgs",
        "default",
        "body"
      ]
    }
  },
  renewcommand: {
    signature: "s d<> +m o +o +m",
    renderInfo: {
      breakAround: true,
      namedArguments: [
        "starred",
        null,
        "name",
        "numArgs",
        "default",
        "body"
      ]
    }
  },
  newenvironment: {
    signature: "s d<> m o o m m",
    renderInfo: { breakAround: true }
  },
  renewenvironment: {
    signature: "s d<> m o o m m",
    renderInfo: { breakAround: true }
  },
  resetcounteronoverlays: {
    signature: "m",
    renderInfo: { breakAround: true }
  },
  resetcountonoverlays: { signature: "m", renderInfo: { breakAround: true } },
  logo: { signature: "m", renderInfo: { breakAround: true } },
  frametitle: { signature: "d<> o m", renderInfo: { breakAround: true } },
  framesubtitle: { signature: "d<> m", renderInfo: { breakAround: true } },
  pause: { signature: "o" },
  onslide: { signature: "t+ t* d<> d{}" },
  only: { signature: "d<> m d<>" },
  uncover: { signature: "d<> m" },
  visible: { signature: "d<> m" },
  invisible: { signature: "d<> m" },
  alt: { signature: "d<> m m d<>" },
  temporal: { signature: "r<> m m m" },
  item: {
    signature: "d<> o d<>",
    renderInfo: {
      hangingIndent: true,
      namedArguments: [null, "label", null]
    }
  },
  label: { signature: "d<> o m" },
  // cleveref adds an optional argument to label; this gives maximum compatibility.
  action: { signature: "d<> m" },
  beamerdefaultoverlayspecification: { signature: "m" },
  titlegraphic: { signature: "m", renderInfo: { breakAround: true } },
  subject: { signature: "m", renderInfo: { breakAround: true } },
  keywords: { signature: "m", renderInfo: { breakAround: true } },
  lecture: { signature: "o m m", renderInfo: { breakAround: true } },
  partpage: { renderInfo: { breakAround: true } },
  sectionpage: { renderInfo: { breakAround: true } },
  subsectionpage: { renderInfo: { breakAround: true } },
  AtBeginLecture: { signature: "m", renderInfo: { breakAround: true } },
  AtBeginPart: { signature: "m", renderInfo: { breakAround: true } },
  tableofcontents: {
    signature: "o",
    renderInfo: { breakAround: true, pgfkeysArgs: true }
  },
  againframe: { signature: "d<> o o m", renderInfo: { breakAround: true } },
  framezoom: {
    signature: "r<> r<> o r() r()",
    renderInfo: { breakAround: true }
  },
  column: { signature: "d<> o m", renderInfo: { breakAround: true } },
  animate: { signature: "r<>", renderInfo: { breakAround: true } },
  animatevalue: { signature: "r<> m m m", renderInfo: { breakAround: true } },
  sound: {
    signature: "o m m",
    renderInfo: { breakAround: true, pgfkeysArgs: true }
  },
  hyperlinksound: {
    signature: "o m m",
    renderInfo: { breakAround: true, pgfkeysArgs: true }
  },
  hyperlinkmute: { signature: "m", renderInfo: { breakAround: true } },
  // These signatures conflict with the default signatures.
  // Care must be taken when processing an AST.
  section: {
    signature: "s d<> o m",
    renderInfo: {
      breakAround: true,
      namedArguments: ["starred", null, "tocTitle", "title"]
    }
  },
  subsection: {
    signature: "s d<> o m",
    renderInfo: {
      breakAround: true,
      namedArguments: ["starred", null, "tocTitle", "title"]
    }
  },
  subsubsection: {
    signature: "s d<> o m",
    renderInfo: {
      breakAround: true,
      namedArguments: ["starred", null, "tocTitle", "title"]
    }
  },
  part: {
    signature: "s d<> o m",
    renderInfo: {
      breakAround: true,
      namedArguments: ["starred", null, "tocTitle", "title"]
    }
  },
  bibitem: {
    signature: "s d<> o m",
    renderInfo: {
      hangingIndent: true,
      namedArguments: ["starred", null, "tocTitle", "title"]
    }
  }
};
var environments13 = {
  frame: {
    signature: "!d<> !o !o !d{} !d{}"
  },
  block: {
    signature: "!d<> !d{} !d<>"
  },
  alertblock: {
    signature: "!d<> !d{} !d<>"
  },
  exampleblock: {
    signature: "!d<> !d{} !d<>"
  },
  onlyenv: {
    signature: "!d<>"
  },
  altenv: {
    signature: "!d<> m m m m !d<>"
  },
  overlayarea: { signature: "m m" },
  overprint: { signature: "o" },
  actionenv: { signature: "!d<>" },
  columns: { signature: "d<> o" },
  column: { signature: "d<> o m" }
};
var macros14 = {
  columnbreak: { renderInfo: { breakAround: true } }
};
var environments14 = {
  multicols: {
    signature: "m o o"
  },
  "multicols*": {
    signature: "m o o"
  }
};
var macroInfo = {
  cleveref: macros,
  exam: macros2,
  geometry: macros3,
  hyperref: macros4,
  latex2e: macros5,
  makeidx: macros6,
  mathtools: macros7,
  nicematrix: macros8,
  systeme: macros9,
  tikz: macros10,
  xcolor: macros11,
  xparse: macros12,
  beamer: macros13,
  multicol: macros14
};
var environmentInfo = {
  cleveref: environments,
  exam: environments2,
  geometry: environments3,
  hyperref: environments4,
  latex2e: environments5,
  makeidx: environments6,
  mathtools: environments7,
  nicematrix: environments8,
  systeme: environments9,
  tikz: environments10,
  xcolor: environments11,
  xparse: environments12,
  beamer: environments13,
  multicol: environments14
};

// ../unified-latex-util-trim/dist/index.js
var linebreak14 = Symbol("linebreak");
var ESCAPE13 = "\\";
function _printRaw13(node) {
  if (typeof node === "string") {
    return [node];
  }
  if (Array.isArray(node)) {
    return [].concat(
      ...node.map((n) => _printRaw13(n))
    );
  }
  let argsString, escape;
  switch (node.type) {
    case "root":
      return _printRaw13(node.content);
    case "argument":
      return [node.openMark, ..._printRaw13(node.content), node.closeMark];
    case "comment":
      var suffix = node.suffixParbreak ? "" : linebreak14;
      var leadingWhitespace = "";
      if (node.sameline && node.leadingWhitespace) {
        leadingWhitespace = " ";
      }
      if (node.sameline) {
        return [
          leadingWhitespace,
          "%",
          ..._printRaw13(node.content),
          suffix
        ];
      }
      return [linebreak14, "%", ..._printRaw13(node.content), suffix];
    case "environment":
    case "mathenv":
    case "verbatim":
      var env = _printRaw13(node.env);
      var envStart = [ESCAPE13 + "begin{", ...env, "}"];
      var envEnd = [ESCAPE13 + "end{", ...env, "}"];
      argsString = node.args == null ? [] : _printRaw13(node.args);
      return [
        ...envStart,
        ...argsString,
        ..._printRaw13(node.content),
        ...envEnd
      ];
    case "displaymath":
      return [ESCAPE13 + "[", ..._printRaw13(node.content), ESCAPE13 + "]"];
    case "group":
      return ["{", ..._printRaw13(node.content), "}"];
    case "inlinemath":
      return ["$", ..._printRaw13(node.content), "$"];
    case "macro":
      argsString = node.args == null ? [] : _printRaw13(node.args);
      escape = node.escapeToken == null ? ESCAPE13 : node.escapeToken;
      return [escape, ..._printRaw13(node.content), ...argsString];
    case "parbreak":
      return [linebreak14, linebreak14];
    case "string":
      return [node.content];
    case "verb":
      return [
        ESCAPE13,
        node.env,
        node.escape,
        ..._printRaw13(node.content),
        node.escape
      ];
    case "whitespace":
      return [" "];
    default:
      console.warn(
        "Cannot find render for node ",
        node,
        `(of type ${typeof node})`
      );
      return ["" + node];
  }
}
function printRaw8(node, options) {
  const asArray = options != null ? options.asArray : false;
  const printedTokens = _printRaw13(node);
  if (asArray) {
    return printedTokens;
  }
  return printedTokens.map((x) => x === linebreak14 ? "\n" : x).join("");
}
function createMacroMatcher13(macros15) {
  const macrosHash = Array.isArray(macros15) ? macros15.length > 0 ? typeof macros15[0] === "string" ? Object.fromEntries(
    macros15.map((macro223) => {
      if (typeof macro223 !== "string") {
        throw new Error("Wrong branch of map function");
      }
      return [macro223, {}];
    })
  ) : Object.fromEntries(
    macros15.map((macro223) => {
      if (typeof macro223 === "string") {
        throw new Error("Wrong branch of map function");
      }
      if (macro223.escapeToken != null) {
        return [
          macro223.content,
          { escapeToken: macro223.escapeToken }
        ];
      }
      return [macro223.content, {}];
    })
  ) : {} : macros15;
  return function matchAgainstMacros(node) {
    if (node == null || node.type !== "macro") {
      return false;
    }
    const spec = macrosHash[node.content];
    if (!spec) {
      return false;
    }
    if (typeof spec === "object" && "escapeToken" in spec) {
      return spec.escapeToken == null || spec.escapeToken === node.escapeToken;
    }
    return true;
  };
}
function createEnvironmentMatcher13(macros15) {
  const environmentsHash = Array.isArray(macros15) ? Object.fromEntries(
    macros15.map((str) => {
      return [str, {}];
    })
  ) : macros15;
  return function matchAgainstEnvironments(node) {
    if (!match13.anyEnvironment(node)) {
      return false;
    }
    const envName = printRaw8(node.env);
    const spec = environmentsHash[envName];
    if (!spec) {
      return false;
    }
    return true;
  };
}
var match13 = {
  macro(node, macroName) {
    if (node == null) {
      return false;
    }
    return node.type === "macro" && (macroName == null || node.content === macroName);
  },
  anyMacro(node) {
    return match13.macro(node);
  },
  environment(node, envName) {
    if (node == null) {
      return false;
    }
    return (node.type === "environment" || node.type === "mathenv") && (envName == null || printRaw8(node.env) === envName);
  },
  anyEnvironment(node) {
    return match13.environment(node);
  },
  comment(node) {
    if (node == null) {
      return false;
    }
    return node.type === "comment";
  },
  parbreak(node) {
    if (node == null) {
      return false;
    }
    return node.type === "parbreak";
  },
  whitespace(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace";
  },
  /**
   * Matches whitespace or a comment with leading whitespace.
   */
  whitespaceLike(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace" || node.type === "whitespace" && node.leadingWhitespace === true;
  },
  string(node, value) {
    if (node == null) {
      return false;
    }
    return node.type === "string" && (value == null || node.content === value);
  },
  anyString(node) {
    return match13.string(node);
  },
  group(node) {
    if (node == null) {
      return false;
    }
    return node.type === "group";
  },
  argument(node) {
    if (node == null) {
      return false;
    }
    return node.type === "argument";
  },
  blankArgument(node) {
    if (!match13.argument(node)) {
      return false;
    }
    return node.openMark === "" && node.closeMark === "" && node.content.length === 0;
  },
  math(node) {
    if (node == null) {
      return false;
    }
    return node.type === "displaymath" || node.type === "inlinemath";
  },
  createMacroMatcher: createMacroMatcher13,
  createEnvironmentMatcher: createEnvironmentMatcher13
};
var {
  anyEnvironment: anyEnvironment13,
  anyMacro: anyMacro13,
  anyString: anyString13,
  argument: argument13,
  blankArgument: blankArgument13,
  comment: comment13,
  environment: environment13,
  group: group13,
  macro: macro13,
  math: math13,
  parbreak: parbreak13,
  string: string13,
  whitespace: whitespace13
} = match13;
function trim2(nodes) {
  if (!Array.isArray(nodes)) {
    console.warn("Trying to trim a non-array ast", nodes);
    return nodes;
  }
  const { trimmedStart } = trimStart2(nodes);
  const { trimmedEnd } = trimEnd2(nodes);
  return { trimmedStart, trimmedEnd };
}
function trimStart2(nodes) {
  const { start } = amountOfLeadingAndTrailingWhitespace2(nodes);
  nodes.splice(0, start);
  for (const leadingToken of nodes) {
    if (!match13.comment(leadingToken)) {
      break;
    }
    if (leadingToken.leadingWhitespace || leadingToken.sameline) {
      leadingToken.leadingWhitespace = false;
      delete leadingToken.position;
    }
    if (start > 0 && leadingToken.sameline) {
      leadingToken.sameline = false;
      delete leadingToken.position;
    }
  }
  return { trimmedStart: start };
}
function trimEnd2(nodes) {
  const { end } = amountOfLeadingAndTrailingWhitespace2(nodes);
  nodes.splice(nodes.length - end, end);
  for (let i = nodes.length - 1; i >= 0; i--) {
    const trailingToken = nodes[i];
    if (!match13.comment(trailingToken)) {
      break;
    }
    delete trailingToken.suffixParbreak;
    if (match13.comment(trailingToken) && trailingToken.leadingWhitespace && !trailingToken.sameline) {
      trailingToken.leadingWhitespace = false;
      delete trailingToken.position;
    }
  }
  return { trimmedEnd: end };
}
function amountOfLeadingAndTrailingWhitespace2(ast) {
  let start = 0;
  let end = 0;
  for (const node of ast) {
    if (match13.whitespace(node) || match13.parbreak(node)) {
      start++;
    } else {
      break;
    }
  }
  if (start === ast.length) {
    return { start, end: 0 };
  }
  for (let i = ast.length - 1; i >= 0; i--) {
    const node = ast[i];
    if (match13.whitespace(node) || match13.parbreak(node)) {
      end++;
    } else {
      break;
    }
  }
  return { start, end };
}
var linebreak27 = Symbol("linebreak");
var ESCAPE27 = "\\";
function _printRaw27(node) {
  if (typeof node === "string") {
    return [node];
  }
  if (Array.isArray(node)) {
    return [].concat(
      ...node.map((n) => _printRaw27(n))
    );
  }
  let argsString, escape;
  switch (node.type) {
    case "root":
      return _printRaw27(node.content);
    case "argument":
      return [node.openMark, ..._printRaw27(node.content), node.closeMark];
    case "comment":
      var suffix = node.suffixParbreak ? "" : linebreak27;
      var leadingWhitespace = "";
      if (node.sameline && node.leadingWhitespace) {
        leadingWhitespace = " ";
      }
      if (node.sameline) {
        return [
          leadingWhitespace,
          "%",
          ..._printRaw27(node.content),
          suffix
        ];
      }
      return [linebreak27, "%", ..._printRaw27(node.content), suffix];
    case "environment":
    case "mathenv":
    case "verbatim":
      var env = _printRaw27(node.env);
      var envStart = [ESCAPE27 + "begin{", ...env, "}"];
      var envEnd = [ESCAPE27 + "end{", ...env, "}"];
      argsString = node.args == null ? [] : _printRaw27(node.args);
      return [
        ...envStart,
        ...argsString,
        ..._printRaw27(node.content),
        ...envEnd
      ];
    case "displaymath":
      return [ESCAPE27 + "[", ..._printRaw27(node.content), ESCAPE27 + "]"];
    case "group":
      return ["{", ..._printRaw27(node.content), "}"];
    case "inlinemath":
      return ["$", ..._printRaw27(node.content), "$"];
    case "macro":
      argsString = node.args == null ? [] : _printRaw27(node.args);
      escape = node.escapeToken == null ? ESCAPE27 : node.escapeToken;
      return [escape, ..._printRaw27(node.content), ...argsString];
    case "parbreak":
      return [linebreak27, linebreak27];
    case "string":
      return [node.content];
    case "verb":
      return [
        ESCAPE27,
        node.env,
        node.escape,
        ..._printRaw27(node.content),
        node.escape
      ];
    case "whitespace":
      return [" "];
    default:
      console.warn(
        "Cannot find render for node ",
        node,
        `(of type ${typeof node})`
      );
      return ["" + node];
  }
}
function printRaw27(node, options) {
  const asArray = options != null ? options.asArray : false;
  const printedTokens = _printRaw27(node);
  if (asArray) {
    return printedTokens;
  }
  return printedTokens.map((x) => x === linebreak27 ? "\n" : x).join("");
}
function createMacroMatcher26(macros15) {
  const macrosHash = Array.isArray(macros15) ? macros15.length > 0 ? typeof macros15[0] === "string" ? Object.fromEntries(
    macros15.map((macro223) => {
      if (typeof macro223 !== "string") {
        throw new Error("Wrong branch of map function");
      }
      return [macro223, {}];
    })
  ) : Object.fromEntries(
    macros15.map((macro223) => {
      if (typeof macro223 === "string") {
        throw new Error("Wrong branch of map function");
      }
      if (macro223.escapeToken != null) {
        return [
          macro223.content,
          { escapeToken: macro223.escapeToken }
        ];
      }
      return [macro223.content, {}];
    })
  ) : {} : macros15;
  return function matchAgainstMacros(node) {
    if (node == null || node.type !== "macro") {
      return false;
    }
    const spec = macrosHash[node.content];
    if (!spec) {
      return false;
    }
    if (typeof spec === "object" && "escapeToken" in spec) {
      return spec.escapeToken == null || spec.escapeToken === node.escapeToken;
    }
    return true;
  };
}
function createEnvironmentMatcher26(macros15) {
  const environmentsHash = Array.isArray(macros15) ? Object.fromEntries(
    macros15.map((str) => {
      return [str, {}];
    })
  ) : macros15;
  return function matchAgainstEnvironments(node) {
    if (!match26.anyEnvironment(node)) {
      return false;
    }
    const envName = printRaw27(node.env);
    const spec = environmentsHash[envName];
    if (!spec) {
      return false;
    }
    return true;
  };
}
var match26 = {
  macro(node, macroName) {
    if (node == null) {
      return false;
    }
    return node.type === "macro" && (macroName == null || node.content === macroName);
  },
  anyMacro(node) {
    return match26.macro(node);
  },
  environment(node, envName) {
    if (node == null) {
      return false;
    }
    return (node.type === "environment" || node.type === "mathenv") && (envName == null || printRaw27(node.env) === envName);
  },
  anyEnvironment(node) {
    return match26.environment(node);
  },
  comment(node) {
    if (node == null) {
      return false;
    }
    return node.type === "comment";
  },
  parbreak(node) {
    if (node == null) {
      return false;
    }
    return node.type === "parbreak";
  },
  whitespace(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace";
  },
  /**
   * Matches whitespace or a comment with leading whitespace.
   */
  whitespaceLike(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace" || node.type === "whitespace" && node.leadingWhitespace === true;
  },
  string(node, value) {
    if (node == null) {
      return false;
    }
    return node.type === "string" && (value == null || node.content === value);
  },
  anyString(node) {
    return match26.string(node);
  },
  group(node) {
    if (node == null) {
      return false;
    }
    return node.type === "group";
  },
  argument(node) {
    if (node == null) {
      return false;
    }
    return node.type === "argument";
  },
  blankArgument(node) {
    if (!match26.argument(node)) {
      return false;
    }
    return node.openMark === "" && node.closeMark === "" && node.content.length === 0;
  },
  math(node) {
    if (node == null) {
      return false;
    }
    return node.type === "displaymath" || node.type === "inlinemath";
  },
  createMacroMatcher: createMacroMatcher26,
  createEnvironmentMatcher: createEnvironmentMatcher26
};
var {
  anyEnvironment: anyEnvironment26,
  anyMacro: anyMacro26,
  anyString: anyString26,
  argument: argument26,
  blankArgument: blankArgument26,
  comment: comment26,
  environment: environment26,
  group: group26,
  macro: macro26,
  math: math26,
  parbreak: parbreak26,
  string: string26,
  whitespace: whitespace26
} = match26;
function listMathChildren(node) {
  const NULL_RETURN = { enter: [], leave: [] };
  if (Array.isArray(node)) {
    return NULL_RETURN;
  }
  if (match26.math(node)) {
    return { enter: ["content"], leave: [] };
  }
  const renderInfo = node._renderInfo || {};
  if (renderInfo.inMathMode == null) {
    return NULL_RETURN;
  }
  if (match26.macro(node)) {
    if (renderInfo.inMathMode === true) {
      return { enter: ["args"], leave: [] };
    } else if (renderInfo.inMathMode === false) {
      return { enter: [], leave: ["args"] };
    }
  }
  if (match26.environment(node)) {
    if (renderInfo.inMathMode === true) {
      return { enter: ["content"], leave: [] };
    } else {
      return { enter: [], leave: ["content"] };
    }
  }
  return NULL_RETURN;
}
var CONTINUE7 = Symbol("continue");
var SKIP7 = Symbol("skip");
var EXIT7 = Symbol("exit");
var DEFAULT_CONTEXT = {
  inMathMode: false,
  hasMathModeAncestor: false
};
function visit(tree, visitor, options) {
  const {
    startingContext = DEFAULT_CONTEXT,
    test = () => true,
    includeArrays = false
  } = options || {};
  let enter;
  let leave;
  if (typeof visitor === "function") {
    enter = visitor;
  } else if (visitor && typeof visitor === "object") {
    enter = visitor.enter;
    leave = visitor.leave;
  }
  walk(tree, {
    key: void 0,
    index: void 0,
    parents: [],
    containingArray: void 0,
    context: { ...startingContext }
  });
  function walk(node, { key, index: index2, parents, context, containingArray }) {
    const nodePassesTest = includeArrays ? test(node, { key, index: index2, parents, context, containingArray }) : !Array.isArray(node) && test(node, { key, index: index2, parents, context, containingArray });
    const result = enter && nodePassesTest ? toResult(
      enter(node, {
        key,
        index: index2,
        parents,
        context,
        containingArray
      })
    ) : [CONTINUE7];
    if (result[0] === EXIT7) {
      return result;
    }
    if (result[0] === SKIP7) {
      return leave && nodePassesTest ? toResult(
        leave(node, {
          key,
          index: index2,
          parents,
          context,
          containingArray
        })
      ) : result;
    }
    if (Array.isArray(node)) {
      for (let index22 = 0; index22 > -1 && index22 < node.length; index22++) {
        const item = node[index22];
        const result2 = walk(item, {
          key,
          index: index22,
          parents,
          context,
          containingArray: node
        });
        if (result2[0] === EXIT7) {
          return result2;
        }
        if (typeof result2[1] === "number") {
          index22 = result2[1] - 1;
        }
      }
    } else {
      let childProps = ["content", "args"];
      switch (node.type) {
        case "macro":
          childProps = ["args"];
          break;
        case "comment":
        case "string":
        case "verb":
        case "verbatim":
          childProps = [];
          break;
        default:
          break;
      }
      const mathModeProps = listMathChildren(node);
      for (const key2 of childProps) {
        const value = node[key2];
        const grandparents = [node].concat(parents);
        if (value == null) {
          continue;
        }
        const newContext = { ...context };
        if (mathModeProps.enter.includes(key2)) {
          newContext.inMathMode = true;
          newContext.hasMathModeAncestor = true;
        } else if (mathModeProps.leave.includes(key2)) {
          newContext.inMathMode = false;
        }
        const result2 = walk(value, {
          key: key2,
          index: void 0,
          parents: grandparents,
          context: newContext,
          containingArray: void 0
        });
        if (result2[0] === EXIT7) {
          return result2;
        }
      }
    }
    return leave && nodePassesTest ? toResult(
      leave(node, {
        key,
        index: index2,
        parents,
        context,
        containingArray
      })
    ) : result;
  }
}
function toResult(value) {
  if (value == null) {
    return [CONTINUE7];
  }
  if (Array.isArray(value)) {
    return value;
  }
  if (typeof value === "number") {
    return [CONTINUE7, value];
  }
  return [value];
}
var unifiedLatexTrimEnvironmentContents = function unifiedLatexTrimEnvironmentContents2() {
  return (tree) => {
    visit(tree, (node) => {
      if (!(match13.math(node) || match13.anyEnvironment(node))) {
        return;
      }
      let firstNode = node.content[0];
      if (match13.comment(firstNode) && firstNode.sameline) {
        firstNode.suffixParbreak = false;
        trimEnd2(node.content);
        const { trimmedStart } = trimStart2(node.content.slice(1));
        node.content.splice(1, trimmedStart);
      } else {
        trim2(node.content);
      }
    });
  };
};
var unifiedLatexTrimRoot = function unifiedLatexTrimRoot2() {
  return (tree) => {
    trim2(tree.content);
  };
};

// ../unified-latex-util-pegjs/dist/index.js
var linebreak15 = Symbol("linebreak");
var ESCAPE14 = "\\";
function _printRaw14(node) {
  if (typeof node === "string") {
    return [node];
  }
  if (Array.isArray(node)) {
    return [].concat(
      ...node.map((n) => _printRaw14(n))
    );
  }
  let argsString, escape;
  switch (node.type) {
    case "root":
      return _printRaw14(node.content);
    case "argument":
      return [node.openMark, ..._printRaw14(node.content), node.closeMark];
    case "comment":
      var suffix = node.suffixParbreak ? "" : linebreak15;
      var leadingWhitespace = "";
      if (node.sameline && node.leadingWhitespace) {
        leadingWhitespace = " ";
      }
      if (node.sameline) {
        return [
          leadingWhitespace,
          "%",
          ..._printRaw14(node.content),
          suffix
        ];
      }
      return [linebreak15, "%", ..._printRaw14(node.content), suffix];
    case "environment":
    case "mathenv":
    case "verbatim":
      var env = _printRaw14(node.env);
      var envStart = [ESCAPE14 + "begin{", ...env, "}"];
      var envEnd = [ESCAPE14 + "end{", ...env, "}"];
      argsString = node.args == null ? [] : _printRaw14(node.args);
      return [
        ...envStart,
        ...argsString,
        ..._printRaw14(node.content),
        ...envEnd
      ];
    case "displaymath":
      return [ESCAPE14 + "[", ..._printRaw14(node.content), ESCAPE14 + "]"];
    case "group":
      return ["{", ..._printRaw14(node.content), "}"];
    case "inlinemath":
      return ["$", ..._printRaw14(node.content), "$"];
    case "macro":
      argsString = node.args == null ? [] : _printRaw14(node.args);
      escape = node.escapeToken == null ? ESCAPE14 : node.escapeToken;
      return [escape, ..._printRaw14(node.content), ...argsString];
    case "parbreak":
      return [linebreak15, linebreak15];
    case "string":
      return [node.content];
    case "verb":
      return [
        ESCAPE14,
        node.env,
        node.escape,
        ..._printRaw14(node.content),
        node.escape
      ];
    case "whitespace":
      return [" "];
    default:
      console.warn(
        "Cannot find render for node ",
        node,
        `(of type ${typeof node})`
      );
      return ["" + node];
  }
}
function printRaw14(node, options) {
  const asArray = options != null ? options.asArray : false;
  const printedTokens = _printRaw14(node);
  if (asArray) {
    return printedTokens;
  }
  return printedTokens.map((x) => x === linebreak15 ? "\n" : x).join("");
}
function createMacroMatcher14(macros15) {
  const macrosHash = Array.isArray(macros15) ? macros15.length > 0 ? typeof macros15[0] === "string" ? Object.fromEntries(
    macros15.map((macro210) => {
      if (typeof macro210 !== "string") {
        throw new Error("Wrong branch of map function");
      }
      return [macro210, {}];
    })
  ) : Object.fromEntries(
    macros15.map((macro210) => {
      if (typeof macro210 === "string") {
        throw new Error("Wrong branch of map function");
      }
      if (macro210.escapeToken != null) {
        return [
          macro210.content,
          { escapeToken: macro210.escapeToken }
        ];
      }
      return [macro210.content, {}];
    })
  ) : {} : macros15;
  return function matchAgainstMacros(node) {
    if (node == null || node.type !== "macro") {
      return false;
    }
    const spec = macrosHash[node.content];
    if (!spec) {
      return false;
    }
    if (typeof spec === "object" && "escapeToken" in spec) {
      return spec.escapeToken == null || spec.escapeToken === node.escapeToken;
    }
    return true;
  };
}
function createEnvironmentMatcher14(macros15) {
  const environmentsHash = Array.isArray(macros15) ? Object.fromEntries(
    macros15.map((str) => {
      return [str, {}];
    })
  ) : macros15;
  return function matchAgainstEnvironments(node) {
    if (!match14.anyEnvironment(node)) {
      return false;
    }
    const envName = printRaw14(node.env);
    const spec = environmentsHash[envName];
    if (!spec) {
      return false;
    }
    return true;
  };
}
var match14 = {
  macro(node, macroName) {
    if (node == null) {
      return false;
    }
    return node.type === "macro" && (macroName == null || node.content === macroName);
  },
  anyMacro(node) {
    return match14.macro(node);
  },
  environment(node, envName) {
    if (node == null) {
      return false;
    }
    return (node.type === "environment" || node.type === "mathenv") && (envName == null || printRaw14(node.env) === envName);
  },
  anyEnvironment(node) {
    return match14.environment(node);
  },
  comment(node) {
    if (node == null) {
      return false;
    }
    return node.type === "comment";
  },
  parbreak(node) {
    if (node == null) {
      return false;
    }
    return node.type === "parbreak";
  },
  whitespace(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace";
  },
  /**
   * Matches whitespace or a comment with leading whitespace.
   */
  whitespaceLike(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace" || node.type === "whitespace" && node.leadingWhitespace === true;
  },
  string(node, value) {
    if (node == null) {
      return false;
    }
    return node.type === "string" && (value == null || node.content === value);
  },
  anyString(node) {
    return match14.string(node);
  },
  group(node) {
    if (node == null) {
      return false;
    }
    return node.type === "group";
  },
  argument(node) {
    if (node == null) {
      return false;
    }
    return node.type === "argument";
  },
  blankArgument(node) {
    if (!match14.argument(node)) {
      return false;
    }
    return node.openMark === "" && node.closeMark === "" && node.content.length === 0;
  },
  math(node) {
    if (node == null) {
      return false;
    }
    return node.type === "displaymath" || node.type === "inlinemath";
  },
  createMacroMatcher: createMacroMatcher14,
  createEnvironmentMatcher: createEnvironmentMatcher14
};
var {
  anyEnvironment: anyEnvironment14,
  anyMacro: anyMacro14,
  anyString: anyString14,
  argument: argument14,
  blankArgument: blankArgument14,
  comment: comment14,
  environment: environment14,
  group: group14,
  macro: macro14,
  math: math14,
  parbreak: parbreak14,
  string: string14,
  whitespace: whitespace14
} = match14;
var latex_default4 = (
  // Generated by Peggy 2.0.1.
  //
  // https://peggyjs.org/
  function() {
    "use strict";
    function peg$subclass(child, parent) {
      function C() {
        this.constructor = child;
      }
      C.prototype = parent.prototype;
      child.prototype = new C();
    }
    function peg$SyntaxError(message, expected, found, location) {
      var self = Error.call(this, message);
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(self, peg$SyntaxError.prototype);
      }
      self.expected = expected;
      self.found = found;
      self.location = location;
      self.name = "SyntaxError";
      return self;
    }
    peg$subclass(peg$SyntaxError, Error);
    function peg$padEnd(str, targetLength, padString) {
      padString = padString || " ";
      if (str.length > targetLength) {
        return str;
      }
      targetLength -= str.length;
      padString += padString.repeat(targetLength);
      return str + padString.slice(0, targetLength);
    }
    peg$SyntaxError.prototype.format = function(sources) {
      var str = "Error: " + this.message;
      if (this.location) {
        var src = null;
        var k;
        for (k = 0; k < sources.length; k++) {
          if (sources[k].source === this.location.source) {
            src = sources[k].text.split(/\r\n|\n|\r/g);
            break;
          }
        }
        var s5 = this.location.start;
        var loc = this.location.source + ":" + s5.line + ":" + s5.column;
        if (src) {
          var e = this.location.end;
          var filler = peg$padEnd("", s5.line.toString().length, " ");
          var line = src[s5.line - 1];
          var last = s5.line === e.line ? e.column : line.length + 1;
          var hatLen = last - s5.column || 1;
          str += "\n --> " + loc + "\n" + filler + " |\n" + s5.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s5.column - 1, " ") + peg$padEnd("", hatLen, "^");
        } else {
          str += "\n at " + loc;
        }
      }
      return str;
    };
    peg$SyntaxError.buildMessage = function(expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        class: function(expectation) {
          var escapedParts = expectation.parts.map(function(part) {
            return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
          });
          return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
        },
        any: function() {
          return "any character";
        },
        end: function() {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        }
      };
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s5) {
        return s5.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function classEscape(s5) {
        return s5.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = expected2.map(describeExpectation);
        var i, j;
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {};
      var peg$source = options.grammarSource;
      var peg$startRuleFunctions = { document: peg$parsedocument, math: peg$parsemath };
      var peg$startRuleFunction = peg$parsedocument;
      var peg$c0 = "%";
      var peg$c1 = ".";
      var peg$c2 = "verb*";
      var peg$c3 = "verb";
      var peg$c4 = "verbatim*";
      var peg$c5 = "verbatim";
      var peg$c6 = "filecontents*";
      var peg$c7 = "filecontents";
      var peg$c8 = "comment";
      var peg$c9 = "lstlisting";
      var peg$c10 = "[";
      var peg$c11 = "]";
      var peg$c12 = "(";
      var peg$c13 = ")";
      var peg$c14 = "begin";
      var peg$c15 = "end";
      var peg$c16 = "equation*";
      var peg$c17 = "equation";
      var peg$c18 = "align*";
      var peg$c19 = "align";
      var peg$c20 = "alignat*";
      var peg$c21 = "alignat";
      var peg$c22 = "gather*";
      var peg$c23 = "gather";
      var peg$c24 = "multline*";
      var peg$c25 = "multline";
      var peg$c26 = "flalign*";
      var peg$c27 = "flalign";
      var peg$c28 = "split";
      var peg$c29 = "math";
      var peg$c30 = "displaymath";
      var peg$c31 = "\\";
      var peg$c32 = "{";
      var peg$c33 = "}";
      var peg$c34 = "$";
      var peg$c35 = "&";
      var peg$c36 = "\r";
      var peg$c37 = "\n";
      var peg$c38 = "\r\n";
      var peg$c39 = "#";
      var peg$c40 = "^";
      var peg$c41 = "_";
      var peg$c42 = "\0";
      var peg$r0 = /^[ \t]/;
      var peg$r1 = /^[a-zA-Z]/;
      var peg$r2 = /^[0-9]/;
      var peg$r3 = /^[.,;:\-*\/()!?=+<>[\]`'"~]/;
      var peg$e0 = peg$otherExpectation("document");
      var peg$e1 = peg$otherExpectation("math");
      var peg$e2 = peg$otherExpectation("token");
      var peg$e3 = peg$anyExpectation();
      var peg$e4 = peg$otherExpectation("parbreak");
      var peg$e5 = peg$otherExpectation("math token");
      var peg$e6 = peg$otherExpectation("nonchar token");
      var peg$e7 = peg$literalExpectation("%", false);
      var peg$e8 = peg$otherExpectation("whitespace");
      var peg$e9 = peg$otherExpectation("number");
      var peg$e10 = peg$literalExpectation(".", false);
      var peg$e11 = peg$otherExpectation("special macro");
      var peg$e12 = peg$literalExpectation("verb*", false);
      var peg$e13 = peg$literalExpectation("verb", false);
      var peg$e14 = peg$otherExpectation("verbatim environment");
      var peg$e15 = peg$literalExpectation("verbatim*", false);
      var peg$e16 = peg$literalExpectation("verbatim", false);
      var peg$e17 = peg$literalExpectation("filecontents*", false);
      var peg$e18 = peg$literalExpectation("filecontents", false);
      var peg$e19 = peg$literalExpectation("comment", false);
      var peg$e20 = peg$literalExpectation("lstlisting", false);
      var peg$e21 = peg$otherExpectation("macro");
      var peg$e22 = peg$otherExpectation("group");
      var peg$e23 = peg$otherExpectation("environment");
      var peg$e24 = peg$otherExpectation("math environment");
      var peg$e25 = peg$otherExpectation("math group");
      var peg$e26 = peg$literalExpectation("[", false);
      var peg$e27 = peg$literalExpectation("]", false);
      var peg$e28 = peg$literalExpectation("(", false);
      var peg$e29 = peg$literalExpectation(")", false);
      var peg$e30 = peg$literalExpectation("begin", false);
      var peg$e31 = peg$literalExpectation("end", false);
      var peg$e32 = peg$literalExpectation("equation*", false);
      var peg$e33 = peg$literalExpectation("equation", false);
      var peg$e34 = peg$literalExpectation("align*", false);
      var peg$e35 = peg$literalExpectation("align", false);
      var peg$e36 = peg$literalExpectation("alignat*", false);
      var peg$e37 = peg$literalExpectation("alignat", false);
      var peg$e38 = peg$literalExpectation("gather*", false);
      var peg$e39 = peg$literalExpectation("gather", false);
      var peg$e40 = peg$literalExpectation("multline*", false);
      var peg$e41 = peg$literalExpectation("multline", false);
      var peg$e42 = peg$literalExpectation("flalign*", false);
      var peg$e43 = peg$literalExpectation("flalign", false);
      var peg$e44 = peg$literalExpectation("split", false);
      var peg$e45 = peg$literalExpectation("math", false);
      var peg$e46 = peg$literalExpectation("displaymath", false);
      var peg$e47 = peg$otherExpectation("escape");
      var peg$e48 = peg$literalExpectation("\\", false);
      var peg$e49 = peg$literalExpectation("{", false);
      var peg$e50 = peg$literalExpectation("}", false);
      var peg$e51 = peg$literalExpectation("$", false);
      var peg$e52 = peg$literalExpectation("&", false);
      var peg$e53 = peg$otherExpectation("newline");
      var peg$e54 = peg$literalExpectation("\r", false);
      var peg$e55 = peg$literalExpectation("\n", false);
      var peg$e56 = peg$literalExpectation("\r\n", false);
      var peg$e57 = peg$literalExpectation("#", false);
      var peg$e58 = peg$literalExpectation("^", false);
      var peg$e59 = peg$literalExpectation("_", false);
      var peg$e60 = peg$literalExpectation("\0", false);
      var peg$e61 = peg$classExpectation([" ", "	"], false, false);
      var peg$e62 = peg$otherExpectation("letter");
      var peg$e63 = peg$classExpectation([["a", "z"], ["A", "Z"]], false, false);
      var peg$e64 = peg$otherExpectation("digit");
      var peg$e65 = peg$classExpectation([["0", "9"]], false, false);
      var peg$e66 = peg$otherExpectation("punctuation");
      var peg$e67 = peg$classExpectation([".", ",", ";", ":", "-", "*", "/", "(", ")", "!", "?", "=", "+", "<", ">", "[", "]", "`", "'", '"', "~"], false, false);
      var peg$e68 = peg$otherExpectation("full comment");
      var peg$e69 = peg$otherExpectation("comment");
      var peg$f0 = function(content) {
        return createNode("root", { content });
      };
      var peg$f1 = function(t) {
        return t;
      };
      var peg$f2 = function(eq) {
        return createNode("inlinemath", { content: eq });
      };
      var peg$f3 = function(s5) {
        return createNode("string", { content: s5 });
      };
      var peg$f4 = function(s5) {
        return createNode("string", { content: s5 });
      };
      var peg$f5 = function() {
        return createNode("parbreak");
      };
      var peg$f6 = function(x) {
        return x;
      };
      var peg$f7 = function(x) {
        return x;
      };
      var peg$f8 = function() {
        return createNode("macro", { content: "^", escapeToken: "" });
      };
      var peg$f9 = function() {
        return createNode("macro", { content: "_", escapeToken: "" });
      };
      var peg$f10 = function(s5) {
        return createNode("string", { content: s5 });
      };
      var peg$f11 = function() {
        return createNode("whitespace");
      };
      var peg$f12 = function(a, b) {
        return a.join("") + "." + b.join("");
      };
      var peg$f13 = function(b) {
        return "." + b.join("");
      };
      var peg$f14 = function(a) {
        return a.join("") + ".";
      };
      var peg$f15 = function(s5) {
        return createNode("string", { content: s5 });
      };
      var peg$f16 = function(env, e, end) {
        return end == e;
      };
      var peg$f17 = function(env, e, x) {
        return x;
      };
      var peg$f18 = function(env, e, x, end) {
        return end == e;
      };
      var peg$f19 = function(env, e, x) {
        return createNode("verb", {
          env,
          escape: e,
          content: x.join("")
        });
      };
      var peg$f20 = function(x) {
        return x;
      };
      var peg$f21 = function(x) {
        return createNode("displaymath", { content: x });
      };
      var peg$f22 = function(x) {
        return x;
      };
      var peg$f23 = function(x) {
        return createNode("inlinemath", { content: x });
      };
      var peg$f24 = function(x) {
        return x;
      };
      var peg$f25 = function(x) {
        return createNode("displaymath", { content: x });
      };
      var peg$f26 = function(env, end_env) {
        return compare_env({ content: [env] }, end_env);
      };
      var peg$f27 = function(env, x) {
        return x;
      };
      var peg$f28 = function(env, body) {
        return createNode("verbatim", {
          env,
          content: body.join("")
        });
      };
      var peg$f29 = function(n) {
        return n.join("");
      };
      var peg$f30 = function(n) {
        return n;
      };
      var peg$f31 = function(m) {
        return createNode("macro", { content: m });
      };
      var peg$f32 = function(c) {
        return c;
      };
      var peg$f33 = function(x) {
        return createNode("group", { content: x });
      };
      var peg$f34 = function(g) {
        return text().slice(1, -1);
      };
      var peg$f35 = function(env, env_comment, end_env) {
        return compare_env(env, end_env);
      };
      var peg$f36 = function(env, env_comment, x) {
        return x;
      };
      var peg$f37 = function(env, env_comment, body) {
        return createNode("environment", {
          env,
          content: env_comment ? [env_comment, ...body] : body
        });
      };
      var peg$f38 = function(env, env_comment, end_env) {
        return compare_env({ content: [env] }, end_env);
      };
      var peg$f39 = function(env, env_comment, x) {
        return x;
      };
      var peg$f40 = function(env, env_comment, body) {
        return createNode("mathenv", {
          env,
          content: env_comment ? [env_comment, ...body] : body
        });
      };
      var peg$f41 = function(c) {
        return c;
      };
      var peg$f42 = function(x) {
        return createNode("group", { content: x });
      };
      var peg$f43 = function(e) {
        return createNode("string", { content: e });
      };
      var peg$f44 = function() {
        return createNode("string", { content: "\\" });
      };
      var peg$f45 = function(s5) {
        return createNode("string", { content: s5 });
      };
      var peg$f46 = function(s5) {
        return createNode("string", { content: s5 });
      };
      var peg$f47 = function(s5) {
        return createNode("string", { content: s5 });
      };
      var peg$f48 = function(s5) {
        return createNode("string", { content: s5 });
      };
      var peg$f49 = function(s5) {
        return createNode("string", { content: s5 });
      };
      var peg$f50 = function(s5) {
        return createNode("string", { content: s5 });
      };
      var peg$f51 = function(s5) {
        return createNode("string", { content: s5 });
      };
      var peg$f52 = function() {
        return " ";
      };
      var peg$f53 = function(p) {
        return createNode("string", { content: p });
      };
      var peg$f54 = function(leading_sp, comment210) {
        return createNode("comment", {
          ...comment210,
          sameline: false,
          leadingWhitespace: leading_sp.length > 0
        });
      };
      var peg$f55 = function(spaces, x) {
        return createNode("comment", {
          ...x,
          sameline: true,
          leadingWhitespace: spaces.length > 0
        });
      };
      var peg$f56 = function(c) {
        return c;
      };
      var peg$f57 = function(c) {
        return { content: c.join(""), suffixParbreak: true };
      };
      var peg$f58 = function(c) {
        return c;
      };
      var peg$f59 = function(c) {
        return { content: c.join("") };
      };
      var peg$f60 = function() {
        var loc = location();
        return loc.start.column === 1;
      };
      var peg$currPos = 0;
      var peg$savedPos = 0;
      var peg$posDetailsCache = [{ line: 1, column: 1 }];
      var peg$maxFailPos = 0;
      var peg$maxFailExpected = [];
      var peg$silentFails = 0;
      var peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function offset() {
        return peg$savedPos;
      }
      function range() {
        return {
          source: peg$source,
          start: peg$savedPos,
          end: peg$currPos
        };
      }
      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError(
          [peg$otherExpectation(description)],
          input.substring(peg$savedPos, peg$currPos),
          location2
        );
      }
      function error(message, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location2);
      }
      function peg$literalExpectation(text2, ignoreCase) {
        return { type: "literal", text: text2, ignoreCase };
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts, inverted, ignoreCase };
      }
      function peg$anyExpectation() {
        return { type: "any" };
      }
      function peg$endExpectation() {
        return { type: "end" };
      }
      function peg$otherExpectation(description) {
        return { type: "other", description };
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p;
        if (details) {
          return details;
        } else {
          p = pos - 1;
          while (!peg$posDetailsCache[p]) {
            p--;
          }
          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };
          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos);
        var endPosDetails = peg$computePosDetails(endPos);
        return {
          source: peg$source,
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildSimpleError(message, location2) {
        return new peg$SyntaxError(message, null, null, location2);
      }
      function peg$buildStructuredError(expected2, found, location2) {
        return new peg$SyntaxError(
          peg$SyntaxError.buildMessage(expected2, found),
          expected2,
          found,
          location2
        );
      }
      function peg$parsedocument() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsetoken();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parsetoken();
        }
        peg$savedPos = s0;
        s1 = peg$f0(s1);
        s0 = s1;
        peg$silentFails--;
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e0);
        }
        return s0;
      }
      function peg$parsemath() {
        var s0, s1;
        peg$silentFails++;
        s0 = [];
        s1 = peg$parsemath_token();
        while (s1 !== peg$FAILED) {
          s0.push(s1);
          s1 = peg$parsemath_token();
        }
        peg$silentFails--;
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e1);
        }
        return s0;
      }
      function peg$parsetoken() {
        var s0, s1, s22, s32, s42, s5;
        peg$silentFails++;
        s0 = peg$parsespecial_macro();
        if (s0 === peg$FAILED) {
          s0 = peg$parsemacro();
          if (s0 === peg$FAILED) {
            s0 = peg$parsefull_comment();
            if (s0 === peg$FAILED) {
              s0 = peg$parsegroup();
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parsemath_shift();
                if (s1 !== peg$FAILED) {
                  s22 = [];
                  s32 = peg$currPos;
                  s42 = peg$currPos;
                  peg$silentFails++;
                  s5 = peg$parsemath_shift();
                  peg$silentFails--;
                  if (s5 === peg$FAILED) {
                    s42 = void 0;
                  } else {
                    peg$currPos = s42;
                    s42 = peg$FAILED;
                  }
                  if (s42 !== peg$FAILED) {
                    s5 = peg$parsemath_token();
                    if (s5 !== peg$FAILED) {
                      peg$savedPos = s32;
                      s32 = peg$f1(s5);
                    } else {
                      peg$currPos = s32;
                      s32 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s32;
                    s32 = peg$FAILED;
                  }
                  if (s32 !== peg$FAILED) {
                    while (s32 !== peg$FAILED) {
                      s22.push(s32);
                      s32 = peg$currPos;
                      s42 = peg$currPos;
                      peg$silentFails++;
                      s5 = peg$parsemath_shift();
                      peg$silentFails--;
                      if (s5 === peg$FAILED) {
                        s42 = void 0;
                      } else {
                        peg$currPos = s42;
                        s42 = peg$FAILED;
                      }
                      if (s42 !== peg$FAILED) {
                        s5 = peg$parsemath_token();
                        if (s5 !== peg$FAILED) {
                          peg$savedPos = s32;
                          s32 = peg$f1(s5);
                        } else {
                          peg$currPos = s32;
                          s32 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s32;
                        s32 = peg$FAILED;
                      }
                    }
                  } else {
                    s22 = peg$FAILED;
                  }
                  if (s22 !== peg$FAILED) {
                    s32 = peg$parsemath_shift();
                    if (s32 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s0 = peg$f2(s22);
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
                if (s0 === peg$FAILED) {
                  s0 = peg$parsealignment_tab();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parseparbreak();
                    if (s0 === peg$FAILED) {
                      s0 = peg$parsemacro_parameter();
                      if (s0 === peg$FAILED) {
                        s0 = peg$parseignore();
                        if (s0 === peg$FAILED) {
                          s0 = peg$parsenumber();
                          if (s0 === peg$FAILED) {
                            s0 = peg$parsewhitespace();
                            if (s0 === peg$FAILED) {
                              s0 = peg$parsepunctuation();
                              if (s0 === peg$FAILED) {
                                s0 = peg$currPos;
                                s1 = peg$currPos;
                                s22 = [];
                                s32 = peg$currPos;
                                s42 = peg$currPos;
                                peg$silentFails++;
                                s5 = peg$parsenonchar_token();
                                peg$silentFails--;
                                if (s5 === peg$FAILED) {
                                  s42 = void 0;
                                } else {
                                  peg$currPos = s42;
                                  s42 = peg$FAILED;
                                }
                                if (s42 !== peg$FAILED) {
                                  if (input.length > peg$currPos) {
                                    s5 = input.charAt(peg$currPos);
                                    peg$currPos++;
                                  } else {
                                    s5 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                      peg$fail(peg$e3);
                                    }
                                  }
                                  if (s5 !== peg$FAILED) {
                                    s42 = [s42, s5];
                                    s32 = s42;
                                  } else {
                                    peg$currPos = s32;
                                    s32 = peg$FAILED;
                                  }
                                } else {
                                  peg$currPos = s32;
                                  s32 = peg$FAILED;
                                }
                                if (s32 !== peg$FAILED) {
                                  while (s32 !== peg$FAILED) {
                                    s22.push(s32);
                                    s32 = peg$currPos;
                                    s42 = peg$currPos;
                                    peg$silentFails++;
                                    s5 = peg$parsenonchar_token();
                                    peg$silentFails--;
                                    if (s5 === peg$FAILED) {
                                      s42 = void 0;
                                    } else {
                                      peg$currPos = s42;
                                      s42 = peg$FAILED;
                                    }
                                    if (s42 !== peg$FAILED) {
                                      if (input.length > peg$currPos) {
                                        s5 = input.charAt(peg$currPos);
                                        peg$currPos++;
                                      } else {
                                        s5 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                          peg$fail(peg$e3);
                                        }
                                      }
                                      if (s5 !== peg$FAILED) {
                                        s42 = [s42, s5];
                                        s32 = s42;
                                      } else {
                                        peg$currPos = s32;
                                        s32 = peg$FAILED;
                                      }
                                    } else {
                                      peg$currPos = s32;
                                      s32 = peg$FAILED;
                                    }
                                  }
                                } else {
                                  s22 = peg$FAILED;
                                }
                                if (s22 !== peg$FAILED) {
                                  s1 = input.substring(s1, peg$currPos);
                                } else {
                                  s1 = s22;
                                }
                                if (s1 !== peg$FAILED) {
                                  peg$savedPos = s0;
                                  s1 = peg$f3(s1);
                                }
                                s0 = s1;
                                if (s0 === peg$FAILED) {
                                  s0 = peg$parsebegin_group();
                                  if (s0 === peg$FAILED) {
                                    s0 = peg$parseend_group();
                                    if (s0 === peg$FAILED) {
                                      s0 = peg$parsemath_shift();
                                      if (s0 === peg$FAILED) {
                                        s0 = peg$currPos;
                                        if (input.length > peg$currPos) {
                                          s1 = input.charAt(peg$currPos);
                                          peg$currPos++;
                                        } else {
                                          s1 = peg$FAILED;
                                          if (peg$silentFails === 0) {
                                            peg$fail(peg$e3);
                                          }
                                        }
                                        if (s1 !== peg$FAILED) {
                                          peg$savedPos = s0;
                                          s1 = peg$f4(s1);
                                        }
                                        s0 = s1;
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        return s0;
      }
      function peg$parseparbreak() {
        var s0, s1, s22, s32, s42, s5, s6, s7;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = [];
        s32 = peg$parsesp();
        while (s32 !== peg$FAILED) {
          s22.push(s32);
          s32 = peg$parsesp();
        }
        s32 = peg$parsenl();
        if (s32 !== peg$FAILED) {
          s42 = [];
          s5 = peg$currPos;
          s6 = [];
          s7 = peg$parsesp();
          while (s7 !== peg$FAILED) {
            s6.push(s7);
            s7 = peg$parsesp();
          }
          s7 = peg$parsenl();
          if (s7 !== peg$FAILED) {
            s6 = [s6, s7];
            s5 = s6;
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
          if (s5 !== peg$FAILED) {
            while (s5 !== peg$FAILED) {
              s42.push(s5);
              s5 = peg$currPos;
              s6 = [];
              s7 = peg$parsesp();
              while (s7 !== peg$FAILED) {
                s6.push(s7);
                s7 = peg$parsesp();
              }
              s7 = peg$parsenl();
              if (s7 !== peg$FAILED) {
                s6 = [s6, s7];
                s5 = s6;
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            }
          } else {
            s42 = peg$FAILED;
          }
          if (s42 !== peg$FAILED) {
            s5 = [];
            s6 = peg$parsesp();
            while (s6 !== peg$FAILED) {
              s5.push(s6);
              s6 = peg$parsesp();
            }
            s6 = peg$currPos;
            peg$silentFails++;
            s7 = peg$parsecomment_start();
            peg$silentFails--;
            if (s7 === peg$FAILED) {
              s6 = void 0;
            } else {
              peg$currPos = s6;
              s6 = peg$FAILED;
            }
            if (s6 !== peg$FAILED) {
              s22 = [s22, s32, s42, s5, s6];
              s1 = s22;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
          s1 = peg$currPos;
          s22 = [];
          s32 = peg$parsesp();
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parsesp();
          }
          s32 = peg$parsenl();
          if (s32 !== peg$FAILED) {
            s42 = [];
            s5 = peg$currPos;
            s6 = [];
            s7 = peg$parsesp();
            while (s7 !== peg$FAILED) {
              s6.push(s7);
              s7 = peg$parsesp();
            }
            s7 = peg$parsenl();
            if (s7 !== peg$FAILED) {
              s6 = [s6, s7];
              s5 = s6;
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
            if (s5 !== peg$FAILED) {
              while (s5 !== peg$FAILED) {
                s42.push(s5);
                s5 = peg$currPos;
                s6 = [];
                s7 = peg$parsesp();
                while (s7 !== peg$FAILED) {
                  s6.push(s7);
                  s7 = peg$parsesp();
                }
                s7 = peg$parsenl();
                if (s7 !== peg$FAILED) {
                  s6 = [s6, s7];
                  s5 = s6;
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              }
            } else {
              s42 = peg$FAILED;
            }
            if (s42 !== peg$FAILED) {
              s22 = [s22, s32, s42];
              s1 = s22;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f5();
        }
        s0 = s1;
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e4);
          }
        }
        return s0;
      }
      function peg$parsemath_token() {
        var s0, s1, s22, s32, s42;
        peg$silentFails++;
        s0 = peg$parsespecial_macro();
        if (s0 === peg$FAILED) {
          s0 = peg$parsemacro();
          if (s0 === peg$FAILED) {
            s0 = peg$parsefull_comment();
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = [];
              s22 = peg$parsewhitespace();
              while (s22 !== peg$FAILED) {
                s1.push(s22);
                s22 = peg$parsewhitespace();
              }
              s22 = peg$parsegroup();
              if (s22 !== peg$FAILED) {
                s32 = [];
                s42 = peg$parsewhitespace();
                while (s42 !== peg$FAILED) {
                  s32.push(s42);
                  s42 = peg$parsewhitespace();
                }
                peg$savedPos = s0;
                s0 = peg$f6(s22);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = [];
                s22 = peg$parsewhitespace();
                while (s22 !== peg$FAILED) {
                  s1.push(s22);
                  s22 = peg$parsewhitespace();
                }
                s22 = peg$parsealignment_tab();
                if (s22 !== peg$FAILED) {
                  s32 = [];
                  s42 = peg$parsewhitespace();
                  while (s42 !== peg$FAILED) {
                    s32.push(s42);
                    s42 = peg$parsewhitespace();
                  }
                  peg$savedPos = s0;
                  s0 = peg$f7(s22);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
                if (s0 === peg$FAILED) {
                  s0 = peg$parsemacro_parameter();
                  if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    s1 = [];
                    s22 = peg$parsewhitespace();
                    while (s22 !== peg$FAILED) {
                      s1.push(s22);
                      s22 = peg$parsewhitespace();
                    }
                    s22 = peg$parsesuperscript();
                    if (s22 !== peg$FAILED) {
                      s32 = [];
                      s42 = peg$parsewhitespace();
                      while (s42 !== peg$FAILED) {
                        s32.push(s42);
                        s42 = peg$parsewhitespace();
                      }
                      peg$savedPos = s0;
                      s0 = peg$f8();
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                    if (s0 === peg$FAILED) {
                      s0 = peg$currPos;
                      s1 = [];
                      s22 = peg$parsewhitespace();
                      while (s22 !== peg$FAILED) {
                        s1.push(s22);
                        s22 = peg$parsewhitespace();
                      }
                      s22 = peg$parsesubscript();
                      if (s22 !== peg$FAILED) {
                        s32 = [];
                        s42 = peg$parsewhitespace();
                        while (s42 !== peg$FAILED) {
                          s32.push(s42);
                          s42 = peg$parsewhitespace();
                        }
                        peg$savedPos = s0;
                        s0 = peg$f9();
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                      if (s0 === peg$FAILED) {
                        s0 = peg$parseignore();
                        if (s0 === peg$FAILED) {
                          s0 = peg$parsewhitespace();
                          if (s0 === peg$FAILED) {
                            s0 = peg$currPos;
                            if (input.length > peg$currPos) {
                              s1 = input.charAt(peg$currPos);
                              peg$currPos++;
                            } else {
                              s1 = peg$FAILED;
                              if (peg$silentFails === 0) {
                                peg$fail(peg$e3);
                              }
                            }
                            if (s1 !== peg$FAILED) {
                              peg$savedPos = s0;
                              s1 = peg$f10(s1);
                            }
                            s0 = s1;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e5);
          }
        }
        return s0;
      }
      function peg$parsenonchar_token() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parseescape();
        if (s0 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 37) {
            s0 = peg$c0;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e7);
            }
          }
          if (s0 === peg$FAILED) {
            s0 = peg$parsebegin_group();
            if (s0 === peg$FAILED) {
              s0 = peg$parseend_group();
              if (s0 === peg$FAILED) {
                s0 = peg$parsemath_shift();
                if (s0 === peg$FAILED) {
                  s0 = peg$parsealignment_tab();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parsenl();
                    if (s0 === peg$FAILED) {
                      s0 = peg$parsemacro_parameter();
                      if (s0 === peg$FAILED) {
                        s0 = peg$parseignore();
                        if (s0 === peg$FAILED) {
                          s0 = peg$parsesp();
                          if (s0 === peg$FAILED) {
                            s0 = peg$parsepunctuation();
                            if (s0 === peg$FAILED) {
                              s0 = peg$parseEOF();
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e6);
          }
        }
        return s0;
      }
      function peg$parsewhitespace() {
        var s0, s1, s22, s32, s42, s5, s6, s7;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$parsenl();
        if (s22 !== peg$FAILED) {
          s32 = [];
          s42 = peg$parsesp();
          while (s42 !== peg$FAILED) {
            s32.push(s42);
            s42 = peg$parsesp();
          }
          s22 = [s22, s32];
          s1 = s22;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
          s1 = peg$currPos;
          s22 = [];
          s32 = peg$parsesp();
          if (s32 !== peg$FAILED) {
            while (s32 !== peg$FAILED) {
              s22.push(s32);
              s32 = peg$parsesp();
            }
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s32 = peg$parsenl();
            if (s32 !== peg$FAILED) {
              s42 = peg$currPos;
              peg$silentFails++;
              s5 = peg$parsecomment_start();
              peg$silentFails--;
              if (s5 === peg$FAILED) {
                s42 = void 0;
              } else {
                peg$currPos = s42;
                s42 = peg$FAILED;
              }
              if (s42 !== peg$FAILED) {
                s5 = [];
                s6 = peg$parsesp();
                while (s6 !== peg$FAILED) {
                  s5.push(s6);
                  s6 = peg$parsesp();
                }
                s6 = peg$currPos;
                peg$silentFails++;
                s7 = peg$parsenl();
                peg$silentFails--;
                if (s7 === peg$FAILED) {
                  s6 = void 0;
                } else {
                  peg$currPos = s6;
                  s6 = peg$FAILED;
                }
                if (s6 !== peg$FAILED) {
                  s22 = [s22, s32, s42, s5, s6];
                  s1 = s22;
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 === peg$FAILED) {
            s1 = [];
            s22 = peg$parsesp();
            if (s22 !== peg$FAILED) {
              while (s22 !== peg$FAILED) {
                s1.push(s22);
                s22 = peg$parsesp();
              }
            } else {
              s1 = peg$FAILED;
            }
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f11();
        }
        s0 = s1;
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e8);
          }
        }
        return s0;
      }
      function peg$parsenumber() {
        var s0, s1, s22, s32, s42, s5;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = [];
        s32 = peg$parsenum();
        if (s32 !== peg$FAILED) {
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parsenum();
          }
        } else {
          s22 = peg$FAILED;
        }
        if (s22 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 46) {
            s32 = peg$c1;
            peg$currPos++;
          } else {
            s32 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e10);
            }
          }
          if (s32 !== peg$FAILED) {
            s42 = [];
            s5 = peg$parsenum();
            if (s5 !== peg$FAILED) {
              while (s5 !== peg$FAILED) {
                s42.push(s5);
                s5 = peg$parsenum();
              }
            } else {
              s42 = peg$FAILED;
            }
            if (s42 !== peg$FAILED) {
              peg$savedPos = s1;
              s1 = peg$f12(s22, s42);
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
          s1 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 46) {
            s22 = peg$c1;
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e10);
            }
          }
          if (s22 !== peg$FAILED) {
            s32 = [];
            s42 = peg$parsenum();
            if (s42 !== peg$FAILED) {
              while (s42 !== peg$FAILED) {
                s32.push(s42);
                s42 = peg$parsenum();
              }
            } else {
              s32 = peg$FAILED;
            }
            if (s32 !== peg$FAILED) {
              peg$savedPos = s1;
              s1 = peg$f13(s32);
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 === peg$FAILED) {
            s1 = peg$currPos;
            s22 = [];
            s32 = peg$parsenum();
            if (s32 !== peg$FAILED) {
              while (s32 !== peg$FAILED) {
                s22.push(s32);
                s32 = peg$parsenum();
              }
            } else {
              s22 = peg$FAILED;
            }
            if (s22 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 46) {
                s32 = peg$c1;
                peg$currPos++;
              } else {
                s32 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e10);
                }
              }
              if (s32 !== peg$FAILED) {
                peg$savedPos = s1;
                s1 = peg$f14(s22);
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f15(s1);
        }
        s0 = s1;
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e9);
          }
        }
        return s0;
      }
      function peg$parsespecial_macro() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8, s9;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parseescape();
        if (s1 !== peg$FAILED) {
          if (input.substr(peg$currPos, 5) === peg$c2) {
            s22 = peg$c2;
            peg$currPos += 5;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e12);
            }
          }
          if (s22 === peg$FAILED) {
            if (input.substr(peg$currPos, 4) === peg$c3) {
              s22 = peg$c3;
              peg$currPos += 4;
            } else {
              s22 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e13);
              }
            }
          }
          if (s22 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s32 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s32 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e3);
              }
            }
            if (s32 !== peg$FAILED) {
              s42 = [];
              s5 = peg$currPos;
              s6 = peg$currPos;
              peg$silentFails++;
              s7 = peg$currPos;
              if (input.length > peg$currPos) {
                s8 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s8 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e3);
                }
              }
              if (s8 !== peg$FAILED) {
                peg$savedPos = peg$currPos;
                s9 = peg$f16(s22, s32, s8);
                if (s9) {
                  s9 = void 0;
                } else {
                  s9 = peg$FAILED;
                }
                if (s9 !== peg$FAILED) {
                  s8 = [s8, s9];
                  s7 = s8;
                } else {
                  peg$currPos = s7;
                  s7 = peg$FAILED;
                }
              } else {
                peg$currPos = s7;
                s7 = peg$FAILED;
              }
              peg$silentFails--;
              if (s7 === peg$FAILED) {
                s6 = void 0;
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
              if (s6 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                  s7 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e3);
                  }
                }
                if (s7 !== peg$FAILED) {
                  peg$savedPos = s5;
                  s5 = peg$f17(s22, s32, s7);
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
              while (s5 !== peg$FAILED) {
                s42.push(s5);
                s5 = peg$currPos;
                s6 = peg$currPos;
                peg$silentFails++;
                s7 = peg$currPos;
                if (input.length > peg$currPos) {
                  s8 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s8 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e3);
                  }
                }
                if (s8 !== peg$FAILED) {
                  peg$savedPos = peg$currPos;
                  s9 = peg$f16(s22, s32, s8);
                  if (s9) {
                    s9 = void 0;
                  } else {
                    s9 = peg$FAILED;
                  }
                  if (s9 !== peg$FAILED) {
                    s8 = [s8, s9];
                    s7 = s8;
                  } else {
                    peg$currPos = s7;
                    s7 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s7;
                  s7 = peg$FAILED;
                }
                peg$silentFails--;
                if (s7 === peg$FAILED) {
                  s6 = void 0;
                } else {
                  peg$currPos = s6;
                  s6 = peg$FAILED;
                }
                if (s6 !== peg$FAILED) {
                  if (input.length > peg$currPos) {
                    s7 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e3);
                    }
                  }
                  if (s7 !== peg$FAILED) {
                    peg$savedPos = s5;
                    s5 = peg$f17(s22, s32, s7);
                  } else {
                    peg$currPos = s5;
                    s5 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              }
              s5 = peg$currPos;
              if (input.length > peg$currPos) {
                s6 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e3);
                }
              }
              if (s6 !== peg$FAILED) {
                peg$savedPos = peg$currPos;
                s7 = peg$f18(s22, s32, s42, s6);
                if (s7) {
                  s7 = void 0;
                } else {
                  s7 = peg$FAILED;
                }
                if (s7 !== peg$FAILED) {
                  s6 = [s6, s7];
                  s5 = s6;
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f19(s22, s32, s42);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$parseverbatim_environment();
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsebegin_display_math();
            if (s1 !== peg$FAILED) {
              s22 = [];
              s32 = peg$currPos;
              s42 = peg$currPos;
              peg$silentFails++;
              s5 = peg$parseend_display_math();
              peg$silentFails--;
              if (s5 === peg$FAILED) {
                s42 = void 0;
              } else {
                peg$currPos = s42;
                s42 = peg$FAILED;
              }
              if (s42 !== peg$FAILED) {
                s5 = peg$parsemath_token();
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s32;
                  s32 = peg$f20(s5);
                } else {
                  peg$currPos = s32;
                  s32 = peg$FAILED;
                }
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
              while (s32 !== peg$FAILED) {
                s22.push(s32);
                s32 = peg$currPos;
                s42 = peg$currPos;
                peg$silentFails++;
                s5 = peg$parseend_display_math();
                peg$silentFails--;
                if (s5 === peg$FAILED) {
                  s42 = void 0;
                } else {
                  peg$currPos = s42;
                  s42 = peg$FAILED;
                }
                if (s42 !== peg$FAILED) {
                  s5 = peg$parsemath_token();
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s32;
                    s32 = peg$f20(s5);
                  } else {
                    peg$currPos = s32;
                    s32 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s32;
                  s32 = peg$FAILED;
                }
              }
              s32 = peg$parseend_display_math();
              if (s32 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f21(s22);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parsebegin_inline_math();
              if (s1 !== peg$FAILED) {
                s22 = [];
                s32 = peg$currPos;
                s42 = peg$currPos;
                peg$silentFails++;
                s5 = peg$parseend_inline_math();
                peg$silentFails--;
                if (s5 === peg$FAILED) {
                  s42 = void 0;
                } else {
                  peg$currPos = s42;
                  s42 = peg$FAILED;
                }
                if (s42 !== peg$FAILED) {
                  s5 = peg$parsemath_token();
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s32;
                    s32 = peg$f22(s5);
                  } else {
                    peg$currPos = s32;
                    s32 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s32;
                  s32 = peg$FAILED;
                }
                while (s32 !== peg$FAILED) {
                  s22.push(s32);
                  s32 = peg$currPos;
                  s42 = peg$currPos;
                  peg$silentFails++;
                  s5 = peg$parseend_inline_math();
                  peg$silentFails--;
                  if (s5 === peg$FAILED) {
                    s42 = void 0;
                  } else {
                    peg$currPos = s42;
                    s42 = peg$FAILED;
                  }
                  if (s42 !== peg$FAILED) {
                    s5 = peg$parsemath_token();
                    if (s5 !== peg$FAILED) {
                      peg$savedPos = s32;
                      s32 = peg$f22(s5);
                    } else {
                      peg$currPos = s32;
                      s32 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s32;
                    s32 = peg$FAILED;
                  }
                }
                s32 = peg$parseend_inline_math();
                if (s32 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s0 = peg$f23(s22);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parsemath_shift();
                if (s1 !== peg$FAILED) {
                  s22 = peg$parsemath_shift();
                  if (s22 !== peg$FAILED) {
                    s32 = [];
                    s42 = peg$currPos;
                    s5 = peg$currPos;
                    peg$silentFails++;
                    s6 = peg$currPos;
                    s7 = peg$parsemath_shift();
                    if (s7 !== peg$FAILED) {
                      s8 = peg$parsemath_shift();
                      if (s8 !== peg$FAILED) {
                        s7 = [s7, s8];
                        s6 = s7;
                      } else {
                        peg$currPos = s6;
                        s6 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s6;
                      s6 = peg$FAILED;
                    }
                    peg$silentFails--;
                    if (s6 === peg$FAILED) {
                      s5 = void 0;
                    } else {
                      peg$currPos = s5;
                      s5 = peg$FAILED;
                    }
                    if (s5 !== peg$FAILED) {
                      s6 = peg$parsemath_token();
                      if (s6 !== peg$FAILED) {
                        peg$savedPos = s42;
                        s42 = peg$f24(s6);
                      } else {
                        peg$currPos = s42;
                        s42 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s42;
                      s42 = peg$FAILED;
                    }
                    while (s42 !== peg$FAILED) {
                      s32.push(s42);
                      s42 = peg$currPos;
                      s5 = peg$currPos;
                      peg$silentFails++;
                      s6 = peg$currPos;
                      s7 = peg$parsemath_shift();
                      if (s7 !== peg$FAILED) {
                        s8 = peg$parsemath_shift();
                        if (s8 !== peg$FAILED) {
                          s7 = [s7, s8];
                          s6 = s7;
                        } else {
                          peg$currPos = s6;
                          s6 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s6;
                        s6 = peg$FAILED;
                      }
                      peg$silentFails--;
                      if (s6 === peg$FAILED) {
                        s5 = void 0;
                      } else {
                        peg$currPos = s5;
                        s5 = peg$FAILED;
                      }
                      if (s5 !== peg$FAILED) {
                        s6 = peg$parsemath_token();
                        if (s6 !== peg$FAILED) {
                          peg$savedPos = s42;
                          s42 = peg$f24(s6);
                        } else {
                          peg$currPos = s42;
                          s42 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s42;
                        s42 = peg$FAILED;
                      }
                    }
                    s42 = peg$parsemath_shift();
                    if (s42 !== peg$FAILED) {
                      s5 = peg$parsemath_shift();
                      if (s5 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s0 = peg$f25(s32);
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
                if (s0 === peg$FAILED) {
                  s0 = peg$parsemath_environment();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parseenvironment();
                  }
                }
              }
            }
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e11);
          }
        }
        return s0;
      }
      function peg$parseverbatim_environment() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8, s9, s10, s11;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parsebegin_env();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsebegin_group();
          if (s22 !== peg$FAILED) {
            s32 = peg$parseverbatim_env_name();
            if (s32 !== peg$FAILED) {
              s42 = peg$parseend_group();
              if (s42 !== peg$FAILED) {
                s5 = [];
                s6 = peg$currPos;
                s7 = peg$currPos;
                peg$silentFails++;
                s8 = peg$currPos;
                s9 = peg$parseend_env();
                if (s9 !== peg$FAILED) {
                  s10 = peg$parsegroup();
                  if (s10 !== peg$FAILED) {
                    peg$savedPos = peg$currPos;
                    s11 = peg$f26(s32, s10);
                    if (s11) {
                      s11 = void 0;
                    } else {
                      s11 = peg$FAILED;
                    }
                    if (s11 !== peg$FAILED) {
                      s9 = [s9, s10, s11];
                      s8 = s9;
                    } else {
                      peg$currPos = s8;
                      s8 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s8;
                    s8 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s8;
                  s8 = peg$FAILED;
                }
                peg$silentFails--;
                if (s8 === peg$FAILED) {
                  s7 = void 0;
                } else {
                  peg$currPos = s7;
                  s7 = peg$FAILED;
                }
                if (s7 !== peg$FAILED) {
                  if (input.length > peg$currPos) {
                    s8 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s8 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e3);
                    }
                  }
                  if (s8 !== peg$FAILED) {
                    peg$savedPos = s6;
                    s6 = peg$f27(s32, s8);
                  } else {
                    peg$currPos = s6;
                    s6 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s6;
                  s6 = peg$FAILED;
                }
                while (s6 !== peg$FAILED) {
                  s5.push(s6);
                  s6 = peg$currPos;
                  s7 = peg$currPos;
                  peg$silentFails++;
                  s8 = peg$currPos;
                  s9 = peg$parseend_env();
                  if (s9 !== peg$FAILED) {
                    s10 = peg$parsegroup();
                    if (s10 !== peg$FAILED) {
                      peg$savedPos = peg$currPos;
                      s11 = peg$f26(s32, s10);
                      if (s11) {
                        s11 = void 0;
                      } else {
                        s11 = peg$FAILED;
                      }
                      if (s11 !== peg$FAILED) {
                        s9 = [s9, s10, s11];
                        s8 = s9;
                      } else {
                        peg$currPos = s8;
                        s8 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s8;
                      s8 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s8;
                    s8 = peg$FAILED;
                  }
                  peg$silentFails--;
                  if (s8 === peg$FAILED) {
                    s7 = void 0;
                  } else {
                    peg$currPos = s7;
                    s7 = peg$FAILED;
                  }
                  if (s7 !== peg$FAILED) {
                    if (input.length > peg$currPos) {
                      s8 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s8 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e3);
                      }
                    }
                    if (s8 !== peg$FAILED) {
                      peg$savedPos = s6;
                      s6 = peg$f27(s32, s8);
                    } else {
                      peg$currPos = s6;
                      s6 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s6;
                    s6 = peg$FAILED;
                  }
                }
                s6 = peg$parseend_env();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parsebegin_group();
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parseverbatim_env_name();
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parseend_group();
                      if (s9 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s0 = peg$f28(s32, s5);
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e14);
          }
        }
        return s0;
      }
      function peg$parseverbatim_env_name() {
        var s0;
        if (input.substr(peg$currPos, 9) === peg$c4) {
          s0 = peg$c4;
          peg$currPos += 9;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e15);
          }
        }
        if (s0 === peg$FAILED) {
          if (input.substr(peg$currPos, 8) === peg$c5) {
            s0 = peg$c5;
            peg$currPos += 8;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e16);
            }
          }
          if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 13) === peg$c6) {
              s0 = peg$c6;
              peg$currPos += 13;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e17);
              }
            }
            if (s0 === peg$FAILED) {
              if (input.substr(peg$currPos, 12) === peg$c7) {
                s0 = peg$c7;
                peg$currPos += 12;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e18);
                }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 7) === peg$c8) {
                  s0 = peg$c8;
                  peg$currPos += 7;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e19);
                  }
                }
                if (s0 === peg$FAILED) {
                  if (input.substr(peg$currPos, 10) === peg$c9) {
                    s0 = peg$c9;
                    peg$currPos += 10;
                  } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e20);
                    }
                  }
                }
              }
            }
          }
        }
        return s0;
      }
      function peg$parsemacro() {
        var s0, s1, s22, s32, s42;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$parseescape();
        if (s22 !== peg$FAILED) {
          s32 = [];
          s42 = peg$parsechar();
          if (s42 !== peg$FAILED) {
            while (s42 !== peg$FAILED) {
              s32.push(s42);
              s42 = peg$parsechar();
            }
          } else {
            s32 = peg$FAILED;
          }
          if (s32 !== peg$FAILED) {
            peg$savedPos = s1;
            s1 = peg$f29(s32);
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
          s1 = peg$currPos;
          s22 = peg$parseescape();
          if (s22 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s32 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s32 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e3);
              }
            }
            if (s32 !== peg$FAILED) {
              peg$savedPos = s1;
              s1 = peg$f30(s32);
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f31(s1);
        }
        s0 = s1;
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e21);
          }
        }
        return s0;
      }
      function peg$parsegroup() {
        var s0, s1, s22, s32, s42, s5;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parsebegin_group();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$currPos;
          s42 = peg$currPos;
          peg$silentFails++;
          s5 = peg$parseend_group();
          peg$silentFails--;
          if (s5 === peg$FAILED) {
            s42 = void 0;
          } else {
            peg$currPos = s42;
            s42 = peg$FAILED;
          }
          if (s42 !== peg$FAILED) {
            s5 = peg$parsetoken();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s32;
              s32 = peg$f32(s5);
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          } else {
            peg$currPos = s32;
            s32 = peg$FAILED;
          }
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$currPos;
            s42 = peg$currPos;
            peg$silentFails++;
            s5 = peg$parseend_group();
            peg$silentFails--;
            if (s5 === peg$FAILED) {
              s42 = void 0;
            } else {
              peg$currPos = s42;
              s42 = peg$FAILED;
            }
            if (s42 !== peg$FAILED) {
              s5 = peg$parsetoken();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s32;
                s32 = peg$f32(s5);
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          }
          s32 = peg$parseend_group();
          if (s32 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f33(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e22);
          }
        }
        return s0;
      }
      function peg$parsegroup_contents_as_string() {
        var s0, s1;
        s0 = peg$currPos;
        s1 = peg$parsegroup();
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f34(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parseenvironment() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8, s9, s10;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parsebegin_env();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsegroup_contents_as_string();
          if (s22 !== peg$FAILED) {
            s32 = peg$parsesameline_comment();
            if (s32 === peg$FAILED) {
              s32 = null;
            }
            s42 = [];
            s5 = peg$currPos;
            s6 = peg$currPos;
            peg$silentFails++;
            s7 = peg$currPos;
            s8 = peg$parseend_env();
            if (s8 !== peg$FAILED) {
              s9 = peg$parsegroup_contents_as_string();
              if (s9 !== peg$FAILED) {
                peg$savedPos = peg$currPos;
                s10 = peg$f35(s22, s32, s9);
                if (s10) {
                  s10 = void 0;
                } else {
                  s10 = peg$FAILED;
                }
                if (s10 !== peg$FAILED) {
                  s8 = [s8, s9, s10];
                  s7 = s8;
                } else {
                  peg$currPos = s7;
                  s7 = peg$FAILED;
                }
              } else {
                peg$currPos = s7;
                s7 = peg$FAILED;
              }
            } else {
              peg$currPos = s7;
              s7 = peg$FAILED;
            }
            peg$silentFails--;
            if (s7 === peg$FAILED) {
              s6 = void 0;
            } else {
              peg$currPos = s6;
              s6 = peg$FAILED;
            }
            if (s6 !== peg$FAILED) {
              s7 = peg$parsetoken();
              if (s7 !== peg$FAILED) {
                peg$savedPos = s5;
                s5 = peg$f36(s22, s32, s7);
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
            while (s5 !== peg$FAILED) {
              s42.push(s5);
              s5 = peg$currPos;
              s6 = peg$currPos;
              peg$silentFails++;
              s7 = peg$currPos;
              s8 = peg$parseend_env();
              if (s8 !== peg$FAILED) {
                s9 = peg$parsegroup_contents_as_string();
                if (s9 !== peg$FAILED) {
                  peg$savedPos = peg$currPos;
                  s10 = peg$f35(s22, s32, s9);
                  if (s10) {
                    s10 = void 0;
                  } else {
                    s10 = peg$FAILED;
                  }
                  if (s10 !== peg$FAILED) {
                    s8 = [s8, s9, s10];
                    s7 = s8;
                  } else {
                    peg$currPos = s7;
                    s7 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s7;
                  s7 = peg$FAILED;
                }
              } else {
                peg$currPos = s7;
                s7 = peg$FAILED;
              }
              peg$silentFails--;
              if (s7 === peg$FAILED) {
                s6 = void 0;
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
              if (s6 !== peg$FAILED) {
                s7 = peg$parsetoken();
                if (s7 !== peg$FAILED) {
                  peg$savedPos = s5;
                  s5 = peg$f36(s22, s32, s7);
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            }
            s5 = peg$parseend_env();
            if (s5 !== peg$FAILED) {
              s6 = peg$parsegroup_contents_as_string();
              if (s6 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f37(s22, s32, s42);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e23);
          }
        }
        return s0;
      }
      function peg$parsemath_environment() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8, s9, s10, s11, s12;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parsebegin_env();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsebegin_group();
          if (s22 !== peg$FAILED) {
            s32 = peg$parsemath_env_name();
            if (s32 !== peg$FAILED) {
              s42 = peg$parseend_group();
              if (s42 !== peg$FAILED) {
                s5 = peg$parsesameline_comment();
                if (s5 === peg$FAILED) {
                  s5 = null;
                }
                s6 = [];
                s7 = peg$currPos;
                s8 = peg$currPos;
                peg$silentFails++;
                s9 = peg$currPos;
                s10 = peg$parseend_env();
                if (s10 !== peg$FAILED) {
                  s11 = peg$parsegroup();
                  if (s11 !== peg$FAILED) {
                    peg$savedPos = peg$currPos;
                    s12 = peg$f38(s32, s5, s11);
                    if (s12) {
                      s12 = void 0;
                    } else {
                      s12 = peg$FAILED;
                    }
                    if (s12 !== peg$FAILED) {
                      s10 = [s10, s11, s12];
                      s9 = s10;
                    } else {
                      peg$currPos = s9;
                      s9 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s9;
                    s9 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s9;
                  s9 = peg$FAILED;
                }
                peg$silentFails--;
                if (s9 === peg$FAILED) {
                  s8 = void 0;
                } else {
                  peg$currPos = s8;
                  s8 = peg$FAILED;
                }
                if (s8 !== peg$FAILED) {
                  s9 = peg$parsemath_token();
                  if (s9 !== peg$FAILED) {
                    peg$savedPos = s7;
                    s7 = peg$f39(s32, s5, s9);
                  } else {
                    peg$currPos = s7;
                    s7 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s7;
                  s7 = peg$FAILED;
                }
                while (s7 !== peg$FAILED) {
                  s6.push(s7);
                  s7 = peg$currPos;
                  s8 = peg$currPos;
                  peg$silentFails++;
                  s9 = peg$currPos;
                  s10 = peg$parseend_env();
                  if (s10 !== peg$FAILED) {
                    s11 = peg$parsegroup();
                    if (s11 !== peg$FAILED) {
                      peg$savedPos = peg$currPos;
                      s12 = peg$f38(s32, s5, s11);
                      if (s12) {
                        s12 = void 0;
                      } else {
                        s12 = peg$FAILED;
                      }
                      if (s12 !== peg$FAILED) {
                        s10 = [s10, s11, s12];
                        s9 = s10;
                      } else {
                        peg$currPos = s9;
                        s9 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s9;
                      s9 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s9;
                    s9 = peg$FAILED;
                  }
                  peg$silentFails--;
                  if (s9 === peg$FAILED) {
                    s8 = void 0;
                  } else {
                    peg$currPos = s8;
                    s8 = peg$FAILED;
                  }
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parsemath_token();
                    if (s9 !== peg$FAILED) {
                      peg$savedPos = s7;
                      s7 = peg$f39(s32, s5, s9);
                    } else {
                      peg$currPos = s7;
                      s7 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s7;
                    s7 = peg$FAILED;
                  }
                }
                s7 = peg$parseend_env();
                if (s7 !== peg$FAILED) {
                  s8 = peg$parsebegin_group();
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parsemath_env_name();
                    if (s9 !== peg$FAILED) {
                      s10 = peg$parseend_group();
                      if (s10 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s0 = peg$f40(s32, s5, s6);
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e24);
          }
        }
        return s0;
      }
      function peg$parsemath_group() {
        var s0, s1, s22, s32, s42, s5;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parsebegin_group();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$currPos;
          s42 = peg$currPos;
          peg$silentFails++;
          s5 = peg$parseend_group();
          peg$silentFails--;
          if (s5 === peg$FAILED) {
            s42 = void 0;
          } else {
            peg$currPos = s42;
            s42 = peg$FAILED;
          }
          if (s42 !== peg$FAILED) {
            s5 = peg$parsemath_token();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s32;
              s32 = peg$f41(s5);
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          } else {
            peg$currPos = s32;
            s32 = peg$FAILED;
          }
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$currPos;
            s42 = peg$currPos;
            peg$silentFails++;
            s5 = peg$parseend_group();
            peg$silentFails--;
            if (s5 === peg$FAILED) {
              s42 = void 0;
            } else {
              peg$currPos = s42;
              s42 = peg$FAILED;
            }
            if (s42 !== peg$FAILED) {
              s5 = peg$parsemath_token();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s32;
                s32 = peg$f41(s5);
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          }
          s32 = peg$parseend_group();
          if (s32 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f42(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e25);
          }
        }
        return s0;
      }
      function peg$parsebegin_display_math() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parseescape();
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 91) {
            s22 = peg$c10;
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e26);
            }
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseend_display_math() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parseescape();
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 93) {
            s22 = peg$c11;
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e27);
            }
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsebegin_inline_math() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parseescape();
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 40) {
            s22 = peg$c12;
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e28);
            }
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseend_inline_math() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parseescape();
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 41) {
            s22 = peg$c13;
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e29);
            }
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsebegin_env() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parseescape();
        if (s1 !== peg$FAILED) {
          if (input.substr(peg$currPos, 5) === peg$c14) {
            s22 = peg$c14;
            peg$currPos += 5;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e30);
            }
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseend_env() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parseescape();
        if (s1 !== peg$FAILED) {
          if (input.substr(peg$currPos, 3) === peg$c15) {
            s22 = peg$c15;
            peg$currPos += 3;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e31);
            }
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsemath_env_name() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 9) === peg$c16) {
          s1 = peg$c16;
          peg$currPos += 9;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e32);
          }
        }
        if (s1 === peg$FAILED) {
          if (input.substr(peg$currPos, 8) === peg$c17) {
            s1 = peg$c17;
            peg$currPos += 8;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e33);
            }
          }
          if (s1 === peg$FAILED) {
            if (input.substr(peg$currPos, 6) === peg$c18) {
              s1 = peg$c18;
              peg$currPos += 6;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e34);
              }
            }
            if (s1 === peg$FAILED) {
              if (input.substr(peg$currPos, 5) === peg$c19) {
                s1 = peg$c19;
                peg$currPos += 5;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e35);
                }
              }
              if (s1 === peg$FAILED) {
                if (input.substr(peg$currPos, 8) === peg$c20) {
                  s1 = peg$c20;
                  peg$currPos += 8;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e36);
                  }
                }
                if (s1 === peg$FAILED) {
                  if (input.substr(peg$currPos, 7) === peg$c21) {
                    s1 = peg$c21;
                    peg$currPos += 7;
                  } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e37);
                    }
                  }
                  if (s1 === peg$FAILED) {
                    if (input.substr(peg$currPos, 7) === peg$c22) {
                      s1 = peg$c22;
                      peg$currPos += 7;
                    } else {
                      s1 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e38);
                      }
                    }
                    if (s1 === peg$FAILED) {
                      if (input.substr(peg$currPos, 6) === peg$c23) {
                        s1 = peg$c23;
                        peg$currPos += 6;
                      } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$e39);
                        }
                      }
                      if (s1 === peg$FAILED) {
                        if (input.substr(peg$currPos, 9) === peg$c24) {
                          s1 = peg$c24;
                          peg$currPos += 9;
                        } else {
                          s1 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$e40);
                          }
                        }
                        if (s1 === peg$FAILED) {
                          if (input.substr(peg$currPos, 8) === peg$c25) {
                            s1 = peg$c25;
                            peg$currPos += 8;
                          } else {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) {
                              peg$fail(peg$e41);
                            }
                          }
                          if (s1 === peg$FAILED) {
                            if (input.substr(peg$currPos, 8) === peg$c26) {
                              s1 = peg$c26;
                              peg$currPos += 8;
                            } else {
                              s1 = peg$FAILED;
                              if (peg$silentFails === 0) {
                                peg$fail(peg$e42);
                              }
                            }
                            if (s1 === peg$FAILED) {
                              if (input.substr(peg$currPos, 7) === peg$c27) {
                                s1 = peg$c27;
                                peg$currPos += 7;
                              } else {
                                s1 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                  peg$fail(peg$e43);
                                }
                              }
                              if (s1 === peg$FAILED) {
                                if (input.substr(peg$currPos, 5) === peg$c28) {
                                  s1 = peg$c28;
                                  peg$currPos += 5;
                                } else {
                                  s1 = peg$FAILED;
                                  if (peg$silentFails === 0) {
                                    peg$fail(peg$e44);
                                  }
                                }
                                if (s1 === peg$FAILED) {
                                  if (input.substr(peg$currPos, 4) === peg$c29) {
                                    s1 = peg$c29;
                                    peg$currPos += 4;
                                  } else {
                                    s1 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                      peg$fail(peg$e45);
                                    }
                                  }
                                  if (s1 === peg$FAILED) {
                                    if (input.substr(peg$currPos, 11) === peg$c30) {
                                      s1 = peg$c30;
                                      peg$currPos += 11;
                                    } else {
                                      s1 = peg$FAILED;
                                      if (peg$silentFails === 0) {
                                        peg$fail(peg$e46);
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f43(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parseescape() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 92) {
          s1 = peg$c31;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e48);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f44();
        }
        s0 = s1;
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e47);
          }
        }
        return s0;
      }
      function peg$parsebegin_group() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 123) {
          s1 = peg$c32;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e49);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f45(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parseend_group() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 125) {
          s1 = peg$c33;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e50);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f46(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parsemath_shift() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 36) {
          s1 = peg$c34;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e51);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f47(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parsealignment_tab() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 38) {
          s1 = peg$c35;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e52);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f48(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parsenl() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 13) {
          s22 = peg$c36;
          peg$currPos++;
        } else {
          s22 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e54);
          }
        }
        peg$silentFails--;
        if (s22 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 10) {
            s22 = peg$c37;
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e55);
            }
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 13) {
            s0 = peg$c36;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e54);
            }
          }
          if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c38) {
              s0 = peg$c38;
              peg$currPos += 2;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e56);
              }
            }
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e53);
          }
        }
        return s0;
      }
      function peg$parsemacro_parameter() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 35) {
          s1 = peg$c39;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e57);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f49(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parsesuperscript() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 94) {
          s1 = peg$c40;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e58);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f50(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parsesubscript() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 95) {
          s1 = peg$c41;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e59);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f51(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parseignore() {
        var s0;
        if (input.charCodeAt(peg$currPos) === 0) {
          s0 = peg$c42;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e60);
          }
        }
        return s0;
      }
      function peg$parsesp() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        if (peg$r0.test(input.charAt(peg$currPos))) {
          s22 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s22 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e61);
          }
        }
        if (s22 !== peg$FAILED) {
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            if (peg$r0.test(input.charAt(peg$currPos))) {
              s22 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s22 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e61);
              }
            }
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f52();
        }
        s0 = s1;
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e8);
          }
        }
        return s0;
      }
      function peg$parsechar() {
        var s0, s1;
        peg$silentFails++;
        if (peg$r1.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e63);
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e62);
          }
        }
        return s0;
      }
      function peg$parsenum() {
        var s0, s1;
        peg$silentFails++;
        if (peg$r2.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e65);
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e64);
          }
        }
        return s0;
      }
      function peg$parsepunctuation() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$currPos;
        if (peg$r3.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e67);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f53(s1);
        }
        s0 = s1;
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e66);
          }
        }
        return s0;
      }
      function peg$parsecomment_start() {
        var s0;
        if (input.charCodeAt(peg$currPos) === 37) {
          s0 = peg$c0;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e7);
          }
        }
        return s0;
      }
      function peg$parsefull_comment() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parseownline_comment();
        if (s0 === peg$FAILED) {
          s0 = peg$parsesameline_comment();
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e68);
          }
        }
        return s0;
      }
      function peg$parseownline_comment() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = [];
        s32 = peg$parsesp();
        while (s32 !== peg$FAILED) {
          s22.push(s32);
          s32 = peg$parsesp();
        }
        s32 = peg$parsenl();
        if (s32 !== peg$FAILED) {
          s22 = [s22, s32];
          s1 = s22;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
          s1 = null;
        }
        s22 = peg$parseleading_sp();
        if (s22 !== peg$FAILED) {
          s32 = peg$parsecomment();
          if (s32 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f54(s22, s32);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsesameline_comment() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsesp();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parsesp();
        }
        s22 = peg$parsecomment();
        if (s22 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f55(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecomment() {
        var s0, s1, s22, s32, s42, s5, s6, s7;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parsecomment_start();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$currPos;
          s42 = peg$currPos;
          peg$silentFails++;
          s5 = peg$parsenl();
          peg$silentFails--;
          if (s5 === peg$FAILED) {
            s42 = void 0;
          } else {
            peg$currPos = s42;
            s42 = peg$FAILED;
          }
          if (s42 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s5 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e3);
              }
            }
            if (s5 !== peg$FAILED) {
              peg$savedPos = s32;
              s32 = peg$f56(s5);
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          } else {
            peg$currPos = s32;
            s32 = peg$FAILED;
          }
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$currPos;
            s42 = peg$currPos;
            peg$silentFails++;
            s5 = peg$parsenl();
            peg$silentFails--;
            if (s5 === peg$FAILED) {
              s42 = void 0;
            } else {
              peg$currPos = s42;
              s42 = peg$FAILED;
            }
            if (s42 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s5 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e3);
                }
              }
              if (s5 !== peg$FAILED) {
                peg$savedPos = s32;
                s32 = peg$f56(s5);
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          }
          s32 = peg$currPos;
          peg$silentFails++;
          s42 = peg$parseparbreak();
          peg$silentFails--;
          if (s42 !== peg$FAILED) {
            peg$currPos = s32;
            s32 = void 0;
          } else {
            s32 = peg$FAILED;
          }
          if (s32 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f57(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsecomment_start();
          if (s1 !== peg$FAILED) {
            s22 = [];
            s32 = peg$currPos;
            s42 = peg$currPos;
            peg$silentFails++;
            s5 = peg$parsenl();
            peg$silentFails--;
            if (s5 === peg$FAILED) {
              s42 = void 0;
            } else {
              peg$currPos = s42;
              s42 = peg$FAILED;
            }
            if (s42 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s5 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e3);
                }
              }
              if (s5 !== peg$FAILED) {
                peg$savedPos = s32;
                s32 = peg$f58(s5);
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
            while (s32 !== peg$FAILED) {
              s22.push(s32);
              s32 = peg$currPos;
              s42 = peg$currPos;
              peg$silentFails++;
              s5 = peg$parsenl();
              peg$silentFails--;
              if (s5 === peg$FAILED) {
                s42 = void 0;
              } else {
                peg$currPos = s42;
                s42 = peg$FAILED;
              }
              if (s42 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                  s5 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e3);
                  }
                }
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s32;
                  s32 = peg$f58(s5);
                } else {
                  peg$currPos = s32;
                  s32 = peg$FAILED;
                }
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
            }
            s32 = peg$currPos;
            s42 = peg$parsenl();
            if (s42 !== peg$FAILED) {
              s5 = [];
              s6 = peg$parsesp();
              while (s6 !== peg$FAILED) {
                s5.push(s6);
                s6 = peg$parsesp();
              }
              s6 = peg$currPos;
              peg$silentFails++;
              s7 = peg$parsecomment_start();
              peg$silentFails--;
              if (s7 === peg$FAILED) {
                s6 = void 0;
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
              if (s6 !== peg$FAILED) {
                s42 = [s42, s5, s6];
                s32 = s42;
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
            if (s32 === peg$FAILED) {
              s32 = peg$parsenl();
              if (s32 === peg$FAILED) {
                s32 = peg$parseEOF();
              }
            }
            if (s32 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f59(s22);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e69);
          }
        }
        return s0;
      }
      function peg$parseleading_sp() {
        var s0, s1, s22, s32, s42;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$parsestart_of_line();
        if (s22 !== peg$FAILED) {
          s32 = [];
          s42 = peg$parsesp();
          while (s42 !== peg$FAILED) {
            s32.push(s42);
            s42 = peg$parsesp();
          }
          s22 = [s22, s32];
          s1 = s22;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }
        return s0;
      }
      function peg$parsestart_of_line() {
        var s0;
        peg$savedPos = peg$currPos;
        s0 = peg$f60();
        if (s0) {
          s0 = void 0;
        } else {
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseEOF() {
        var s0, s1;
        s0 = peg$currPos;
        peg$silentFails++;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        peg$silentFails--;
        if (s1 === peg$FAILED) {
          s0 = void 0;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function toString(e) {
        if (typeof e === "string") {
          return e;
        }
        if (typeof e.content === "string") {
          return e.content;
        }
        if (e && e.type === "whitespace") {
          return " ";
        }
        return e;
      }
      function compare_env(g1, g2) {
        const g1Name = typeof g1 === "string" ? g1 : g1.content.map(toString).join("");
        const g2Name = typeof g2 === "string" ? g2 : g2.content.map(toString).join("");
        return g1Name === g2Name;
      }
      function createNode(type, extra = {}) {
        return { type, ...extra, position: location() };
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(
          peg$maxFailExpected,
          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
      }
    }
    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }()
);
var align_environment_default4 = (
  // Generated by Peggy 2.0.1.
  //
  // https://peggyjs.org/
  function() {
    "use strict";
    function peg$subclass(child, parent) {
      function C() {
        this.constructor = child;
      }
      C.prototype = parent.prototype;
      child.prototype = new C();
    }
    function peg$SyntaxError(message, expected, found, location) {
      var self = Error.call(this, message);
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(self, peg$SyntaxError.prototype);
      }
      self.expected = expected;
      self.found = found;
      self.location = location;
      self.name = "SyntaxError";
      return self;
    }
    peg$subclass(peg$SyntaxError, Error);
    function peg$padEnd(str, targetLength, padString) {
      padString = padString || " ";
      if (str.length > targetLength) {
        return str;
      }
      targetLength -= str.length;
      padString += padString.repeat(targetLength);
      return str + padString.slice(0, targetLength);
    }
    peg$SyntaxError.prototype.format = function(sources) {
      var str = "Error: " + this.message;
      if (this.location) {
        var src = null;
        var k;
        for (k = 0; k < sources.length; k++) {
          if (sources[k].source === this.location.source) {
            src = sources[k].text.split(/\r\n|\n|\r/g);
            break;
          }
        }
        var s5 = this.location.start;
        var loc = this.location.source + ":" + s5.line + ":" + s5.column;
        if (src) {
          var e = this.location.end;
          var filler = peg$padEnd("", s5.line.toString().length, " ");
          var line = src[s5.line - 1];
          var last = s5.line === e.line ? e.column : line.length + 1;
          var hatLen = last - s5.column || 1;
          str += "\n --> " + loc + "\n" + filler + " |\n" + s5.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s5.column - 1, " ") + peg$padEnd("", hatLen, "^");
        } else {
          str += "\n at " + loc;
        }
      }
      return str;
    };
    peg$SyntaxError.buildMessage = function(expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        class: function(expectation) {
          var escapedParts = expectation.parts.map(function(part) {
            return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
          });
          return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
        },
        any: function() {
          return "any character";
        },
        end: function() {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        }
      };
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s5) {
        return s5.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function classEscape(s5) {
        return s5.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = expected2.map(describeExpectation);
        var i, j;
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {};
      var peg$source = options.grammarSource;
      var peg$startRuleFunctions = { body: peg$parsebody };
      var peg$startRuleFunction = peg$parsebody;
      var peg$e0 = peg$anyExpectation();
      var peg$f0 = function() {
        return [];
      };
      var peg$f1 = function(x) {
        return { cells: [], colSeps: [], ...x };
      };
      var peg$f2 = function(rowItems, rowSep, trailingComment) {
        return { ...rowItems, rowSep, trailingComment };
      };
      var peg$f3 = function(rowItems, trailingComment) {
        return { ...rowItems, rowSep: null, trailingComment };
      };
      var peg$f4 = function(x) {
        return x;
      };
      var peg$f5 = function(x) {
        return {
          cells: [],
          colSeps: [],
          rowSep: null,
          trailingComment: x
        };
      };
      var peg$f6 = function(x) {
        return x;
      };
      var peg$f7 = function(colSep, cell) {
        return { colSep, cell };
      };
      var peg$f8 = function(colSep) {
        return { colSep };
      };
      var peg$f9 = function(a, b) {
        return processRow(a, b);
      };
      var peg$f10 = function(b) {
        return processRow(null, b);
      };
      var peg$f11 = function(tok) {
        return options.isSameLineComment(tok);
      };
      var peg$f12 = function(tok) {
        return tok;
      };
      var peg$f13 = function(tok) {
        return options.isOwnLineComment(tok);
      };
      var peg$f14 = function(tok) {
        return tok;
      };
      var peg$f15 = function(tok) {
        return options.isWhitespace(tok);
      };
      var peg$f16 = function(tok) {
        return tok;
      };
      var peg$f17 = function(tok) {
        return options.isRowSep(tok);
      };
      var peg$f18 = function(tok) {
        return tok;
      };
      var peg$f19 = function(tok) {
        return options.isColSep(tok);
      };
      var peg$f20 = function(tok) {
        return tok;
      };
      var peg$currPos = 0;
      var peg$savedPos = 0;
      var peg$posDetailsCache = [{ line: 1, column: 1 }];
      var peg$maxFailPos = 0;
      var peg$maxFailExpected = [];
      var peg$silentFails = 0;
      var peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function offset() {
        return peg$savedPos;
      }
      function range() {
        return {
          source: peg$source,
          start: peg$savedPos,
          end: peg$currPos
        };
      }
      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError(
          [peg$otherExpectation(description)],
          input.substring(peg$savedPos, peg$currPos),
          location2
        );
      }
      function error(message, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location2);
      }
      function peg$literalExpectation(text2, ignoreCase) {
        return { type: "literal", text: text2, ignoreCase };
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts, inverted, ignoreCase };
      }
      function peg$anyExpectation() {
        return { type: "any" };
      }
      function peg$endExpectation() {
        return { type: "end" };
      }
      function peg$otherExpectation(description) {
        return { type: "other", description };
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p;
        if (details) {
          return details;
        } else {
          p = pos - 1;
          while (!peg$posDetailsCache[p]) {
            p--;
          }
          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };
          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos);
        var endPosDetails = peg$computePosDetails(endPos);
        return {
          source: peg$source,
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildSimpleError(message, location2) {
        return new peg$SyntaxError(message, null, null, location2);
      }
      function peg$buildStructuredError(expected2, found, location2) {
        return new peg$SyntaxError(
          peg$SyntaxError.buildMessage(expected2, found),
          expected2,
          found,
          location2
        );
      }
      function peg$parsebody() {
        var s0, s1;
        s0 = [];
        s1 = peg$parsecomment_only_line();
        if (s1 === peg$FAILED) {
          s1 = peg$parserow_with_end();
          if (s1 === peg$FAILED) {
            s1 = peg$parserow_without_end();
          }
        }
        if (s1 !== peg$FAILED) {
          while (s1 !== peg$FAILED) {
            s0.push(s1);
            s1 = peg$parsecomment_only_line();
            if (s1 === peg$FAILED) {
              s1 = peg$parserow_with_end();
              if (s1 === peg$FAILED) {
                s1 = peg$parserow_without_end();
              }
            }
          }
        } else {
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseEOL();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f0();
          }
          s0 = s1;
        }
        return s0;
      }
      function peg$parserow_with_end() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$parserow_items();
        if (s22 === peg$FAILED) {
          s22 = null;
        }
        peg$savedPos = s1;
        s22 = peg$f1(s22);
        s1 = s22;
        s22 = peg$parserow_sep();
        if (s22 !== peg$FAILED) {
          s32 = peg$parsetrailing_comment();
          if (s32 === peg$FAILED) {
            s32 = null;
          }
          peg$savedPos = s0;
          s0 = peg$f2(s1, s22, s32);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parserow_without_end() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parserow_items();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsetrailing_comment();
          if (s22 === peg$FAILED) {
            s22 = null;
          }
          peg$savedPos = s0;
          s0 = peg$f3(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsetrailing_comment() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsewhitespace();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parsewhitespace();
        }
        s22 = peg$parsesame_line_comment();
        if (s22 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f4(s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecomment_only_line() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsewhitespace();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parsewhitespace();
        }
        s22 = peg$parseown_line_comment();
        if (s22 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f5(s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsetoken() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        s22 = peg$parserow_sep();
        if (s22 === peg$FAILED) {
          s22 = peg$parsecol_sep();
          if (s22 === peg$FAILED) {
            s22 = peg$parsetrailing_comment();
            if (s22 === peg$FAILED) {
              s22 = peg$parseown_line_comment();
            }
          }
        }
        peg$silentFails--;
        if (s22 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s22 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f6(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecell() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsetoken();
        if (s22 !== peg$FAILED) {
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            s22 = peg$parsetoken();
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }
        return s0;
      }
      function peg$parseseparated_cell() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parsecol_sep();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsecell();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f7(s1, s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsecol_sep();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f8(s1);
          }
          s0 = s1;
        }
        return s0;
      }
      function peg$parserow_items() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$parsecell();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$parseseparated_cell();
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parseseparated_cell();
          }
          peg$savedPos = s0;
          s0 = peg$f9(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = [];
          s22 = peg$parseseparated_cell();
          if (s22 !== peg$FAILED) {
            while (s22 !== peg$FAILED) {
              s1.push(s22);
              s22 = peg$parseseparated_cell();
            }
          } else {
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f10(s1);
          }
          s0 = s1;
        }
        return s0;
      }
      function peg$parsesame_line_comment() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f11(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f12(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseown_line_comment() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f13(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f14(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsewhitespace() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f15(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f16(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parserow_sep() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f17(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f18(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecol_sep() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f19(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f20(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseEOL() {
        var s0, s1;
        s0 = peg$currPos;
        peg$silentFails++;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        peg$silentFails--;
        if (s1 === peg$FAILED) {
          s0 = void 0;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function processRow(leadCell, otherCells) {
        const cells = [leadCell || []];
        const seps = [];
        for (const x of otherCells) {
          cells.push(x.cell || []);
          seps.push(x.colSep);
        }
        return { cells, colSeps: seps };
      }
      if (!options.isWhitespace) {
        try {
          Object.assign(
            options,
            createMatchers(["\\", "hline", "cr"], ["&"])
          );
        } catch (e) {
          console.warn("Error when initializing parser", e);
        }
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(
          peg$maxFailExpected,
          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
      }
    }
    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }()
);
var xparse_argspec_default4 = (
  // Generated by Peggy 2.0.1.
  //
  // https://peggyjs.org/
  function() {
    "use strict";
    function peg$subclass(child, parent) {
      function C() {
        this.constructor = child;
      }
      C.prototype = parent.prototype;
      child.prototype = new C();
    }
    function peg$SyntaxError(message, expected, found, location) {
      var self = Error.call(this, message);
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(self, peg$SyntaxError.prototype);
      }
      self.expected = expected;
      self.found = found;
      self.location = location;
      self.name = "SyntaxError";
      return self;
    }
    peg$subclass(peg$SyntaxError, Error);
    function peg$padEnd(str, targetLength, padString) {
      padString = padString || " ";
      if (str.length > targetLength) {
        return str;
      }
      targetLength -= str.length;
      padString += padString.repeat(targetLength);
      return str + padString.slice(0, targetLength);
    }
    peg$SyntaxError.prototype.format = function(sources) {
      var str = "Error: " + this.message;
      if (this.location) {
        var src = null;
        var k;
        for (k = 0; k < sources.length; k++) {
          if (sources[k].source === this.location.source) {
            src = sources[k].text.split(/\r\n|\n|\r/g);
            break;
          }
        }
        var s5 = this.location.start;
        var loc = this.location.source + ":" + s5.line + ":" + s5.column;
        if (src) {
          var e = this.location.end;
          var filler = peg$padEnd("", s5.line.toString().length, " ");
          var line = src[s5.line - 1];
          var last = s5.line === e.line ? e.column : line.length + 1;
          var hatLen = last - s5.column || 1;
          str += "\n --> " + loc + "\n" + filler + " |\n" + s5.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s5.column - 1, " ") + peg$padEnd("", hatLen, "^");
        } else {
          str += "\n at " + loc;
        }
      }
      return str;
    };
    peg$SyntaxError.buildMessage = function(expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        class: function(expectation) {
          var escapedParts = expectation.parts.map(function(part) {
            return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
          });
          return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
        },
        any: function() {
          return "any character";
        },
        end: function() {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        }
      };
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s5) {
        return s5.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function classEscape(s5) {
        return s5.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = expected2.map(describeExpectation);
        var i, j;
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {};
      var peg$source = options.grammarSource;
      var peg$startRuleFunctions = { args_spec_list: peg$parseargs_spec_list };
      var peg$startRuleFunction = peg$parseargs_spec_list;
      var peg$c0 = "+";
      var peg$c1 = "v";
      var peg$c2 = "b";
      var peg$c3 = "!";
      var peg$c4 = "D";
      var peg$c5 = "d";
      var peg$c6 = "s";
      var peg$c7 = "O";
      var peg$c8 = "o";
      var peg$c9 = "e";
      var peg$c10 = "E";
      var peg$c11 = "t";
      var peg$c12 = "R";
      var peg$c13 = "r";
      var peg$c14 = "u";
      var peg$c15 = "m";
      var peg$c16 = "{";
      var peg$c17 = "}";
      var peg$c18 = " ";
      var peg$c19 = "\n";
      var peg$c20 = "\r";
      var peg$r0 = /^[{ ]/;
      var peg$e0 = peg$literalExpectation("+", false);
      var peg$e1 = peg$literalExpectation("v", false);
      var peg$e2 = peg$anyExpectation();
      var peg$e3 = peg$literalExpectation("b", false);
      var peg$e4 = peg$literalExpectation("!", false);
      var peg$e5 = peg$literalExpectation("D", false);
      var peg$e6 = peg$literalExpectation("d", false);
      var peg$e7 = peg$literalExpectation("s", false);
      var peg$e8 = peg$literalExpectation("O", false);
      var peg$e9 = peg$literalExpectation("o", false);
      var peg$e10 = peg$literalExpectation("e", false);
      var peg$e11 = peg$literalExpectation("E", false);
      var peg$e12 = peg$literalExpectation("t", false);
      var peg$e13 = peg$literalExpectation("R", false);
      var peg$e14 = peg$literalExpectation("r", false);
      var peg$e15 = peg$literalExpectation("u", false);
      var peg$e16 = peg$classExpectation(["{", " "], false, false);
      var peg$e17 = peg$literalExpectation("m", false);
      var peg$e18 = peg$literalExpectation("{", false);
      var peg$e19 = peg$literalExpectation("}", false);
      var peg$e20 = peg$literalExpectation(" ", false);
      var peg$e21 = peg$literalExpectation("\n", false);
      var peg$e22 = peg$literalExpectation("\r", false);
      var peg$f0 = function(x) {
        return x;
      };
      var peg$f1 = function(spec) {
        return spec;
      };
      var peg$f2 = function(spec) {
        return spec;
      };
      var peg$f3 = function(openBrace) {
        return createNode("verbatim", { openBrace, closeBrace: openBrace });
      };
      var peg$f4 = function() {
        return createNode("body");
      };
      var peg$f5 = function(leading_bang, spec) {
        return leading_bang ? { ...spec, noLeadingWhitespace: true } : spec;
      };
      var peg$f6 = function(braceSpec, defaultArg) {
        return createNode("optional", { ...braceSpec, defaultArg });
      };
      var peg$f7 = function(braceSpec) {
        return createNode("optional", braceSpec);
      };
      var peg$f8 = function() {
        return createNode("optionalStar");
      };
      var peg$f9 = function(g) {
        return createNode("optional", { defaultArg: g });
      };
      var peg$f10 = function() {
        return createNode("optional");
      };
      var peg$f11 = function(args) {
        return createNode("embellishment", {
          embellishmentTokens: args.content
        });
      };
      var peg$f12 = function(args, g) {
        return createNode("embellishment", {
          embellishmentTokens: args.content,
          defaultArg: g
        });
      };
      var peg$f13 = function(tok) {
        return createNode("optionalToken", { token: tok });
      };
      var peg$f14 = function(braceSpec, defaultArg) {
        return createNode("mandatory", { ...braceSpec, defaultArg });
      };
      var peg$f15 = function(braceSpec) {
        return createNode("mandatory", braceSpec);
      };
      var peg$f16 = function(stopTokens) {
        return createNode("until", { stopTokens });
      };
      var peg$f17 = function(x) {
        return [x];
      };
      var peg$f18 = function(g) {
        return g.content;
      };
      var peg$f19 = function() {
        return createNode("mandatory");
      };
      var peg$f20 = function(openBrace, closeBrace) {
        return { openBrace, closeBrace };
      };
      var peg$f21 = function(content) {
        return { type: "group", content };
      };
      var peg$f22 = function() {
        return "";
      };
      var peg$currPos = 0;
      var peg$savedPos = 0;
      var peg$posDetailsCache = [{ line: 1, column: 1 }];
      var peg$maxFailPos = 0;
      var peg$maxFailExpected = [];
      var peg$silentFails = 0;
      var peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function offset() {
        return peg$savedPos;
      }
      function range() {
        return {
          source: peg$source,
          start: peg$savedPos,
          end: peg$currPos
        };
      }
      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError(
          [peg$otherExpectation(description)],
          input.substring(peg$savedPos, peg$currPos),
          location2
        );
      }
      function error(message, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location2);
      }
      function peg$literalExpectation(text2, ignoreCase) {
        return { type: "literal", text: text2, ignoreCase };
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts, inverted, ignoreCase };
      }
      function peg$anyExpectation() {
        return { type: "any" };
      }
      function peg$endExpectation() {
        return { type: "end" };
      }
      function peg$otherExpectation(description) {
        return { type: "other", description };
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p;
        if (details) {
          return details;
        } else {
          p = pos - 1;
          while (!peg$posDetailsCache[p]) {
            p--;
          }
          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };
          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos);
        var endPosDetails = peg$computePosDetails(endPos);
        return {
          source: peg$source,
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildSimpleError(message, location2) {
        return new peg$SyntaxError(message, null, null, location2);
      }
      function peg$buildStructuredError(expected2, found, location2) {
        return new peg$SyntaxError(
          peg$SyntaxError.buildMessage(expected2, found),
          expected2,
          found,
          location2
        );
      }
      function peg$parseargs_spec_list() {
        var s0, s1, s22, s32, s42;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$currPos;
        s32 = peg$parsewhitespace();
        s42 = peg$parsearg_spec();
        if (s42 !== peg$FAILED) {
          peg$savedPos = s22;
          s22 = peg$f0(s42);
        } else {
          peg$currPos = s22;
          s22 = peg$FAILED;
        }
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$currPos;
          s32 = peg$parsewhitespace();
          s42 = peg$parsearg_spec();
          if (s42 !== peg$FAILED) {
            peg$savedPos = s22;
            s22 = peg$f0(s42);
          } else {
            peg$currPos = s22;
            s22 = peg$FAILED;
          }
        }
        s22 = peg$parsewhitespace();
        peg$savedPos = s0;
        s0 = peg$f1(s1);
        return s0;
      }
      function peg$parsearg_spec() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 43) {
          s1 = peg$c0;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 === peg$FAILED) {
          s1 = null;
        }
        s22 = peg$parseoptional();
        if (s22 === peg$FAILED) {
          s22 = peg$parsemandatory();
          if (s22 === peg$FAILED) {
            s22 = peg$parseverbatim();
            if (s22 === peg$FAILED) {
              s22 = peg$parserequired();
              if (s22 === peg$FAILED) {
                s22 = peg$parsebody();
                if (s22 === peg$FAILED) {
                  s22 = peg$parseuntil();
                }
              }
            }
          }
        }
        if (s22 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f2(s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseverbatim() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 118) {
          s1 = peg$c1;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e1);
          }
        }
        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s22 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f3(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsebody() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 98) {
          s1 = peg$c2;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f4();
        }
        s0 = s1;
        return s0;
      }
      function peg$parseoptional() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 33) {
          s1 = peg$c3;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e4);
          }
        }
        if (s1 === peg$FAILED) {
          s1 = null;
        }
        s22 = peg$parseoptional_star();
        if (s22 === peg$FAILED) {
          s22 = peg$parseoptional_standard();
          if (s22 === peg$FAILED) {
            s22 = peg$parseoptional_delimited();
            if (s22 === peg$FAILED) {
              s22 = peg$parseoptional_embellishment();
              if (s22 === peg$FAILED) {
                s22 = peg$parseoptional_token();
              }
            }
          }
        }
        if (s22 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f5(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseoptional_delimited() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 68) {
          s1 = peg$c4;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e5);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parsebrace_spec();
          s32 = peg$parsebraced_group();
          if (s32 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f6(s22, s32);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 100) {
            s1 = peg$c5;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e6);
            }
          }
          if (s1 !== peg$FAILED) {
            s22 = peg$parsebrace_spec();
            peg$savedPos = s0;
            s0 = peg$f7(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        return s0;
      }
      function peg$parseoptional_star() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 115) {
          s1 = peg$c6;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e7);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f8();
        }
        s0 = s1;
        return s0;
      }
      function peg$parseoptional_standard() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 79) {
          s1 = peg$c7;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e8);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parsebraced_group();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f9(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 111) {
            s1 = peg$c8;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e9);
            }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f10();
          }
          s0 = s1;
        }
        return s0;
      }
      function peg$parseoptional_embellishment() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 101) {
          s1 = peg$c9;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e10);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parsebraced_group();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f11(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 69) {
            s1 = peg$c10;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e11);
            }
          }
          if (s1 !== peg$FAILED) {
            s22 = peg$parsebraced_group();
            if (s22 !== peg$FAILED) {
              s32 = peg$parsebraced_group();
              if (s32 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f12(s22, s32);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        return s0;
      }
      function peg$parseoptional_token() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 116) {
          s1 = peg$c11;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e12);
          }
        }
        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s22 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f13(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parserequired() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 82) {
          s1 = peg$c12;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e13);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parsebrace_spec();
          s32 = peg$parsebraced_group();
          if (s32 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f14(s22, s32);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 114) {
            s1 = peg$c13;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e14);
            }
          }
          if (s1 !== peg$FAILED) {
            s22 = peg$parsebrace_spec();
            peg$savedPos = s0;
            s0 = peg$f15(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        return s0;
      }
      function peg$parseuntil() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 117) {
          s1 = peg$c14;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e15);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parseuntil_stop_token();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f16(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseuntil_stop_token() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        if (peg$r0.test(input.charAt(peg$currPos))) {
          s22 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s22 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e16);
          }
        }
        peg$silentFails--;
        if (s22 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s22 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f17(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsebraced_group();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f18(s1);
          }
          s0 = s1;
        }
        return s0;
      }
      function peg$parsemandatory() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 109) {
          s1 = peg$c15;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e17);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f19();
        }
        s0 = s1;
        return s0;
      }
      function peg$parsebrace_spec() {
        var s0, s1, s22, s32, s42, s5;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$currPos;
        s32 = peg$currPos;
        peg$silentFails++;
        s42 = peg$parsewhitespace_token();
        peg$silentFails--;
        if (s42 === peg$FAILED) {
          s32 = void 0;
        } else {
          peg$currPos = s32;
          s32 = peg$FAILED;
        }
        if (s32 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s42 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s42 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          if (s42 !== peg$FAILED) {
            s32 = [s32, s42];
            s22 = s32;
          } else {
            peg$currPos = s22;
            s22 = peg$FAILED;
          }
        } else {
          peg$currPos = s22;
          s22 = peg$FAILED;
        }
        if (s22 === peg$FAILED) {
          s22 = null;
        }
        s1 = input.substring(s1, peg$currPos);
        s22 = peg$currPos;
        s32 = peg$currPos;
        s42 = peg$currPos;
        peg$silentFails++;
        s5 = peg$parsewhitespace_token();
        peg$silentFails--;
        if (s5 === peg$FAILED) {
          s42 = void 0;
        } else {
          peg$currPos = s42;
          s42 = peg$FAILED;
        }
        if (s42 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          if (s5 !== peg$FAILED) {
            s42 = [s42, s5];
            s32 = s42;
          } else {
            peg$currPos = s32;
            s32 = peg$FAILED;
          }
        } else {
          peg$currPos = s32;
          s32 = peg$FAILED;
        }
        if (s32 === peg$FAILED) {
          s32 = null;
        }
        s22 = input.substring(s22, peg$currPos);
        peg$savedPos = s0;
        s0 = peg$f20(s1, s22);
        return s0;
      }
      function peg$parsebraced_group() {
        var s0, s1, s22, s32, s42, s5, s6, s7;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 123) {
          s1 = peg$c16;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e18);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$currPos;
          s42 = peg$currPos;
          s5 = peg$currPos;
          peg$silentFails++;
          if (input.charCodeAt(peg$currPos) === 125) {
            s6 = peg$c17;
            peg$currPos++;
          } else {
            s6 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e19);
            }
          }
          peg$silentFails--;
          if (s6 === peg$FAILED) {
            s5 = void 0;
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$currPos;
            peg$silentFails++;
            s7 = peg$parsebraced_group();
            peg$silentFails--;
            if (s7 === peg$FAILED) {
              s6 = void 0;
            } else {
              peg$currPos = s6;
              s6 = peg$FAILED;
            }
            if (s6 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s7 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s7 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e2);
                }
              }
              if (s7 !== peg$FAILED) {
                s5 = [s5, s6, s7];
                s42 = s5;
              } else {
                peg$currPos = s42;
                s42 = peg$FAILED;
              }
            } else {
              peg$currPos = s42;
              s42 = peg$FAILED;
            }
          } else {
            peg$currPos = s42;
            s42 = peg$FAILED;
          }
          if (s42 !== peg$FAILED) {
            s32 = input.substring(s32, peg$currPos);
          } else {
            s32 = s42;
          }
          if (s32 === peg$FAILED) {
            s32 = peg$parsebraced_group();
          }
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$currPos;
            s42 = peg$currPos;
            s5 = peg$currPos;
            peg$silentFails++;
            if (input.charCodeAt(peg$currPos) === 125) {
              s6 = peg$c17;
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e19);
              }
            }
            peg$silentFails--;
            if (s6 === peg$FAILED) {
              s5 = void 0;
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$currPos;
              peg$silentFails++;
              s7 = peg$parsebraced_group();
              peg$silentFails--;
              if (s7 === peg$FAILED) {
                s6 = void 0;
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
              if (s6 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                  s7 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e2);
                  }
                }
                if (s7 !== peg$FAILED) {
                  s5 = [s5, s6, s7];
                  s42 = s5;
                } else {
                  peg$currPos = s42;
                  s42 = peg$FAILED;
                }
              } else {
                peg$currPos = s42;
                s42 = peg$FAILED;
              }
            } else {
              peg$currPos = s42;
              s42 = peg$FAILED;
            }
            if (s42 !== peg$FAILED) {
              s32 = input.substring(s32, peg$currPos);
            } else {
              s32 = s42;
            }
            if (s32 === peg$FAILED) {
              s32 = peg$parsebraced_group();
            }
          }
          if (input.charCodeAt(peg$currPos) === 125) {
            s32 = peg$c17;
            peg$currPos++;
          } else {
            s32 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e19);
            }
          }
          if (s32 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f21(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsewhitespace() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsewhitespace_token();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parsewhitespace_token();
        }
        peg$savedPos = s0;
        s1 = peg$f22();
        s0 = s1;
        return s0;
      }
      function peg$parsewhitespace_token() {
        var s0;
        if (input.charCodeAt(peg$currPos) === 32) {
          s0 = peg$c18;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e20);
          }
        }
        if (s0 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 10) {
            s0 = peg$c19;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e21);
            }
          }
          if (s0 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 13) {
              s0 = peg$c20;
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e22);
              }
            }
          }
        }
        return s0;
      }
      const DEFAULT_OPTIONS = {
        optional: { openBrace: "[", closeBrace: "]" },
        mandatory: { openBrace: "{", closeBrace: "}" }
      };
      function createNode(type, options2) {
        const computedOptions = DEFAULT_OPTIONS[type] || {};
        return { type, ...computedOptions, ...options2 };
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(
          peg$maxFailExpected,
          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
      }
    }
    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }()
);
var pgfkeys_default4 = (
  // Generated by Peggy 2.0.1.
  //
  // https://peggyjs.org/
  function() {
    "use strict";
    function peg$subclass(child, parent) {
      function C() {
        this.constructor = child;
      }
      C.prototype = parent.prototype;
      child.prototype = new C();
    }
    function peg$SyntaxError(message, expected, found, location) {
      var self = Error.call(this, message);
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(self, peg$SyntaxError.prototype);
      }
      self.expected = expected;
      self.found = found;
      self.location = location;
      self.name = "SyntaxError";
      return self;
    }
    peg$subclass(peg$SyntaxError, Error);
    function peg$padEnd(str, targetLength, padString) {
      padString = padString || " ";
      if (str.length > targetLength) {
        return str;
      }
      targetLength -= str.length;
      padString += padString.repeat(targetLength);
      return str + padString.slice(0, targetLength);
    }
    peg$SyntaxError.prototype.format = function(sources) {
      var str = "Error: " + this.message;
      if (this.location) {
        var src = null;
        var k;
        for (k = 0; k < sources.length; k++) {
          if (sources[k].source === this.location.source) {
            src = sources[k].text.split(/\r\n|\n|\r/g);
            break;
          }
        }
        var s5 = this.location.start;
        var loc = this.location.source + ":" + s5.line + ":" + s5.column;
        if (src) {
          var e = this.location.end;
          var filler = peg$padEnd("", s5.line.toString().length, " ");
          var line = src[s5.line - 1];
          var last = s5.line === e.line ? e.column : line.length + 1;
          var hatLen = last - s5.column || 1;
          str += "\n --> " + loc + "\n" + filler + " |\n" + s5.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s5.column - 1, " ") + peg$padEnd("", hatLen, "^");
        } else {
          str += "\n at " + loc;
        }
      }
      return str;
    };
    peg$SyntaxError.buildMessage = function(expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        class: function(expectation) {
          var escapedParts = expectation.parts.map(function(part) {
            return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
          });
          return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
        },
        any: function() {
          return "any character";
        },
        end: function() {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        }
      };
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s5) {
        return s5.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function classEscape(s5) {
        return s5.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = expected2.map(describeExpectation);
        var i, j;
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {};
      var peg$source = options.grammarSource;
      var peg$startRuleFunctions = { body: peg$parsebody };
      var peg$startRuleFunction = peg$parsebody;
      var peg$e0 = peg$anyExpectation();
      var peg$f0 = function() {
        return [];
      };
      var peg$f1 = function(rowItems, trailingComment) {
        return {
          itemParts: [],
          ...rowItems,
          trailingComment,
          trailingComma: true
        };
      };
      var peg$f2 = function(rowItems, trailingComment) {
        return { ...rowItems, trailingComment };
      };
      var peg$f3 = function(a, b) {
        return processItem(a, b);
      };
      var peg$f4 = function(b) {
        return processItem(null, b);
      };
      var peg$f5 = function(cell) {
        return { cell };
      };
      var peg$f6 = function() {
        return {};
      };
      var peg$f7 = function(part) {
        return part;
      };
      var peg$f8 = function(x) {
        return x;
      };
      var peg$f9 = function(space, x) {
        return {
          trailingComment: x,
          leadingParbreak: space.parbreak > 0
        };
      };
      var peg$f10 = function(list) {
        return {
          whitespace: list.filter((x) => options.isWhitespace(x)).length,
          parbreak: list.filter((x) => options.isParbreak(x)).length
        };
      };
      var peg$f11 = function() {
        return !options.allowParenGroups;
      };
      var peg$f12 = function(tok) {
        return options.isSameLineComment(tok);
      };
      var peg$f13 = function(tok) {
        return tok;
      };
      var peg$f14 = function(tok) {
        return options.isOwnLineComment(tok);
      };
      var peg$f15 = function(tok) {
        return tok;
      };
      var peg$f16 = function(tok) {
        return options.isWhitespace(tok);
      };
      var peg$f17 = function(tok) {
        return tok;
      };
      var peg$f18 = function(tok) {
        return options.isParbreak(tok);
      };
      var peg$f19 = function(tok) {
        return tok;
      };
      var peg$f20 = function(tok) {
        return options.isComma(tok);
      };
      var peg$f21 = function(tok) {
        return tok;
      };
      var peg$f22 = function(tok) {
        return options.isEquals(tok);
      };
      var peg$f23 = function(tok) {
        return tok;
      };
      var peg$f24 = function(tok) {
        return options.isChar(tok, "(");
      };
      var peg$f25 = function(tok) {
        return tok;
      };
      var peg$f26 = function(tok) {
        return options.isChar(tok, ")");
      };
      var peg$f27 = function(tok) {
        return tok;
      };
      var peg$currPos = 0;
      var peg$savedPos = 0;
      var peg$posDetailsCache = [{ line: 1, column: 1 }];
      var peg$maxFailPos = 0;
      var peg$maxFailExpected = [];
      var peg$silentFails = 0;
      var peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function offset() {
        return peg$savedPos;
      }
      function range() {
        return {
          source: peg$source,
          start: peg$savedPos,
          end: peg$currPos
        };
      }
      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError(
          [peg$otherExpectation(description)],
          input.substring(peg$savedPos, peg$currPos),
          location2
        );
      }
      function error(message, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location2);
      }
      function peg$literalExpectation(text2, ignoreCase) {
        return { type: "literal", text: text2, ignoreCase };
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts, inverted, ignoreCase };
      }
      function peg$anyExpectation() {
        return { type: "any" };
      }
      function peg$endExpectation() {
        return { type: "end" };
      }
      function peg$otherExpectation(description) {
        return { type: "other", description };
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p;
        if (details) {
          return details;
        } else {
          p = pos - 1;
          while (!peg$posDetailsCache[p]) {
            p--;
          }
          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };
          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos);
        var endPosDetails = peg$computePosDetails(endPos);
        return {
          source: peg$source,
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildSimpleError(message, location2) {
        return new peg$SyntaxError(message, null, null, location2);
      }
      function peg$buildStructuredError(expected2, found, location2) {
        return new peg$SyntaxError(
          peg$SyntaxError.buildMessage(expected2, found),
          expected2,
          found,
          location2
        );
      }
      function peg$parsebody() {
        var s0, s1, s22;
        s0 = [];
        s1 = peg$parsecomment_only_line();
        if (s1 === peg$FAILED) {
          s1 = peg$parseitem_with_end();
          if (s1 === peg$FAILED) {
            s1 = peg$parseitem_without_end();
          }
        }
        if (s1 !== peg$FAILED) {
          while (s1 !== peg$FAILED) {
            s0.push(s1);
            s1 = peg$parsecomment_only_line();
            if (s1 === peg$FAILED) {
              s1 = peg$parseitem_with_end();
              if (s1 === peg$FAILED) {
                s1 = peg$parseitem_without_end();
              }
            }
          }
        } else {
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = [];
          s22 = peg$parsewhitespace();
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            s22 = peg$parsewhitespace();
          }
          s22 = peg$parseEOL();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f0();
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        return s0;
      }
      function peg$parseitem_with_end() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8;
        s0 = peg$currPos;
        s1 = peg$parsewhitespace_or_parbreaks();
        s22 = peg$parserow_items();
        if (s22 === peg$FAILED) {
          s22 = null;
        }
        s32 = peg$parsewhitespace_or_parbreaks();
        s42 = peg$parseitem_sep();
        if (s42 !== peg$FAILED) {
          s5 = [];
          s6 = peg$parsewhitespace();
          while (s6 !== peg$FAILED) {
            s5.push(s6);
            s6 = peg$parsewhitespace();
          }
          s6 = peg$parsetrailing_comment();
          if (s6 === peg$FAILED) {
            s6 = null;
          }
          s7 = [];
          s8 = peg$parsewhitespace();
          while (s8 !== peg$FAILED) {
            s7.push(s8);
            s8 = peg$parsewhitespace();
          }
          peg$savedPos = s0;
          s0 = peg$f1(s22, s6);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseitem_without_end() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$parsewhitespace_or_parbreaks();
        s22 = peg$parserow_items();
        if (s22 !== peg$FAILED) {
          s32 = peg$parsetrailing_comment();
          if (s32 === peg$FAILED) {
            s32 = null;
          }
          peg$savedPos = s0;
          s0 = peg$f2(s22, s32);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parserow_items() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$parseitem_part();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$parseseparated_part();
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parseseparated_part();
          }
          peg$savedPos = s0;
          s0 = peg$f3(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = [];
          s22 = peg$parseseparated_part();
          if (s22 !== peg$FAILED) {
            while (s22 !== peg$FAILED) {
              s1.push(s22);
              s22 = peg$parseseparated_part();
            }
          } else {
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f4(s1);
          }
          s0 = s1;
        }
        return s0;
      }
      function peg$parseseparated_part() {
        var s0, s1, s22, s32, s42;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parseparbreak();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parseparbreak();
        }
        s22 = peg$parseequals();
        if (s22 !== peg$FAILED) {
          s32 = [];
          s42 = peg$parseparbreak();
          while (s42 !== peg$FAILED) {
            s32.push(s42);
            s42 = peg$parseparbreak();
          }
          s42 = peg$parseitem_part();
          if (s42 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f5(s42);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = [];
          s22 = peg$parseparbreak();
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            s22 = peg$parseparbreak();
          }
          s22 = peg$parseequals();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f6();
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        return s0;
      }
      function peg$parseitem_part() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8, s9;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsewhitespace();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parsewhitespace();
        }
        s22 = peg$currPos;
        s32 = [];
        s42 = peg$parsenon_whitespace_non_parbreak_token();
        if (s42 === peg$FAILED) {
          s42 = peg$currPos;
          s5 = peg$parsewhitespace();
          if (s5 === peg$FAILED) {
            s5 = peg$parseparbreak();
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$currPos;
            peg$silentFails++;
            s7 = peg$currPos;
            s8 = [];
            s9 = peg$parsewhitespace();
            if (s9 === peg$FAILED) {
              s9 = peg$parseparbreak();
            }
            while (s9 !== peg$FAILED) {
              s8.push(s9);
              s9 = peg$parsewhitespace();
              if (s9 === peg$FAILED) {
                s9 = peg$parseparbreak();
              }
            }
            s9 = peg$parsenon_whitespace_non_parbreak_token();
            if (s9 !== peg$FAILED) {
              s8 = [s8, s9];
              s7 = s8;
            } else {
              peg$currPos = s7;
              s7 = peg$FAILED;
            }
            peg$silentFails--;
            if (s7 !== peg$FAILED) {
              peg$currPos = s6;
              s6 = void 0;
            } else {
              s6 = peg$FAILED;
            }
            if (s6 !== peg$FAILED) {
              s5 = [s5, s6];
              s42 = s5;
            } else {
              peg$currPos = s42;
              s42 = peg$FAILED;
            }
          } else {
            peg$currPos = s42;
            s42 = peg$FAILED;
          }
        }
        if (s42 !== peg$FAILED) {
          while (s42 !== peg$FAILED) {
            s32.push(s42);
            s42 = peg$parsenon_whitespace_non_parbreak_token();
            if (s42 === peg$FAILED) {
              s42 = peg$currPos;
              s5 = peg$parsewhitespace();
              if (s5 === peg$FAILED) {
                s5 = peg$parseparbreak();
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$currPos;
                peg$silentFails++;
                s7 = peg$currPos;
                s8 = [];
                s9 = peg$parsewhitespace();
                if (s9 === peg$FAILED) {
                  s9 = peg$parseparbreak();
                }
                while (s9 !== peg$FAILED) {
                  s8.push(s9);
                  s9 = peg$parsewhitespace();
                  if (s9 === peg$FAILED) {
                    s9 = peg$parseparbreak();
                  }
                }
                s9 = peg$parsenon_whitespace_non_parbreak_token();
                if (s9 !== peg$FAILED) {
                  s8 = [s8, s9];
                  s7 = s8;
                } else {
                  peg$currPos = s7;
                  s7 = peg$FAILED;
                }
                peg$silentFails--;
                if (s7 !== peg$FAILED) {
                  peg$currPos = s6;
                  s6 = void 0;
                } else {
                  s6 = peg$FAILED;
                }
                if (s6 !== peg$FAILED) {
                  s5 = [s5, s6];
                  s42 = s5;
                } else {
                  peg$currPos = s42;
                  s42 = peg$FAILED;
                }
              } else {
                peg$currPos = s42;
                s42 = peg$FAILED;
              }
            }
          }
        } else {
          s32 = peg$FAILED;
        }
        if (s32 !== peg$FAILED) {
          s22 = input.substring(s22, peg$currPos);
        } else {
          s22 = s32;
        }
        if (s22 !== peg$FAILED) {
          s32 = [];
          s42 = peg$parsewhitespace();
          while (s42 !== peg$FAILED) {
            s32.push(s42);
            s42 = peg$parsewhitespace();
          }
          peg$savedPos = s0;
          s0 = peg$f7(s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsetrailing_comment() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsewhitespace();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parsewhitespace();
        }
        s22 = peg$parsesame_line_comment();
        if (s22 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f8(s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecomment_only_line() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parsewhitespace_or_parbreaks();
        s22 = peg$parseown_line_comment();
        if (s22 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f9(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsetoken() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$currPos;
        peg$silentFails++;
        s32 = peg$parsenon_token();
        peg$silentFails--;
        if (s32 === peg$FAILED) {
          s22 = void 0;
        } else {
          peg$currPos = s22;
          s22 = peg$FAILED;
        }
        if (s22 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s32 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s32 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s32 !== peg$FAILED) {
            s22 = [s22, s32];
            s1 = s22;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }
        return s0;
      }
      function peg$parsenon_whitespace_non_parbreak_token() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$currPos;
        peg$silentFails++;
        s32 = peg$parsewhitespace();
        if (s32 === peg$FAILED) {
          s32 = peg$parseparbreak();
        }
        peg$silentFails--;
        if (s32 === peg$FAILED) {
          s22 = void 0;
        } else {
          peg$currPos = s22;
          s22 = peg$FAILED;
        }
        if (s22 !== peg$FAILED) {
          s32 = peg$parseparen_block();
          if (s32 === peg$FAILED) {
            s32 = peg$parsetoken();
          }
          if (s32 !== peg$FAILED) {
            s22 = [s22, s32];
            s1 = s22;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }
        return s0;
      }
      function peg$parsenon_token() {
        var s0;
        s0 = peg$parseitem_sep();
        if (s0 === peg$FAILED) {
          s0 = peg$parseequals();
          if (s0 === peg$FAILED) {
            s0 = peg$parsetrailing_comment();
            if (s0 === peg$FAILED) {
              s0 = peg$parseown_line_comment();
            }
          }
        }
        return s0;
      }
      function peg$parsewhitespace_or_parbreaks() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsewhitespace();
        if (s22 === peg$FAILED) {
          s22 = peg$parseparbreak();
        }
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parsewhitespace();
          if (s22 === peg$FAILED) {
            s22 = peg$parseparbreak();
          }
        }
        peg$savedPos = s0;
        s1 = peg$f10(s1);
        s0 = s1;
        return s0;
      }
      function peg$parseparen_block() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8;
        s0 = peg$currPos;
        peg$savedPos = peg$currPos;
        s1 = peg$f11();
        if (s1) {
          s1 = peg$FAILED;
        } else {
          s1 = void 0;
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$currPos;
          s32 = peg$currPos;
          s42 = peg$parseopen_paren();
          if (s42 !== peg$FAILED) {
            s5 = [];
            s6 = peg$currPos;
            s7 = peg$currPos;
            peg$silentFails++;
            s8 = peg$parseclose_paren();
            peg$silentFails--;
            if (s8 === peg$FAILED) {
              s7 = void 0;
            } else {
              peg$currPos = s7;
              s7 = peg$FAILED;
            }
            if (s7 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s8 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s8 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              if (s8 !== peg$FAILED) {
                s7 = [s7, s8];
                s6 = s7;
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
            } else {
              peg$currPos = s6;
              s6 = peg$FAILED;
            }
            while (s6 !== peg$FAILED) {
              s5.push(s6);
              s6 = peg$currPos;
              s7 = peg$currPos;
              peg$silentFails++;
              s8 = peg$parseclose_paren();
              peg$silentFails--;
              if (s8 === peg$FAILED) {
                s7 = void 0;
              } else {
                peg$currPos = s7;
                s7 = peg$FAILED;
              }
              if (s7 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                  s8 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s8 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e0);
                  }
                }
                if (s8 !== peg$FAILED) {
                  s7 = [s7, s8];
                  s6 = s7;
                } else {
                  peg$currPos = s6;
                  s6 = peg$FAILED;
                }
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
            }
            s6 = peg$parseclose_paren();
            if (s6 !== peg$FAILED) {
              s42 = [s42, s5, s6];
              s32 = s42;
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          } else {
            peg$currPos = s32;
            s32 = peg$FAILED;
          }
          if (s32 !== peg$FAILED) {
            s22 = input.substring(s22, peg$currPos);
          } else {
            s22 = s32;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsesame_line_comment() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f12(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f13(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseown_line_comment() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f14(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f15(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsewhitespace() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f16(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f17(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseparbreak() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f18(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f19(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseitem_sep() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f20(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f21(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseequals() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f22(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f23(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseopen_paren() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f24(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f25(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseclose_paren() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f26(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f27(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseEOL() {
        var s0, s1;
        s0 = peg$currPos;
        peg$silentFails++;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        peg$silentFails--;
        if (s1 === peg$FAILED) {
          s0 = void 0;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function processItem(leadCell, otherCells) {
        const cells = [leadCell || []];
        for (const x of otherCells) {
          cells.push(x.cell || []);
        }
        return { itemParts: cells };
      }
      if (!options.isWhitespace) {
        try {
          Object.assign(options, {
            isChar: (node, char) => node.type === "string" && node.content === char,
            isComma(node) {
              return node.type === "string" && node.content === ",";
            },
            isEquals(node) {
              return node.type === "string" && node.content === "=";
            },
            isParbreak(node) {
              return node.type === "parbreak";
            },
            isWhitespace(node) {
              return node.type === "whitespace";
            },
            isSameLineComment: (node) => node.type === "comment" && node.sameline,
            isOwnLineComment: (node) => node.type === "comment" && !node.sameline,
            isComment: (node) => node.type === "comment",
            allowParenGroups: true
          });
        } catch (e) {
          console.warn("Error when initializing parser", e);
        }
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(
          peg$maxFailExpected,
          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
      }
    }
    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }()
);
var macro_substitutions_default4 = (
  // Generated by Peggy 2.0.1.
  //
  // https://peggyjs.org/
  function() {
    "use strict";
    function peg$subclass(child, parent) {
      function C() {
        this.constructor = child;
      }
      C.prototype = parent.prototype;
      child.prototype = new C();
    }
    function peg$SyntaxError(message, expected, found, location) {
      var self = Error.call(this, message);
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(self, peg$SyntaxError.prototype);
      }
      self.expected = expected;
      self.found = found;
      self.location = location;
      self.name = "SyntaxError";
      return self;
    }
    peg$subclass(peg$SyntaxError, Error);
    function peg$padEnd(str, targetLength, padString) {
      padString = padString || " ";
      if (str.length > targetLength) {
        return str;
      }
      targetLength -= str.length;
      padString += padString.repeat(targetLength);
      return str + padString.slice(0, targetLength);
    }
    peg$SyntaxError.prototype.format = function(sources) {
      var str = "Error: " + this.message;
      if (this.location) {
        var src = null;
        var k;
        for (k = 0; k < sources.length; k++) {
          if (sources[k].source === this.location.source) {
            src = sources[k].text.split(/\r\n|\n|\r/g);
            break;
          }
        }
        var s5 = this.location.start;
        var loc = this.location.source + ":" + s5.line + ":" + s5.column;
        if (src) {
          var e = this.location.end;
          var filler = peg$padEnd("", s5.line.toString().length, " ");
          var line = src[s5.line - 1];
          var last = s5.line === e.line ? e.column : line.length + 1;
          var hatLen = last - s5.column || 1;
          str += "\n --> " + loc + "\n" + filler + " |\n" + s5.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s5.column - 1, " ") + peg$padEnd("", hatLen, "^");
        } else {
          str += "\n at " + loc;
        }
      }
      return str;
    };
    peg$SyntaxError.buildMessage = function(expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        class: function(expectation) {
          var escapedParts = expectation.parts.map(function(part) {
            return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
          });
          return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
        },
        any: function() {
          return "any character";
        },
        end: function() {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        }
      };
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s5) {
        return s5.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function classEscape(s5) {
        return s5.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = expected2.map(describeExpectation);
        var i, j;
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {};
      var peg$source = options.grammarSource;
      var peg$startRuleFunctions = { body: peg$parsebody };
      var peg$startRuleFunction = peg$parsebody;
      var peg$e0 = peg$anyExpectation();
      var peg$f0 = function(e) {
        return [].concat(...e).filter((n) => !!n);
      };
      var peg$f1 = function() {
        return [];
      };
      var peg$f2 = function(tok) {
        return options.isHash(tok);
      };
      var peg$f3 = function(tok) {
        return tok;
      };
      var peg$f4 = function(tok) {
        return options.isNumber(tok);
      };
      var peg$f5 = function(tok) {
        return tok;
      };
      var peg$f6 = function() {
        return { type: "string", content: "#" };
      };
      var peg$f7 = function(num) {
        const split = options.splitNumber(num);
        return [{ type: "hash_number", number: split.number }, split.rest];
      };
      var peg$currPos = 0;
      var peg$savedPos = 0;
      var peg$posDetailsCache = [{ line: 1, column: 1 }];
      var peg$maxFailPos = 0;
      var peg$maxFailExpected = [];
      var peg$silentFails = 0;
      var peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function offset() {
        return peg$savedPos;
      }
      function range() {
        return {
          source: peg$source,
          start: peg$savedPos,
          end: peg$currPos
        };
      }
      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError(
          [peg$otherExpectation(description)],
          input.substring(peg$savedPos, peg$currPos),
          location2
        );
      }
      function error(message, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location2);
      }
      function peg$literalExpectation(text2, ignoreCase) {
        return { type: "literal", text: text2, ignoreCase };
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts, inverted, ignoreCase };
      }
      function peg$anyExpectation() {
        return { type: "any" };
      }
      function peg$endExpectation() {
        return { type: "end" };
      }
      function peg$otherExpectation(description) {
        return { type: "other", description };
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p;
        if (details) {
          return details;
        } else {
          p = pos - 1;
          while (!peg$posDetailsCache[p]) {
            p--;
          }
          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };
          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos);
        var endPosDetails = peg$computePosDetails(endPos);
        return {
          source: peg$source,
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildSimpleError(message, location2) {
        return new peg$SyntaxError(message, null, null, location2);
      }
      function peg$buildStructuredError(expected2, found, location2) {
        return new peg$SyntaxError(
          peg$SyntaxError.buildMessage(expected2, found),
          expected2,
          found,
          location2
        );
      }
      function peg$parsebody() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsedouble_hash();
        if (s22 === peg$FAILED) {
          s22 = peg$parsehash_number();
          if (s22 === peg$FAILED) {
            if (input.length > peg$currPos) {
              s22 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s22 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
          }
        }
        if (s22 !== peg$FAILED) {
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            s22 = peg$parsedouble_hash();
            if (s22 === peg$FAILED) {
              s22 = peg$parsehash_number();
              if (s22 === peg$FAILED) {
                if (input.length > peg$currPos) {
                  s22 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s22 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e0);
                  }
                }
              }
            }
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f0(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseEOL();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f1();
          }
          s0 = s1;
        }
        return s0;
      }
      function peg$parsehash() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f2(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f3(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsenumber() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f4(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f5(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsedouble_hash() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parsehash();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsehash();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f6();
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsehash_number() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parsehash();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsenumber();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f7(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseEOL() {
        var s0, s1;
        s0 = peg$currPos;
        peg$silentFails++;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        peg$silentFails--;
        if (s1 === peg$FAILED) {
          s0 = void 0;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      if (!options.isHash) {
        try {
          Object.assign(options, {
            isHash: (node) => node.type === "string" && node.content === "#",
            isNumber: (node) => node.type === "string" && 0 < +node.content.charAt(0),
            splitNumber: (node) => {
              const number = +node.content.charAt(0);
              if (node.content.length > 1) {
                return {
                  number,
                  rest: {
                    type: "string",
                    content: node.content.slice(1)
                  }
                };
              }
              return { number };
            }
          });
        } catch (e) {
          console.warn("Error when initializing parser", e);
        }
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(
          peg$maxFailExpected,
          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
      }
    }
    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }()
);
var ligatures_default4 = (
  // Generated by Peggy 2.0.1.
  //
  // https://peggyjs.org/
  function() {
    "use strict";
    function peg$subclass(child, parent) {
      function C() {
        this.constructor = child;
      }
      C.prototype = parent.prototype;
      child.prototype = new C();
    }
    function peg$SyntaxError(message, expected, found, location) {
      var self = Error.call(this, message);
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(self, peg$SyntaxError.prototype);
      }
      self.expected = expected;
      self.found = found;
      self.location = location;
      self.name = "SyntaxError";
      return self;
    }
    peg$subclass(peg$SyntaxError, Error);
    function peg$padEnd(str, targetLength, padString) {
      padString = padString || " ";
      if (str.length > targetLength) {
        return str;
      }
      targetLength -= str.length;
      padString += padString.repeat(targetLength);
      return str + padString.slice(0, targetLength);
    }
    peg$SyntaxError.prototype.format = function(sources) {
      var str = "Error: " + this.message;
      if (this.location) {
        var src = null;
        var k;
        for (k = 0; k < sources.length; k++) {
          if (sources[k].source === this.location.source) {
            src = sources[k].text.split(/\r\n|\n|\r/g);
            break;
          }
        }
        var s5 = this.location.start;
        var loc = this.location.source + ":" + s5.line + ":" + s5.column;
        if (src) {
          var e = this.location.end;
          var filler = peg$padEnd("", s5.line.toString().length, " ");
          var line = src[s5.line - 1];
          var last = s5.line === e.line ? e.column : line.length + 1;
          var hatLen = last - s5.column || 1;
          str += "\n --> " + loc + "\n" + filler + " |\n" + s5.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s5.column - 1, " ") + peg$padEnd("", hatLen, "^");
        } else {
          str += "\n at " + loc;
        }
      }
      return str;
    };
    peg$SyntaxError.buildMessage = function(expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        class: function(expectation) {
          var escapedParts = expectation.parts.map(function(part) {
            return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
          });
          return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
        },
        any: function() {
          return "any character";
        },
        end: function() {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        }
      };
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s5) {
        return s5.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function classEscape(s5) {
        return s5.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = expected2.map(describeExpectation);
        var i, j;
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {};
      var peg$source = options.grammarSource;
      var peg$startRuleFunctions = { body: peg$parsebody };
      var peg$startRuleFunction = peg$parsebody;
      var peg$e0 = peg$anyExpectation();
      var peg$f0 = function(e) {
        return [].concat(...e).filter((n) => !!n);
      };
      var peg$f1 = function() {
        return [];
      };
      var peg$f2 = function(toks) {
        return options.isRecognized(toks);
      };
      var peg$f3 = function(toks) {
        return options.isRecognized(toks);
      };
      var peg$f4 = function(tok1, tok2) {
        const split = options.split(tok2);
        return options.isRecognized([tok1, split[0]]);
      };
      var peg$f5 = function(tok1, tok2) {
        const split = options.split(tok2);
        return [options.isRecognized([tok1, split[0]]), split[1]];
      };
      var peg$f6 = function(tok1, tok2) {
        return options.isRecognized([tok1, tok2]);
      };
      var peg$f7 = function(tok1, tok2) {
        return options.isRecognized([tok1, tok2]);
      };
      var peg$f8 = function(toks) {
        return options.isRecognized(toks);
      };
      var peg$f9 = function(toks) {
        return options.isRecognized(toks);
      };
      var peg$f10 = function(tok) {
        return options.isRecognized([tok]);
      };
      var peg$f11 = function(tok) {
        return options.isRecognized([tok]);
      };
      var peg$f12 = function(tok) {
        return options.isMacro(tok);
      };
      var peg$f13 = function(tok) {
        return tok;
      };
      var peg$f14 = function(tok) {
        return options.isWhitespace(tok);
      };
      var peg$f15 = function(tok) {
        return tok;
      };
      var peg$f16 = function(tok) {
        return options.isSplitable(tok);
      };
      var peg$f17 = function(tok) {
        return tok;
      };
      var peg$currPos = 0;
      var peg$savedPos = 0;
      var peg$posDetailsCache = [{ line: 1, column: 1 }];
      var peg$maxFailPos = 0;
      var peg$maxFailExpected = [];
      var peg$silentFails = 0;
      var peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function offset() {
        return peg$savedPos;
      }
      function range() {
        return {
          source: peg$source,
          start: peg$savedPos,
          end: peg$currPos
        };
      }
      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError(
          [peg$otherExpectation(description)],
          input.substring(peg$savedPos, peg$currPos),
          location2
        );
      }
      function error(message, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location2);
      }
      function peg$literalExpectation(text2, ignoreCase) {
        return { type: "literal", text: text2, ignoreCase };
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts, inverted, ignoreCase };
      }
      function peg$anyExpectation() {
        return { type: "any" };
      }
      function peg$endExpectation() {
        return { type: "end" };
      }
      function peg$otherExpectation(description) {
        return { type: "other", description };
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p;
        if (details) {
          return details;
        } else {
          p = pos - 1;
          while (!peg$posDetailsCache[p]) {
            p--;
          }
          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };
          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos);
        var endPosDetails = peg$computePosDetails(endPos);
        return {
          source: peg$source,
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildSimpleError(message, location2) {
        return new peg$SyntaxError(message, null, null, location2);
      }
      function peg$buildStructuredError(expected2, found, location2) {
        return new peg$SyntaxError(
          peg$SyntaxError.buildMessage(expected2, found),
          expected2,
          found,
          location2
        );
      }
      function peg$parsebody() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsetriple_ligature();
        if (s22 === peg$FAILED) {
          s22 = peg$parsedouble_ligature();
          if (s22 === peg$FAILED) {
            s22 = peg$parsemono_ligature();
            if (s22 === peg$FAILED) {
              if (input.length > peg$currPos) {
                s22 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s22 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
            }
          }
        }
        if (s22 !== peg$FAILED) {
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            s22 = peg$parsetriple_ligature();
            if (s22 === peg$FAILED) {
              s22 = peg$parsedouble_ligature();
              if (s22 === peg$FAILED) {
                s22 = peg$parsemono_ligature();
                if (s22 === peg$FAILED) {
                  if (input.length > peg$currPos) {
                    s22 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s22 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e0);
                    }
                  }
                }
              }
            }
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f0(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseEOL();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f1();
          }
          s0 = s1;
        }
        return s0;
      }
      function peg$parsetriple_ligature() {
        var s0, s1, s22, s32, s42;
        s0 = peg$currPos;
        s1 = peg$currPos;
        if (input.length > peg$currPos) {
          s22 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s22 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s22 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s32 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s32 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s32 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s42 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s42 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            if (s42 !== peg$FAILED) {
              s22 = [s22, s32, s42];
              s1 = s22;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f2(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f3(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsedouble_ligature() {
        var s0;
        s0 = peg$parsedouble_macro_ligature();
        if (s0 === peg$FAILED) {
          s0 = peg$parsedouble_macro_ligature_extracted();
          if (s0 === peg$FAILED) {
            s0 = peg$parsedouble_char_ligature();
          }
        }
        return s0;
      }
      function peg$parsedouble_macro_ligature_extracted() {
        var s0, s1, s22, s32, s42;
        s0 = peg$currPos;
        s1 = peg$parsemacro();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$parsewhitespace();
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parsewhitespace();
          }
          s32 = peg$parsesplitable();
          if (s32 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s42 = peg$f4(s1, s32);
            if (s42) {
              s42 = void 0;
            } else {
              s42 = peg$FAILED;
            }
            if (s42 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f5(s1, s32);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsedouble_macro_ligature() {
        var s0, s1, s22, s32, s42;
        s0 = peg$currPos;
        s1 = peg$parsemacro();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$parsewhitespace();
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parsewhitespace();
          }
          if (input.length > peg$currPos) {
            s32 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s32 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s32 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s42 = peg$f6(s1, s32);
            if (s42) {
              s42 = void 0;
            } else {
              s42 = peg$FAILED;
            }
            if (s42 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f7(s1, s32);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsedouble_char_ligature() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$currPos;
        if (input.length > peg$currPos) {
          s22 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s22 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s22 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s32 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s32 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s32 !== peg$FAILED) {
            s22 = [s22, s32];
            s1 = s22;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f8(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f9(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsemono_ligature() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f10(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f11(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsemacro() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f12(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f13(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsewhitespace() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f14(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f15(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsesplitable() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f16(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f17(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseEOL() {
        var s0, s1;
        s0 = peg$currPos;
        peg$silentFails++;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        peg$silentFails--;
        if (s1 === peg$FAILED) {
          s0 = void 0;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      if (!options.isWhitespace) {
        try {
          Object.assign(options, {
            isMacro: (node) => node.type === "macro",
            isWhitespace: (node) => node.type === "whitespace",
            isRecognized: (nodes) => {
              if (nodes.length == 2 && nodes[0].content === "^" && nodes[1].content === "o") {
                return { type: "string", content: "\xF4" };
              }
              return null;
            },
            isSplitable: (node) => node.type === "string" && node.content.length > 1,
            split: (node) => [
              { type: "string", content: node.content.charAt(0) },
              { type: "string", content: node.content.slice(1) }
            ]
          });
        } catch (e) {
          console.warn("Error when initializing parser", e);
        }
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(
          peg$maxFailExpected,
          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
      }
    }
    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }()
);
var xcolor_expressions_default4 = (
  // Generated by Peggy 2.0.1.
  //
  // https://peggyjs.org/
  function() {
    "use strict";
    function peg$subclass(child, parent) {
      function C() {
        this.constructor = child;
      }
      C.prototype = parent.prototype;
      child.prototype = new C();
    }
    function peg$SyntaxError(message, expected, found, location) {
      var self = Error.call(this, message);
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(self, peg$SyntaxError.prototype);
      }
      self.expected = expected;
      self.found = found;
      self.location = location;
      self.name = "SyntaxError";
      return self;
    }
    peg$subclass(peg$SyntaxError, Error);
    function peg$padEnd(str, targetLength, padString) {
      padString = padString || " ";
      if (str.length > targetLength) {
        return str;
      }
      targetLength -= str.length;
      padString += padString.repeat(targetLength);
      return str + padString.slice(0, targetLength);
    }
    peg$SyntaxError.prototype.format = function(sources) {
      var str = "Error: " + this.message;
      if (this.location) {
        var src = null;
        var k;
        for (k = 0; k < sources.length; k++) {
          if (sources[k].source === this.location.source) {
            src = sources[k].text.split(/\r\n|\n|\r/g);
            break;
          }
        }
        var s5 = this.location.start;
        var loc = this.location.source + ":" + s5.line + ":" + s5.column;
        if (src) {
          var e = this.location.end;
          var filler = peg$padEnd("", s5.line.toString().length, " ");
          var line = src[s5.line - 1];
          var last = s5.line === e.line ? e.column : line.length + 1;
          var hatLen = last - s5.column || 1;
          str += "\n --> " + loc + "\n" + filler + " |\n" + s5.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s5.column - 1, " ") + peg$padEnd("", hatLen, "^");
        } else {
          str += "\n at " + loc;
        }
      }
      return str;
    };
    peg$SyntaxError.buildMessage = function(expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        class: function(expectation) {
          var escapedParts = expectation.parts.map(function(part) {
            return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
          });
          return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
        },
        any: function() {
          return "any character";
        },
        end: function() {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        }
      };
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s5) {
        return s5.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function classEscape(s5) {
        return s5.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = expected2.map(describeExpectation);
        var i, j;
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {};
      var peg$source = options.grammarSource;
      var peg$startRuleFunctions = { start: peg$parsestart };
      var peg$startRuleFunction = peg$parsestart;
      var peg$c0 = ";";
      var peg$c1 = ",";
      var peg$c2 = ":";
      var peg$c3 = "/";
      var peg$c4 = ">";
      var peg$c5 = "!";
      var peg$c6 = ".";
      var peg$c7 = "!![";
      var peg$c8 = "]";
      var peg$c9 = "!!";
      var peg$c10 = "+";
      var peg$c11 = "-";
      var peg$r0 = /^[a-zA-Z0-9]/;
      var peg$r1 = /^[0-9]/;
      var peg$r2 = /^[ \t\n\r]/;
      var peg$r3 = /^[0-9a-fA-F]/;
      var peg$e0 = peg$anyExpectation();
      var peg$e1 = peg$literalExpectation(";", false);
      var peg$e2 = peg$literalExpectation(",", false);
      var peg$e3 = peg$otherExpectation("model list");
      var peg$e4 = peg$literalExpectation(":", false);
      var peg$e5 = peg$literalExpectation("/", false);
      var peg$e6 = peg$otherExpectation("model");
      var peg$e7 = peg$otherExpectation("color spec list");
      var peg$e8 = peg$otherExpectation("color spec");
      var peg$e9 = peg$otherExpectation("color");
      var peg$e10 = peg$otherExpectation("function expression");
      var peg$e11 = peg$literalExpectation(">", false);
      var peg$e12 = peg$otherExpectation("function");
      var peg$e13 = peg$otherExpectation("extended expression");
      var peg$e14 = peg$otherExpectation("core model");
      var peg$e15 = peg$otherExpectation("expr");
      var peg$e16 = peg$literalExpectation("!", false);
      var peg$e17 = peg$otherExpectation("mix expr");
      var peg$e18 = peg$otherExpectation("name");
      var peg$e19 = peg$literalExpectation(".", false);
      var peg$e20 = peg$classExpectation([["a", "z"], ["A", "Z"], ["0", "9"]], false, false);
      var peg$e21 = peg$otherExpectation("postfix");
      var peg$e22 = peg$literalExpectation("!![", false);
      var peg$e23 = peg$literalExpectation("]", false);
      var peg$e24 = peg$literalExpectation("!!", false);
      var peg$e25 = peg$otherExpectation("prefix");
      var peg$e26 = peg$otherExpectation("plus");
      var peg$e27 = peg$literalExpectation("+", false);
      var peg$e28 = peg$otherExpectation("minus");
      var peg$e29 = peg$literalExpectation("-", false);
      var peg$e30 = peg$otherExpectation("num");
      var peg$e31 = peg$classExpectation([["0", "9"]], false, false);
      var peg$e32 = peg$otherExpectation("positive float");
      var peg$e33 = peg$otherExpectation("divisor");
      var peg$e34 = peg$otherExpectation("int");
      var peg$e35 = peg$otherExpectation("whitespace");
      var peg$e36 = peg$classExpectation([" ", "	", "\n", "\r"], false, false);
      var peg$e37 = peg$classExpectation([["0", "9"], ["a", "f"], ["A", "F"]], false, false);
      var peg$f0 = function(m) {
        return m;
      };
      var peg$f1 = function(m) {
        return m;
      };
      var peg$f2 = function(m) {
        return m;
      };
      var peg$f3 = function(m) {
        return m;
      };
      var peg$f4 = function(m) {
        return m;
      };
      var peg$f5 = function(a) {
        return { type: "invalid_spec", content: a };
      };
      var peg$f6 = function(f, c) {
        return c;
      };
      var peg$f7 = function(f, r) {
        return { type: "color_set", content: [f].concat(r) };
      };
      var peg$f8 = function(n, s5) {
        return { type: "color_set_item", name: n, spec_list: s5 };
      };
      var peg$f9 = function(c, m) {
        return { type: "model_list", contents: m, core_model: c };
      };
      var peg$f10 = function(m) {
        return { type: "model_list", contents: m, core_model: null };
      };
      var peg$f11 = function(m, a) {
        return a;
      };
      var peg$f12 = function(m, r) {
        return [m].concat(r);
      };
      var peg$f13 = function(s5, a) {
        return a;
      };
      var peg$f14 = function(s5, r) {
        return { type: "spec_list", content: [s5].concat(r) };
      };
      var peg$f15 = function(c) {
        return { type: "hex_spec", content: [c] };
      };
      var peg$f16 = function(c, d) {
        return d;
      };
      var peg$f17 = function(c, d) {
        return d;
      };
      var peg$f18 = function(c, r) {
        return { type: "num_spec", content: r ? [c].concat(r) : [c] };
      };
      var peg$f19 = function(c, fs) {
        return { type: "color", color: c, functions: fs };
      };
      var peg$f20 = function(f, n) {
        return n;
      };
      var peg$f21 = function(f, args) {
        return { type: "function", name: f, args };
      };
      var peg$f22 = function(core, d, e, es) {
        return {
          type: "extended_expr",
          core_model: core,
          div: d,
          expressions: [e].concat(es)
        };
      };
      var peg$f23 = function(core, e, es) {
        return {
          type: "extended_expr",
          core_model: core,
          div: null,
          expressions: [e].concat(es)
        };
      };
      var peg$f24 = function(e, d) {
        return { type: "weighted_expr", color: e, weight: d };
      };
      var peg$f25 = function(e) {
        return e;
      };
      var peg$f26 = function(p, n, e, po) {
        return {
          type: "expr",
          prefix: p,
          name: n,
          mix_expr: e,
          postfix: po
        };
      };
      var peg$f27 = function(p, n) {
        return { type: "complete_mix", mix_percent: p, name: n };
      };
      var peg$f28 = function(p) {
        return { type: "partial_mix", mix_percent: p };
      };
      var peg$f29 = function(c, p) {
        return c.concat(p || []);
      };
      var peg$f30 = function(n) {
        return { type: "postfix", num: n };
      };
      var peg$f31 = function(p) {
        return { type: "postfix", plusses: p };
      };
      var peg$f32 = function(n) {
        return parseInt(n, 10);
      };
      var peg$f33 = function(n) {
        return parseFloat(n);
      };
      var peg$f34 = function(n) {
        return n;
      };
      var peg$f35 = function(n) {
        return -n;
      };
      var peg$f36 = function(m, n) {
        return m ? -n : n;
      };
      var peg$f37 = function(h) {
        return h.toUpperCase();
      };
      var peg$currPos = 0;
      var peg$savedPos = 0;
      var peg$posDetailsCache = [{ line: 1, column: 1 }];
      var peg$maxFailPos = 0;
      var peg$maxFailExpected = [];
      var peg$silentFails = 0;
      var peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function offset() {
        return peg$savedPos;
      }
      function range() {
        return {
          source: peg$source,
          start: peg$savedPos,
          end: peg$currPos
        };
      }
      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError(
          [peg$otherExpectation(description)],
          input.substring(peg$savedPos, peg$currPos),
          location2
        );
      }
      function error(message, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location2);
      }
      function peg$literalExpectation(text2, ignoreCase) {
        return { type: "literal", text: text2, ignoreCase };
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts, inverted, ignoreCase };
      }
      function peg$anyExpectation() {
        return { type: "any" };
      }
      function peg$endExpectation() {
        return { type: "end" };
      }
      function peg$otherExpectation(description) {
        return { type: "other", description };
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p;
        if (details) {
          return details;
        } else {
          p = pos - 1;
          while (!peg$posDetailsCache[p]) {
            p--;
          }
          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };
          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos);
        var endPosDetails = peg$computePosDetails(endPos);
        return {
          source: peg$source,
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildSimpleError(message, location2) {
        return new peg$SyntaxError(message, null, null, location2);
      }
      function peg$buildStructuredError(expected2, found, location2) {
        return new peg$SyntaxError(
          peg$SyntaxError.buildMessage(expected2, found),
          expected2,
          found,
          location2
        );
      }
      function peg$parsestart() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$parsespec();
        if (s1 !== peg$FAILED) {
          s22 = peg$parseEOL();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f0(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsespec_list();
          if (s1 !== peg$FAILED) {
            s22 = peg$parseEOL();
            if (s22 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f1(s1);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsecolor();
            if (s1 !== peg$FAILED) {
              s22 = peg$parseEOL();
              if (s22 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f2(s1);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parsemodel_list();
              if (s1 !== peg$FAILED) {
                s22 = peg$parseEOL();
                if (s22 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s0 = peg$f3(s1);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parsecolor_set_spec();
                if (s1 !== peg$FAILED) {
                  s22 = peg$parseEOL();
                  if (s22 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s0 = peg$f4(s1);
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  s1 = peg$currPos;
                  s22 = [];
                  if (input.length > peg$currPos) {
                    s32 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s32 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e0);
                    }
                  }
                  while (s32 !== peg$FAILED) {
                    s22.push(s32);
                    if (input.length > peg$currPos) {
                      s32 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s32 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e0);
                      }
                    }
                  }
                  s1 = input.substring(s1, peg$currPos);
                  peg$savedPos = s0;
                  s1 = peg$f5(s1);
                  s0 = s1;
                }
              }
            }
          }
        }
        return s0;
      }
      function peg$parsecolor_set_spec() {
        var s0, s1, s22, s32, s42, s5;
        s0 = peg$currPos;
        s1 = peg$parsecolor_set_item();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 59) {
            s42 = peg$c0;
            peg$currPos++;
          } else {
            s42 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e1);
            }
          }
          if (s42 !== peg$FAILED) {
            s5 = peg$parsecolor_set_item();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s32;
              s32 = peg$f6(s1, s5);
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          } else {
            peg$currPos = s32;
            s32 = peg$FAILED;
          }
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 59) {
              s42 = peg$c0;
              peg$currPos++;
            } else {
              s42 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e1);
              }
            }
            if (s42 !== peg$FAILED) {
              s5 = peg$parsecolor_set_item();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s32;
                s32 = peg$f6(s1, s5);
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          }
          peg$savedPos = s0;
          s0 = peg$f7(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecolor_set_item() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$parsename();
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 44) {
            s22 = peg$c1;
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          if (s22 !== peg$FAILED) {
            s32 = peg$parsespec_list();
            if (s32 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f8(s1, s32);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsemodel_list() {
        var s0, s1, s22, s32;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parsecore_model();
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 58) {
            s22 = peg$c2;
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e4);
            }
          }
          if (s22 !== peg$FAILED) {
            s32 = peg$parsemodel_list_tail();
            if (s32 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f9(s1, s32);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsemodel_list_tail();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f10(s1);
          }
          s0 = s1;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        return s0;
      }
      function peg$parsemodel_list_tail() {
        var s0, s1, s22, s32, s42, s5;
        s0 = peg$currPos;
        s1 = peg$parsemodel();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 47) {
            s42 = peg$c3;
            peg$currPos++;
          } else {
            s42 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e5);
            }
          }
          if (s42 !== peg$FAILED) {
            s5 = peg$parsemodel();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s32;
              s32 = peg$f11(s1, s5);
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          } else {
            peg$currPos = s32;
            s32 = peg$FAILED;
          }
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 47) {
              s42 = peg$c3;
              peg$currPos++;
            } else {
              s42 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e5);
              }
            }
            if (s42 !== peg$FAILED) {
              s5 = peg$parsemodel();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s32;
                s32 = peg$f11(s1, s5);
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          }
          peg$savedPos = s0;
          s0 = peg$f12(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsemodel() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parsecore_model();
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e6);
          }
        }
        return s0;
      }
      function peg$parsespec_list() {
        var s0, s1, s22, s32, s42, s5;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parsespec();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 47) {
            s42 = peg$c3;
            peg$currPos++;
          } else {
            s42 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e5);
            }
          }
          if (s42 !== peg$FAILED) {
            s5 = peg$parsespec();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s32;
              s32 = peg$f13(s1, s5);
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          } else {
            peg$currPos = s32;
            s32 = peg$FAILED;
          }
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 47) {
              s42 = peg$c3;
              peg$currPos++;
            } else {
              s42 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e5);
              }
            }
            if (s42 !== peg$FAILED) {
              s5 = peg$parsespec();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s32;
                s32 = peg$f13(s1, s5);
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          }
          peg$savedPos = s0;
          s0 = peg$f14(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e7);
          }
        }
        return s0;
      }
      function peg$parsespec() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$currPos;
        s32 = peg$parsehex();
        if (s32 !== peg$FAILED) {
          s42 = peg$parsehex();
          if (s42 !== peg$FAILED) {
            s5 = peg$parsehex();
            if (s5 !== peg$FAILED) {
              s6 = peg$parsehex();
              if (s6 !== peg$FAILED) {
                s7 = peg$parsehex();
                if (s7 !== peg$FAILED) {
                  s8 = peg$parsehex();
                  if (s8 !== peg$FAILED) {
                    s32 = [s32, s42, s5, s6, s7, s8];
                    s22 = s32;
                  } else {
                    peg$currPos = s22;
                    s22 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s22;
                  s22 = peg$FAILED;
                }
              } else {
                peg$currPos = s22;
                s22 = peg$FAILED;
              }
            } else {
              peg$currPos = s22;
              s22 = peg$FAILED;
            }
          } else {
            peg$currPos = s22;
            s22 = peg$FAILED;
          }
        } else {
          peg$currPos = s22;
          s22 = peg$FAILED;
        }
        if (s22 !== peg$FAILED) {
          s1 = input.substring(s1, peg$currPos);
        } else {
          s1 = s22;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f15(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsedec();
          if (s1 !== peg$FAILED) {
            s22 = [];
            s32 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 44) {
              s42 = peg$c1;
              peg$currPos++;
            } else {
              s42 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e2);
              }
            }
            if (s42 !== peg$FAILED) {
              s5 = peg$parsedec();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s32;
                s32 = peg$f16(s1, s5);
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
            if (s32 !== peg$FAILED) {
              while (s32 !== peg$FAILED) {
                s22.push(s32);
                s32 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 44) {
                  s42 = peg$c1;
                  peg$currPos++;
                } else {
                  s42 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e2);
                  }
                }
                if (s42 !== peg$FAILED) {
                  s5 = peg$parsedec();
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s32;
                    s32 = peg$f16(s1, s5);
                  } else {
                    peg$currPos = s32;
                    s32 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s32;
                  s32 = peg$FAILED;
                }
              }
            } else {
              s22 = peg$FAILED;
            }
            if (s22 === peg$FAILED) {
              s22 = [];
              s32 = peg$currPos;
              s42 = peg$parsesp();
              if (s42 !== peg$FAILED) {
                s5 = peg$parsedec();
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s32;
                  s32 = peg$f17(s1, s5);
                } else {
                  peg$currPos = s32;
                  s32 = peg$FAILED;
                }
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
              if (s32 !== peg$FAILED) {
                while (s32 !== peg$FAILED) {
                  s22.push(s32);
                  s32 = peg$currPos;
                  s42 = peg$parsesp();
                  if (s42 !== peg$FAILED) {
                    s5 = peg$parsedec();
                    if (s5 !== peg$FAILED) {
                      peg$savedPos = s32;
                      s32 = peg$f17(s1, s5);
                    } else {
                      peg$currPos = s32;
                      s32 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s32;
                    s32 = peg$FAILED;
                  }
                }
              } else {
                s22 = peg$FAILED;
              }
            }
            if (s22 === peg$FAILED) {
              s22 = null;
            }
            peg$savedPos = s0;
            s0 = peg$f18(s1, s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e8);
          }
        }
        return s0;
      }
      function peg$parsecolor() {
        var s0, s1, s22, s32;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parsecolor_expr();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$parsefunc_expr();
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parsefunc_expr();
          }
          peg$savedPos = s0;
          s0 = peg$f19(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e9);
          }
        }
        return s0;
      }
      function peg$parsecolor_expr() {
        var s0;
        s0 = peg$parseext_expr();
        if (s0 === peg$FAILED) {
          s0 = peg$parseexpr();
          if (s0 === peg$FAILED) {
            s0 = peg$parsename();
          }
        }
        return s0;
      }
      function peg$parsefunc_expr() {
        var s0, s1, s22, s32, s42, s5, s6;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 62) {
          s1 = peg$c4;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e11);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parsefunction();
          if (s22 !== peg$FAILED) {
            s32 = [];
            s42 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 44) {
              s5 = peg$c1;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e2);
              }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parseint();
              if (s6 !== peg$FAILED) {
                peg$savedPos = s42;
                s42 = peg$f20(s22, s6);
              } else {
                peg$currPos = s42;
                s42 = peg$FAILED;
              }
            } else {
              peg$currPos = s42;
              s42 = peg$FAILED;
            }
            while (s42 !== peg$FAILED) {
              s32.push(s42);
              s42 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 44) {
                s5 = peg$c1;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e2);
                }
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parseint();
                if (s6 !== peg$FAILED) {
                  peg$savedPos = s42;
                  s42 = peg$f20(s22, s6);
                } else {
                  peg$currPos = s42;
                  s42 = peg$FAILED;
                }
              } else {
                peg$currPos = s42;
                s42 = peg$FAILED;
              }
            }
            peg$savedPos = s0;
            s0 = peg$f21(s22, s32);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e10);
          }
        }
        return s0;
      }
      function peg$parsefunction() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parsename();
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e12);
          }
        }
        return s0;
      }
      function peg$parseext_expr() {
        var s0, s1, s22, s32, s42, s5, s6, s7;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parsecore_model();
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 44) {
            s22 = peg$c1;
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          if (s22 !== peg$FAILED) {
            s32 = peg$parsediv();
            if (s32 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 58) {
                s42 = peg$c2;
                peg$currPos++;
              } else {
                s42 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e4);
                }
              }
              if (s42 !== peg$FAILED) {
                s5 = peg$parseweighted_expr();
                if (s5 !== peg$FAILED) {
                  s6 = [];
                  s7 = peg$parseadditional_weighted_expr();
                  while (s7 !== peg$FAILED) {
                    s6.push(s7);
                    s7 = peg$parseadditional_weighted_expr();
                  }
                  peg$savedPos = s0;
                  s0 = peg$f22(s1, s32, s5, s6);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsecore_model();
          if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 58) {
              s22 = peg$c2;
              peg$currPos++;
            } else {
              s22 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e4);
              }
            }
            if (s22 !== peg$FAILED) {
              s32 = peg$parseweighted_expr();
              if (s32 !== peg$FAILED) {
                s42 = [];
                s5 = peg$parseadditional_weighted_expr();
                while (s5 !== peg$FAILED) {
                  s42.push(s5);
                  s5 = peg$parseadditional_weighted_expr();
                }
                peg$savedPos = s0;
                s0 = peg$f23(s1, s32, s42);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e13);
          }
        }
        return s0;
      }
      function peg$parseweighted_expr() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$parseexpr();
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 44) {
            s22 = peg$c1;
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          if (s22 !== peg$FAILED) {
            s32 = peg$parsedec();
            if (s32 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f24(s1, s32);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseadditional_weighted_expr() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 59) {
          s1 = peg$c0;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e1);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parseweighted_expr();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f25(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecore_model() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parsename();
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e14);
          }
        }
        return s0;
      }
      function peg$parseexpr() {
        var s0, s1, s22, s32, s42;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parseprefix();
        s22 = peg$parsename();
        if (s22 !== peg$FAILED) {
          s32 = peg$parsemix_expr();
          s42 = peg$parsepostfix();
          if (s42 === peg$FAILED) {
            s42 = null;
          }
          peg$savedPos = s0;
          s0 = peg$f26(s1, s22, s32, s42);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e15);
          }
        }
        return s0;
      }
      function peg$parsecomplete_mix() {
        var s0, s1, s22, s32, s42;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 33) {
          s1 = peg$c5;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e16);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parsepct();
          if (s22 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 33) {
              s32 = peg$c5;
              peg$currPos++;
            } else {
              s32 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e16);
              }
            }
            if (s32 !== peg$FAILED) {
              s42 = peg$parsename();
              if (s42 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f27(s22, s42);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsepartial_mix() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 33) {
          s1 = peg$c5;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e16);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parsepct();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f28(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsemix_expr() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsecomplete_mix();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parsecomplete_mix();
        }
        s22 = peg$parsepartial_mix();
        if (s22 === peg$FAILED) {
          s22 = null;
        }
        peg$savedPos = s0;
        s0 = peg$f29(s1, s22);
        peg$silentFails--;
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e17);
        }
        return s0;
      }
      function peg$parsename() {
        var s0, s1, s22;
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 46) {
          s0 = peg$c6;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e19);
          }
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = [];
          if (peg$r0.test(input.charAt(peg$currPos))) {
            s22 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e20);
            }
          }
          if (s22 !== peg$FAILED) {
            while (s22 !== peg$FAILED) {
              s1.push(s22);
              if (peg$r0.test(input.charAt(peg$currPos))) {
                s22 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s22 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e20);
                }
              }
            }
          } else {
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            s0 = input.substring(s0, peg$currPos);
          } else {
            s0 = s1;
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e18);
          }
        }
        return s0;
      }
      function peg$parsepostfix() {
        var s0, s1, s22, s32, s42;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 3) === peg$c7) {
          s1 = peg$c7;
          peg$currPos += 3;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e22);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parsenum();
          if (s22 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 93) {
              s32 = peg$c8;
              peg$currPos++;
            } else {
              s32 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e23);
              }
            }
            if (s32 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f30(s22);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c9) {
            s1 = peg$c9;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e24);
            }
          }
          if (s1 !== peg$FAILED) {
            s22 = peg$currPos;
            s32 = [];
            s42 = peg$parseplus();
            if (s42 !== peg$FAILED) {
              while (s42 !== peg$FAILED) {
                s32.push(s42);
                s42 = peg$parseplus();
              }
            } else {
              s32 = peg$FAILED;
            }
            if (s32 !== peg$FAILED) {
              s22 = input.substring(s22, peg$currPos);
            } else {
              s22 = s32;
            }
            if (s22 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f31(s22);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e21);
          }
        }
        return s0;
      }
      function peg$parseprefix() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parseminus();
        if (s0 === peg$FAILED) {
          s0 = null;
        }
        peg$silentFails--;
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e25);
        }
        return s0;
      }
      function peg$parseplus() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        if (input.charCodeAt(peg$currPos) === 43) {
          s22 = peg$c10;
          peg$currPos++;
        } else {
          s22 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e27);
          }
        }
        if (s22 !== peg$FAILED) {
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            if (input.charCodeAt(peg$currPos) === 43) {
              s22 = peg$c10;
              peg$currPos++;
            } else {
              s22 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e27);
              }
            }
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e26);
          }
        }
        return s0;
      }
      function peg$parseminus() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        if (input.charCodeAt(peg$currPos) === 45) {
          s22 = peg$c11;
          peg$currPos++;
        } else {
          s22 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e29);
          }
        }
        if (s22 !== peg$FAILED) {
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            if (input.charCodeAt(peg$currPos) === 45) {
              s22 = peg$c11;
              peg$currPos++;
            } else {
              s22 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e29);
              }
            }
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e28);
          }
        }
        return s0;
      }
      function peg$parsenum() {
        var s0, s1, s22, s32;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = [];
        if (peg$r1.test(input.charAt(peg$currPos))) {
          s32 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s32 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e31);
          }
        }
        if (s32 !== peg$FAILED) {
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            if (peg$r1.test(input.charAt(peg$currPos))) {
              s32 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s32 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e31);
              }
            }
          }
        } else {
          s22 = peg$FAILED;
        }
        if (s22 !== peg$FAILED) {
          s1 = input.substring(s1, peg$currPos);
        } else {
          s1 = s22;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f32(s1);
        }
        s0 = s1;
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e30);
          }
        }
        return s0;
      }
      function peg$parsepct() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8, s9;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$currPos;
        s32 = peg$currPos;
        s42 = [];
        if (peg$r1.test(input.charAt(peg$currPos))) {
          s5 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e31);
          }
        }
        if (s5 !== peg$FAILED) {
          while (s5 !== peg$FAILED) {
            s42.push(s5);
            if (peg$r1.test(input.charAt(peg$currPos))) {
              s5 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e31);
              }
            }
          }
        } else {
          s42 = peg$FAILED;
        }
        if (s42 !== peg$FAILED) {
          s32 = input.substring(s32, peg$currPos);
        } else {
          s32 = s42;
        }
        if (s32 !== peg$FAILED) {
          s42 = peg$currPos;
          s5 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 46) {
            s6 = peg$c6;
            peg$currPos++;
          } else {
            s6 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e19);
            }
          }
          if (s6 !== peg$FAILED) {
            s7 = peg$currPos;
            s8 = [];
            if (peg$r1.test(input.charAt(peg$currPos))) {
              s9 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s9 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e31);
              }
            }
            while (s9 !== peg$FAILED) {
              s8.push(s9);
              if (peg$r1.test(input.charAt(peg$currPos))) {
                s9 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s9 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e31);
                }
              }
            }
            s7 = input.substring(s7, peg$currPos);
            s6 = [s6, s7];
            s5 = s6;
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
          if (s5 === peg$FAILED) {
            s5 = null;
          }
          s42 = input.substring(s42, peg$currPos);
          s32 = [s32, s42];
          s22 = s32;
        } else {
          peg$currPos = s22;
          s22 = peg$FAILED;
        }
        if (s22 !== peg$FAILED) {
          s1 = input.substring(s1, peg$currPos);
        } else {
          s1 = s22;
        }
        if (s1 === peg$FAILED) {
          s1 = peg$currPos;
          s22 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 46) {
            s32 = peg$c6;
            peg$currPos++;
          } else {
            s32 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e19);
            }
          }
          if (s32 !== peg$FAILED) {
            s42 = peg$currPos;
            s5 = [];
            if (peg$r1.test(input.charAt(peg$currPos))) {
              s6 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e31);
              }
            }
            if (s6 !== peg$FAILED) {
              while (s6 !== peg$FAILED) {
                s5.push(s6);
                if (peg$r1.test(input.charAt(peg$currPos))) {
                  s6 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e31);
                  }
                }
              }
            } else {
              s5 = peg$FAILED;
            }
            if (s5 !== peg$FAILED) {
              s42 = input.substring(s42, peg$currPos);
            } else {
              s42 = s5;
            }
            if (s42 !== peg$FAILED) {
              s32 = [s32, s42];
              s22 = s32;
            } else {
              peg$currPos = s22;
              s22 = peg$FAILED;
            }
          } else {
            peg$currPos = s22;
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = input.substring(s1, peg$currPos);
          } else {
            s1 = s22;
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f33(s1);
        }
        s0 = s1;
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e32);
          }
        }
        return s0;
      }
      function peg$parsediv() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parsepct();
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e33);
          }
        }
        return s0;
      }
      function peg$parsedec() {
        var s0, s1, s22;
        s0 = peg$parsepct();
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 43) {
            s1 = peg$c10;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e27);
            }
          }
          if (s1 !== peg$FAILED) {
            s22 = peg$parsepct();
            if (s22 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f34(s22);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 45) {
              s1 = peg$c11;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e29);
              }
            }
            if (s1 !== peg$FAILED) {
              s22 = peg$parsepct();
              if (s22 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f35(s22);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
        }
        return s0;
      }
      function peg$parseint() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parseminus();
        if (s1 === peg$FAILED) {
          s1 = null;
        }
        s22 = peg$parsenum();
        if (s22 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f36(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e34);
          }
        }
        return s0;
      }
      function peg$parse_() {
        var s0, s1;
        peg$silentFails++;
        s0 = [];
        if (peg$r2.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e36);
          }
        }
        while (s1 !== peg$FAILED) {
          s0.push(s1);
          if (peg$r2.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e36);
            }
          }
        }
        peg$silentFails--;
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e35);
        }
        return s0;
      }
      function peg$parsesp() {
        var s0, s1;
        s0 = [];
        if (peg$r2.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e36);
          }
        }
        if (s1 !== peg$FAILED) {
          while (s1 !== peg$FAILED) {
            s0.push(s1);
            if (peg$r2.test(input.charAt(peg$currPos))) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e36);
              }
            }
          }
        } else {
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsehex() {
        var s0, s1;
        s0 = peg$currPos;
        if (peg$r3.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e37);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f37(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parseEOL() {
        var s0, s1;
        s0 = peg$currPos;
        peg$silentFails++;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        peg$silentFails--;
        if (s1 === peg$FAILED) {
          s0 = void 0;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(
          peg$maxFailExpected,
          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
      }
    }
    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }()
);
var tabular_spec_default4 = (
  // Generated by Peggy 2.0.1.
  //
  // https://peggyjs.org/
  function() {
    "use strict";
    function peg$subclass(child, parent) {
      function C() {
        this.constructor = child;
      }
      C.prototype = parent.prototype;
      child.prototype = new C();
    }
    function peg$SyntaxError(message, expected, found, location) {
      var self = Error.call(this, message);
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(self, peg$SyntaxError.prototype);
      }
      self.expected = expected;
      self.found = found;
      self.location = location;
      self.name = "SyntaxError";
      return self;
    }
    peg$subclass(peg$SyntaxError, Error);
    function peg$padEnd(str, targetLength, padString) {
      padString = padString || " ";
      if (str.length > targetLength) {
        return str;
      }
      targetLength -= str.length;
      padString += padString.repeat(targetLength);
      return str + padString.slice(0, targetLength);
    }
    peg$SyntaxError.prototype.format = function(sources) {
      var str = "Error: " + this.message;
      if (this.location) {
        var src = null;
        var k;
        for (k = 0; k < sources.length; k++) {
          if (sources[k].source === this.location.source) {
            src = sources[k].text.split(/\r\n|\n|\r/g);
            break;
          }
        }
        var s5 = this.location.start;
        var loc = this.location.source + ":" + s5.line + ":" + s5.column;
        if (src) {
          var e = this.location.end;
          var filler = peg$padEnd("", s5.line.toString().length, " ");
          var line = src[s5.line - 1];
          var last = s5.line === e.line ? e.column : line.length + 1;
          var hatLen = last - s5.column || 1;
          str += "\n --> " + loc + "\n" + filler + " |\n" + s5.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s5.column - 1, " ") + peg$padEnd("", hatLen, "^");
        } else {
          str += "\n at " + loc;
        }
      }
      return str;
    };
    peg$SyntaxError.buildMessage = function(expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        class: function(expectation) {
          var escapedParts = expectation.parts.map(function(part) {
            return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
          });
          return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
        },
        any: function() {
          return "any character";
        },
        end: function() {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        }
      };
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s5) {
        return s5.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function classEscape(s5) {
        return s5.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = expected2.map(describeExpectation);
        var i, j;
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {};
      var peg$source = options.grammarSource;
      var peg$startRuleFunctions = { body: peg$parsebody };
      var peg$startRuleFunction = peg$parsebody;
      var peg$e0 = peg$otherExpectation("decl_start");
      var peg$e1 = peg$otherExpectation("decl_end");
      var peg$e2 = peg$otherExpectation("vert");
      var peg$e3 = peg$anyExpectation();
      var peg$e4 = peg$otherExpectation("l");
      var peg$e5 = peg$otherExpectation("r");
      var peg$e6 = peg$otherExpectation("c");
      var peg$e7 = peg$otherExpectation("p");
      var peg$e8 = peg$otherExpectation("m");
      var peg$e9 = peg$otherExpectation("b");
      var peg$e10 = peg$otherExpectation("w");
      var peg$e11 = peg$otherExpectation("W");
      var peg$e12 = peg$otherExpectation("X");
      var peg$e13 = peg$otherExpectation("!");
      var peg$e14 = peg$otherExpectation("@");
      var peg$e15 = peg$otherExpectation("<");
      var peg$e16 = peg$otherExpectation(">");
      var peg$e17 = peg$otherExpectation("group");
      var peg$e18 = peg$otherExpectation("whitespace");
      var peg$f0 = function(c) {
        return c;
      };
      var peg$f1 = function(cols) {
        return cols;
      };
      var peg$f2 = function() {
        return [];
      };
      var peg$f3 = function(divs1, start, a, end, divs2) {
        return {
          type: "column",
          pre_dividers: divs1,
          post_dividers: divs2,
          before_start_code: start,
          before_end_code: end,
          alignment: a
        };
      };
      var peg$f4 = function() {
        return {
          type: "vert_divider"
        };
      };
      var peg$f5 = function(b, g) {
        return {
          type: "bang_divider",
          content: g[0].content
        };
      };
      var peg$f6 = function(g) {
        return {
          type: "at_divider",
          content: g[0].content
        };
      };
      var peg$f7 = function(div) {
        return div;
      };
      var peg$f8 = function(g) {
        return { type: "decl_code", code: g[0].content };
      };
      var peg$f9 = function(g) {
        return { type: "decl_code", code: g[0].content };
      };
      var peg$f10 = function() {
        return { type: "alignment", alignment: "left" };
      };
      var peg$f11 = function() {
        return { type: "alignment", alignment: "center" };
      };
      var peg$f12 = function() {
        return { type: "alignment", alignment: "right" };
      };
      var peg$f13 = function() {
        return { type: "alignment", alignment: "X" };
      };
      var peg$f14 = function() {
        return "top";
      };
      var peg$f15 = function() {
        return "default";
      };
      var peg$f16 = function() {
        return "bottom";
      };
      var peg$f17 = function(a, g) {
        return {
          type: "alignment",
          alignment: "parbox",
          baseline: a,
          size: g[0].content
        };
      };
      var peg$f18 = function(g1, g2) {
        return {
          type: "alignment",
          alignment: "parbox",
          baseline: g1[0].content,
          size: g2[0].content
        };
      };
      var peg$f19 = function(tok) {
        return options.matchChar(tok, "|");
      };
      var peg$f20 = function(tok) {
        return options.matchChar(tok, "l");
      };
      var peg$f21 = function(tok) {
        return options.matchChar(tok, "r");
      };
      var peg$f22 = function(tok) {
        return options.matchChar(tok, "c");
      };
      var peg$f23 = function(tok) {
        return options.matchChar(tok, "p");
      };
      var peg$f24 = function(tok) {
        return options.matchChar(tok, "m");
      };
      var peg$f25 = function(tok) {
        return options.matchChar(tok, "b");
      };
      var peg$f26 = function(tok) {
        return options.matchChar(tok, "w");
      };
      var peg$f27 = function(tok) {
        return options.matchChar(tok, "W");
      };
      var peg$f28 = function(tok) {
        return options.matchChar(tok, "X");
      };
      var peg$f29 = function(tok) {
        return options.matchChar(tok, "!");
      };
      var peg$f30 = function(tok) {
        return options.matchChar(tok, "@");
      };
      var peg$f31 = function(tok) {
        return options.matchChar(tok, "<");
      };
      var peg$f32 = function(tok) {
        return options.matchChar(tok, ">");
      };
      var peg$f33 = function(tok) {
        return options.isGroup(tok);
      };
      var peg$f34 = function(tok) {
        return options.isWhitespace(tok);
      };
      var peg$currPos = 0;
      var peg$savedPos = 0;
      var peg$posDetailsCache = [{ line: 1, column: 1 }];
      var peg$maxFailPos = 0;
      var peg$maxFailExpected = [];
      var peg$silentFails = 0;
      var peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function offset() {
        return peg$savedPos;
      }
      function range() {
        return {
          source: peg$source,
          start: peg$savedPos,
          end: peg$currPos
        };
      }
      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError(
          [peg$otherExpectation(description)],
          input.substring(peg$savedPos, peg$currPos),
          location2
        );
      }
      function error(message, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location2);
      }
      function peg$literalExpectation(text2, ignoreCase) {
        return { type: "literal", text: text2, ignoreCase };
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts, inverted, ignoreCase };
      }
      function peg$anyExpectation() {
        return { type: "any" };
      }
      function peg$endExpectation() {
        return { type: "end" };
      }
      function peg$otherExpectation(description) {
        return { type: "other", description };
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p;
        if (details) {
          return details;
        } else {
          p = pos - 1;
          while (!peg$posDetailsCache[p]) {
            p--;
          }
          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };
          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos);
        var endPosDetails = peg$computePosDetails(endPos);
        return {
          source: peg$source,
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildSimpleError(message, location2) {
        return new peg$SyntaxError(message, null, null, location2);
      }
      function peg$buildStructuredError(expected2, found, location2) {
        return new peg$SyntaxError(
          peg$SyntaxError.buildMessage(expected2, found),
          expected2,
          found,
          location2
        );
      }
      function peg$parsebody() {
        var s0, s1, s22, s32, s42, s5;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$currPos;
        s32 = peg$parsecolumn();
        if (s32 !== peg$FAILED) {
          s42 = [];
          s5 = peg$parse_();
          while (s5 !== peg$FAILED) {
            s42.push(s5);
            s5 = peg$parse_();
          }
          peg$savedPos = s22;
          s22 = peg$f0(s32);
        } else {
          peg$currPos = s22;
          s22 = peg$FAILED;
        }
        if (s22 !== peg$FAILED) {
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            s22 = peg$currPos;
            s32 = peg$parsecolumn();
            if (s32 !== peg$FAILED) {
              s42 = [];
              s5 = peg$parse_();
              while (s5 !== peg$FAILED) {
                s42.push(s5);
                s5 = peg$parse_();
              }
              peg$savedPos = s22;
              s22 = peg$f0(s32);
            } else {
              peg$currPos = s22;
              s22 = peg$FAILED;
            }
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f1(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseEOL();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f2();
          }
          s0 = s1;
        }
        return s0;
      }
      function peg$parsecolumn() {
        var s0, s1, s22, s32, s42, s5, s6;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsecolumn_divider();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parsecolumn_divider();
        }
        s22 = peg$parsedecl_start();
        if (s22 === peg$FAILED) {
          s22 = null;
        }
        s32 = peg$parsealignment();
        if (s32 !== peg$FAILED) {
          s42 = peg$parsedecl_end();
          if (s42 === peg$FAILED) {
            s42 = null;
          }
          s5 = [];
          s6 = peg$parsecolumn_divider();
          while (s6 !== peg$FAILED) {
            s5.push(s6);
            s6 = peg$parsecolumn_divider();
          }
          peg$savedPos = s0;
          s0 = peg$f3(s1, s22, s32, s42, s5);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecolumn_divider() {
        var s0, s1, s22, s32, s42;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parse_();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parse_();
        }
        s22 = peg$currPos;
        s32 = peg$parsevert();
        if (s32 !== peg$FAILED) {
          peg$savedPos = s22;
          s32 = peg$f4();
        }
        s22 = s32;
        if (s22 === peg$FAILED) {
          s22 = peg$currPos;
          s32 = peg$parsebang();
          if (s32 !== peg$FAILED) {
            s42 = peg$parsegroup();
            if (s42 !== peg$FAILED) {
              peg$savedPos = s22;
              s22 = peg$f5(s32, s42);
            } else {
              peg$currPos = s22;
              s22 = peg$FAILED;
            }
          } else {
            peg$currPos = s22;
            s22 = peg$FAILED;
          }
          if (s22 === peg$FAILED) {
            s22 = peg$currPos;
            s32 = peg$parseat();
            if (s32 !== peg$FAILED) {
              s42 = peg$parsegroup();
              if (s42 !== peg$FAILED) {
                peg$savedPos = s22;
                s22 = peg$f6(s42);
              } else {
                peg$currPos = s22;
                s22 = peg$FAILED;
              }
            } else {
              peg$currPos = s22;
              s22 = peg$FAILED;
            }
          }
        }
        if (s22 !== peg$FAILED) {
          s32 = [];
          s42 = peg$parse_();
          while (s42 !== peg$FAILED) {
            s32.push(s42);
            s42 = peg$parse_();
          }
          peg$savedPos = s0;
          s0 = peg$f7(s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsedecl_start() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parsegreater();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsegroup();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f8(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        return s0;
      }
      function peg$parsedecl_end() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parseless();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsegroup();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f9(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e1);
          }
        }
        return s0;
      }
      function peg$parsealignment() {
        var s0, s1, s22, s32, s42, s5;
        s0 = peg$currPos;
        s1 = peg$parsel();
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f10();
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsec();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f11();
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parser();
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$f12();
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parseX();
              if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$f13();
              }
              s0 = s1;
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$currPos;
                s22 = peg$parsep();
                if (s22 !== peg$FAILED) {
                  peg$savedPos = s1;
                  s22 = peg$f14();
                }
                s1 = s22;
                if (s1 === peg$FAILED) {
                  s1 = peg$currPos;
                  s22 = peg$parsem();
                  if (s22 !== peg$FAILED) {
                    peg$savedPos = s1;
                    s22 = peg$f15();
                  }
                  s1 = s22;
                  if (s1 === peg$FAILED) {
                    s1 = peg$currPos;
                    s22 = peg$parseb();
                    if (s22 !== peg$FAILED) {
                      peg$savedPos = s1;
                      s22 = peg$f16();
                    }
                    s1 = s22;
                  }
                }
                if (s1 !== peg$FAILED) {
                  s22 = [];
                  s32 = peg$parse_();
                  while (s32 !== peg$FAILED) {
                    s22.push(s32);
                    s32 = peg$parse_();
                  }
                  s32 = peg$parsegroup();
                  if (s32 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s0 = peg$f17(s1, s32);
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  s1 = peg$parsew();
                  if (s1 === peg$FAILED) {
                    s1 = peg$parseW();
                  }
                  if (s1 !== peg$FAILED) {
                    s22 = [];
                    s32 = peg$parse_();
                    while (s32 !== peg$FAILED) {
                      s22.push(s32);
                      s32 = peg$parse_();
                    }
                    s32 = peg$parsegroup();
                    if (s32 !== peg$FAILED) {
                      s42 = [];
                      s5 = peg$parse_();
                      while (s5 !== peg$FAILED) {
                        s42.push(s5);
                        s5 = peg$parse_();
                      }
                      s5 = peg$parsegroup();
                      if (s5 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s0 = peg$f18(s32, s5);
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                }
              }
            }
          }
        }
        return s0;
      }
      function peg$parsevert() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f19(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        return s0;
      }
      function peg$parsel() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f20(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e4);
          }
        }
        return s0;
      }
      function peg$parser() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f21(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e5);
          }
        }
        return s0;
      }
      function peg$parsec() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f22(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e6);
          }
        }
        return s0;
      }
      function peg$parsep() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f23(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e7);
          }
        }
        return s0;
      }
      function peg$parsem() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f24(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e8);
          }
        }
        return s0;
      }
      function peg$parseb() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f25(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e9);
          }
        }
        return s0;
      }
      function peg$parsew() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f26(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e10);
          }
        }
        return s0;
      }
      function peg$parseW() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f27(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e11);
          }
        }
        return s0;
      }
      function peg$parseX() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f28(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e12);
          }
        }
        return s0;
      }
      function peg$parsebang() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f29(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e13);
          }
        }
        return s0;
      }
      function peg$parseat() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f30(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e14);
          }
        }
        return s0;
      }
      function peg$parseless() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f31(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e15);
          }
        }
        return s0;
      }
      function peg$parsegreater() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f32(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e16);
          }
        }
        return s0;
      }
      function peg$parsegroup() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f33(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e17);
          }
        }
        return s0;
      }
      function peg$parse_() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f34(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e18);
          }
        }
        return s0;
      }
      function peg$parseEOL() {
        var s0, s1;
        s0 = peg$currPos;
        peg$silentFails++;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        peg$silentFails--;
        if (s1 === peg$FAILED) {
          s0 = void 0;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      if (!options.isHash) {
        try {
          Object.assign(options, {
            matchChar: (node, char) => node.type === "string" && node.content === char,
            isGroup: (node) => node.type === "group",
            isWhitespace: (node) => node.type === "whitespace"
          });
        } catch (e) {
          console.warn("Error when initializing parser", e);
        }
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(
          peg$maxFailExpected,
          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
      }
    }
    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }()
);
var systeme_environment_default4 = (
  // Generated by Peggy 2.0.1.
  //
  // https://peggyjs.org/
  function() {
    "use strict";
    function peg$subclass(child, parent) {
      function C() {
        this.constructor = child;
      }
      C.prototype = parent.prototype;
      child.prototype = new C();
    }
    function peg$SyntaxError(message, expected, found, location) {
      var self = Error.call(this, message);
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(self, peg$SyntaxError.prototype);
      }
      self.expected = expected;
      self.found = found;
      self.location = location;
      self.name = "SyntaxError";
      return self;
    }
    peg$subclass(peg$SyntaxError, Error);
    function peg$padEnd(str, targetLength, padString) {
      padString = padString || " ";
      if (str.length > targetLength) {
        return str;
      }
      targetLength -= str.length;
      padString += padString.repeat(targetLength);
      return str + padString.slice(0, targetLength);
    }
    peg$SyntaxError.prototype.format = function(sources) {
      var str = "Error: " + this.message;
      if (this.location) {
        var src = null;
        var k;
        for (k = 0; k < sources.length; k++) {
          if (sources[k].source === this.location.source) {
            src = sources[k].text.split(/\r\n|\n|\r/g);
            break;
          }
        }
        var s5 = this.location.start;
        var loc = this.location.source + ":" + s5.line + ":" + s5.column;
        if (src) {
          var e = this.location.end;
          var filler = peg$padEnd("", s5.line.toString().length, " ");
          var line = src[s5.line - 1];
          var last = s5.line === e.line ? e.column : line.length + 1;
          var hatLen = last - s5.column || 1;
          str += "\n --> " + loc + "\n" + filler + " |\n" + s5.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s5.column - 1, " ") + peg$padEnd("", hatLen, "^");
        } else {
          str += "\n at " + loc;
        }
      }
      return str;
    };
    peg$SyntaxError.buildMessage = function(expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        class: function(expectation) {
          var escapedParts = expectation.parts.map(function(part) {
            return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
          });
          return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
        },
        any: function() {
          return "any character";
        },
        end: function() {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        }
      };
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s5) {
        return s5.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function classEscape(s5) {
        return s5.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = expected2.map(describeExpectation);
        var i, j;
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {};
      var peg$source = options.grammarSource;
      var peg$startRuleFunctions = { body: peg$parsebody };
      var peg$startRuleFunction = peg$parsebody;
      var peg$e0 = peg$otherExpectation("partial item");
      var peg$e1 = peg$otherExpectation("item");
      var peg$e2 = peg$anyExpectation();
      var peg$e3 = peg$otherExpectation("equation");
      var peg$e4 = peg$otherExpectation("trailing comment");
      var peg$e5 = peg$otherExpectation("comment only line");
      var peg$e6 = peg$otherExpectation("non-var token");
      var peg$e7 = peg$otherExpectation("token");
      var peg$e8 = peg$otherExpectation("same line comment");
      var peg$e9 = peg$otherExpectation("own line comment");
      var peg$e10 = peg$otherExpectation(",");
      var peg$e11 = peg$otherExpectation("@");
      var peg$e12 = peg$otherExpectation("variable token");
      var peg$e13 = peg$otherExpectation("+/-");
      var peg$e14 = peg$otherExpectation("=");
      var peg$f0 = function(a, b) {
        return a.concat(b ? b : []);
      };
      var peg$f1 = function() {
        return [];
      };
      var peg$f2 = function(a, b, c) {
        return a.concat(b, c);
      };
      var peg$f3 = function(op, a, b, c) {
        return { type: "item", op, variable: b, content: a.concat(b, c) };
      };
      var peg$f4 = function(op, a) {
        return { type: "item", op, variable: null, content: a };
      };
      var peg$f5 = function(line, sep, comment210) {
        return { ...line, sep: [].concat(sep), trailingComment: comment210 };
      };
      var peg$f6 = function(line, comment210) {
        return { ...line, trailingComment: comment210 };
      };
      var peg$f7 = function(eq, ann) {
        return {
          type: "line",
          equation: eq,
          annotation: ann,
          sep: null
        };
      };
      var peg$f8 = function(at, ann) {
        return at ? { type: "annotation", marker: at, content: ann } : null;
      };
      var peg$f9 = function(left, eq, right) {
        return { type: "equation", left, right, equals: eq };
      };
      var peg$f10 = function(x) {
        return x;
      };
      var peg$f11 = function(x) {
        return {
          type: "line",
          trailingComment: x
        };
      };
      var peg$f12 = function(v, s5) {
        return [v].concat(s5 ? s5 : []);
      };
      var peg$f13 = function(t) {
        return t;
      };
      var peg$f14 = function(x) {
        return x;
      };
      var peg$f15 = function(x) {
        return x;
      };
      var peg$f16 = function(tok) {
        return options.isSameLineComment(tok);
      };
      var peg$f17 = function(tok) {
        return tok;
      };
      var peg$f18 = function(tok) {
        return options.isOwnLineComment(tok);
      };
      var peg$f19 = function(tok) {
        return tok;
      };
      var peg$f20 = function(tok) {
        return options.isWhitespace(tok);
      };
      var peg$f21 = function(tok) {
        return tok;
      };
      var peg$f22 = function(tok) {
        return options.isSep(tok);
      };
      var peg$f23 = function(tok) {
        return tok;
      };
      var peg$f24 = function(tok) {
        return options.isAt(tok);
      };
      var peg$f25 = function(tok) {
        return tok;
      };
      var peg$f26 = function(tok) {
        return options.isVar(tok);
      };
      var peg$f27 = function(tok) {
        return tok;
      };
      var peg$f28 = function(tok) {
        return options.isOperation(tok);
      };
      var peg$f29 = function(tok) {
        return tok;
      };
      var peg$f30 = function(tok) {
        return options.isEquals(tok);
      };
      var peg$f31 = function(tok) {
        return tok;
      };
      var peg$f32 = function(tok) {
        return options.isSubscript(tok);
      };
      var peg$f33 = function(tok) {
        return tok;
      };
      var peg$currPos = 0;
      var peg$savedPos = 0;
      var peg$posDetailsCache = [{ line: 1, column: 1 }];
      var peg$maxFailPos = 0;
      var peg$maxFailExpected = [];
      var peg$silentFails = 0;
      var peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function offset() {
        return peg$savedPos;
      }
      function range() {
        return {
          source: peg$source,
          start: peg$savedPos,
          end: peg$currPos
        };
      }
      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError(
          [peg$otherExpectation(description)],
          input.substring(peg$savedPos, peg$currPos),
          location2
        );
      }
      function error(message, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location2);
      }
      function peg$literalExpectation(text2, ignoreCase) {
        return { type: "literal", text: text2, ignoreCase };
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts, inverted, ignoreCase };
      }
      function peg$anyExpectation() {
        return { type: "any" };
      }
      function peg$endExpectation() {
        return { type: "end" };
      }
      function peg$otherExpectation(description) {
        return { type: "other", description };
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p;
        if (details) {
          return details;
        } else {
          p = pos - 1;
          while (!peg$posDetailsCache[p]) {
            p--;
          }
          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };
          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos);
        var endPosDetails = peg$computePosDetails(endPos);
        return {
          source: peg$source,
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildSimpleError(message, location2) {
        return new peg$SyntaxError(message, null, null, location2);
      }
      function peg$buildStructuredError(expected2, found, location2) {
        return new peg$SyntaxError(
          peg$SyntaxError.buildMessage(expected2, found),
          expected2,
          found,
          location2
        );
      }
      function peg$parsebody() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsecomment_only_line();
        if (s22 === peg$FAILED) {
          s22 = peg$parseline_with_sep();
          if (s22 === peg$FAILED) {
            s22 = peg$parsepartial_line_with_comment();
          }
        }
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parsecomment_only_line();
          if (s22 === peg$FAILED) {
            s22 = peg$parseline_with_sep();
            if (s22 === peg$FAILED) {
              s22 = peg$parsepartial_line_with_comment();
            }
          }
        }
        s22 = peg$parseline_without_sep();
        if (s22 === peg$FAILED) {
          s22 = peg$parseEOL();
        }
        if (s22 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f0(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseEOL();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f1();
          }
          s0 = s1;
        }
        return s0;
      }
      function peg$parsepartial_item() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parse_();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parse_();
        }
        s22 = [];
        s32 = peg$parsenon_var_token();
        while (s32 !== peg$FAILED) {
          s22.push(s32);
          s32 = peg$parsenon_var_token();
        }
        s32 = [];
        s42 = peg$parse_();
        while (s42 !== peg$FAILED) {
          s32.push(s42);
          s42 = peg$parse_();
        }
        s42 = peg$parsevar();
        if (s42 !== peg$FAILED) {
          s5 = [];
          s6 = peg$parse_();
          while (s6 !== peg$FAILED) {
            s5.push(s6);
            s6 = peg$parse_();
          }
          s6 = [];
          s7 = peg$parsetoken();
          while (s7 !== peg$FAILED) {
            s6.push(s7);
            s7 = peg$parsetoken();
          }
          s7 = [];
          s8 = peg$parse_();
          while (s8 !== peg$FAILED) {
            s7.push(s8);
            s8 = peg$parse_();
          }
          peg$savedPos = s0;
          s0 = peg$f2(s22, s42, s6);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        return s0;
      }
      function peg$parseitem() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8, s9;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parseoperation();
        if (s1 === peg$FAILED) {
          s1 = null;
        }
        s22 = [];
        s32 = peg$parse_();
        while (s32 !== peg$FAILED) {
          s22.push(s32);
          s32 = peg$parse_();
        }
        s32 = [];
        s42 = peg$parsenon_var_token();
        while (s42 !== peg$FAILED) {
          s32.push(s42);
          s42 = peg$parsenon_var_token();
        }
        s42 = [];
        s5 = peg$parse_();
        while (s5 !== peg$FAILED) {
          s42.push(s5);
          s5 = peg$parse_();
        }
        s5 = peg$parsevar();
        if (s5 !== peg$FAILED) {
          s6 = [];
          s7 = peg$parse_();
          while (s7 !== peg$FAILED) {
            s6.push(s7);
            s7 = peg$parse_();
          }
          s7 = [];
          s8 = peg$parsetoken();
          while (s8 !== peg$FAILED) {
            s7.push(s8);
            s8 = peg$parsetoken();
          }
          s8 = [];
          s9 = peg$parse_();
          while (s9 !== peg$FAILED) {
            s8.push(s9);
            s9 = peg$parse_();
          }
          peg$savedPos = s0;
          s0 = peg$f3(s1, s32, s5, s7);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseoperation();
          if (s1 === peg$FAILED) {
            s1 = null;
          }
          s22 = [];
          s32 = peg$parse_();
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parse_();
          }
          s32 = [];
          s42 = peg$parsenon_var_token();
          if (s42 !== peg$FAILED) {
            while (s42 !== peg$FAILED) {
              s32.push(s42);
              s42 = peg$parsenon_var_token();
            }
          } else {
            s32 = peg$FAILED;
          }
          if (s32 !== peg$FAILED) {
            s42 = [];
            s5 = peg$parse_();
            while (s5 !== peg$FAILED) {
              s42.push(s5);
              s5 = peg$parse_();
            }
            peg$savedPos = s0;
            s0 = peg$f4(s1, s32);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e1);
          }
        }
        return s0;
      }
      function peg$parseline_with_sep() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$parseline_without_sep();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsesep();
          if (s22 !== peg$FAILED) {
            s32 = peg$parsetrailing_comment();
            if (s32 === peg$FAILED) {
              s32 = null;
            }
            peg$savedPos = s0;
            s0 = peg$f5(s1, s22, s32);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsepartial_line_with_comment() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parseline_without_sep();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsetrailing_comment();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f6(s1, s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseline_without_sep() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        if (input.length > peg$currPos) {
          s22 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s22 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        peg$silentFails--;
        if (s22 !== peg$FAILED) {
          peg$currPos = s1;
          s1 = void 0;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parseequation();
          s32 = peg$parseannotation();
          if (s32 === peg$FAILED) {
            s32 = null;
          }
          peg$savedPos = s0;
          s0 = peg$f7(s22, s32);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseannotation() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$parseat();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$parsenon_sep_token();
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parsenon_sep_token();
          }
          peg$savedPos = s0;
          s0 = peg$f8(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseequation() {
        var s0, s1, s22, s32, s42;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parseitem();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parseitem();
        }
        s22 = peg$parseequals();
        if (s22 === peg$FAILED) {
          s22 = null;
        }
        s32 = [];
        s42 = peg$parsetoken();
        if (s42 === peg$FAILED) {
          s42 = peg$parseoperation();
        }
        while (s42 !== peg$FAILED) {
          s32.push(s42);
          s42 = peg$parsetoken();
          if (s42 === peg$FAILED) {
            s42 = peg$parseoperation();
          }
        }
        peg$savedPos = s0;
        s0 = peg$f9(s1, s22, s32);
        peg$silentFails--;
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e3);
        }
        return s0;
      }
      function peg$parsetrailing_comment() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parse_();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parse_();
        }
        s22 = peg$parsesame_line_comment();
        if (s22 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f10(s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e4);
          }
        }
        return s0;
      }
      function peg$parsecomment_only_line() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parse_();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parse_();
        }
        s22 = peg$parseown_line_comment();
        if (s22 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f11(s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e5);
          }
        }
        return s0;
      }
      function peg$parsevar() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$parsevar_token();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$parse_();
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parse_();
          }
          s32 = peg$parsesubscript();
          if (s32 === peg$FAILED) {
            s32 = null;
          }
          peg$savedPos = s0;
          s0 = peg$f12(s1, s32);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsenon_var_token() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        s22 = peg$parsevar();
        peg$silentFails--;
        if (s22 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parsetoken();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f13(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e6);
          }
        }
        return s0;
      }
      function peg$parsenon_sep_token() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        s22 = peg$parsesep();
        if (s22 === peg$FAILED) {
          s22 = peg$parsetrailing_comment();
          if (s22 === peg$FAILED) {
            s22 = peg$parseown_line_comment();
          }
        }
        peg$silentFails--;
        if (s22 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s22 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f14(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsetoken() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        s22 = peg$parsesep();
        if (s22 === peg$FAILED) {
          s22 = peg$parseat();
          if (s22 === peg$FAILED) {
            s22 = peg$parseoperation();
            if (s22 === peg$FAILED) {
              s22 = peg$parseequals();
              if (s22 === peg$FAILED) {
                s22 = peg$parsetrailing_comment();
                if (s22 === peg$FAILED) {
                  s22 = peg$parseown_line_comment();
                }
              }
            }
          }
        }
        peg$silentFails--;
        if (s22 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s22 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f15(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e7);
          }
        }
        return s0;
      }
      function peg$parsesame_line_comment() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f16(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f17(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e8);
          }
        }
        return s0;
      }
      function peg$parseown_line_comment() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f18(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f19(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e9);
          }
        }
        return s0;
      }
      function peg$parse_() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f20(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f21(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsesep() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f22(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f23(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e10);
          }
        }
        return s0;
      }
      function peg$parseat() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f24(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f25(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e11);
          }
        }
        return s0;
      }
      function peg$parsevar_token() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f26(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f27(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e12);
          }
        }
        return s0;
      }
      function peg$parseoperation() {
        var s0, s1, s22, s32, s42;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parse_();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parse_();
        }
        if (input.length > peg$currPos) {
          s22 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s22 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        if (s22 !== peg$FAILED) {
          s32 = [];
          s42 = peg$parse_();
          while (s42 !== peg$FAILED) {
            s32.push(s42);
            s42 = peg$parse_();
          }
          peg$savedPos = peg$currPos;
          s42 = peg$f28(s22);
          if (s42) {
            s42 = void 0;
          } else {
            s42 = peg$FAILED;
          }
          if (s42 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f29(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e13);
          }
        }
        return s0;
      }
      function peg$parseequals() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f30(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f31(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e14);
          }
        }
        return s0;
      }
      function peg$parsesubscript() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f32(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f33(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseEOL() {
        var s0, s1;
        s0 = peg$currPos;
        peg$silentFails++;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        peg$silentFails--;
        if (s1 === peg$FAILED) {
          s0 = void 0;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      if (!options.isWhitespace) {
        try {
          Object.assign(options, {
            isSep: (node) => node.type === "string" && node.content === ",",
            isVar: (node) => node.type === "string" && node.content.match(/[a-zA-Z]/),
            isOperation: (node) => node.type === "string" && node.content.match(/[+-]/),
            isEquals: (node) => node.type === "string" && node.content === "=",
            isAt: (node) => node.type === "string" && node.content === "@",
            isSubscript: (node) => node.content === "_",
            isWhitespace: (node) => node.type === "whitespace",
            isSameLineComment: (node) => node.type === "comment" && node.sameline,
            isOwnLineComment: (node) => node.type === "comment" && !node.sameline
          });
        } catch (e) {
          console.warn("Error when initializing parser", e);
        }
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(
          peg$maxFailExpected,
          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
      }
    }
    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }()
);
var tex_glue_default4 = (
  // Generated by Peggy 2.0.1.
  //
  // https://peggyjs.org/
  function() {
    "use strict";
    function peg$subclass(child, parent) {
      function C() {
        this.constructor = child;
      }
      C.prototype = parent.prototype;
      child.prototype = new C();
    }
    function peg$SyntaxError(message, expected, found, location) {
      var self = Error.call(this, message);
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(self, peg$SyntaxError.prototype);
      }
      self.expected = expected;
      self.found = found;
      self.location = location;
      self.name = "SyntaxError";
      return self;
    }
    peg$subclass(peg$SyntaxError, Error);
    function peg$padEnd(str, targetLength, padString) {
      padString = padString || " ";
      if (str.length > targetLength) {
        return str;
      }
      targetLength -= str.length;
      padString += padString.repeat(targetLength);
      return str + padString.slice(0, targetLength);
    }
    peg$SyntaxError.prototype.format = function(sources) {
      var str = "Error: " + this.message;
      if (this.location) {
        var src = null;
        var k;
        for (k = 0; k < sources.length; k++) {
          if (sources[k].source === this.location.source) {
            src = sources[k].text.split(/\r\n|\n|\r/g);
            break;
          }
        }
        var s5 = this.location.start;
        var loc = this.location.source + ":" + s5.line + ":" + s5.column;
        if (src) {
          var e = this.location.end;
          var filler = peg$padEnd("", s5.line.toString().length, " ");
          var line = src[s5.line - 1];
          var last = s5.line === e.line ? e.column : line.length + 1;
          var hatLen = last - s5.column || 1;
          str += "\n --> " + loc + "\n" + filler + " |\n" + s5.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s5.column - 1, " ") + peg$padEnd("", hatLen, "^");
        } else {
          str += "\n at " + loc;
        }
      }
      return str;
    };
    peg$SyntaxError.buildMessage = function(expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        class: function(expectation) {
          var escapedParts = expectation.parts.map(function(part) {
            return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
          });
          return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
        },
        any: function() {
          return "any character";
        },
        end: function() {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        }
      };
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s5) {
        return s5.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function classEscape(s5) {
        return s5.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = expected2.map(describeExpectation);
        var i, j;
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {};
      var peg$source = options.grammarSource;
      var peg$startRuleFunctions = { root: peg$parseroot };
      var peg$startRuleFunction = peg$parseroot;
      var peg$c0 = "plus";
      var peg$c1 = "minus";
      var peg$c2 = "pt";
      var peg$c3 = "mm";
      var peg$c4 = "cm";
      var peg$c5 = "in";
      var peg$c6 = "ex";
      var peg$c7 = "em";
      var peg$c8 = "bp";
      var peg$c9 = "pc";
      var peg$c10 = "dd";
      var peg$c11 = "cc";
      var peg$c12 = "nd";
      var peg$c13 = "nc";
      var peg$c14 = "sp";
      var peg$c15 = "filll";
      var peg$c16 = "fill";
      var peg$c17 = "fil";
      var peg$c18 = ".";
      var peg$c19 = "+";
      var peg$c20 = "-";
      var peg$r0 = /^[0-9]/;
      var peg$e0 = peg$anyExpectation();
      var peg$e1 = peg$literalExpectation("plus", false);
      var peg$e2 = peg$literalExpectation("minus", false);
      var peg$e3 = peg$literalExpectation("pt", false);
      var peg$e4 = peg$literalExpectation("mm", false);
      var peg$e5 = peg$literalExpectation("cm", false);
      var peg$e6 = peg$literalExpectation("in", false);
      var peg$e7 = peg$literalExpectation("ex", false);
      var peg$e8 = peg$literalExpectation("em", false);
      var peg$e9 = peg$literalExpectation("bp", false);
      var peg$e10 = peg$literalExpectation("pc", false);
      var peg$e11 = peg$literalExpectation("dd", false);
      var peg$e12 = peg$literalExpectation("cc", false);
      var peg$e13 = peg$literalExpectation("nd", false);
      var peg$e14 = peg$literalExpectation("nc", false);
      var peg$e15 = peg$literalExpectation("sp", false);
      var peg$e16 = peg$literalExpectation("filll", false);
      var peg$e17 = peg$literalExpectation("fill", false);
      var peg$e18 = peg$literalExpectation("fil", false);
      var peg$e19 = peg$otherExpectation("number");
      var peg$e20 = peg$classExpectation([["0", "9"]], false, false);
      var peg$e21 = peg$literalExpectation(".", false);
      var peg$e22 = peg$literalExpectation("+", false);
      var peg$e23 = peg$literalExpectation("-", false);
      var peg$f0 = function(b, st, sh) {
        return {
          type: "glue",
          fixed: b,
          stretchable: st,
          shrinkable: sh,
          position: location()
        };
      };
      var peg$f1 = function(glue) {
        return glue;
      };
      var peg$f2 = function(n, u) {
        return { type: "dim", value: n, unit: u };
      };
      var peg$f3 = function(n, u) {
        return { type: "dim", value: n, unit: u };
      };
      var peg$f4 = function(n, u) {
        return { type: "dim", value: n, unit: u };
      };
      var peg$f5 = function(n) {
        return parseFloat(n);
      };
      var peg$currPos = 0;
      var peg$savedPos = 0;
      var peg$posDetailsCache = [{ line: 1, column: 1 }];
      var peg$maxFailPos = 0;
      var peg$maxFailExpected = [];
      var peg$silentFails = 0;
      var peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function offset() {
        return peg$savedPos;
      }
      function range() {
        return {
          source: peg$source,
          start: peg$savedPos,
          end: peg$currPos
        };
      }
      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError(
          [peg$otherExpectation(description)],
          input.substring(peg$savedPos, peg$currPos),
          location2
        );
      }
      function error(message, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location2);
      }
      function peg$literalExpectation(text2, ignoreCase) {
        return { type: "literal", text: text2, ignoreCase };
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts, inverted, ignoreCase };
      }
      function peg$anyExpectation() {
        return { type: "any" };
      }
      function peg$endExpectation() {
        return { type: "end" };
      }
      function peg$otherExpectation(description) {
        return { type: "other", description };
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p;
        if (details) {
          return details;
        } else {
          p = pos - 1;
          while (!peg$posDetailsCache[p]) {
            p--;
          }
          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };
          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos);
        var endPosDetails = peg$computePosDetails(endPos);
        return {
          source: peg$source,
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildSimpleError(message, location2) {
        return new peg$SyntaxError(message, null, null, location2);
      }
      function peg$buildStructuredError(expected2, found, location2) {
        return new peg$SyntaxError(
          peg$SyntaxError.buildMessage(expected2, found),
          expected2,
          found,
          location2
        );
      }
      function peg$parseroot() {
        var s0, s1, s22, s32, s42;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$parsebase();
        if (s22 !== peg$FAILED) {
          s32 = peg$parsestretchable();
          if (s32 === peg$FAILED) {
            s32 = null;
          }
          s42 = peg$parseshrinkable();
          if (s42 === peg$FAILED) {
            s42 = null;
          }
          peg$savedPos = s1;
          s1 = peg$f0(s22, s32, s42);
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s22 = [];
          if (input.length > peg$currPos) {
            s32 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s32 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            if (input.length > peg$currPos) {
              s32 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s32 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
          }
          peg$savedPos = s0;
          s0 = peg$f1(s1);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsebase() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parsenumber();
        if (s1 !== peg$FAILED) {
          s22 = peg$parseunit();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f2(s1, s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsestretchable() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 4) === peg$c0) {
          s1 = peg$c0;
          peg$currPos += 4;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e1);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parsenumber();
          if (s22 !== peg$FAILED) {
            s32 = peg$parserubber_unit();
            if (s32 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f3(s22, s32);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseshrinkable() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 5) === peg$c1) {
          s1 = peg$c1;
          peg$currPos += 5;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parsenumber();
          if (s22 !== peg$FAILED) {
            s32 = peg$parserubber_unit();
            if (s32 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f4(s22, s32);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseunit() {
        var s0;
        if (input.substr(peg$currPos, 2) === peg$c2) {
          s0 = peg$c2;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s0 === peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c3) {
            s0 = peg$c3;
            peg$currPos += 2;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e4);
            }
          }
          if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c4) {
              s0 = peg$c4;
              peg$currPos += 2;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e5);
              }
            }
            if (s0 === peg$FAILED) {
              if (input.substr(peg$currPos, 2) === peg$c5) {
                s0 = peg$c5;
                peg$currPos += 2;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e6);
                }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 2) === peg$c6) {
                  s0 = peg$c6;
                  peg$currPos += 2;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e7);
                  }
                }
                if (s0 === peg$FAILED) {
                  if (input.substr(peg$currPos, 2) === peg$c7) {
                    s0 = peg$c7;
                    peg$currPos += 2;
                  } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e8);
                    }
                  }
                  if (s0 === peg$FAILED) {
                    if (input.substr(peg$currPos, 2) === peg$c8) {
                      s0 = peg$c8;
                      peg$currPos += 2;
                    } else {
                      s0 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e9);
                      }
                    }
                    if (s0 === peg$FAILED) {
                      if (input.substr(peg$currPos, 2) === peg$c9) {
                        s0 = peg$c9;
                        peg$currPos += 2;
                      } else {
                        s0 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$e10);
                        }
                      }
                      if (s0 === peg$FAILED) {
                        if (input.substr(peg$currPos, 2) === peg$c10) {
                          s0 = peg$c10;
                          peg$currPos += 2;
                        } else {
                          s0 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$e11);
                          }
                        }
                        if (s0 === peg$FAILED) {
                          if (input.substr(peg$currPos, 2) === peg$c11) {
                            s0 = peg$c11;
                            peg$currPos += 2;
                          } else {
                            s0 = peg$FAILED;
                            if (peg$silentFails === 0) {
                              peg$fail(peg$e12);
                            }
                          }
                          if (s0 === peg$FAILED) {
                            if (input.substr(peg$currPos, 2) === peg$c12) {
                              s0 = peg$c12;
                              peg$currPos += 2;
                            } else {
                              s0 = peg$FAILED;
                              if (peg$silentFails === 0) {
                                peg$fail(peg$e13);
                              }
                            }
                            if (s0 === peg$FAILED) {
                              if (input.substr(peg$currPos, 2) === peg$c13) {
                                s0 = peg$c13;
                                peg$currPos += 2;
                              } else {
                                s0 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                  peg$fail(peg$e14);
                                }
                              }
                              if (s0 === peg$FAILED) {
                                if (input.substr(peg$currPos, 2) === peg$c14) {
                                  s0 = peg$c14;
                                  peg$currPos += 2;
                                } else {
                                  s0 = peg$FAILED;
                                  if (peg$silentFails === 0) {
                                    peg$fail(peg$e15);
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return s0;
      }
      function peg$parserubber_unit() {
        var s0;
        s0 = peg$parseunit();
        if (s0 === peg$FAILED) {
          if (input.substr(peg$currPos, 5) === peg$c15) {
            s0 = peg$c15;
            peg$currPos += 5;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e16);
            }
          }
          if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 4) === peg$c16) {
              s0 = peg$c16;
              peg$currPos += 4;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e17);
              }
            }
            if (s0 === peg$FAILED) {
              if (input.substr(peg$currPos, 3) === peg$c17) {
                s0 = peg$c17;
                peg$currPos += 3;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e18);
                }
              }
            }
          }
        }
        return s0;
      }
      function peg$parsenumber() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$currPos;
        s32 = peg$parsesign();
        if (s32 === peg$FAILED) {
          s32 = null;
        }
        s42 = peg$currPos;
        s5 = [];
        if (peg$r0.test(input.charAt(peg$currPos))) {
          s6 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s6 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e20);
          }
        }
        while (s6 !== peg$FAILED) {
          s5.push(s6);
          if (peg$r0.test(input.charAt(peg$currPos))) {
            s6 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s6 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e20);
            }
          }
        }
        if (input.charCodeAt(peg$currPos) === 46) {
          s6 = peg$c18;
          peg$currPos++;
        } else {
          s6 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e21);
          }
        }
        if (s6 !== peg$FAILED) {
          s7 = [];
          if (peg$r0.test(input.charAt(peg$currPos))) {
            s8 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s8 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e20);
            }
          }
          if (s8 !== peg$FAILED) {
            while (s8 !== peg$FAILED) {
              s7.push(s8);
              if (peg$r0.test(input.charAt(peg$currPos))) {
                s8 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s8 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e20);
                }
              }
            }
          } else {
            s7 = peg$FAILED;
          }
          if (s7 !== peg$FAILED) {
            s5 = [s5, s6, s7];
            s42 = s5;
          } else {
            peg$currPos = s42;
            s42 = peg$FAILED;
          }
        } else {
          peg$currPos = s42;
          s42 = peg$FAILED;
        }
        if (s42 === peg$FAILED) {
          s42 = [];
          if (peg$r0.test(input.charAt(peg$currPos))) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e20);
            }
          }
          if (s5 !== peg$FAILED) {
            while (s5 !== peg$FAILED) {
              s42.push(s5);
              if (peg$r0.test(input.charAt(peg$currPos))) {
                s5 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e20);
                }
              }
            }
          } else {
            s42 = peg$FAILED;
          }
        }
        if (s42 !== peg$FAILED) {
          s32 = [s32, s42];
          s22 = s32;
        } else {
          peg$currPos = s22;
          s22 = peg$FAILED;
        }
        if (s22 !== peg$FAILED) {
          s1 = input.substring(s1, peg$currPos);
        } else {
          s1 = s22;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f5(s1);
        }
        s0 = s1;
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e19);
          }
        }
        return s0;
      }
      function peg$parsesign() {
        var s0;
        if (input.charCodeAt(peg$currPos) === 43) {
          s0 = peg$c19;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e22);
          }
        }
        if (s0 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 45) {
            s0 = peg$c20;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e23);
            }
          }
        }
        return s0;
      }
      function peg$parseEOL() {
        var s0, s1;
        s0 = peg$currPos;
        peg$silentFails++;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        peg$silentFails--;
        if (s1 === peg$FAILED) {
          s0 = void 0;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(
          peg$maxFailExpected,
          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
      }
    }
    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }()
);
var tikz_default4 = (
  // Generated by Peggy 2.0.1.
  //
  // https://peggyjs.org/
  function() {
    "use strict";
    function peg$subclass(child, parent) {
      function C() {
        this.constructor = child;
      }
      C.prototype = parent.prototype;
      child.prototype = new C();
    }
    function peg$SyntaxError(message, expected, found, location) {
      var self = Error.call(this, message);
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(self, peg$SyntaxError.prototype);
      }
      self.expected = expected;
      self.found = found;
      self.location = location;
      self.name = "SyntaxError";
      return self;
    }
    peg$subclass(peg$SyntaxError, Error);
    function peg$padEnd(str, targetLength, padString) {
      padString = padString || " ";
      if (str.length > targetLength) {
        return str;
      }
      targetLength -= str.length;
      padString += padString.repeat(targetLength);
      return str + padString.slice(0, targetLength);
    }
    peg$SyntaxError.prototype.format = function(sources) {
      var str = "Error: " + this.message;
      if (this.location) {
        var src = null;
        var k;
        for (k = 0; k < sources.length; k++) {
          if (sources[k].source === this.location.source) {
            src = sources[k].text.split(/\r\n|\n|\r/g);
            break;
          }
        }
        var s5 = this.location.start;
        var loc = this.location.source + ":" + s5.line + ":" + s5.column;
        if (src) {
          var e = this.location.end;
          var filler = peg$padEnd("", s5.line.toString().length, " ");
          var line = src[s5.line - 1];
          var last = s5.line === e.line ? e.column : line.length + 1;
          var hatLen = last - s5.column || 1;
          str += "\n --> " + loc + "\n" + filler + " |\n" + s5.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s5.column - 1, " ") + peg$padEnd("", hatLen, "^");
        } else {
          str += "\n at " + loc;
        }
      }
      return str;
    };
    peg$SyntaxError.buildMessage = function(expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        class: function(expectation) {
          var escapedParts = expectation.parts.map(function(part) {
            return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
          });
          return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
        },
        any: function() {
          return "any character";
        },
        end: function() {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        }
      };
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s5) {
        return s5.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function classEscape(s5) {
        return s5.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = expected2.map(describeExpectation);
        var i, j;
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {};
      var peg$source = options.grammarSource;
      var peg$startRuleFunctions = { path_spec: peg$parsepath_spec, foreach_body: peg$parseforeach_body };
      var peg$startRuleFunction = peg$parsepath_spec;
      var peg$e0 = peg$anyExpectation();
      var peg$e1 = peg$otherExpectation("same line comment");
      var peg$e2 = peg$otherExpectation("own line comment");
      var peg$e3 = peg$otherExpectation("comment");
      var peg$e4 = peg$otherExpectation("floating comment");
      var peg$e5 = peg$otherExpectation("operation");
      var peg$e6 = peg$otherExpectation("=");
      var peg$f0 = function(v) {
        return v;
      };
      var peg$f1 = function(ops) {
        return { type: "path_spec", content: ops };
      };
      var peg$f2 = function(c1, op, comment210) {
        return { op, comment: comment210 };
      };
      var peg$f3 = function(c1, ops, c2, body) {
        const comments = [c1, ...ops.map((x) => x.comment), c2].filter(
          (x) => x
        );
        const attribute = ops.map((x) => x.op.content.content).join(" ");
        return {
          type: "animation",
          comments,
          attribute,
          content: body.content
        };
      };
      var peg$f4 = function(start, b) {
        return { ...b, start, type: "foreach" };
      };
      var peg$f5 = function(c1, variables, options2, c2, c3, list, c4, command) {
        const comments = [c1, c2, c3, c4].filter((x) => x);
        return {
          type: "foreach_body",
          variables,
          options: options2 && options2.content,
          list,
          command,
          comments
        };
      };
      var peg$f6 = function(c1, options2, c2, body) {
        const comments = [c1, c2].filter((x) => x);
        return {
          type: "svg_operation",
          options: options2 && options2.content,
          content: body,
          comments
        };
      };
      var peg$f7 = function(c1, c2, coord, c3, c4, x) {
        return { coord: x, comment: c4 };
      };
      var peg$f8 = function(c1, c2, coord, c3, a, c5) {
        const comments = [c1, c2, c3, a && a.comment, c5].filter((x) => x);
        return {
          type: "curve_to",
          controls: a ? [coord, a.coord] : [coord],
          comments
        };
      };
      var peg$f9 = function() {
        return { type: "line_to", command: "|-" };
      };
      var peg$f10 = function() {
        return { type: "line_to", command: "-|" };
      };
      var peg$f11 = function() {
        return { type: "line_to", command: "--" };
      };
      var peg$f12 = function(prefix, content) {
        return { type: "coordinate", content, prefix };
      };
      var peg$f13 = function(content) {
        return { type: "square_brace_group", content };
      };
      var peg$f14 = function(v) {
        return { type: "unknown", content: v };
      };
      var peg$f15 = function(tok) {
        return options.isSameLineComment(tok);
      };
      var peg$f16 = function(tok) {
        return tok;
      };
      var peg$f17 = function(tok) {
        return options.isOwnLineComment(tok);
      };
      var peg$f18 = function(tok) {
        return tok;
      };
      var peg$f19 = function(tok) {
        return options.isComment(tok);
      };
      var peg$f20 = function(tok) {
        return tok;
      };
      var peg$f21 = function(tok) {
        return options.isWhitespace(tok);
      };
      var peg$f22 = function(tok) {
        return tok;
      };
      var peg$f23 = function(c) {
        return c;
      };
      var peg$f24 = function(tok) {
        return options.isOperation(tok);
      };
      var peg$f25 = function(tok) {
        return { type: "operation", content: tok };
      };
      var peg$f26 = function(tok) {
        return options.isChar(tok, "=");
      };
      var peg$f27 = function(tok) {
        return tok;
      };
      var peg$f28 = function(tok) {
        return options.isChar(tok, "[");
      };
      var peg$f29 = function(tok) {
        return tok;
      };
      var peg$f30 = function(tok) {
        return options.isChar(tok, "]");
      };
      var peg$f31 = function(tok) {
        return tok;
      };
      var peg$f32 = function(tok) {
        return options.isChar(tok, "(");
      };
      var peg$f33 = function(tok) {
        return tok;
      };
      var peg$f34 = function(tok) {
        return options.isChar(tok, ")");
      };
      var peg$f35 = function(tok) {
        return tok;
      };
      var peg$f36 = function(tok) {
        return options.isChar(tok, "+");
      };
      var peg$f37 = function(tok) {
        return tok;
      };
      var peg$f38 = function(tok) {
        return options.isChar(tok, "-");
      };
      var peg$f39 = function(tok) {
        return tok;
      };
      var peg$f40 = function(tok) {
        return options.isChar(tok, "|");
      };
      var peg$f41 = function(tok) {
        return tok;
      };
      var peg$f42 = function(tok) {
        return options.isChar(tok, ".");
      };
      var peg$f43 = function(tok) {
        return tok;
      };
      var peg$f44 = function(tok) {
        return options.isChar(tok, "controls");
      };
      var peg$f45 = function(tok) {
        return tok;
      };
      var peg$f46 = function(tok) {
        return options.isChar(tok, "and");
      };
      var peg$f47 = function(tok) {
        return tok;
      };
      var peg$f48 = function(tok) {
        return options.isChar(tok, "svg");
      };
      var peg$f49 = function(tok) {
        return tok;
      };
      var peg$f50 = function(tok) {
        return options.isGroup(tok);
      };
      var peg$f51 = function(tok) {
        return tok;
      };
      var peg$f52 = function(tok) {
        return options.isAnyMacro(tok);
      };
      var peg$f53 = function(tok) {
        return tok;
      };
      var peg$f54 = function(tok) {
        return options.isChar(tok, "foreach");
      };
      var peg$f55 = function(tok) {
        return tok;
      };
      var peg$f56 = function(tok) {
        return options.isMacro(tok, "foreach");
      };
      var peg$f57 = function(tok) {
        return tok;
      };
      var peg$f58 = function(tok) {
        return options.isChar(tok, "in");
      };
      var peg$f59 = function(tok) {
        return tok;
      };
      var peg$f60 = function(tok) {
        return options.isChar(tok, ":");
      };
      var peg$f61 = function(tok) {
        return tok;
      };
      var peg$currPos = 0;
      var peg$savedPos = 0;
      var peg$posDetailsCache = [{ line: 1, column: 1 }];
      var peg$maxFailPos = 0;
      var peg$maxFailExpected = [];
      var peg$silentFails = 0;
      var peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function offset() {
        return peg$savedPos;
      }
      function range() {
        return {
          source: peg$source,
          start: peg$savedPos,
          end: peg$currPos
        };
      }
      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError(
          [peg$otherExpectation(description)],
          input.substring(peg$savedPos, peg$currPos),
          location2
        );
      }
      function error(message, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location2);
      }
      function peg$literalExpectation(text2, ignoreCase) {
        return { type: "literal", text: text2, ignoreCase };
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts, inverted, ignoreCase };
      }
      function peg$anyExpectation() {
        return { type: "any" };
      }
      function peg$endExpectation() {
        return { type: "end" };
      }
      function peg$otherExpectation(description) {
        return { type: "other", description };
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p;
        if (details) {
          return details;
        } else {
          p = pos - 1;
          while (!peg$posDetailsCache[p]) {
            p--;
          }
          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };
          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos);
        var endPosDetails = peg$computePosDetails(endPos);
        return {
          source: peg$source,
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildSimpleError(message, location2) {
        return new peg$SyntaxError(message, null, null, location2);
      }
      function peg$buildStructuredError(expected2, found, location2) {
        return new peg$SyntaxError(
          peg$SyntaxError.buildMessage(expected2, found),
          expected2,
          found,
          location2
        );
      }
      function peg$parsepath_spec() {
        var s0, s1, s22, s32, s42, s5;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$currPos;
        s32 = peg$parsesquare_brace_group();
        if (s32 === peg$FAILED) {
          s32 = peg$parsecoordinate();
          if (s32 === peg$FAILED) {
            s32 = peg$parsecurve_to();
            if (s32 === peg$FAILED) {
              s32 = peg$parseline_to();
              if (s32 === peg$FAILED) {
                s32 = peg$parsesvg();
                if (s32 === peg$FAILED) {
                  s32 = peg$parseforeach();
                  if (s32 === peg$FAILED) {
                    s32 = peg$parseoperation();
                    if (s32 === peg$FAILED) {
                      s32 = peg$parsecomment();
                      if (s32 === peg$FAILED) {
                        s32 = peg$parseanimation();
                        if (s32 === peg$FAILED) {
                          s32 = peg$parseunknown();
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (s32 !== peg$FAILED) {
          s42 = [];
          s5 = peg$parse_();
          while (s5 !== peg$FAILED) {
            s42.push(s5);
            s5 = peg$parse_();
          }
          peg$savedPos = s22;
          s22 = peg$f0(s32);
        } else {
          peg$currPos = s22;
          s22 = peg$FAILED;
        }
        if (s22 !== peg$FAILED) {
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            s22 = peg$currPos;
            s32 = peg$parsesquare_brace_group();
            if (s32 === peg$FAILED) {
              s32 = peg$parsecoordinate();
              if (s32 === peg$FAILED) {
                s32 = peg$parsecurve_to();
                if (s32 === peg$FAILED) {
                  s32 = peg$parseline_to();
                  if (s32 === peg$FAILED) {
                    s32 = peg$parsesvg();
                    if (s32 === peg$FAILED) {
                      s32 = peg$parseforeach();
                      if (s32 === peg$FAILED) {
                        s32 = peg$parseoperation();
                        if (s32 === peg$FAILED) {
                          s32 = peg$parsecomment();
                          if (s32 === peg$FAILED) {
                            s32 = peg$parseanimation();
                            if (s32 === peg$FAILED) {
                              s32 = peg$parseunknown();
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            if (s32 !== peg$FAILED) {
              s42 = [];
              s5 = peg$parse_();
              while (s5 !== peg$FAILED) {
                s42.push(s5);
                s5 = peg$parse_();
              }
              peg$savedPos = s22;
              s22 = peg$f0(s32);
            } else {
              peg$currPos = s22;
              s22 = peg$FAILED;
            }
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f1(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parseanimation() {
        var s0, s1, s22, s32, s42, s5, s6;
        s0 = peg$currPos;
        s1 = peg$parsecolon();
        if (s1 !== peg$FAILED) {
          s22 = peg$parse_comment_();
          s32 = [];
          s42 = peg$currPos;
          s5 = peg$parseoperation();
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_comment_();
            peg$savedPos = s42;
            s42 = peg$f2(s22, s5, s6);
          } else {
            peg$currPos = s42;
            s42 = peg$FAILED;
          }
          if (s42 !== peg$FAILED) {
            while (s42 !== peg$FAILED) {
              s32.push(s42);
              s42 = peg$currPos;
              s5 = peg$parseoperation();
              if (s5 !== peg$FAILED) {
                s6 = peg$parse_comment_();
                peg$savedPos = s42;
                s42 = peg$f2(s22, s5, s6);
              } else {
                peg$currPos = s42;
                s42 = peg$FAILED;
              }
            }
          } else {
            s32 = peg$FAILED;
          }
          if (s32 !== peg$FAILED) {
            s42 = peg$parseequals();
            if (s42 !== peg$FAILED) {
              s5 = peg$parse_comment_();
              s6 = peg$parsegroup();
              if (s6 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f3(s22, s32, s5, s6);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseforeach() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parseforeach_keyword();
        if (s1 === peg$FAILED) {
          s1 = peg$parseforeach_macro();
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parseforeach_body();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f4(s1, s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseforeach_body() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8, s9;
        s0 = peg$currPos;
        s1 = peg$parse_comment_();
        s22 = peg$currPos;
        s32 = [];
        s42 = peg$currPos;
        s5 = peg$currPos;
        peg$silentFails++;
        s6 = peg$parsein_keyword();
        if (s6 === peg$FAILED) {
          s6 = peg$parsesquare_brace_group();
        }
        peg$silentFails--;
        if (s6 === peg$FAILED) {
          s5 = void 0;
        } else {
          peg$currPos = s5;
          s5 = peg$FAILED;
        }
        if (s5 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s6 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s6 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s6 !== peg$FAILED) {
            s5 = [s5, s6];
            s42 = s5;
          } else {
            peg$currPos = s42;
            s42 = peg$FAILED;
          }
        } else {
          peg$currPos = s42;
          s42 = peg$FAILED;
        }
        while (s42 !== peg$FAILED) {
          s32.push(s42);
          s42 = peg$currPos;
          s5 = peg$currPos;
          peg$silentFails++;
          s6 = peg$parsein_keyword();
          if (s6 === peg$FAILED) {
            s6 = peg$parsesquare_brace_group();
          }
          peg$silentFails--;
          if (s6 === peg$FAILED) {
            s5 = void 0;
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
          if (s5 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s6 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            if (s6 !== peg$FAILED) {
              s5 = [s5, s6];
              s42 = s5;
            } else {
              peg$currPos = s42;
              s42 = peg$FAILED;
            }
          } else {
            peg$currPos = s42;
            s42 = peg$FAILED;
          }
        }
        s22 = input.substring(s22, peg$currPos);
        s32 = peg$parsesquare_brace_group();
        if (s32 === peg$FAILED) {
          s32 = null;
        }
        s42 = peg$parse_comment_();
        s5 = peg$parsein_keyword();
        if (s5 !== peg$FAILED) {
          s6 = peg$parse_comment_();
          s7 = peg$parsegroup();
          if (s7 === peg$FAILED) {
            s7 = peg$parsemacro();
          }
          if (s7 !== peg$FAILED) {
            s8 = peg$parse_comment_();
            s9 = peg$parseforeach();
            if (s9 === peg$FAILED) {
              s9 = peg$parsegroup();
              if (s9 === peg$FAILED) {
                s9 = peg$parsemacro();
              }
            }
            if (s9 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f5(s1, s22, s32, s42, s6, s7, s8, s9);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsesvg() {
        var s0, s1, s22, s32, s42, s5;
        s0 = peg$currPos;
        s1 = peg$parsesvg_keyword();
        if (s1 !== peg$FAILED) {
          s22 = peg$parse_comment_();
          s32 = peg$parsesquare_brace_group();
          if (s32 === peg$FAILED) {
            s32 = null;
          }
          s42 = peg$parse_comment_();
          s5 = peg$parsegroup();
          if (s5 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f6(s22, s32, s42, s5);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecurve_to() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8, s9, s10;
        s0 = peg$currPos;
        s1 = peg$parsedotdot();
        if (s1 !== peg$FAILED) {
          s22 = peg$parse_comment_();
          s32 = peg$parsecontrols_keyword();
          if (s32 !== peg$FAILED) {
            s42 = peg$parse_comment_();
            s5 = peg$parsecoordinate();
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_comment_();
              s7 = peg$currPos;
              s8 = peg$parseand_keyword();
              if (s8 !== peg$FAILED) {
                s9 = peg$parse_comment_();
                s10 = peg$parsecoordinate();
                if (s10 !== peg$FAILED) {
                  peg$savedPos = s7;
                  s7 = peg$f7(s22, s42, s5, s6, s9, s10);
                } else {
                  peg$currPos = s7;
                  s7 = peg$FAILED;
                }
              } else {
                peg$currPos = s7;
                s7 = peg$FAILED;
              }
              if (s7 === peg$FAILED) {
                s7 = null;
              }
              s8 = peg$parse_comment_();
              s9 = peg$parsedotdot();
              if (s9 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f8(s22, s42, s5, s6, s7, s8);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseline_to() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parsepipe();
        if (s1 !== peg$FAILED) {
          s22 = peg$parseminus();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f9();
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseminus();
          if (s1 !== peg$FAILED) {
            s22 = peg$parsepipe();
            if (s22 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f10();
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseminus();
            if (s1 !== peg$FAILED) {
              s22 = peg$parseminus();
              if (s22 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f11();
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
        }
        return s0;
      }
      function peg$parsecoordinate() {
        var s0, s1, s22, s32, s42, s5, s6, s7;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$currPos;
        s32 = peg$parseplus();
        if (s32 !== peg$FAILED) {
          s42 = peg$parseplus();
          if (s42 === peg$FAILED) {
            s42 = null;
          }
          s32 = [s32, s42];
          s22 = s32;
        } else {
          peg$currPos = s22;
          s22 = peg$FAILED;
        }
        if (s22 === peg$FAILED) {
          s22 = null;
        }
        s1 = input.substring(s1, peg$currPos);
        s22 = peg$parseopen_paren();
        if (s22 !== peg$FAILED) {
          s32 = peg$currPos;
          s42 = [];
          s5 = peg$currPos;
          s6 = peg$currPos;
          peg$silentFails++;
          s7 = peg$parseclose_paren();
          peg$silentFails--;
          if (s7 === peg$FAILED) {
            s6 = void 0;
          } else {
            peg$currPos = s6;
            s6 = peg$FAILED;
          }
          if (s6 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s7 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s7 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            if (s7 !== peg$FAILED) {
              s6 = [s6, s7];
              s5 = s6;
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
          while (s5 !== peg$FAILED) {
            s42.push(s5);
            s5 = peg$currPos;
            s6 = peg$currPos;
            peg$silentFails++;
            s7 = peg$parseclose_paren();
            peg$silentFails--;
            if (s7 === peg$FAILED) {
              s6 = void 0;
            } else {
              peg$currPos = s6;
              s6 = peg$FAILED;
            }
            if (s6 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s7 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s7 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              if (s7 !== peg$FAILED) {
                s6 = [s6, s7];
                s5 = s6;
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
          }
          s32 = input.substring(s32, peg$currPos);
          s42 = peg$parseclose_paren();
          if (s42 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f12(s1, s32);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsesquare_brace_group() {
        var s0, s1, s22, s32, s42, s5, s6;
        s0 = peg$currPos;
        s1 = peg$parseopen_square_brace();
        if (s1 !== peg$FAILED) {
          s22 = peg$currPos;
          s32 = [];
          s42 = peg$currPos;
          s5 = peg$currPos;
          peg$silentFails++;
          s6 = peg$parseclose_square_brace();
          peg$silentFails--;
          if (s6 === peg$FAILED) {
            s5 = void 0;
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
          if (s5 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s6 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            if (s6 !== peg$FAILED) {
              s5 = [s5, s6];
              s42 = s5;
            } else {
              peg$currPos = s42;
              s42 = peg$FAILED;
            }
          } else {
            peg$currPos = s42;
            s42 = peg$FAILED;
          }
          while (s42 !== peg$FAILED) {
            s32.push(s42);
            s42 = peg$currPos;
            s5 = peg$currPos;
            peg$silentFails++;
            s6 = peg$parseclose_square_brace();
            peg$silentFails--;
            if (s6 === peg$FAILED) {
              s5 = void 0;
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
            if (s5 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s6 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              if (s6 !== peg$FAILED) {
                s5 = [s5, s6];
                s42 = s5;
              } else {
                peg$currPos = s42;
                s42 = peg$FAILED;
              }
            } else {
              peg$currPos = s42;
              s42 = peg$FAILED;
            }
          }
          s22 = input.substring(s22, peg$currPos);
          s32 = peg$parseclose_square_brace();
          if (s32 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f13(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsedotdot() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parsedot();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsedot();
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseunknown() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f14(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parsesame_line_comment() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f15(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f16(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e1);
          }
        }
        return s0;
      }
      function peg$parseown_line_comment() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f17(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f18(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        return s0;
      }
      function peg$parsecomment() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f19(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f20(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        return s0;
      }
      function peg$parse_() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f21(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f22(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parse_comment_() {
        var s0, s1, s22, s32, s42;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parse_();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parse_();
        }
        s22 = peg$parsecomment();
        if (s22 === peg$FAILED) {
          s22 = null;
        }
        s32 = [];
        s42 = peg$parse_();
        while (s42 !== peg$FAILED) {
          s32.push(s42);
          s42 = peg$parse_();
        }
        peg$savedPos = s0;
        s0 = peg$f23(s22);
        peg$silentFails--;
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e4);
        }
        return s0;
      }
      function peg$parseoperation() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f24(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f25(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e5);
          }
        }
        return s0;
      }
      function peg$parseequals() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f26(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f27(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e6);
          }
        }
        return s0;
      }
      function peg$parseopen_square_brace() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f28(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f29(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseclose_square_brace() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f30(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f31(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseopen_paren() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f32(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f33(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseclose_paren() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f34(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f35(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseplus() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f36(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f37(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseminus() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f38(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f39(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsepipe() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f40(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f41(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsedot() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f42(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f43(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecontrols_keyword() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f44(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f45(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseand_keyword() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f46(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f47(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsesvg_keyword() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f48(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f49(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsegroup() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f50(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f51(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsemacro() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f52(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f53(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseforeach_keyword() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f54(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f55(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseforeach_macro() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f56(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f57(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsein_keyword() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f58(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f59(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecolon() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f60(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f61(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseEOL() {
        var s0, s1;
        s0 = peg$currPos;
        peg$silentFails++;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        peg$silentFails--;
        if (s1 === peg$FAILED) {
          s0 = void 0;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      if (!options.isWhitespace) {
        try {
          Object.assign(options, {
            isChar: (node, char) => node.type === "string" && node.content === char,
            isOperation: (node) => node.type === "string" && node.content.match(/[a-zA-Z]/),
            isWhitespace: (node) => node.type === "whitespace" || node.type === "parbreak",
            isSameLineComment: (node) => node.type === "comment" && node.sameline,
            isOwnLineComment: (node) => node.type === "comment" && !node.sameline,
            isComment: (node) => node.type === "comment",
            isGroup: (node) => node.type === "group",
            isMacro: (node, name) => node.type === "macro" && node.content === name,
            isAnyMacro: (node) => node.type === "macro"
          });
        } catch (e) {
          console.warn("Error when initializing parser", e);
        }
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(
          peg$maxFailExpected,
          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
      }
    }
    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }()
);
var LatexPegParser = latex_default4;

// libs/parse-minimal.ts
function parseMinimal(str) {
  return LatexPegParser.parse(str);
}
function parseMathMinimal(str) {
  return LatexPegParser.parse(str, { startRule: "math" });
}

// libs/plugin-from-string-minimal.ts
var unifiedLatexFromStringMinimal = function unifiedLatexFromStringMinimal2(options) {
  const parser2 = (str) => {
    if ((options == null ? void 0 : options.mode) === "math") {
      return {
        type: "root",
        content: parseMathMinimal(str),
        _renderInfo: { inMathMode: true }
      };
    }
    return parseMinimal(str);
  };
  Object.assign(this, { Parser: parser2 });
};

// ../unified-latex-util-visit/dist/index.js
var linebreak16 = Symbol("linebreak");
var ESCAPE15 = "\\";
function _printRaw15(node) {
  if (typeof node === "string") {
    return [node];
  }
  if (Array.isArray(node)) {
    return [].concat(
      ...node.map((n) => _printRaw15(n))
    );
  }
  let argsString, escape;
  switch (node.type) {
    case "root":
      return _printRaw15(node.content);
    case "argument":
      return [node.openMark, ..._printRaw15(node.content), node.closeMark];
    case "comment":
      var suffix = node.suffixParbreak ? "" : linebreak16;
      var leadingWhitespace = "";
      if (node.sameline && node.leadingWhitespace) {
        leadingWhitespace = " ";
      }
      if (node.sameline) {
        return [
          leadingWhitespace,
          "%",
          ..._printRaw15(node.content),
          suffix
        ];
      }
      return [linebreak16, "%", ..._printRaw15(node.content), suffix];
    case "environment":
    case "mathenv":
    case "verbatim":
      var env = _printRaw15(node.env);
      var envStart = [ESCAPE15 + "begin{", ...env, "}"];
      var envEnd = [ESCAPE15 + "end{", ...env, "}"];
      argsString = node.args == null ? [] : _printRaw15(node.args);
      return [
        ...envStart,
        ...argsString,
        ..._printRaw15(node.content),
        ...envEnd
      ];
    case "displaymath":
      return [ESCAPE15 + "[", ..._printRaw15(node.content), ESCAPE15 + "]"];
    case "group":
      return ["{", ..._printRaw15(node.content), "}"];
    case "inlinemath":
      return ["$", ..._printRaw15(node.content), "$"];
    case "macro":
      argsString = node.args == null ? [] : _printRaw15(node.args);
      escape = node.escapeToken == null ? ESCAPE15 : node.escapeToken;
      return [escape, ..._printRaw15(node.content), ...argsString];
    case "parbreak":
      return [linebreak16, linebreak16];
    case "string":
      return [node.content];
    case "verb":
      return [
        ESCAPE15,
        node.env,
        node.escape,
        ..._printRaw15(node.content),
        node.escape
      ];
    case "whitespace":
      return [" "];
    default:
      console.warn(
        "Cannot find render for node ",
        node,
        `(of type ${typeof node})`
      );
      return ["" + node];
  }
}
function printRaw15(node, options) {
  const asArray = options != null ? options.asArray : false;
  const printedTokens = _printRaw15(node);
  if (asArray) {
    return printedTokens;
  }
  return printedTokens.map((x) => x === linebreak16 ? "\n" : x).join("");
}
function createMacroMatcher15(macros15) {
  const macrosHash = Array.isArray(macros15) ? macros15.length > 0 ? typeof macros15[0] === "string" ? Object.fromEntries(
    macros15.map((macro210) => {
      if (typeof macro210 !== "string") {
        throw new Error("Wrong branch of map function");
      }
      return [macro210, {}];
    })
  ) : Object.fromEntries(
    macros15.map((macro210) => {
      if (typeof macro210 === "string") {
        throw new Error("Wrong branch of map function");
      }
      if (macro210.escapeToken != null) {
        return [
          macro210.content,
          { escapeToken: macro210.escapeToken }
        ];
      }
      return [macro210.content, {}];
    })
  ) : {} : macros15;
  return function matchAgainstMacros(node) {
    if (node == null || node.type !== "macro") {
      return false;
    }
    const spec = macrosHash[node.content];
    if (!spec) {
      return false;
    }
    if (typeof spec === "object" && "escapeToken" in spec) {
      return spec.escapeToken == null || spec.escapeToken === node.escapeToken;
    }
    return true;
  };
}
function createEnvironmentMatcher15(macros15) {
  const environmentsHash = Array.isArray(macros15) ? Object.fromEntries(
    macros15.map((str) => {
      return [str, {}];
    })
  ) : macros15;
  return function matchAgainstEnvironments(node) {
    if (!match15.anyEnvironment(node)) {
      return false;
    }
    const envName = printRaw15(node.env);
    const spec = environmentsHash[envName];
    if (!spec) {
      return false;
    }
    return true;
  };
}
var match15 = {
  macro(node, macroName) {
    if (node == null) {
      return false;
    }
    return node.type === "macro" && (macroName == null || node.content === macroName);
  },
  anyMacro(node) {
    return match15.macro(node);
  },
  environment(node, envName) {
    if (node == null) {
      return false;
    }
    return (node.type === "environment" || node.type === "mathenv") && (envName == null || printRaw15(node.env) === envName);
  },
  anyEnvironment(node) {
    return match15.environment(node);
  },
  comment(node) {
    if (node == null) {
      return false;
    }
    return node.type === "comment";
  },
  parbreak(node) {
    if (node == null) {
      return false;
    }
    return node.type === "parbreak";
  },
  whitespace(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace";
  },
  /**
   * Matches whitespace or a comment with leading whitespace.
   */
  whitespaceLike(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace" || node.type === "whitespace" && node.leadingWhitespace === true;
  },
  string(node, value) {
    if (node == null) {
      return false;
    }
    return node.type === "string" && (value == null || node.content === value);
  },
  anyString(node) {
    return match15.string(node);
  },
  group(node) {
    if (node == null) {
      return false;
    }
    return node.type === "group";
  },
  argument(node) {
    if (node == null) {
      return false;
    }
    return node.type === "argument";
  },
  blankArgument(node) {
    if (!match15.argument(node)) {
      return false;
    }
    return node.openMark === "" && node.closeMark === "" && node.content.length === 0;
  },
  math(node) {
    if (node == null) {
      return false;
    }
    return node.type === "displaymath" || node.type === "inlinemath";
  },
  createMacroMatcher: createMacroMatcher15,
  createEnvironmentMatcher: createEnvironmentMatcher15
};
var {
  anyEnvironment: anyEnvironment15,
  anyMacro: anyMacro15,
  anyString: anyString15,
  argument: argument15,
  blankArgument: blankArgument15,
  comment: comment15,
  environment: environment15,
  group: group15,
  macro: macro15,
  math: math15,
  parbreak: parbreak15,
  string: string15,
  whitespace: whitespace15
} = match15;
function listMathChildren2(node) {
  const NULL_RETURN = { enter: [], leave: [] };
  if (Array.isArray(node)) {
    return NULL_RETURN;
  }
  if (match15.math(node)) {
    return { enter: ["content"], leave: [] };
  }
  const renderInfo = node._renderInfo || {};
  if (renderInfo.inMathMode == null) {
    return NULL_RETURN;
  }
  if (match15.macro(node)) {
    if (renderInfo.inMathMode === true) {
      return { enter: ["args"], leave: [] };
    } else if (renderInfo.inMathMode === false) {
      return { enter: [], leave: ["args"] };
    }
  }
  if (match15.environment(node)) {
    if (renderInfo.inMathMode === true) {
      return { enter: ["content"], leave: [] };
    } else {
      return { enter: [], leave: ["content"] };
    }
  }
  return NULL_RETURN;
}
var CONTINUE8 = Symbol("continue");
var SKIP8 = Symbol("skip");
var EXIT8 = Symbol("exit");
var DEFAULT_CONTEXT2 = {
  inMathMode: false,
  hasMathModeAncestor: false
};
function visit2(tree, visitor, options) {
  const {
    startingContext = DEFAULT_CONTEXT2,
    test = () => true,
    includeArrays = false
  } = options || {};
  let enter;
  let leave;
  if (typeof visitor === "function") {
    enter = visitor;
  } else if (visitor && typeof visitor === "object") {
    enter = visitor.enter;
    leave = visitor.leave;
  }
  walk(tree, {
    key: void 0,
    index: void 0,
    parents: [],
    containingArray: void 0,
    context: { ...startingContext }
  });
  function walk(node, { key, index: index2, parents, context, containingArray }) {
    const nodePassesTest = includeArrays ? test(node, { key, index: index2, parents, context, containingArray }) : !Array.isArray(node) && test(node, { key, index: index2, parents, context, containingArray });
    const result = enter && nodePassesTest ? toResult2(
      enter(node, {
        key,
        index: index2,
        parents,
        context,
        containingArray
      })
    ) : [CONTINUE8];
    if (result[0] === EXIT8) {
      return result;
    }
    if (result[0] === SKIP8) {
      return leave && nodePassesTest ? toResult2(
        leave(node, {
          key,
          index: index2,
          parents,
          context,
          containingArray
        })
      ) : result;
    }
    if (Array.isArray(node)) {
      for (let index22 = 0; index22 > -1 && index22 < node.length; index22++) {
        const item = node[index22];
        const result2 = walk(item, {
          key,
          index: index22,
          parents,
          context,
          containingArray: node
        });
        if (result2[0] === EXIT8) {
          return result2;
        }
        if (typeof result2[1] === "number") {
          index22 = result2[1] - 1;
        }
      }
    } else {
      let childProps = ["content", "args"];
      switch (node.type) {
        case "macro":
          childProps = ["args"];
          break;
        case "comment":
        case "string":
        case "verb":
        case "verbatim":
          childProps = [];
          break;
        default:
          break;
      }
      const mathModeProps = listMathChildren2(node);
      for (const key2 of childProps) {
        const value = node[key2];
        const grandparents = [node].concat(parents);
        if (value == null) {
          continue;
        }
        const newContext = { ...context };
        if (mathModeProps.enter.includes(key2)) {
          newContext.inMathMode = true;
          newContext.hasMathModeAncestor = true;
        } else if (mathModeProps.leave.includes(key2)) {
          newContext.inMathMode = false;
        }
        const result2 = walk(value, {
          key: key2,
          index: void 0,
          parents: grandparents,
          context: newContext,
          containingArray: void 0
        });
        if (result2[0] === EXIT8) {
          return result2;
        }
      }
    }
    return leave && nodePassesTest ? toResult2(
      leave(node, {
        key,
        index: index2,
        parents,
        context,
        containingArray
      })
    ) : result;
  }
}
function toResult2(value) {
  if (value == null) {
    return [CONTINUE8];
  }
  if (Array.isArray(value)) {
    return value;
  }
  if (typeof value === "number") {
    return [CONTINUE8, value];
  }
  return [value];
}

// ../unified-latex-util-match/dist/index.js
var linebreak17 = Symbol("linebreak");
var ESCAPE16 = "\\";
function _printRaw16(node) {
  if (typeof node === "string") {
    return [node];
  }
  if (Array.isArray(node)) {
    return [].concat(
      ...node.map((n) => _printRaw16(n))
    );
  }
  let argsString, escape;
  switch (node.type) {
    case "root":
      return _printRaw16(node.content);
    case "argument":
      return [node.openMark, ..._printRaw16(node.content), node.closeMark];
    case "comment":
      var suffix = node.suffixParbreak ? "" : linebreak17;
      var leadingWhitespace = "";
      if (node.sameline && node.leadingWhitespace) {
        leadingWhitespace = " ";
      }
      if (node.sameline) {
        return [
          leadingWhitespace,
          "%",
          ..._printRaw16(node.content),
          suffix
        ];
      }
      return [linebreak17, "%", ..._printRaw16(node.content), suffix];
    case "environment":
    case "mathenv":
    case "verbatim":
      var env = _printRaw16(node.env);
      var envStart = [ESCAPE16 + "begin{", ...env, "}"];
      var envEnd = [ESCAPE16 + "end{", ...env, "}"];
      argsString = node.args == null ? [] : _printRaw16(node.args);
      return [
        ...envStart,
        ...argsString,
        ..._printRaw16(node.content),
        ...envEnd
      ];
    case "displaymath":
      return [ESCAPE16 + "[", ..._printRaw16(node.content), ESCAPE16 + "]"];
    case "group":
      return ["{", ..._printRaw16(node.content), "}"];
    case "inlinemath":
      return ["$", ..._printRaw16(node.content), "$"];
    case "macro":
      argsString = node.args == null ? [] : _printRaw16(node.args);
      escape = node.escapeToken == null ? ESCAPE16 : node.escapeToken;
      return [escape, ..._printRaw16(node.content), ...argsString];
    case "parbreak":
      return [linebreak17, linebreak17];
    case "string":
      return [node.content];
    case "verb":
      return [
        ESCAPE16,
        node.env,
        node.escape,
        ..._printRaw16(node.content),
        node.escape
      ];
    case "whitespace":
      return [" "];
    default:
      console.warn(
        "Cannot find render for node ",
        node,
        `(of type ${typeof node})`
      );
      return ["" + node];
  }
}
function printRaw16(node, options) {
  const asArray = options != null ? options.asArray : false;
  const printedTokens = _printRaw16(node);
  if (asArray) {
    return printedTokens;
  }
  return printedTokens.map((x) => x === linebreak17 ? "\n" : x).join("");
}
function createMacroMatcher16(macros15) {
  const macrosHash = Array.isArray(macros15) ? macros15.length > 0 ? typeof macros15[0] === "string" ? Object.fromEntries(
    macros15.map((macro210) => {
      if (typeof macro210 !== "string") {
        throw new Error("Wrong branch of map function");
      }
      return [macro210, {}];
    })
  ) : Object.fromEntries(
    macros15.map((macro210) => {
      if (typeof macro210 === "string") {
        throw new Error("Wrong branch of map function");
      }
      if (macro210.escapeToken != null) {
        return [
          macro210.content,
          { escapeToken: macro210.escapeToken }
        ];
      }
      return [macro210.content, {}];
    })
  ) : {} : macros15;
  return function matchAgainstMacros(node) {
    if (node == null || node.type !== "macro") {
      return false;
    }
    const spec = macrosHash[node.content];
    if (!spec) {
      return false;
    }
    if (typeof spec === "object" && "escapeToken" in spec) {
      return spec.escapeToken == null || spec.escapeToken === node.escapeToken;
    }
    return true;
  };
}
function createEnvironmentMatcher16(macros15) {
  const environmentsHash = Array.isArray(macros15) ? Object.fromEntries(
    macros15.map((str) => {
      return [str, {}];
    })
  ) : macros15;
  return function matchAgainstEnvironments(node) {
    if (!match16.anyEnvironment(node)) {
      return false;
    }
    const envName = printRaw16(node.env);
    const spec = environmentsHash[envName];
    if (!spec) {
      return false;
    }
    return true;
  };
}
var match16 = {
  macro(node, macroName) {
    if (node == null) {
      return false;
    }
    return node.type === "macro" && (macroName == null || node.content === macroName);
  },
  anyMacro(node) {
    return match16.macro(node);
  },
  environment(node, envName) {
    if (node == null) {
      return false;
    }
    return (node.type === "environment" || node.type === "mathenv") && (envName == null || printRaw16(node.env) === envName);
  },
  anyEnvironment(node) {
    return match16.environment(node);
  },
  comment(node) {
    if (node == null) {
      return false;
    }
    return node.type === "comment";
  },
  parbreak(node) {
    if (node == null) {
      return false;
    }
    return node.type === "parbreak";
  },
  whitespace(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace";
  },
  /**
   * Matches whitespace or a comment with leading whitespace.
   */
  whitespaceLike(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace" || node.type === "whitespace" && node.leadingWhitespace === true;
  },
  string(node, value) {
    if (node == null) {
      return false;
    }
    return node.type === "string" && (value == null || node.content === value);
  },
  anyString(node) {
    return match16.string(node);
  },
  group(node) {
    if (node == null) {
      return false;
    }
    return node.type === "group";
  },
  argument(node) {
    if (node == null) {
      return false;
    }
    return node.type === "argument";
  },
  blankArgument(node) {
    if (!match16.argument(node)) {
      return false;
    }
    return node.openMark === "" && node.closeMark === "" && node.content.length === 0;
  },
  math(node) {
    if (node == null) {
      return false;
    }
    return node.type === "displaymath" || node.type === "inlinemath";
  },
  createMacroMatcher: createMacroMatcher16,
  createEnvironmentMatcher: createEnvironmentMatcher16
};
var {
  anyEnvironment: anyEnvironment16,
  anyMacro: anyMacro16,
  anyString: anyString16,
  argument: argument16,
  blankArgument: blankArgument16,
  comment: comment16,
  environment: environment16,
  group: group16,
  macro: macro16,
  math: math16,
  parbreak: parbreak16,
  string: string16,
  whitespace: whitespace16
} = match16;

// ../unified-latex-util-print-raw/dist/index.js
var linebreak18 = Symbol("linebreak");
var ESCAPE17 = "\\";
function _printRaw17(node) {
  if (typeof node === "string") {
    return [node];
  }
  if (Array.isArray(node)) {
    return [].concat(
      ...node.map((n) => _printRaw17(n))
    );
  }
  let argsString, escape;
  switch (node.type) {
    case "root":
      return _printRaw17(node.content);
    case "argument":
      return [node.openMark, ..._printRaw17(node.content), node.closeMark];
    case "comment":
      var suffix = node.suffixParbreak ? "" : linebreak18;
      var leadingWhitespace = "";
      if (node.sameline && node.leadingWhitespace) {
        leadingWhitespace = " ";
      }
      if (node.sameline) {
        return [
          leadingWhitespace,
          "%",
          ..._printRaw17(node.content),
          suffix
        ];
      }
      return [linebreak18, "%", ..._printRaw17(node.content), suffix];
    case "environment":
    case "mathenv":
    case "verbatim":
      var env = _printRaw17(node.env);
      var envStart = [ESCAPE17 + "begin{", ...env, "}"];
      var envEnd = [ESCAPE17 + "end{", ...env, "}"];
      argsString = node.args == null ? [] : _printRaw17(node.args);
      return [
        ...envStart,
        ...argsString,
        ..._printRaw17(node.content),
        ...envEnd
      ];
    case "displaymath":
      return [ESCAPE17 + "[", ..._printRaw17(node.content), ESCAPE17 + "]"];
    case "group":
      return ["{", ..._printRaw17(node.content), "}"];
    case "inlinemath":
      return ["$", ..._printRaw17(node.content), "$"];
    case "macro":
      argsString = node.args == null ? [] : _printRaw17(node.args);
      escape = node.escapeToken == null ? ESCAPE17 : node.escapeToken;
      return [escape, ..._printRaw17(node.content), ...argsString];
    case "parbreak":
      return [linebreak18, linebreak18];
    case "string":
      return [node.content];
    case "verb":
      return [
        ESCAPE17,
        node.env,
        node.escape,
        ..._printRaw17(node.content),
        node.escape
      ];
    case "whitespace":
      return [" "];
    default:
      console.warn(
        "Cannot find render for node ",
        node,
        `(of type ${typeof node})`
      );
      return ["" + node];
  }
}
function printRaw17(node, options) {
  const asArray = options != null ? options.asArray : false;
  const printedTokens = _printRaw17(node);
  if (asArray) {
    return printedTokens;
  }
  return printedTokens.map((x) => x === linebreak18 ? "\n" : x).join("");
}

// libs/reparse-math.ts
function unifiedLatexReparseMathConstructPlugin({
  mathEnvs,
  mathMacros
}) {
  const isMathEnvironment = match16.createEnvironmentMatcher(mathEnvs);
  const isMathMacro = match16.createMacroMatcher(mathMacros);
  return (tree) => {
    visit2(
      tree,
      (node) => {
        if (match16.anyMacro(node)) {
          for (const arg5 of node.args || []) {
            if (arg5.content.length > 0 && !wasParsedInMathMode(arg5.content)) {
              arg5.content = parseMathMinimal(
                printRaw17(arg5.content)
              );
            }
          }
        }
        if (match16.anyEnvironment(node)) {
          if (!wasParsedInMathMode(node.content)) {
            node.content = parseMathMinimal(printRaw17(node.content));
          }
        }
      },
      {
        test: (node) => isMathEnvironment(node) || isMathMacro(node)
      }
    );
  };
}
function wasParsedInMathMode(nodes) {
  return !nodes.some(
    (node) => (
      // If there are multi-char strings or ^ and _ have been parsed as strings, we know
      // that we were not parsed in math mode.
      match16.anyString(node) && node.content.length > 1 || match16.string(node, "^") || match16.string(node, "_")
    )
  );
}

// ../unified-latex-util-arguments/dist/index.js
var linebreak19 = Symbol("linebreak");
var ESCAPE18 = "\\";
function _printRaw18(node) {
  if (typeof node === "string") {
    return [node];
  }
  if (Array.isArray(node)) {
    return [].concat(
      ...node.map((n) => _printRaw18(n))
    );
  }
  let argsString, escape;
  switch (node.type) {
    case "root":
      return _printRaw18(node.content);
    case "argument":
      return [node.openMark, ..._printRaw18(node.content), node.closeMark];
    case "comment":
      var suffix = node.suffixParbreak ? "" : linebreak19;
      var leadingWhitespace = "";
      if (node.sameline && node.leadingWhitespace) {
        leadingWhitespace = " ";
      }
      if (node.sameline) {
        return [
          leadingWhitespace,
          "%",
          ..._printRaw18(node.content),
          suffix
        ];
      }
      return [linebreak19, "%", ..._printRaw18(node.content), suffix];
    case "environment":
    case "mathenv":
    case "verbatim":
      var env = _printRaw18(node.env);
      var envStart = [ESCAPE18 + "begin{", ...env, "}"];
      var envEnd = [ESCAPE18 + "end{", ...env, "}"];
      argsString = node.args == null ? [] : _printRaw18(node.args);
      return [
        ...envStart,
        ...argsString,
        ..._printRaw18(node.content),
        ...envEnd
      ];
    case "displaymath":
      return [ESCAPE18 + "[", ..._printRaw18(node.content), ESCAPE18 + "]"];
    case "group":
      return ["{", ..._printRaw18(node.content), "}"];
    case "inlinemath":
      return ["$", ..._printRaw18(node.content), "$"];
    case "macro":
      argsString = node.args == null ? [] : _printRaw18(node.args);
      escape = node.escapeToken == null ? ESCAPE18 : node.escapeToken;
      return [escape, ..._printRaw18(node.content), ...argsString];
    case "parbreak":
      return [linebreak19, linebreak19];
    case "string":
      return [node.content];
    case "verb":
      return [
        ESCAPE18,
        node.env,
        node.escape,
        ..._printRaw18(node.content),
        node.escape
      ];
    case "whitespace":
      return [" "];
    default:
      console.warn(
        "Cannot find render for node ",
        node,
        `(of type ${typeof node})`
      );
      return ["" + node];
  }
}
function printRaw18(node, options) {
  const asArray = options != null ? options.asArray : false;
  const printedTokens = _printRaw18(node);
  if (asArray) {
    return printedTokens;
  }
  return printedTokens.map((x) => x === linebreak19 ? "\n" : x).join("");
}
function createMacroMatcher17(macros15) {
  const macrosHash = Array.isArray(macros15) ? macros15.length > 0 ? typeof macros15[0] === "string" ? Object.fromEntries(
    macros15.map((macro223) => {
      if (typeof macro223 !== "string") {
        throw new Error("Wrong branch of map function");
      }
      return [macro223, {}];
    })
  ) : Object.fromEntries(
    macros15.map((macro223) => {
      if (typeof macro223 === "string") {
        throw new Error("Wrong branch of map function");
      }
      if (macro223.escapeToken != null) {
        return [
          macro223.content,
          { escapeToken: macro223.escapeToken }
        ];
      }
      return [macro223.content, {}];
    })
  ) : {} : macros15;
  return function matchAgainstMacros(node) {
    if (node == null || node.type !== "macro") {
      return false;
    }
    const spec = macrosHash[node.content];
    if (!spec) {
      return false;
    }
    if (typeof spec === "object" && "escapeToken" in spec) {
      return spec.escapeToken == null || spec.escapeToken === node.escapeToken;
    }
    return true;
  };
}
function createEnvironmentMatcher17(macros15) {
  const environmentsHash = Array.isArray(macros15) ? Object.fromEntries(
    macros15.map((str) => {
      return [str, {}];
    })
  ) : macros15;
  return function matchAgainstEnvironments(node) {
    if (!match17.anyEnvironment(node)) {
      return false;
    }
    const envName = printRaw18(node.env);
    const spec = environmentsHash[envName];
    if (!spec) {
      return false;
    }
    return true;
  };
}
var match17 = {
  macro(node, macroName) {
    if (node == null) {
      return false;
    }
    return node.type === "macro" && (macroName == null || node.content === macroName);
  },
  anyMacro(node) {
    return match17.macro(node);
  },
  environment(node, envName) {
    if (node == null) {
      return false;
    }
    return (node.type === "environment" || node.type === "mathenv") && (envName == null || printRaw18(node.env) === envName);
  },
  anyEnvironment(node) {
    return match17.environment(node);
  },
  comment(node) {
    if (node == null) {
      return false;
    }
    return node.type === "comment";
  },
  parbreak(node) {
    if (node == null) {
      return false;
    }
    return node.type === "parbreak";
  },
  whitespace(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace";
  },
  /**
   * Matches whitespace or a comment with leading whitespace.
   */
  whitespaceLike(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace" || node.type === "whitespace" && node.leadingWhitespace === true;
  },
  string(node, value) {
    if (node == null) {
      return false;
    }
    return node.type === "string" && (value == null || node.content === value);
  },
  anyString(node) {
    return match17.string(node);
  },
  group(node) {
    if (node == null) {
      return false;
    }
    return node.type === "group";
  },
  argument(node) {
    if (node == null) {
      return false;
    }
    return node.type === "argument";
  },
  blankArgument(node) {
    if (!match17.argument(node)) {
      return false;
    }
    return node.openMark === "" && node.closeMark === "" && node.content.length === 0;
  },
  math(node) {
    if (node == null) {
      return false;
    }
    return node.type === "displaymath" || node.type === "inlinemath";
  },
  createMacroMatcher: createMacroMatcher17,
  createEnvironmentMatcher: createEnvironmentMatcher17
};
var {
  anyEnvironment: anyEnvironment17,
  anyMacro: anyMacro17,
  anyString: anyString17,
  argument: argument17,
  blankArgument: blankArgument17,
  comment: comment17,
  environment: environment17,
  group: group17,
  macro: macro17,
  math: math17,
  parbreak: parbreak17,
  string: string17,
  whitespace: whitespace17
} = match17;
var latex_default5 = (
  // Generated by Peggy 2.0.1.
  //
  // https://peggyjs.org/
  function() {
    "use strict";
    function peg$subclass(child, parent) {
      function C() {
        this.constructor = child;
      }
      C.prototype = parent.prototype;
      child.prototype = new C();
    }
    function peg$SyntaxError(message, expected, found, location) {
      var self = Error.call(this, message);
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(self, peg$SyntaxError.prototype);
      }
      self.expected = expected;
      self.found = found;
      self.location = location;
      self.name = "SyntaxError";
      return self;
    }
    peg$subclass(peg$SyntaxError, Error);
    function peg$padEnd(str, targetLength, padString) {
      padString = padString || " ";
      if (str.length > targetLength) {
        return str;
      }
      targetLength -= str.length;
      padString += padString.repeat(targetLength);
      return str + padString.slice(0, targetLength);
    }
    peg$SyntaxError.prototype.format = function(sources) {
      var str = "Error: " + this.message;
      if (this.location) {
        var src = null;
        var k;
        for (k = 0; k < sources.length; k++) {
          if (sources[k].source === this.location.source) {
            src = sources[k].text.split(/\r\n|\n|\r/g);
            break;
          }
        }
        var s22 = this.location.start;
        var loc = this.location.source + ":" + s22.line + ":" + s22.column;
        if (src) {
          var e = this.location.end;
          var filler = peg$padEnd("", s22.line.toString().length, " ");
          var line = src[s22.line - 1];
          var last = s22.line === e.line ? e.column : line.length + 1;
          var hatLen = last - s22.column || 1;
          str += "\n --> " + loc + "\n" + filler + " |\n" + s22.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s22.column - 1, " ") + peg$padEnd("", hatLen, "^");
        } else {
          str += "\n at " + loc;
        }
      }
      return str;
    };
    peg$SyntaxError.buildMessage = function(expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        class: function(expectation) {
          var escapedParts = expectation.parts.map(function(part) {
            return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
          });
          return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
        },
        any: function() {
          return "any character";
        },
        end: function() {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        }
      };
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s22) {
        return s22.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function classEscape(s22) {
        return s22.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = expected2.map(describeExpectation);
        var i, j;
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {};
      var peg$source = options.grammarSource;
      var peg$startRuleFunctions = { document: peg$parsedocument, math: peg$parsemath };
      var peg$startRuleFunction = peg$parsedocument;
      var peg$c0 = "%";
      var peg$c1 = ".";
      var peg$c2 = "verb*";
      var peg$c3 = "verb";
      var peg$c4 = "verbatim*";
      var peg$c5 = "verbatim";
      var peg$c6 = "filecontents*";
      var peg$c7 = "filecontents";
      var peg$c8 = "comment";
      var peg$c9 = "lstlisting";
      var peg$c10 = "[";
      var peg$c11 = "]";
      var peg$c12 = "(";
      var peg$c13 = ")";
      var peg$c14 = "begin";
      var peg$c15 = "end";
      var peg$c16 = "equation*";
      var peg$c17 = "equation";
      var peg$c18 = "align*";
      var peg$c19 = "align";
      var peg$c20 = "alignat*";
      var peg$c21 = "alignat";
      var peg$c22 = "gather*";
      var peg$c23 = "gather";
      var peg$c24 = "multline*";
      var peg$c25 = "multline";
      var peg$c26 = "flalign*";
      var peg$c27 = "flalign";
      var peg$c28 = "split";
      var peg$c29 = "math";
      var peg$c30 = "displaymath";
      var peg$c31 = "\\";
      var peg$c32 = "{";
      var peg$c33 = "}";
      var peg$c34 = "$";
      var peg$c35 = "&";
      var peg$c36 = "\r";
      var peg$c37 = "\n";
      var peg$c38 = "\r\n";
      var peg$c39 = "#";
      var peg$c40 = "^";
      var peg$c41 = "_";
      var peg$c42 = "\0";
      var peg$r0 = /^[ \t]/;
      var peg$r1 = /^[a-zA-Z]/;
      var peg$r2 = /^[0-9]/;
      var peg$r3 = /^[.,;:\-*\/()!?=+<>[\]`'"~]/;
      var peg$e0 = peg$otherExpectation("document");
      var peg$e1 = peg$otherExpectation("math");
      var peg$e2 = peg$otherExpectation("token");
      var peg$e3 = peg$anyExpectation();
      var peg$e4 = peg$otherExpectation("parbreak");
      var peg$e5 = peg$otherExpectation("math token");
      var peg$e6 = peg$otherExpectation("nonchar token");
      var peg$e7 = peg$literalExpectation("%", false);
      var peg$e8 = peg$otherExpectation("whitespace");
      var peg$e9 = peg$otherExpectation("number");
      var peg$e10 = peg$literalExpectation(".", false);
      var peg$e11 = peg$otherExpectation("special macro");
      var peg$e12 = peg$literalExpectation("verb*", false);
      var peg$e13 = peg$literalExpectation("verb", false);
      var peg$e14 = peg$otherExpectation("verbatim environment");
      var peg$e15 = peg$literalExpectation("verbatim*", false);
      var peg$e16 = peg$literalExpectation("verbatim", false);
      var peg$e17 = peg$literalExpectation("filecontents*", false);
      var peg$e18 = peg$literalExpectation("filecontents", false);
      var peg$e19 = peg$literalExpectation("comment", false);
      var peg$e20 = peg$literalExpectation("lstlisting", false);
      var peg$e21 = peg$otherExpectation("macro");
      var peg$e22 = peg$otherExpectation("group");
      var peg$e23 = peg$otherExpectation("environment");
      var peg$e24 = peg$otherExpectation("math environment");
      var peg$e25 = peg$otherExpectation("math group");
      var peg$e26 = peg$literalExpectation("[", false);
      var peg$e27 = peg$literalExpectation("]", false);
      var peg$e28 = peg$literalExpectation("(", false);
      var peg$e29 = peg$literalExpectation(")", false);
      var peg$e30 = peg$literalExpectation("begin", false);
      var peg$e31 = peg$literalExpectation("end", false);
      var peg$e32 = peg$literalExpectation("equation*", false);
      var peg$e33 = peg$literalExpectation("equation", false);
      var peg$e34 = peg$literalExpectation("align*", false);
      var peg$e35 = peg$literalExpectation("align", false);
      var peg$e36 = peg$literalExpectation("alignat*", false);
      var peg$e37 = peg$literalExpectation("alignat", false);
      var peg$e38 = peg$literalExpectation("gather*", false);
      var peg$e39 = peg$literalExpectation("gather", false);
      var peg$e40 = peg$literalExpectation("multline*", false);
      var peg$e41 = peg$literalExpectation("multline", false);
      var peg$e42 = peg$literalExpectation("flalign*", false);
      var peg$e43 = peg$literalExpectation("flalign", false);
      var peg$e44 = peg$literalExpectation("split", false);
      var peg$e45 = peg$literalExpectation("math", false);
      var peg$e46 = peg$literalExpectation("displaymath", false);
      var peg$e47 = peg$otherExpectation("escape");
      var peg$e48 = peg$literalExpectation("\\", false);
      var peg$e49 = peg$literalExpectation("{", false);
      var peg$e50 = peg$literalExpectation("}", false);
      var peg$e51 = peg$literalExpectation("$", false);
      var peg$e52 = peg$literalExpectation("&", false);
      var peg$e53 = peg$otherExpectation("newline");
      var peg$e54 = peg$literalExpectation("\r", false);
      var peg$e55 = peg$literalExpectation("\n", false);
      var peg$e56 = peg$literalExpectation("\r\n", false);
      var peg$e57 = peg$literalExpectation("#", false);
      var peg$e58 = peg$literalExpectation("^", false);
      var peg$e59 = peg$literalExpectation("_", false);
      var peg$e60 = peg$literalExpectation("\0", false);
      var peg$e61 = peg$classExpectation([" ", "	"], false, false);
      var peg$e62 = peg$otherExpectation("letter");
      var peg$e63 = peg$classExpectation([["a", "z"], ["A", "Z"]], false, false);
      var peg$e64 = peg$otherExpectation("digit");
      var peg$e65 = peg$classExpectation([["0", "9"]], false, false);
      var peg$e66 = peg$otherExpectation("punctuation");
      var peg$e67 = peg$classExpectation([".", ",", ";", ":", "-", "*", "/", "(", ")", "!", "?", "=", "+", "<", ">", "[", "]", "`", "'", '"', "~"], false, false);
      var peg$e68 = peg$otherExpectation("full comment");
      var peg$e69 = peg$otherExpectation("comment");
      var peg$f0 = function(content) {
        return createNode("root", { content });
      };
      var peg$f1 = function(t) {
        return t;
      };
      var peg$f2 = function(eq) {
        return createNode("inlinemath", { content: eq });
      };
      var peg$f3 = function(s22) {
        return createNode("string", { content: s22 });
      };
      var peg$f4 = function(s22) {
        return createNode("string", { content: s22 });
      };
      var peg$f5 = function() {
        return createNode("parbreak");
      };
      var peg$f6 = function(x) {
        return x;
      };
      var peg$f7 = function(x) {
        return x;
      };
      var peg$f8 = function() {
        return createNode("macro", { content: "^", escapeToken: "" });
      };
      var peg$f9 = function() {
        return createNode("macro", { content: "_", escapeToken: "" });
      };
      var peg$f10 = function(s22) {
        return createNode("string", { content: s22 });
      };
      var peg$f11 = function() {
        return createNode("whitespace");
      };
      var peg$f12 = function(a, b) {
        return a.join("") + "." + b.join("");
      };
      var peg$f13 = function(b) {
        return "." + b.join("");
      };
      var peg$f14 = function(a) {
        return a.join("") + ".";
      };
      var peg$f15 = function(s22) {
        return createNode("string", { content: s22 });
      };
      var peg$f16 = function(env, e, end) {
        return end == e;
      };
      var peg$f17 = function(env, e, x) {
        return x;
      };
      var peg$f18 = function(env, e, x, end) {
        return end == e;
      };
      var peg$f19 = function(env, e, x) {
        return createNode("verb", {
          env,
          escape: e,
          content: x.join("")
        });
      };
      var peg$f20 = function(x) {
        return x;
      };
      var peg$f21 = function(x) {
        return createNode("displaymath", { content: x });
      };
      var peg$f22 = function(x) {
        return x;
      };
      var peg$f23 = function(x) {
        return createNode("inlinemath", { content: x });
      };
      var peg$f24 = function(x) {
        return x;
      };
      var peg$f25 = function(x) {
        return createNode("displaymath", { content: x });
      };
      var peg$f26 = function(env, end_env) {
        return compare_env({ content: [env] }, end_env);
      };
      var peg$f27 = function(env, x) {
        return x;
      };
      var peg$f28 = function(env, body) {
        return createNode("verbatim", {
          env,
          content: body.join("")
        });
      };
      var peg$f29 = function(n) {
        return n.join("");
      };
      var peg$f30 = function(n) {
        return n;
      };
      var peg$f31 = function(m) {
        return createNode("macro", { content: m });
      };
      var peg$f32 = function(c) {
        return c;
      };
      var peg$f33 = function(x) {
        return createNode("group", { content: x });
      };
      var peg$f34 = function(g) {
        return text().slice(1, -1);
      };
      var peg$f35 = function(env, env_comment, end_env) {
        return compare_env(env, end_env);
      };
      var peg$f36 = function(env, env_comment, x) {
        return x;
      };
      var peg$f37 = function(env, env_comment, body) {
        return createNode("environment", {
          env,
          content: env_comment ? [env_comment, ...body] : body
        });
      };
      var peg$f38 = function(env, env_comment, end_env) {
        return compare_env({ content: [env] }, end_env);
      };
      var peg$f39 = function(env, env_comment, x) {
        return x;
      };
      var peg$f40 = function(env, env_comment, body) {
        return createNode("mathenv", {
          env,
          content: env_comment ? [env_comment, ...body] : body
        });
      };
      var peg$f41 = function(c) {
        return c;
      };
      var peg$f42 = function(x) {
        return createNode("group", { content: x });
      };
      var peg$f43 = function(e) {
        return createNode("string", { content: e });
      };
      var peg$f44 = function() {
        return createNode("string", { content: "\\" });
      };
      var peg$f45 = function(s22) {
        return createNode("string", { content: s22 });
      };
      var peg$f46 = function(s22) {
        return createNode("string", { content: s22 });
      };
      var peg$f47 = function(s22) {
        return createNode("string", { content: s22 });
      };
      var peg$f48 = function(s22) {
        return createNode("string", { content: s22 });
      };
      var peg$f49 = function(s22) {
        return createNode("string", { content: s22 });
      };
      var peg$f50 = function(s22) {
        return createNode("string", { content: s22 });
      };
      var peg$f51 = function(s22) {
        return createNode("string", { content: s22 });
      };
      var peg$f52 = function() {
        return " ";
      };
      var peg$f53 = function(p) {
        return createNode("string", { content: p });
      };
      var peg$f54 = function(leading_sp, comment223) {
        return createNode("comment", {
          ...comment223,
          sameline: false,
          leadingWhitespace: leading_sp.length > 0
        });
      };
      var peg$f55 = function(spaces, x) {
        return createNode("comment", {
          ...x,
          sameline: true,
          leadingWhitespace: spaces.length > 0
        });
      };
      var peg$f56 = function(c) {
        return c;
      };
      var peg$f57 = function(c) {
        return { content: c.join(""), suffixParbreak: true };
      };
      var peg$f58 = function(c) {
        return c;
      };
      var peg$f59 = function(c) {
        return { content: c.join("") };
      };
      var peg$f60 = function() {
        var loc = location();
        return loc.start.column === 1;
      };
      var peg$currPos = 0;
      var peg$savedPos = 0;
      var peg$posDetailsCache = [{ line: 1, column: 1 }];
      var peg$maxFailPos = 0;
      var peg$maxFailExpected = [];
      var peg$silentFails = 0;
      var peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function offset() {
        return peg$savedPos;
      }
      function range() {
        return {
          source: peg$source,
          start: peg$savedPos,
          end: peg$currPos
        };
      }
      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError(
          [peg$otherExpectation(description)],
          input.substring(peg$savedPos, peg$currPos),
          location2
        );
      }
      function error(message, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location2);
      }
      function peg$literalExpectation(text2, ignoreCase) {
        return { type: "literal", text: text2, ignoreCase };
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts, inverted, ignoreCase };
      }
      function peg$anyExpectation() {
        return { type: "any" };
      }
      function peg$endExpectation() {
        return { type: "end" };
      }
      function peg$otherExpectation(description) {
        return { type: "other", description };
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p;
        if (details) {
          return details;
        } else {
          p = pos - 1;
          while (!peg$posDetailsCache[p]) {
            p--;
          }
          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };
          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos);
        var endPosDetails = peg$computePosDetails(endPos);
        return {
          source: peg$source,
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildSimpleError(message, location2) {
        return new peg$SyntaxError(message, null, null, location2);
      }
      function peg$buildStructuredError(expected2, found, location2) {
        return new peg$SyntaxError(
          peg$SyntaxError.buildMessage(expected2, found),
          expected2,
          found,
          location2
        );
      }
      function peg$parsedocument() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsetoken();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parsetoken();
        }
        peg$savedPos = s0;
        s1 = peg$f0(s1);
        s0 = s1;
        peg$silentFails--;
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e0);
        }
        return s0;
      }
      function peg$parsemath() {
        var s0, s1;
        peg$silentFails++;
        s0 = [];
        s1 = peg$parsemath_token();
        while (s1 !== peg$FAILED) {
          s0.push(s1);
          s1 = peg$parsemath_token();
        }
        peg$silentFails--;
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e1);
        }
        return s0;
      }
      function peg$parsetoken() {
        var s0, s1, s22, s32, s42, s5;
        peg$silentFails++;
        s0 = peg$parsespecial_macro();
        if (s0 === peg$FAILED) {
          s0 = peg$parsemacro();
          if (s0 === peg$FAILED) {
            s0 = peg$parsefull_comment();
            if (s0 === peg$FAILED) {
              s0 = peg$parsegroup();
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parsemath_shift();
                if (s1 !== peg$FAILED) {
                  s22 = [];
                  s32 = peg$currPos;
                  s42 = peg$currPos;
                  peg$silentFails++;
                  s5 = peg$parsemath_shift();
                  peg$silentFails--;
                  if (s5 === peg$FAILED) {
                    s42 = void 0;
                  } else {
                    peg$currPos = s42;
                    s42 = peg$FAILED;
                  }
                  if (s42 !== peg$FAILED) {
                    s5 = peg$parsemath_token();
                    if (s5 !== peg$FAILED) {
                      peg$savedPos = s32;
                      s32 = peg$f1(s5);
                    } else {
                      peg$currPos = s32;
                      s32 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s32;
                    s32 = peg$FAILED;
                  }
                  if (s32 !== peg$FAILED) {
                    while (s32 !== peg$FAILED) {
                      s22.push(s32);
                      s32 = peg$currPos;
                      s42 = peg$currPos;
                      peg$silentFails++;
                      s5 = peg$parsemath_shift();
                      peg$silentFails--;
                      if (s5 === peg$FAILED) {
                        s42 = void 0;
                      } else {
                        peg$currPos = s42;
                        s42 = peg$FAILED;
                      }
                      if (s42 !== peg$FAILED) {
                        s5 = peg$parsemath_token();
                        if (s5 !== peg$FAILED) {
                          peg$savedPos = s32;
                          s32 = peg$f1(s5);
                        } else {
                          peg$currPos = s32;
                          s32 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s32;
                        s32 = peg$FAILED;
                      }
                    }
                  } else {
                    s22 = peg$FAILED;
                  }
                  if (s22 !== peg$FAILED) {
                    s32 = peg$parsemath_shift();
                    if (s32 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s0 = peg$f2(s22);
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
                if (s0 === peg$FAILED) {
                  s0 = peg$parsealignment_tab();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parseparbreak();
                    if (s0 === peg$FAILED) {
                      s0 = peg$parsemacro_parameter();
                      if (s0 === peg$FAILED) {
                        s0 = peg$parseignore();
                        if (s0 === peg$FAILED) {
                          s0 = peg$parsenumber();
                          if (s0 === peg$FAILED) {
                            s0 = peg$parsewhitespace();
                            if (s0 === peg$FAILED) {
                              s0 = peg$parsepunctuation();
                              if (s0 === peg$FAILED) {
                                s0 = peg$currPos;
                                s1 = peg$currPos;
                                s22 = [];
                                s32 = peg$currPos;
                                s42 = peg$currPos;
                                peg$silentFails++;
                                s5 = peg$parsenonchar_token();
                                peg$silentFails--;
                                if (s5 === peg$FAILED) {
                                  s42 = void 0;
                                } else {
                                  peg$currPos = s42;
                                  s42 = peg$FAILED;
                                }
                                if (s42 !== peg$FAILED) {
                                  if (input.length > peg$currPos) {
                                    s5 = input.charAt(peg$currPos);
                                    peg$currPos++;
                                  } else {
                                    s5 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                      peg$fail(peg$e3);
                                    }
                                  }
                                  if (s5 !== peg$FAILED) {
                                    s42 = [s42, s5];
                                    s32 = s42;
                                  } else {
                                    peg$currPos = s32;
                                    s32 = peg$FAILED;
                                  }
                                } else {
                                  peg$currPos = s32;
                                  s32 = peg$FAILED;
                                }
                                if (s32 !== peg$FAILED) {
                                  while (s32 !== peg$FAILED) {
                                    s22.push(s32);
                                    s32 = peg$currPos;
                                    s42 = peg$currPos;
                                    peg$silentFails++;
                                    s5 = peg$parsenonchar_token();
                                    peg$silentFails--;
                                    if (s5 === peg$FAILED) {
                                      s42 = void 0;
                                    } else {
                                      peg$currPos = s42;
                                      s42 = peg$FAILED;
                                    }
                                    if (s42 !== peg$FAILED) {
                                      if (input.length > peg$currPos) {
                                        s5 = input.charAt(peg$currPos);
                                        peg$currPos++;
                                      } else {
                                        s5 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                          peg$fail(peg$e3);
                                        }
                                      }
                                      if (s5 !== peg$FAILED) {
                                        s42 = [s42, s5];
                                        s32 = s42;
                                      } else {
                                        peg$currPos = s32;
                                        s32 = peg$FAILED;
                                      }
                                    } else {
                                      peg$currPos = s32;
                                      s32 = peg$FAILED;
                                    }
                                  }
                                } else {
                                  s22 = peg$FAILED;
                                }
                                if (s22 !== peg$FAILED) {
                                  s1 = input.substring(s1, peg$currPos);
                                } else {
                                  s1 = s22;
                                }
                                if (s1 !== peg$FAILED) {
                                  peg$savedPos = s0;
                                  s1 = peg$f3(s1);
                                }
                                s0 = s1;
                                if (s0 === peg$FAILED) {
                                  s0 = peg$parsebegin_group();
                                  if (s0 === peg$FAILED) {
                                    s0 = peg$parseend_group();
                                    if (s0 === peg$FAILED) {
                                      s0 = peg$parsemath_shift();
                                      if (s0 === peg$FAILED) {
                                        s0 = peg$currPos;
                                        if (input.length > peg$currPos) {
                                          s1 = input.charAt(peg$currPos);
                                          peg$currPos++;
                                        } else {
                                          s1 = peg$FAILED;
                                          if (peg$silentFails === 0) {
                                            peg$fail(peg$e3);
                                          }
                                        }
                                        if (s1 !== peg$FAILED) {
                                          peg$savedPos = s0;
                                          s1 = peg$f4(s1);
                                        }
                                        s0 = s1;
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        return s0;
      }
      function peg$parseparbreak() {
        var s0, s1, s22, s32, s42, s5, s6, s7;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = [];
        s32 = peg$parsesp();
        while (s32 !== peg$FAILED) {
          s22.push(s32);
          s32 = peg$parsesp();
        }
        s32 = peg$parsenl();
        if (s32 !== peg$FAILED) {
          s42 = [];
          s5 = peg$currPos;
          s6 = [];
          s7 = peg$parsesp();
          while (s7 !== peg$FAILED) {
            s6.push(s7);
            s7 = peg$parsesp();
          }
          s7 = peg$parsenl();
          if (s7 !== peg$FAILED) {
            s6 = [s6, s7];
            s5 = s6;
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
          if (s5 !== peg$FAILED) {
            while (s5 !== peg$FAILED) {
              s42.push(s5);
              s5 = peg$currPos;
              s6 = [];
              s7 = peg$parsesp();
              while (s7 !== peg$FAILED) {
                s6.push(s7);
                s7 = peg$parsesp();
              }
              s7 = peg$parsenl();
              if (s7 !== peg$FAILED) {
                s6 = [s6, s7];
                s5 = s6;
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            }
          } else {
            s42 = peg$FAILED;
          }
          if (s42 !== peg$FAILED) {
            s5 = [];
            s6 = peg$parsesp();
            while (s6 !== peg$FAILED) {
              s5.push(s6);
              s6 = peg$parsesp();
            }
            s6 = peg$currPos;
            peg$silentFails++;
            s7 = peg$parsecomment_start();
            peg$silentFails--;
            if (s7 === peg$FAILED) {
              s6 = void 0;
            } else {
              peg$currPos = s6;
              s6 = peg$FAILED;
            }
            if (s6 !== peg$FAILED) {
              s22 = [s22, s32, s42, s5, s6];
              s1 = s22;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
          s1 = peg$currPos;
          s22 = [];
          s32 = peg$parsesp();
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parsesp();
          }
          s32 = peg$parsenl();
          if (s32 !== peg$FAILED) {
            s42 = [];
            s5 = peg$currPos;
            s6 = [];
            s7 = peg$parsesp();
            while (s7 !== peg$FAILED) {
              s6.push(s7);
              s7 = peg$parsesp();
            }
            s7 = peg$parsenl();
            if (s7 !== peg$FAILED) {
              s6 = [s6, s7];
              s5 = s6;
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
            if (s5 !== peg$FAILED) {
              while (s5 !== peg$FAILED) {
                s42.push(s5);
                s5 = peg$currPos;
                s6 = [];
                s7 = peg$parsesp();
                while (s7 !== peg$FAILED) {
                  s6.push(s7);
                  s7 = peg$parsesp();
                }
                s7 = peg$parsenl();
                if (s7 !== peg$FAILED) {
                  s6 = [s6, s7];
                  s5 = s6;
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              }
            } else {
              s42 = peg$FAILED;
            }
            if (s42 !== peg$FAILED) {
              s22 = [s22, s32, s42];
              s1 = s22;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f5();
        }
        s0 = s1;
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e4);
          }
        }
        return s0;
      }
      function peg$parsemath_token() {
        var s0, s1, s22, s32, s42;
        peg$silentFails++;
        s0 = peg$parsespecial_macro();
        if (s0 === peg$FAILED) {
          s0 = peg$parsemacro();
          if (s0 === peg$FAILED) {
            s0 = peg$parsefull_comment();
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = [];
              s22 = peg$parsewhitespace();
              while (s22 !== peg$FAILED) {
                s1.push(s22);
                s22 = peg$parsewhitespace();
              }
              s22 = peg$parsegroup();
              if (s22 !== peg$FAILED) {
                s32 = [];
                s42 = peg$parsewhitespace();
                while (s42 !== peg$FAILED) {
                  s32.push(s42);
                  s42 = peg$parsewhitespace();
                }
                peg$savedPos = s0;
                s0 = peg$f6(s22);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = [];
                s22 = peg$parsewhitespace();
                while (s22 !== peg$FAILED) {
                  s1.push(s22);
                  s22 = peg$parsewhitespace();
                }
                s22 = peg$parsealignment_tab();
                if (s22 !== peg$FAILED) {
                  s32 = [];
                  s42 = peg$parsewhitespace();
                  while (s42 !== peg$FAILED) {
                    s32.push(s42);
                    s42 = peg$parsewhitespace();
                  }
                  peg$savedPos = s0;
                  s0 = peg$f7(s22);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
                if (s0 === peg$FAILED) {
                  s0 = peg$parsemacro_parameter();
                  if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    s1 = [];
                    s22 = peg$parsewhitespace();
                    while (s22 !== peg$FAILED) {
                      s1.push(s22);
                      s22 = peg$parsewhitespace();
                    }
                    s22 = peg$parsesuperscript();
                    if (s22 !== peg$FAILED) {
                      s32 = [];
                      s42 = peg$parsewhitespace();
                      while (s42 !== peg$FAILED) {
                        s32.push(s42);
                        s42 = peg$parsewhitespace();
                      }
                      peg$savedPos = s0;
                      s0 = peg$f8();
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                    if (s0 === peg$FAILED) {
                      s0 = peg$currPos;
                      s1 = [];
                      s22 = peg$parsewhitespace();
                      while (s22 !== peg$FAILED) {
                        s1.push(s22);
                        s22 = peg$parsewhitespace();
                      }
                      s22 = peg$parsesubscript();
                      if (s22 !== peg$FAILED) {
                        s32 = [];
                        s42 = peg$parsewhitespace();
                        while (s42 !== peg$FAILED) {
                          s32.push(s42);
                          s42 = peg$parsewhitespace();
                        }
                        peg$savedPos = s0;
                        s0 = peg$f9();
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                      if (s0 === peg$FAILED) {
                        s0 = peg$parseignore();
                        if (s0 === peg$FAILED) {
                          s0 = peg$parsewhitespace();
                          if (s0 === peg$FAILED) {
                            s0 = peg$currPos;
                            if (input.length > peg$currPos) {
                              s1 = input.charAt(peg$currPos);
                              peg$currPos++;
                            } else {
                              s1 = peg$FAILED;
                              if (peg$silentFails === 0) {
                                peg$fail(peg$e3);
                              }
                            }
                            if (s1 !== peg$FAILED) {
                              peg$savedPos = s0;
                              s1 = peg$f10(s1);
                            }
                            s0 = s1;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e5);
          }
        }
        return s0;
      }
      function peg$parsenonchar_token() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parseescape();
        if (s0 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 37) {
            s0 = peg$c0;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e7);
            }
          }
          if (s0 === peg$FAILED) {
            s0 = peg$parsebegin_group();
            if (s0 === peg$FAILED) {
              s0 = peg$parseend_group();
              if (s0 === peg$FAILED) {
                s0 = peg$parsemath_shift();
                if (s0 === peg$FAILED) {
                  s0 = peg$parsealignment_tab();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parsenl();
                    if (s0 === peg$FAILED) {
                      s0 = peg$parsemacro_parameter();
                      if (s0 === peg$FAILED) {
                        s0 = peg$parseignore();
                        if (s0 === peg$FAILED) {
                          s0 = peg$parsesp();
                          if (s0 === peg$FAILED) {
                            s0 = peg$parsepunctuation();
                            if (s0 === peg$FAILED) {
                              s0 = peg$parseEOF();
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e6);
          }
        }
        return s0;
      }
      function peg$parsewhitespace() {
        var s0, s1, s22, s32, s42, s5, s6, s7;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$parsenl();
        if (s22 !== peg$FAILED) {
          s32 = [];
          s42 = peg$parsesp();
          while (s42 !== peg$FAILED) {
            s32.push(s42);
            s42 = peg$parsesp();
          }
          s22 = [s22, s32];
          s1 = s22;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
          s1 = peg$currPos;
          s22 = [];
          s32 = peg$parsesp();
          if (s32 !== peg$FAILED) {
            while (s32 !== peg$FAILED) {
              s22.push(s32);
              s32 = peg$parsesp();
            }
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s32 = peg$parsenl();
            if (s32 !== peg$FAILED) {
              s42 = peg$currPos;
              peg$silentFails++;
              s5 = peg$parsecomment_start();
              peg$silentFails--;
              if (s5 === peg$FAILED) {
                s42 = void 0;
              } else {
                peg$currPos = s42;
                s42 = peg$FAILED;
              }
              if (s42 !== peg$FAILED) {
                s5 = [];
                s6 = peg$parsesp();
                while (s6 !== peg$FAILED) {
                  s5.push(s6);
                  s6 = peg$parsesp();
                }
                s6 = peg$currPos;
                peg$silentFails++;
                s7 = peg$parsenl();
                peg$silentFails--;
                if (s7 === peg$FAILED) {
                  s6 = void 0;
                } else {
                  peg$currPos = s6;
                  s6 = peg$FAILED;
                }
                if (s6 !== peg$FAILED) {
                  s22 = [s22, s32, s42, s5, s6];
                  s1 = s22;
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 === peg$FAILED) {
            s1 = [];
            s22 = peg$parsesp();
            if (s22 !== peg$FAILED) {
              while (s22 !== peg$FAILED) {
                s1.push(s22);
                s22 = peg$parsesp();
              }
            } else {
              s1 = peg$FAILED;
            }
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f11();
        }
        s0 = s1;
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e8);
          }
        }
        return s0;
      }
      function peg$parsenumber() {
        var s0, s1, s22, s32, s42, s5;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = [];
        s32 = peg$parsenum();
        if (s32 !== peg$FAILED) {
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parsenum();
          }
        } else {
          s22 = peg$FAILED;
        }
        if (s22 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 46) {
            s32 = peg$c1;
            peg$currPos++;
          } else {
            s32 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e10);
            }
          }
          if (s32 !== peg$FAILED) {
            s42 = [];
            s5 = peg$parsenum();
            if (s5 !== peg$FAILED) {
              while (s5 !== peg$FAILED) {
                s42.push(s5);
                s5 = peg$parsenum();
              }
            } else {
              s42 = peg$FAILED;
            }
            if (s42 !== peg$FAILED) {
              peg$savedPos = s1;
              s1 = peg$f12(s22, s42);
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
          s1 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 46) {
            s22 = peg$c1;
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e10);
            }
          }
          if (s22 !== peg$FAILED) {
            s32 = [];
            s42 = peg$parsenum();
            if (s42 !== peg$FAILED) {
              while (s42 !== peg$FAILED) {
                s32.push(s42);
                s42 = peg$parsenum();
              }
            } else {
              s32 = peg$FAILED;
            }
            if (s32 !== peg$FAILED) {
              peg$savedPos = s1;
              s1 = peg$f13(s32);
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 === peg$FAILED) {
            s1 = peg$currPos;
            s22 = [];
            s32 = peg$parsenum();
            if (s32 !== peg$FAILED) {
              while (s32 !== peg$FAILED) {
                s22.push(s32);
                s32 = peg$parsenum();
              }
            } else {
              s22 = peg$FAILED;
            }
            if (s22 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 46) {
                s32 = peg$c1;
                peg$currPos++;
              } else {
                s32 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e10);
                }
              }
              if (s32 !== peg$FAILED) {
                peg$savedPos = s1;
                s1 = peg$f14(s22);
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f15(s1);
        }
        s0 = s1;
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e9);
          }
        }
        return s0;
      }
      function peg$parsespecial_macro() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8, s9;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parseescape();
        if (s1 !== peg$FAILED) {
          if (input.substr(peg$currPos, 5) === peg$c2) {
            s22 = peg$c2;
            peg$currPos += 5;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e12);
            }
          }
          if (s22 === peg$FAILED) {
            if (input.substr(peg$currPos, 4) === peg$c3) {
              s22 = peg$c3;
              peg$currPos += 4;
            } else {
              s22 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e13);
              }
            }
          }
          if (s22 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s32 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s32 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e3);
              }
            }
            if (s32 !== peg$FAILED) {
              s42 = [];
              s5 = peg$currPos;
              s6 = peg$currPos;
              peg$silentFails++;
              s7 = peg$currPos;
              if (input.length > peg$currPos) {
                s8 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s8 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e3);
                }
              }
              if (s8 !== peg$FAILED) {
                peg$savedPos = peg$currPos;
                s9 = peg$f16(s22, s32, s8);
                if (s9) {
                  s9 = void 0;
                } else {
                  s9 = peg$FAILED;
                }
                if (s9 !== peg$FAILED) {
                  s8 = [s8, s9];
                  s7 = s8;
                } else {
                  peg$currPos = s7;
                  s7 = peg$FAILED;
                }
              } else {
                peg$currPos = s7;
                s7 = peg$FAILED;
              }
              peg$silentFails--;
              if (s7 === peg$FAILED) {
                s6 = void 0;
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
              if (s6 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                  s7 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e3);
                  }
                }
                if (s7 !== peg$FAILED) {
                  peg$savedPos = s5;
                  s5 = peg$f17(s22, s32, s7);
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
              while (s5 !== peg$FAILED) {
                s42.push(s5);
                s5 = peg$currPos;
                s6 = peg$currPos;
                peg$silentFails++;
                s7 = peg$currPos;
                if (input.length > peg$currPos) {
                  s8 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s8 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e3);
                  }
                }
                if (s8 !== peg$FAILED) {
                  peg$savedPos = peg$currPos;
                  s9 = peg$f16(s22, s32, s8);
                  if (s9) {
                    s9 = void 0;
                  } else {
                    s9 = peg$FAILED;
                  }
                  if (s9 !== peg$FAILED) {
                    s8 = [s8, s9];
                    s7 = s8;
                  } else {
                    peg$currPos = s7;
                    s7 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s7;
                  s7 = peg$FAILED;
                }
                peg$silentFails--;
                if (s7 === peg$FAILED) {
                  s6 = void 0;
                } else {
                  peg$currPos = s6;
                  s6 = peg$FAILED;
                }
                if (s6 !== peg$FAILED) {
                  if (input.length > peg$currPos) {
                    s7 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e3);
                    }
                  }
                  if (s7 !== peg$FAILED) {
                    peg$savedPos = s5;
                    s5 = peg$f17(s22, s32, s7);
                  } else {
                    peg$currPos = s5;
                    s5 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              }
              s5 = peg$currPos;
              if (input.length > peg$currPos) {
                s6 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e3);
                }
              }
              if (s6 !== peg$FAILED) {
                peg$savedPos = peg$currPos;
                s7 = peg$f18(s22, s32, s42, s6);
                if (s7) {
                  s7 = void 0;
                } else {
                  s7 = peg$FAILED;
                }
                if (s7 !== peg$FAILED) {
                  s6 = [s6, s7];
                  s5 = s6;
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f19(s22, s32, s42);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$parseverbatim_environment();
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsebegin_display_math();
            if (s1 !== peg$FAILED) {
              s22 = [];
              s32 = peg$currPos;
              s42 = peg$currPos;
              peg$silentFails++;
              s5 = peg$parseend_display_math();
              peg$silentFails--;
              if (s5 === peg$FAILED) {
                s42 = void 0;
              } else {
                peg$currPos = s42;
                s42 = peg$FAILED;
              }
              if (s42 !== peg$FAILED) {
                s5 = peg$parsemath_token();
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s32;
                  s32 = peg$f20(s5);
                } else {
                  peg$currPos = s32;
                  s32 = peg$FAILED;
                }
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
              while (s32 !== peg$FAILED) {
                s22.push(s32);
                s32 = peg$currPos;
                s42 = peg$currPos;
                peg$silentFails++;
                s5 = peg$parseend_display_math();
                peg$silentFails--;
                if (s5 === peg$FAILED) {
                  s42 = void 0;
                } else {
                  peg$currPos = s42;
                  s42 = peg$FAILED;
                }
                if (s42 !== peg$FAILED) {
                  s5 = peg$parsemath_token();
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s32;
                    s32 = peg$f20(s5);
                  } else {
                    peg$currPos = s32;
                    s32 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s32;
                  s32 = peg$FAILED;
                }
              }
              s32 = peg$parseend_display_math();
              if (s32 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f21(s22);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parsebegin_inline_math();
              if (s1 !== peg$FAILED) {
                s22 = [];
                s32 = peg$currPos;
                s42 = peg$currPos;
                peg$silentFails++;
                s5 = peg$parseend_inline_math();
                peg$silentFails--;
                if (s5 === peg$FAILED) {
                  s42 = void 0;
                } else {
                  peg$currPos = s42;
                  s42 = peg$FAILED;
                }
                if (s42 !== peg$FAILED) {
                  s5 = peg$parsemath_token();
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s32;
                    s32 = peg$f22(s5);
                  } else {
                    peg$currPos = s32;
                    s32 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s32;
                  s32 = peg$FAILED;
                }
                while (s32 !== peg$FAILED) {
                  s22.push(s32);
                  s32 = peg$currPos;
                  s42 = peg$currPos;
                  peg$silentFails++;
                  s5 = peg$parseend_inline_math();
                  peg$silentFails--;
                  if (s5 === peg$FAILED) {
                    s42 = void 0;
                  } else {
                    peg$currPos = s42;
                    s42 = peg$FAILED;
                  }
                  if (s42 !== peg$FAILED) {
                    s5 = peg$parsemath_token();
                    if (s5 !== peg$FAILED) {
                      peg$savedPos = s32;
                      s32 = peg$f22(s5);
                    } else {
                      peg$currPos = s32;
                      s32 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s32;
                    s32 = peg$FAILED;
                  }
                }
                s32 = peg$parseend_inline_math();
                if (s32 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s0 = peg$f23(s22);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parsemath_shift();
                if (s1 !== peg$FAILED) {
                  s22 = peg$parsemath_shift();
                  if (s22 !== peg$FAILED) {
                    s32 = [];
                    s42 = peg$currPos;
                    s5 = peg$currPos;
                    peg$silentFails++;
                    s6 = peg$currPos;
                    s7 = peg$parsemath_shift();
                    if (s7 !== peg$FAILED) {
                      s8 = peg$parsemath_shift();
                      if (s8 !== peg$FAILED) {
                        s7 = [s7, s8];
                        s6 = s7;
                      } else {
                        peg$currPos = s6;
                        s6 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s6;
                      s6 = peg$FAILED;
                    }
                    peg$silentFails--;
                    if (s6 === peg$FAILED) {
                      s5 = void 0;
                    } else {
                      peg$currPos = s5;
                      s5 = peg$FAILED;
                    }
                    if (s5 !== peg$FAILED) {
                      s6 = peg$parsemath_token();
                      if (s6 !== peg$FAILED) {
                        peg$savedPos = s42;
                        s42 = peg$f24(s6);
                      } else {
                        peg$currPos = s42;
                        s42 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s42;
                      s42 = peg$FAILED;
                    }
                    while (s42 !== peg$FAILED) {
                      s32.push(s42);
                      s42 = peg$currPos;
                      s5 = peg$currPos;
                      peg$silentFails++;
                      s6 = peg$currPos;
                      s7 = peg$parsemath_shift();
                      if (s7 !== peg$FAILED) {
                        s8 = peg$parsemath_shift();
                        if (s8 !== peg$FAILED) {
                          s7 = [s7, s8];
                          s6 = s7;
                        } else {
                          peg$currPos = s6;
                          s6 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s6;
                        s6 = peg$FAILED;
                      }
                      peg$silentFails--;
                      if (s6 === peg$FAILED) {
                        s5 = void 0;
                      } else {
                        peg$currPos = s5;
                        s5 = peg$FAILED;
                      }
                      if (s5 !== peg$FAILED) {
                        s6 = peg$parsemath_token();
                        if (s6 !== peg$FAILED) {
                          peg$savedPos = s42;
                          s42 = peg$f24(s6);
                        } else {
                          peg$currPos = s42;
                          s42 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s42;
                        s42 = peg$FAILED;
                      }
                    }
                    s42 = peg$parsemath_shift();
                    if (s42 !== peg$FAILED) {
                      s5 = peg$parsemath_shift();
                      if (s5 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s0 = peg$f25(s32);
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
                if (s0 === peg$FAILED) {
                  s0 = peg$parsemath_environment();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parseenvironment();
                  }
                }
              }
            }
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e11);
          }
        }
        return s0;
      }
      function peg$parseverbatim_environment() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8, s9, s10, s11;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parsebegin_env();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsebegin_group();
          if (s22 !== peg$FAILED) {
            s32 = peg$parseverbatim_env_name();
            if (s32 !== peg$FAILED) {
              s42 = peg$parseend_group();
              if (s42 !== peg$FAILED) {
                s5 = [];
                s6 = peg$currPos;
                s7 = peg$currPos;
                peg$silentFails++;
                s8 = peg$currPos;
                s9 = peg$parseend_env();
                if (s9 !== peg$FAILED) {
                  s10 = peg$parsegroup();
                  if (s10 !== peg$FAILED) {
                    peg$savedPos = peg$currPos;
                    s11 = peg$f26(s32, s10);
                    if (s11) {
                      s11 = void 0;
                    } else {
                      s11 = peg$FAILED;
                    }
                    if (s11 !== peg$FAILED) {
                      s9 = [s9, s10, s11];
                      s8 = s9;
                    } else {
                      peg$currPos = s8;
                      s8 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s8;
                    s8 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s8;
                  s8 = peg$FAILED;
                }
                peg$silentFails--;
                if (s8 === peg$FAILED) {
                  s7 = void 0;
                } else {
                  peg$currPos = s7;
                  s7 = peg$FAILED;
                }
                if (s7 !== peg$FAILED) {
                  if (input.length > peg$currPos) {
                    s8 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s8 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e3);
                    }
                  }
                  if (s8 !== peg$FAILED) {
                    peg$savedPos = s6;
                    s6 = peg$f27(s32, s8);
                  } else {
                    peg$currPos = s6;
                    s6 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s6;
                  s6 = peg$FAILED;
                }
                while (s6 !== peg$FAILED) {
                  s5.push(s6);
                  s6 = peg$currPos;
                  s7 = peg$currPos;
                  peg$silentFails++;
                  s8 = peg$currPos;
                  s9 = peg$parseend_env();
                  if (s9 !== peg$FAILED) {
                    s10 = peg$parsegroup();
                    if (s10 !== peg$FAILED) {
                      peg$savedPos = peg$currPos;
                      s11 = peg$f26(s32, s10);
                      if (s11) {
                        s11 = void 0;
                      } else {
                        s11 = peg$FAILED;
                      }
                      if (s11 !== peg$FAILED) {
                        s9 = [s9, s10, s11];
                        s8 = s9;
                      } else {
                        peg$currPos = s8;
                        s8 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s8;
                      s8 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s8;
                    s8 = peg$FAILED;
                  }
                  peg$silentFails--;
                  if (s8 === peg$FAILED) {
                    s7 = void 0;
                  } else {
                    peg$currPos = s7;
                    s7 = peg$FAILED;
                  }
                  if (s7 !== peg$FAILED) {
                    if (input.length > peg$currPos) {
                      s8 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s8 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e3);
                      }
                    }
                    if (s8 !== peg$FAILED) {
                      peg$savedPos = s6;
                      s6 = peg$f27(s32, s8);
                    } else {
                      peg$currPos = s6;
                      s6 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s6;
                    s6 = peg$FAILED;
                  }
                }
                s6 = peg$parseend_env();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parsebegin_group();
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parseverbatim_env_name();
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parseend_group();
                      if (s9 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s0 = peg$f28(s32, s5);
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e14);
          }
        }
        return s0;
      }
      function peg$parseverbatim_env_name() {
        var s0;
        if (input.substr(peg$currPos, 9) === peg$c4) {
          s0 = peg$c4;
          peg$currPos += 9;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e15);
          }
        }
        if (s0 === peg$FAILED) {
          if (input.substr(peg$currPos, 8) === peg$c5) {
            s0 = peg$c5;
            peg$currPos += 8;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e16);
            }
          }
          if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 13) === peg$c6) {
              s0 = peg$c6;
              peg$currPos += 13;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e17);
              }
            }
            if (s0 === peg$FAILED) {
              if (input.substr(peg$currPos, 12) === peg$c7) {
                s0 = peg$c7;
                peg$currPos += 12;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e18);
                }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 7) === peg$c8) {
                  s0 = peg$c8;
                  peg$currPos += 7;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e19);
                  }
                }
                if (s0 === peg$FAILED) {
                  if (input.substr(peg$currPos, 10) === peg$c9) {
                    s0 = peg$c9;
                    peg$currPos += 10;
                  } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e20);
                    }
                  }
                }
              }
            }
          }
        }
        return s0;
      }
      function peg$parsemacro() {
        var s0, s1, s22, s32, s42;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$parseescape();
        if (s22 !== peg$FAILED) {
          s32 = [];
          s42 = peg$parsechar();
          if (s42 !== peg$FAILED) {
            while (s42 !== peg$FAILED) {
              s32.push(s42);
              s42 = peg$parsechar();
            }
          } else {
            s32 = peg$FAILED;
          }
          if (s32 !== peg$FAILED) {
            peg$savedPos = s1;
            s1 = peg$f29(s32);
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
          s1 = peg$currPos;
          s22 = peg$parseescape();
          if (s22 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s32 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s32 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e3);
              }
            }
            if (s32 !== peg$FAILED) {
              peg$savedPos = s1;
              s1 = peg$f30(s32);
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f31(s1);
        }
        s0 = s1;
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e21);
          }
        }
        return s0;
      }
      function peg$parsegroup() {
        var s0, s1, s22, s32, s42, s5;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parsebegin_group();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$currPos;
          s42 = peg$currPos;
          peg$silentFails++;
          s5 = peg$parseend_group();
          peg$silentFails--;
          if (s5 === peg$FAILED) {
            s42 = void 0;
          } else {
            peg$currPos = s42;
            s42 = peg$FAILED;
          }
          if (s42 !== peg$FAILED) {
            s5 = peg$parsetoken();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s32;
              s32 = peg$f32(s5);
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          } else {
            peg$currPos = s32;
            s32 = peg$FAILED;
          }
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$currPos;
            s42 = peg$currPos;
            peg$silentFails++;
            s5 = peg$parseend_group();
            peg$silentFails--;
            if (s5 === peg$FAILED) {
              s42 = void 0;
            } else {
              peg$currPos = s42;
              s42 = peg$FAILED;
            }
            if (s42 !== peg$FAILED) {
              s5 = peg$parsetoken();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s32;
                s32 = peg$f32(s5);
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          }
          s32 = peg$parseend_group();
          if (s32 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f33(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e22);
          }
        }
        return s0;
      }
      function peg$parsegroup_contents_as_string() {
        var s0, s1;
        s0 = peg$currPos;
        s1 = peg$parsegroup();
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f34(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parseenvironment() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8, s9, s10;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parsebegin_env();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsegroup_contents_as_string();
          if (s22 !== peg$FAILED) {
            s32 = peg$parsesameline_comment();
            if (s32 === peg$FAILED) {
              s32 = null;
            }
            s42 = [];
            s5 = peg$currPos;
            s6 = peg$currPos;
            peg$silentFails++;
            s7 = peg$currPos;
            s8 = peg$parseend_env();
            if (s8 !== peg$FAILED) {
              s9 = peg$parsegroup_contents_as_string();
              if (s9 !== peg$FAILED) {
                peg$savedPos = peg$currPos;
                s10 = peg$f35(s22, s32, s9);
                if (s10) {
                  s10 = void 0;
                } else {
                  s10 = peg$FAILED;
                }
                if (s10 !== peg$FAILED) {
                  s8 = [s8, s9, s10];
                  s7 = s8;
                } else {
                  peg$currPos = s7;
                  s7 = peg$FAILED;
                }
              } else {
                peg$currPos = s7;
                s7 = peg$FAILED;
              }
            } else {
              peg$currPos = s7;
              s7 = peg$FAILED;
            }
            peg$silentFails--;
            if (s7 === peg$FAILED) {
              s6 = void 0;
            } else {
              peg$currPos = s6;
              s6 = peg$FAILED;
            }
            if (s6 !== peg$FAILED) {
              s7 = peg$parsetoken();
              if (s7 !== peg$FAILED) {
                peg$savedPos = s5;
                s5 = peg$f36(s22, s32, s7);
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
            while (s5 !== peg$FAILED) {
              s42.push(s5);
              s5 = peg$currPos;
              s6 = peg$currPos;
              peg$silentFails++;
              s7 = peg$currPos;
              s8 = peg$parseend_env();
              if (s8 !== peg$FAILED) {
                s9 = peg$parsegroup_contents_as_string();
                if (s9 !== peg$FAILED) {
                  peg$savedPos = peg$currPos;
                  s10 = peg$f35(s22, s32, s9);
                  if (s10) {
                    s10 = void 0;
                  } else {
                    s10 = peg$FAILED;
                  }
                  if (s10 !== peg$FAILED) {
                    s8 = [s8, s9, s10];
                    s7 = s8;
                  } else {
                    peg$currPos = s7;
                    s7 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s7;
                  s7 = peg$FAILED;
                }
              } else {
                peg$currPos = s7;
                s7 = peg$FAILED;
              }
              peg$silentFails--;
              if (s7 === peg$FAILED) {
                s6 = void 0;
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
              if (s6 !== peg$FAILED) {
                s7 = peg$parsetoken();
                if (s7 !== peg$FAILED) {
                  peg$savedPos = s5;
                  s5 = peg$f36(s22, s32, s7);
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            }
            s5 = peg$parseend_env();
            if (s5 !== peg$FAILED) {
              s6 = peg$parsegroup_contents_as_string();
              if (s6 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f37(s22, s32, s42);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e23);
          }
        }
        return s0;
      }
      function peg$parsemath_environment() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8, s9, s10, s11, s12;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parsebegin_env();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsebegin_group();
          if (s22 !== peg$FAILED) {
            s32 = peg$parsemath_env_name();
            if (s32 !== peg$FAILED) {
              s42 = peg$parseend_group();
              if (s42 !== peg$FAILED) {
                s5 = peg$parsesameline_comment();
                if (s5 === peg$FAILED) {
                  s5 = null;
                }
                s6 = [];
                s7 = peg$currPos;
                s8 = peg$currPos;
                peg$silentFails++;
                s9 = peg$currPos;
                s10 = peg$parseend_env();
                if (s10 !== peg$FAILED) {
                  s11 = peg$parsegroup();
                  if (s11 !== peg$FAILED) {
                    peg$savedPos = peg$currPos;
                    s12 = peg$f38(s32, s5, s11);
                    if (s12) {
                      s12 = void 0;
                    } else {
                      s12 = peg$FAILED;
                    }
                    if (s12 !== peg$FAILED) {
                      s10 = [s10, s11, s12];
                      s9 = s10;
                    } else {
                      peg$currPos = s9;
                      s9 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s9;
                    s9 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s9;
                  s9 = peg$FAILED;
                }
                peg$silentFails--;
                if (s9 === peg$FAILED) {
                  s8 = void 0;
                } else {
                  peg$currPos = s8;
                  s8 = peg$FAILED;
                }
                if (s8 !== peg$FAILED) {
                  s9 = peg$parsemath_token();
                  if (s9 !== peg$FAILED) {
                    peg$savedPos = s7;
                    s7 = peg$f39(s32, s5, s9);
                  } else {
                    peg$currPos = s7;
                    s7 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s7;
                  s7 = peg$FAILED;
                }
                while (s7 !== peg$FAILED) {
                  s6.push(s7);
                  s7 = peg$currPos;
                  s8 = peg$currPos;
                  peg$silentFails++;
                  s9 = peg$currPos;
                  s10 = peg$parseend_env();
                  if (s10 !== peg$FAILED) {
                    s11 = peg$parsegroup();
                    if (s11 !== peg$FAILED) {
                      peg$savedPos = peg$currPos;
                      s12 = peg$f38(s32, s5, s11);
                      if (s12) {
                        s12 = void 0;
                      } else {
                        s12 = peg$FAILED;
                      }
                      if (s12 !== peg$FAILED) {
                        s10 = [s10, s11, s12];
                        s9 = s10;
                      } else {
                        peg$currPos = s9;
                        s9 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s9;
                      s9 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s9;
                    s9 = peg$FAILED;
                  }
                  peg$silentFails--;
                  if (s9 === peg$FAILED) {
                    s8 = void 0;
                  } else {
                    peg$currPos = s8;
                    s8 = peg$FAILED;
                  }
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parsemath_token();
                    if (s9 !== peg$FAILED) {
                      peg$savedPos = s7;
                      s7 = peg$f39(s32, s5, s9);
                    } else {
                      peg$currPos = s7;
                      s7 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s7;
                    s7 = peg$FAILED;
                  }
                }
                s7 = peg$parseend_env();
                if (s7 !== peg$FAILED) {
                  s8 = peg$parsebegin_group();
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parsemath_env_name();
                    if (s9 !== peg$FAILED) {
                      s10 = peg$parseend_group();
                      if (s10 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s0 = peg$f40(s32, s5, s6);
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e24);
          }
        }
        return s0;
      }
      function peg$parsemath_group() {
        var s0, s1, s22, s32, s42, s5;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parsebegin_group();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$currPos;
          s42 = peg$currPos;
          peg$silentFails++;
          s5 = peg$parseend_group();
          peg$silentFails--;
          if (s5 === peg$FAILED) {
            s42 = void 0;
          } else {
            peg$currPos = s42;
            s42 = peg$FAILED;
          }
          if (s42 !== peg$FAILED) {
            s5 = peg$parsemath_token();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s32;
              s32 = peg$f41(s5);
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          } else {
            peg$currPos = s32;
            s32 = peg$FAILED;
          }
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$currPos;
            s42 = peg$currPos;
            peg$silentFails++;
            s5 = peg$parseend_group();
            peg$silentFails--;
            if (s5 === peg$FAILED) {
              s42 = void 0;
            } else {
              peg$currPos = s42;
              s42 = peg$FAILED;
            }
            if (s42 !== peg$FAILED) {
              s5 = peg$parsemath_token();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s32;
                s32 = peg$f41(s5);
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          }
          s32 = peg$parseend_group();
          if (s32 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f42(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e25);
          }
        }
        return s0;
      }
      function peg$parsebegin_display_math() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parseescape();
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 91) {
            s22 = peg$c10;
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e26);
            }
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseend_display_math() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parseescape();
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 93) {
            s22 = peg$c11;
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e27);
            }
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsebegin_inline_math() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parseescape();
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 40) {
            s22 = peg$c12;
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e28);
            }
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseend_inline_math() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parseescape();
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 41) {
            s22 = peg$c13;
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e29);
            }
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsebegin_env() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parseescape();
        if (s1 !== peg$FAILED) {
          if (input.substr(peg$currPos, 5) === peg$c14) {
            s22 = peg$c14;
            peg$currPos += 5;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e30);
            }
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseend_env() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parseescape();
        if (s1 !== peg$FAILED) {
          if (input.substr(peg$currPos, 3) === peg$c15) {
            s22 = peg$c15;
            peg$currPos += 3;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e31);
            }
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsemath_env_name() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 9) === peg$c16) {
          s1 = peg$c16;
          peg$currPos += 9;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e32);
          }
        }
        if (s1 === peg$FAILED) {
          if (input.substr(peg$currPos, 8) === peg$c17) {
            s1 = peg$c17;
            peg$currPos += 8;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e33);
            }
          }
          if (s1 === peg$FAILED) {
            if (input.substr(peg$currPos, 6) === peg$c18) {
              s1 = peg$c18;
              peg$currPos += 6;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e34);
              }
            }
            if (s1 === peg$FAILED) {
              if (input.substr(peg$currPos, 5) === peg$c19) {
                s1 = peg$c19;
                peg$currPos += 5;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e35);
                }
              }
              if (s1 === peg$FAILED) {
                if (input.substr(peg$currPos, 8) === peg$c20) {
                  s1 = peg$c20;
                  peg$currPos += 8;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e36);
                  }
                }
                if (s1 === peg$FAILED) {
                  if (input.substr(peg$currPos, 7) === peg$c21) {
                    s1 = peg$c21;
                    peg$currPos += 7;
                  } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e37);
                    }
                  }
                  if (s1 === peg$FAILED) {
                    if (input.substr(peg$currPos, 7) === peg$c22) {
                      s1 = peg$c22;
                      peg$currPos += 7;
                    } else {
                      s1 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e38);
                      }
                    }
                    if (s1 === peg$FAILED) {
                      if (input.substr(peg$currPos, 6) === peg$c23) {
                        s1 = peg$c23;
                        peg$currPos += 6;
                      } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$e39);
                        }
                      }
                      if (s1 === peg$FAILED) {
                        if (input.substr(peg$currPos, 9) === peg$c24) {
                          s1 = peg$c24;
                          peg$currPos += 9;
                        } else {
                          s1 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$e40);
                          }
                        }
                        if (s1 === peg$FAILED) {
                          if (input.substr(peg$currPos, 8) === peg$c25) {
                            s1 = peg$c25;
                            peg$currPos += 8;
                          } else {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) {
                              peg$fail(peg$e41);
                            }
                          }
                          if (s1 === peg$FAILED) {
                            if (input.substr(peg$currPos, 8) === peg$c26) {
                              s1 = peg$c26;
                              peg$currPos += 8;
                            } else {
                              s1 = peg$FAILED;
                              if (peg$silentFails === 0) {
                                peg$fail(peg$e42);
                              }
                            }
                            if (s1 === peg$FAILED) {
                              if (input.substr(peg$currPos, 7) === peg$c27) {
                                s1 = peg$c27;
                                peg$currPos += 7;
                              } else {
                                s1 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                  peg$fail(peg$e43);
                                }
                              }
                              if (s1 === peg$FAILED) {
                                if (input.substr(peg$currPos, 5) === peg$c28) {
                                  s1 = peg$c28;
                                  peg$currPos += 5;
                                } else {
                                  s1 = peg$FAILED;
                                  if (peg$silentFails === 0) {
                                    peg$fail(peg$e44);
                                  }
                                }
                                if (s1 === peg$FAILED) {
                                  if (input.substr(peg$currPos, 4) === peg$c29) {
                                    s1 = peg$c29;
                                    peg$currPos += 4;
                                  } else {
                                    s1 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                      peg$fail(peg$e45);
                                    }
                                  }
                                  if (s1 === peg$FAILED) {
                                    if (input.substr(peg$currPos, 11) === peg$c30) {
                                      s1 = peg$c30;
                                      peg$currPos += 11;
                                    } else {
                                      s1 = peg$FAILED;
                                      if (peg$silentFails === 0) {
                                        peg$fail(peg$e46);
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f43(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parseescape() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 92) {
          s1 = peg$c31;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e48);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f44();
        }
        s0 = s1;
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e47);
          }
        }
        return s0;
      }
      function peg$parsebegin_group() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 123) {
          s1 = peg$c32;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e49);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f45(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parseend_group() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 125) {
          s1 = peg$c33;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e50);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f46(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parsemath_shift() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 36) {
          s1 = peg$c34;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e51);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f47(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parsealignment_tab() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 38) {
          s1 = peg$c35;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e52);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f48(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parsenl() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 13) {
          s22 = peg$c36;
          peg$currPos++;
        } else {
          s22 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e54);
          }
        }
        peg$silentFails--;
        if (s22 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 10) {
            s22 = peg$c37;
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e55);
            }
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 13) {
            s0 = peg$c36;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e54);
            }
          }
          if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c38) {
              s0 = peg$c38;
              peg$currPos += 2;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e56);
              }
            }
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e53);
          }
        }
        return s0;
      }
      function peg$parsemacro_parameter() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 35) {
          s1 = peg$c39;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e57);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f49(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parsesuperscript() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 94) {
          s1 = peg$c40;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e58);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f50(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parsesubscript() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 95) {
          s1 = peg$c41;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e59);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f51(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parseignore() {
        var s0;
        if (input.charCodeAt(peg$currPos) === 0) {
          s0 = peg$c42;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e60);
          }
        }
        return s0;
      }
      function peg$parsesp() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        if (peg$r0.test(input.charAt(peg$currPos))) {
          s22 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s22 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e61);
          }
        }
        if (s22 !== peg$FAILED) {
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            if (peg$r0.test(input.charAt(peg$currPos))) {
              s22 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s22 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e61);
              }
            }
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f52();
        }
        s0 = s1;
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e8);
          }
        }
        return s0;
      }
      function peg$parsechar() {
        var s0, s1;
        peg$silentFails++;
        if (peg$r1.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e63);
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e62);
          }
        }
        return s0;
      }
      function peg$parsenum() {
        var s0, s1;
        peg$silentFails++;
        if (peg$r2.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e65);
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e64);
          }
        }
        return s0;
      }
      function peg$parsepunctuation() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$currPos;
        if (peg$r3.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e67);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f53(s1);
        }
        s0 = s1;
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e66);
          }
        }
        return s0;
      }
      function peg$parsecomment_start() {
        var s0;
        if (input.charCodeAt(peg$currPos) === 37) {
          s0 = peg$c0;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e7);
          }
        }
        return s0;
      }
      function peg$parsefull_comment() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parseownline_comment();
        if (s0 === peg$FAILED) {
          s0 = peg$parsesameline_comment();
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e68);
          }
        }
        return s0;
      }
      function peg$parseownline_comment() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = [];
        s32 = peg$parsesp();
        while (s32 !== peg$FAILED) {
          s22.push(s32);
          s32 = peg$parsesp();
        }
        s32 = peg$parsenl();
        if (s32 !== peg$FAILED) {
          s22 = [s22, s32];
          s1 = s22;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
          s1 = null;
        }
        s22 = peg$parseleading_sp();
        if (s22 !== peg$FAILED) {
          s32 = peg$parsecomment();
          if (s32 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f54(s22, s32);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsesameline_comment() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsesp();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parsesp();
        }
        s22 = peg$parsecomment();
        if (s22 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f55(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecomment() {
        var s0, s1, s22, s32, s42, s5, s6, s7;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parsecomment_start();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$currPos;
          s42 = peg$currPos;
          peg$silentFails++;
          s5 = peg$parsenl();
          peg$silentFails--;
          if (s5 === peg$FAILED) {
            s42 = void 0;
          } else {
            peg$currPos = s42;
            s42 = peg$FAILED;
          }
          if (s42 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s5 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e3);
              }
            }
            if (s5 !== peg$FAILED) {
              peg$savedPos = s32;
              s32 = peg$f56(s5);
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          } else {
            peg$currPos = s32;
            s32 = peg$FAILED;
          }
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$currPos;
            s42 = peg$currPos;
            peg$silentFails++;
            s5 = peg$parsenl();
            peg$silentFails--;
            if (s5 === peg$FAILED) {
              s42 = void 0;
            } else {
              peg$currPos = s42;
              s42 = peg$FAILED;
            }
            if (s42 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s5 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e3);
                }
              }
              if (s5 !== peg$FAILED) {
                peg$savedPos = s32;
                s32 = peg$f56(s5);
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          }
          s32 = peg$currPos;
          peg$silentFails++;
          s42 = peg$parseparbreak();
          peg$silentFails--;
          if (s42 !== peg$FAILED) {
            peg$currPos = s32;
            s32 = void 0;
          } else {
            s32 = peg$FAILED;
          }
          if (s32 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f57(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsecomment_start();
          if (s1 !== peg$FAILED) {
            s22 = [];
            s32 = peg$currPos;
            s42 = peg$currPos;
            peg$silentFails++;
            s5 = peg$parsenl();
            peg$silentFails--;
            if (s5 === peg$FAILED) {
              s42 = void 0;
            } else {
              peg$currPos = s42;
              s42 = peg$FAILED;
            }
            if (s42 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s5 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e3);
                }
              }
              if (s5 !== peg$FAILED) {
                peg$savedPos = s32;
                s32 = peg$f58(s5);
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
            while (s32 !== peg$FAILED) {
              s22.push(s32);
              s32 = peg$currPos;
              s42 = peg$currPos;
              peg$silentFails++;
              s5 = peg$parsenl();
              peg$silentFails--;
              if (s5 === peg$FAILED) {
                s42 = void 0;
              } else {
                peg$currPos = s42;
                s42 = peg$FAILED;
              }
              if (s42 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                  s5 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e3);
                  }
                }
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s32;
                  s32 = peg$f58(s5);
                } else {
                  peg$currPos = s32;
                  s32 = peg$FAILED;
                }
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
            }
            s32 = peg$currPos;
            s42 = peg$parsenl();
            if (s42 !== peg$FAILED) {
              s5 = [];
              s6 = peg$parsesp();
              while (s6 !== peg$FAILED) {
                s5.push(s6);
                s6 = peg$parsesp();
              }
              s6 = peg$currPos;
              peg$silentFails++;
              s7 = peg$parsecomment_start();
              peg$silentFails--;
              if (s7 === peg$FAILED) {
                s6 = void 0;
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
              if (s6 !== peg$FAILED) {
                s42 = [s42, s5, s6];
                s32 = s42;
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
            if (s32 === peg$FAILED) {
              s32 = peg$parsenl();
              if (s32 === peg$FAILED) {
                s32 = peg$parseEOF();
              }
            }
            if (s32 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f59(s22);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e69);
          }
        }
        return s0;
      }
      function peg$parseleading_sp() {
        var s0, s1, s22, s32, s42;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$parsestart_of_line();
        if (s22 !== peg$FAILED) {
          s32 = [];
          s42 = peg$parsesp();
          while (s42 !== peg$FAILED) {
            s32.push(s42);
            s42 = peg$parsesp();
          }
          s22 = [s22, s32];
          s1 = s22;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }
        return s0;
      }
      function peg$parsestart_of_line() {
        var s0;
        peg$savedPos = peg$currPos;
        s0 = peg$f60();
        if (s0) {
          s0 = void 0;
        } else {
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseEOF() {
        var s0, s1;
        s0 = peg$currPos;
        peg$silentFails++;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        peg$silentFails--;
        if (s1 === peg$FAILED) {
          s0 = void 0;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function toString(e) {
        if (typeof e === "string") {
          return e;
        }
        if (typeof e.content === "string") {
          return e.content;
        }
        if (e && e.type === "whitespace") {
          return " ";
        }
        return e;
      }
      function compare_env(g1, g2) {
        const g1Name = typeof g1 === "string" ? g1 : g1.content.map(toString).join("");
        const g2Name = typeof g2 === "string" ? g2 : g2.content.map(toString).join("");
        return g1Name === g2Name;
      }
      function createNode(type, extra = {}) {
        return { type, ...extra, position: location() };
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(
          peg$maxFailExpected,
          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
      }
    }
    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }()
);
var align_environment_default5 = (
  // Generated by Peggy 2.0.1.
  //
  // https://peggyjs.org/
  function() {
    "use strict";
    function peg$subclass(child, parent) {
      function C() {
        this.constructor = child;
      }
      C.prototype = parent.prototype;
      child.prototype = new C();
    }
    function peg$SyntaxError(message, expected, found, location) {
      var self = Error.call(this, message);
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(self, peg$SyntaxError.prototype);
      }
      self.expected = expected;
      self.found = found;
      self.location = location;
      self.name = "SyntaxError";
      return self;
    }
    peg$subclass(peg$SyntaxError, Error);
    function peg$padEnd(str, targetLength, padString) {
      padString = padString || " ";
      if (str.length > targetLength) {
        return str;
      }
      targetLength -= str.length;
      padString += padString.repeat(targetLength);
      return str + padString.slice(0, targetLength);
    }
    peg$SyntaxError.prototype.format = function(sources) {
      var str = "Error: " + this.message;
      if (this.location) {
        var src = null;
        var k;
        for (k = 0; k < sources.length; k++) {
          if (sources[k].source === this.location.source) {
            src = sources[k].text.split(/\r\n|\n|\r/g);
            break;
          }
        }
        var s22 = this.location.start;
        var loc = this.location.source + ":" + s22.line + ":" + s22.column;
        if (src) {
          var e = this.location.end;
          var filler = peg$padEnd("", s22.line.toString().length, " ");
          var line = src[s22.line - 1];
          var last = s22.line === e.line ? e.column : line.length + 1;
          var hatLen = last - s22.column || 1;
          str += "\n --> " + loc + "\n" + filler + " |\n" + s22.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s22.column - 1, " ") + peg$padEnd("", hatLen, "^");
        } else {
          str += "\n at " + loc;
        }
      }
      return str;
    };
    peg$SyntaxError.buildMessage = function(expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        class: function(expectation) {
          var escapedParts = expectation.parts.map(function(part) {
            return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
          });
          return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
        },
        any: function() {
          return "any character";
        },
        end: function() {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        }
      };
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s22) {
        return s22.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function classEscape(s22) {
        return s22.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = expected2.map(describeExpectation);
        var i, j;
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {};
      var peg$source = options.grammarSource;
      var peg$startRuleFunctions = { body: peg$parsebody };
      var peg$startRuleFunction = peg$parsebody;
      var peg$e0 = peg$anyExpectation();
      var peg$f0 = function() {
        return [];
      };
      var peg$f1 = function(x) {
        return { cells: [], colSeps: [], ...x };
      };
      var peg$f2 = function(rowItems, rowSep, trailingComment) {
        return { ...rowItems, rowSep, trailingComment };
      };
      var peg$f3 = function(rowItems, trailingComment) {
        return { ...rowItems, rowSep: null, trailingComment };
      };
      var peg$f4 = function(x) {
        return x;
      };
      var peg$f5 = function(x) {
        return {
          cells: [],
          colSeps: [],
          rowSep: null,
          trailingComment: x
        };
      };
      var peg$f6 = function(x) {
        return x;
      };
      var peg$f7 = function(colSep, cell) {
        return { colSep, cell };
      };
      var peg$f8 = function(colSep) {
        return { colSep };
      };
      var peg$f9 = function(a, b) {
        return processRow(a, b);
      };
      var peg$f10 = function(b) {
        return processRow(null, b);
      };
      var peg$f11 = function(tok) {
        return options.isSameLineComment(tok);
      };
      var peg$f12 = function(tok) {
        return tok;
      };
      var peg$f13 = function(tok) {
        return options.isOwnLineComment(tok);
      };
      var peg$f14 = function(tok) {
        return tok;
      };
      var peg$f15 = function(tok) {
        return options.isWhitespace(tok);
      };
      var peg$f16 = function(tok) {
        return tok;
      };
      var peg$f17 = function(tok) {
        return options.isRowSep(tok);
      };
      var peg$f18 = function(tok) {
        return tok;
      };
      var peg$f19 = function(tok) {
        return options.isColSep(tok);
      };
      var peg$f20 = function(tok) {
        return tok;
      };
      var peg$currPos = 0;
      var peg$savedPos = 0;
      var peg$posDetailsCache = [{ line: 1, column: 1 }];
      var peg$maxFailPos = 0;
      var peg$maxFailExpected = [];
      var peg$silentFails = 0;
      var peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function offset() {
        return peg$savedPos;
      }
      function range() {
        return {
          source: peg$source,
          start: peg$savedPos,
          end: peg$currPos
        };
      }
      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError(
          [peg$otherExpectation(description)],
          input.substring(peg$savedPos, peg$currPos),
          location2
        );
      }
      function error(message, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location2);
      }
      function peg$literalExpectation(text2, ignoreCase) {
        return { type: "literal", text: text2, ignoreCase };
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts, inverted, ignoreCase };
      }
      function peg$anyExpectation() {
        return { type: "any" };
      }
      function peg$endExpectation() {
        return { type: "end" };
      }
      function peg$otherExpectation(description) {
        return { type: "other", description };
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p;
        if (details) {
          return details;
        } else {
          p = pos - 1;
          while (!peg$posDetailsCache[p]) {
            p--;
          }
          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };
          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos);
        var endPosDetails = peg$computePosDetails(endPos);
        return {
          source: peg$source,
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildSimpleError(message, location2) {
        return new peg$SyntaxError(message, null, null, location2);
      }
      function peg$buildStructuredError(expected2, found, location2) {
        return new peg$SyntaxError(
          peg$SyntaxError.buildMessage(expected2, found),
          expected2,
          found,
          location2
        );
      }
      function peg$parsebody() {
        var s0, s1;
        s0 = [];
        s1 = peg$parsecomment_only_line();
        if (s1 === peg$FAILED) {
          s1 = peg$parserow_with_end();
          if (s1 === peg$FAILED) {
            s1 = peg$parserow_without_end();
          }
        }
        if (s1 !== peg$FAILED) {
          while (s1 !== peg$FAILED) {
            s0.push(s1);
            s1 = peg$parsecomment_only_line();
            if (s1 === peg$FAILED) {
              s1 = peg$parserow_with_end();
              if (s1 === peg$FAILED) {
                s1 = peg$parserow_without_end();
              }
            }
          }
        } else {
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseEOL();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f0();
          }
          s0 = s1;
        }
        return s0;
      }
      function peg$parserow_with_end() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$parserow_items();
        if (s22 === peg$FAILED) {
          s22 = null;
        }
        peg$savedPos = s1;
        s22 = peg$f1(s22);
        s1 = s22;
        s22 = peg$parserow_sep();
        if (s22 !== peg$FAILED) {
          s32 = peg$parsetrailing_comment();
          if (s32 === peg$FAILED) {
            s32 = null;
          }
          peg$savedPos = s0;
          s0 = peg$f2(s1, s22, s32);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parserow_without_end() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parserow_items();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsetrailing_comment();
          if (s22 === peg$FAILED) {
            s22 = null;
          }
          peg$savedPos = s0;
          s0 = peg$f3(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsetrailing_comment() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsewhitespace();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parsewhitespace();
        }
        s22 = peg$parsesame_line_comment();
        if (s22 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f4(s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecomment_only_line() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsewhitespace();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parsewhitespace();
        }
        s22 = peg$parseown_line_comment();
        if (s22 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f5(s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsetoken() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        s22 = peg$parserow_sep();
        if (s22 === peg$FAILED) {
          s22 = peg$parsecol_sep();
          if (s22 === peg$FAILED) {
            s22 = peg$parsetrailing_comment();
            if (s22 === peg$FAILED) {
              s22 = peg$parseown_line_comment();
            }
          }
        }
        peg$silentFails--;
        if (s22 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s22 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f6(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecell() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsetoken();
        if (s22 !== peg$FAILED) {
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            s22 = peg$parsetoken();
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }
        return s0;
      }
      function peg$parseseparated_cell() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parsecol_sep();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsecell();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f7(s1, s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsecol_sep();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f8(s1);
          }
          s0 = s1;
        }
        return s0;
      }
      function peg$parserow_items() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$parsecell();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$parseseparated_cell();
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parseseparated_cell();
          }
          peg$savedPos = s0;
          s0 = peg$f9(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = [];
          s22 = peg$parseseparated_cell();
          if (s22 !== peg$FAILED) {
            while (s22 !== peg$FAILED) {
              s1.push(s22);
              s22 = peg$parseseparated_cell();
            }
          } else {
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f10(s1);
          }
          s0 = s1;
        }
        return s0;
      }
      function peg$parsesame_line_comment() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f11(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f12(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseown_line_comment() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f13(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f14(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsewhitespace() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f15(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f16(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parserow_sep() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f17(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f18(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecol_sep() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f19(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f20(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseEOL() {
        var s0, s1;
        s0 = peg$currPos;
        peg$silentFails++;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        peg$silentFails--;
        if (s1 === peg$FAILED) {
          s0 = void 0;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function processRow(leadCell, otherCells) {
        const cells = [leadCell || []];
        const seps = [];
        for (const x of otherCells) {
          cells.push(x.cell || []);
          seps.push(x.colSep);
        }
        return { cells, colSeps: seps };
      }
      if (!options.isWhitespace) {
        try {
          Object.assign(
            options,
            createMatchers(["\\", "hline", "cr"], ["&"])
          );
        } catch (e) {
          console.warn("Error when initializing parser", e);
        }
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(
          peg$maxFailExpected,
          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
      }
    }
    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }()
);
var xparse_argspec_default5 = (
  // Generated by Peggy 2.0.1.
  //
  // https://peggyjs.org/
  function() {
    "use strict";
    function peg$subclass(child, parent) {
      function C() {
        this.constructor = child;
      }
      C.prototype = parent.prototype;
      child.prototype = new C();
    }
    function peg$SyntaxError(message, expected, found, location) {
      var self = Error.call(this, message);
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(self, peg$SyntaxError.prototype);
      }
      self.expected = expected;
      self.found = found;
      self.location = location;
      self.name = "SyntaxError";
      return self;
    }
    peg$subclass(peg$SyntaxError, Error);
    function peg$padEnd(str, targetLength, padString) {
      padString = padString || " ";
      if (str.length > targetLength) {
        return str;
      }
      targetLength -= str.length;
      padString += padString.repeat(targetLength);
      return str + padString.slice(0, targetLength);
    }
    peg$SyntaxError.prototype.format = function(sources) {
      var str = "Error: " + this.message;
      if (this.location) {
        var src = null;
        var k;
        for (k = 0; k < sources.length; k++) {
          if (sources[k].source === this.location.source) {
            src = sources[k].text.split(/\r\n|\n|\r/g);
            break;
          }
        }
        var s22 = this.location.start;
        var loc = this.location.source + ":" + s22.line + ":" + s22.column;
        if (src) {
          var e = this.location.end;
          var filler = peg$padEnd("", s22.line.toString().length, " ");
          var line = src[s22.line - 1];
          var last = s22.line === e.line ? e.column : line.length + 1;
          var hatLen = last - s22.column || 1;
          str += "\n --> " + loc + "\n" + filler + " |\n" + s22.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s22.column - 1, " ") + peg$padEnd("", hatLen, "^");
        } else {
          str += "\n at " + loc;
        }
      }
      return str;
    };
    peg$SyntaxError.buildMessage = function(expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        class: function(expectation) {
          var escapedParts = expectation.parts.map(function(part) {
            return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
          });
          return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
        },
        any: function() {
          return "any character";
        },
        end: function() {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        }
      };
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s22) {
        return s22.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function classEscape(s22) {
        return s22.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = expected2.map(describeExpectation);
        var i, j;
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {};
      var peg$source = options.grammarSource;
      var peg$startRuleFunctions = { args_spec_list: peg$parseargs_spec_list };
      var peg$startRuleFunction = peg$parseargs_spec_list;
      var peg$c0 = "+";
      var peg$c1 = "v";
      var peg$c2 = "b";
      var peg$c3 = "!";
      var peg$c4 = "D";
      var peg$c5 = "d";
      var peg$c6 = "s";
      var peg$c7 = "O";
      var peg$c8 = "o";
      var peg$c9 = "e";
      var peg$c10 = "E";
      var peg$c11 = "t";
      var peg$c12 = "R";
      var peg$c13 = "r";
      var peg$c14 = "u";
      var peg$c15 = "m";
      var peg$c16 = "{";
      var peg$c17 = "}";
      var peg$c18 = " ";
      var peg$c19 = "\n";
      var peg$c20 = "\r";
      var peg$r0 = /^[{ ]/;
      var peg$e0 = peg$literalExpectation("+", false);
      var peg$e1 = peg$literalExpectation("v", false);
      var peg$e2 = peg$anyExpectation();
      var peg$e3 = peg$literalExpectation("b", false);
      var peg$e4 = peg$literalExpectation("!", false);
      var peg$e5 = peg$literalExpectation("D", false);
      var peg$e6 = peg$literalExpectation("d", false);
      var peg$e7 = peg$literalExpectation("s", false);
      var peg$e8 = peg$literalExpectation("O", false);
      var peg$e9 = peg$literalExpectation("o", false);
      var peg$e10 = peg$literalExpectation("e", false);
      var peg$e11 = peg$literalExpectation("E", false);
      var peg$e12 = peg$literalExpectation("t", false);
      var peg$e13 = peg$literalExpectation("R", false);
      var peg$e14 = peg$literalExpectation("r", false);
      var peg$e15 = peg$literalExpectation("u", false);
      var peg$e16 = peg$classExpectation(["{", " "], false, false);
      var peg$e17 = peg$literalExpectation("m", false);
      var peg$e18 = peg$literalExpectation("{", false);
      var peg$e19 = peg$literalExpectation("}", false);
      var peg$e20 = peg$literalExpectation(" ", false);
      var peg$e21 = peg$literalExpectation("\n", false);
      var peg$e22 = peg$literalExpectation("\r", false);
      var peg$f0 = function(x) {
        return x;
      };
      var peg$f1 = function(spec) {
        return spec;
      };
      var peg$f2 = function(spec) {
        return spec;
      };
      var peg$f3 = function(openBrace) {
        return createNode("verbatim", { openBrace, closeBrace: openBrace });
      };
      var peg$f4 = function() {
        return createNode("body");
      };
      var peg$f5 = function(leading_bang, spec) {
        return leading_bang ? { ...spec, noLeadingWhitespace: true } : spec;
      };
      var peg$f6 = function(braceSpec, defaultArg) {
        return createNode("optional", { ...braceSpec, defaultArg });
      };
      var peg$f7 = function(braceSpec) {
        return createNode("optional", braceSpec);
      };
      var peg$f8 = function() {
        return createNode("optionalStar");
      };
      var peg$f9 = function(g) {
        return createNode("optional", { defaultArg: g });
      };
      var peg$f10 = function() {
        return createNode("optional");
      };
      var peg$f11 = function(args) {
        return createNode("embellishment", {
          embellishmentTokens: args.content
        });
      };
      var peg$f12 = function(args, g) {
        return createNode("embellishment", {
          embellishmentTokens: args.content,
          defaultArg: g
        });
      };
      var peg$f13 = function(tok) {
        return createNode("optionalToken", { token: tok });
      };
      var peg$f14 = function(braceSpec, defaultArg) {
        return createNode("mandatory", { ...braceSpec, defaultArg });
      };
      var peg$f15 = function(braceSpec) {
        return createNode("mandatory", braceSpec);
      };
      var peg$f16 = function(stopTokens) {
        return createNode("until", { stopTokens });
      };
      var peg$f17 = function(x) {
        return [x];
      };
      var peg$f18 = function(g) {
        return g.content;
      };
      var peg$f19 = function() {
        return createNode("mandatory");
      };
      var peg$f20 = function(openBrace, closeBrace) {
        return { openBrace, closeBrace };
      };
      var peg$f21 = function(content) {
        return { type: "group", content };
      };
      var peg$f22 = function() {
        return "";
      };
      var peg$currPos = 0;
      var peg$savedPos = 0;
      var peg$posDetailsCache = [{ line: 1, column: 1 }];
      var peg$maxFailPos = 0;
      var peg$maxFailExpected = [];
      var peg$silentFails = 0;
      var peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function offset() {
        return peg$savedPos;
      }
      function range() {
        return {
          source: peg$source,
          start: peg$savedPos,
          end: peg$currPos
        };
      }
      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError(
          [peg$otherExpectation(description)],
          input.substring(peg$savedPos, peg$currPos),
          location2
        );
      }
      function error(message, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location2);
      }
      function peg$literalExpectation(text2, ignoreCase) {
        return { type: "literal", text: text2, ignoreCase };
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts, inverted, ignoreCase };
      }
      function peg$anyExpectation() {
        return { type: "any" };
      }
      function peg$endExpectation() {
        return { type: "end" };
      }
      function peg$otherExpectation(description) {
        return { type: "other", description };
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p;
        if (details) {
          return details;
        } else {
          p = pos - 1;
          while (!peg$posDetailsCache[p]) {
            p--;
          }
          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };
          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos);
        var endPosDetails = peg$computePosDetails(endPos);
        return {
          source: peg$source,
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildSimpleError(message, location2) {
        return new peg$SyntaxError(message, null, null, location2);
      }
      function peg$buildStructuredError(expected2, found, location2) {
        return new peg$SyntaxError(
          peg$SyntaxError.buildMessage(expected2, found),
          expected2,
          found,
          location2
        );
      }
      function peg$parseargs_spec_list() {
        var s0, s1, s22, s32, s42;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$currPos;
        s32 = peg$parsewhitespace();
        s42 = peg$parsearg_spec();
        if (s42 !== peg$FAILED) {
          peg$savedPos = s22;
          s22 = peg$f0(s42);
        } else {
          peg$currPos = s22;
          s22 = peg$FAILED;
        }
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$currPos;
          s32 = peg$parsewhitespace();
          s42 = peg$parsearg_spec();
          if (s42 !== peg$FAILED) {
            peg$savedPos = s22;
            s22 = peg$f0(s42);
          } else {
            peg$currPos = s22;
            s22 = peg$FAILED;
          }
        }
        s22 = peg$parsewhitespace();
        peg$savedPos = s0;
        s0 = peg$f1(s1);
        return s0;
      }
      function peg$parsearg_spec() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 43) {
          s1 = peg$c0;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 === peg$FAILED) {
          s1 = null;
        }
        s22 = peg$parseoptional();
        if (s22 === peg$FAILED) {
          s22 = peg$parsemandatory();
          if (s22 === peg$FAILED) {
            s22 = peg$parseverbatim();
            if (s22 === peg$FAILED) {
              s22 = peg$parserequired();
              if (s22 === peg$FAILED) {
                s22 = peg$parsebody();
                if (s22 === peg$FAILED) {
                  s22 = peg$parseuntil();
                }
              }
            }
          }
        }
        if (s22 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f2(s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseverbatim() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 118) {
          s1 = peg$c1;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e1);
          }
        }
        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s22 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f3(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsebody() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 98) {
          s1 = peg$c2;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f4();
        }
        s0 = s1;
        return s0;
      }
      function peg$parseoptional() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 33) {
          s1 = peg$c3;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e4);
          }
        }
        if (s1 === peg$FAILED) {
          s1 = null;
        }
        s22 = peg$parseoptional_star();
        if (s22 === peg$FAILED) {
          s22 = peg$parseoptional_standard();
          if (s22 === peg$FAILED) {
            s22 = peg$parseoptional_delimited();
            if (s22 === peg$FAILED) {
              s22 = peg$parseoptional_embellishment();
              if (s22 === peg$FAILED) {
                s22 = peg$parseoptional_token();
              }
            }
          }
        }
        if (s22 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f5(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseoptional_delimited() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 68) {
          s1 = peg$c4;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e5);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parsebrace_spec();
          s32 = peg$parsebraced_group();
          if (s32 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f6(s22, s32);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 100) {
            s1 = peg$c5;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e6);
            }
          }
          if (s1 !== peg$FAILED) {
            s22 = peg$parsebrace_spec();
            peg$savedPos = s0;
            s0 = peg$f7(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        return s0;
      }
      function peg$parseoptional_star() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 115) {
          s1 = peg$c6;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e7);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f8();
        }
        s0 = s1;
        return s0;
      }
      function peg$parseoptional_standard() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 79) {
          s1 = peg$c7;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e8);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parsebraced_group();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f9(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 111) {
            s1 = peg$c8;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e9);
            }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f10();
          }
          s0 = s1;
        }
        return s0;
      }
      function peg$parseoptional_embellishment() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 101) {
          s1 = peg$c9;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e10);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parsebraced_group();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f11(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 69) {
            s1 = peg$c10;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e11);
            }
          }
          if (s1 !== peg$FAILED) {
            s22 = peg$parsebraced_group();
            if (s22 !== peg$FAILED) {
              s32 = peg$parsebraced_group();
              if (s32 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f12(s22, s32);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        return s0;
      }
      function peg$parseoptional_token() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 116) {
          s1 = peg$c11;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e12);
          }
        }
        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s22 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f13(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parserequired() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 82) {
          s1 = peg$c12;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e13);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parsebrace_spec();
          s32 = peg$parsebraced_group();
          if (s32 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f14(s22, s32);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 114) {
            s1 = peg$c13;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e14);
            }
          }
          if (s1 !== peg$FAILED) {
            s22 = peg$parsebrace_spec();
            peg$savedPos = s0;
            s0 = peg$f15(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        return s0;
      }
      function peg$parseuntil() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 117) {
          s1 = peg$c14;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e15);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parseuntil_stop_token();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f16(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseuntil_stop_token() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        if (peg$r0.test(input.charAt(peg$currPos))) {
          s22 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s22 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e16);
          }
        }
        peg$silentFails--;
        if (s22 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s22 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f17(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsebraced_group();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f18(s1);
          }
          s0 = s1;
        }
        return s0;
      }
      function peg$parsemandatory() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 109) {
          s1 = peg$c15;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e17);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f19();
        }
        s0 = s1;
        return s0;
      }
      function peg$parsebrace_spec() {
        var s0, s1, s22, s32, s42, s5;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$currPos;
        s32 = peg$currPos;
        peg$silentFails++;
        s42 = peg$parsewhitespace_token();
        peg$silentFails--;
        if (s42 === peg$FAILED) {
          s32 = void 0;
        } else {
          peg$currPos = s32;
          s32 = peg$FAILED;
        }
        if (s32 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s42 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s42 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          if (s42 !== peg$FAILED) {
            s32 = [s32, s42];
            s22 = s32;
          } else {
            peg$currPos = s22;
            s22 = peg$FAILED;
          }
        } else {
          peg$currPos = s22;
          s22 = peg$FAILED;
        }
        if (s22 === peg$FAILED) {
          s22 = null;
        }
        s1 = input.substring(s1, peg$currPos);
        s22 = peg$currPos;
        s32 = peg$currPos;
        s42 = peg$currPos;
        peg$silentFails++;
        s5 = peg$parsewhitespace_token();
        peg$silentFails--;
        if (s5 === peg$FAILED) {
          s42 = void 0;
        } else {
          peg$currPos = s42;
          s42 = peg$FAILED;
        }
        if (s42 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          if (s5 !== peg$FAILED) {
            s42 = [s42, s5];
            s32 = s42;
          } else {
            peg$currPos = s32;
            s32 = peg$FAILED;
          }
        } else {
          peg$currPos = s32;
          s32 = peg$FAILED;
        }
        if (s32 === peg$FAILED) {
          s32 = null;
        }
        s22 = input.substring(s22, peg$currPos);
        peg$savedPos = s0;
        s0 = peg$f20(s1, s22);
        return s0;
      }
      function peg$parsebraced_group() {
        var s0, s1, s22, s32, s42, s5, s6, s7;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 123) {
          s1 = peg$c16;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e18);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$currPos;
          s42 = peg$currPos;
          s5 = peg$currPos;
          peg$silentFails++;
          if (input.charCodeAt(peg$currPos) === 125) {
            s6 = peg$c17;
            peg$currPos++;
          } else {
            s6 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e19);
            }
          }
          peg$silentFails--;
          if (s6 === peg$FAILED) {
            s5 = void 0;
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$currPos;
            peg$silentFails++;
            s7 = peg$parsebraced_group();
            peg$silentFails--;
            if (s7 === peg$FAILED) {
              s6 = void 0;
            } else {
              peg$currPos = s6;
              s6 = peg$FAILED;
            }
            if (s6 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s7 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s7 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e2);
                }
              }
              if (s7 !== peg$FAILED) {
                s5 = [s5, s6, s7];
                s42 = s5;
              } else {
                peg$currPos = s42;
                s42 = peg$FAILED;
              }
            } else {
              peg$currPos = s42;
              s42 = peg$FAILED;
            }
          } else {
            peg$currPos = s42;
            s42 = peg$FAILED;
          }
          if (s42 !== peg$FAILED) {
            s32 = input.substring(s32, peg$currPos);
          } else {
            s32 = s42;
          }
          if (s32 === peg$FAILED) {
            s32 = peg$parsebraced_group();
          }
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$currPos;
            s42 = peg$currPos;
            s5 = peg$currPos;
            peg$silentFails++;
            if (input.charCodeAt(peg$currPos) === 125) {
              s6 = peg$c17;
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e19);
              }
            }
            peg$silentFails--;
            if (s6 === peg$FAILED) {
              s5 = void 0;
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$currPos;
              peg$silentFails++;
              s7 = peg$parsebraced_group();
              peg$silentFails--;
              if (s7 === peg$FAILED) {
                s6 = void 0;
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
              if (s6 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                  s7 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e2);
                  }
                }
                if (s7 !== peg$FAILED) {
                  s5 = [s5, s6, s7];
                  s42 = s5;
                } else {
                  peg$currPos = s42;
                  s42 = peg$FAILED;
                }
              } else {
                peg$currPos = s42;
                s42 = peg$FAILED;
              }
            } else {
              peg$currPos = s42;
              s42 = peg$FAILED;
            }
            if (s42 !== peg$FAILED) {
              s32 = input.substring(s32, peg$currPos);
            } else {
              s32 = s42;
            }
            if (s32 === peg$FAILED) {
              s32 = peg$parsebraced_group();
            }
          }
          if (input.charCodeAt(peg$currPos) === 125) {
            s32 = peg$c17;
            peg$currPos++;
          } else {
            s32 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e19);
            }
          }
          if (s32 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f21(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsewhitespace() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsewhitespace_token();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parsewhitespace_token();
        }
        peg$savedPos = s0;
        s1 = peg$f22();
        s0 = s1;
        return s0;
      }
      function peg$parsewhitespace_token() {
        var s0;
        if (input.charCodeAt(peg$currPos) === 32) {
          s0 = peg$c18;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e20);
          }
        }
        if (s0 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 10) {
            s0 = peg$c19;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e21);
            }
          }
          if (s0 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 13) {
              s0 = peg$c20;
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e22);
              }
            }
          }
        }
        return s0;
      }
      const DEFAULT_OPTIONS = {
        optional: { openBrace: "[", closeBrace: "]" },
        mandatory: { openBrace: "{", closeBrace: "}" }
      };
      function createNode(type, options2) {
        const computedOptions = DEFAULT_OPTIONS[type] || {};
        return { type, ...computedOptions, ...options2 };
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(
          peg$maxFailExpected,
          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
      }
    }
    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }()
);
var pgfkeys_default5 = (
  // Generated by Peggy 2.0.1.
  //
  // https://peggyjs.org/
  function() {
    "use strict";
    function peg$subclass(child, parent) {
      function C() {
        this.constructor = child;
      }
      C.prototype = parent.prototype;
      child.prototype = new C();
    }
    function peg$SyntaxError(message, expected, found, location) {
      var self = Error.call(this, message);
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(self, peg$SyntaxError.prototype);
      }
      self.expected = expected;
      self.found = found;
      self.location = location;
      self.name = "SyntaxError";
      return self;
    }
    peg$subclass(peg$SyntaxError, Error);
    function peg$padEnd(str, targetLength, padString) {
      padString = padString || " ";
      if (str.length > targetLength) {
        return str;
      }
      targetLength -= str.length;
      padString += padString.repeat(targetLength);
      return str + padString.slice(0, targetLength);
    }
    peg$SyntaxError.prototype.format = function(sources) {
      var str = "Error: " + this.message;
      if (this.location) {
        var src = null;
        var k;
        for (k = 0; k < sources.length; k++) {
          if (sources[k].source === this.location.source) {
            src = sources[k].text.split(/\r\n|\n|\r/g);
            break;
          }
        }
        var s22 = this.location.start;
        var loc = this.location.source + ":" + s22.line + ":" + s22.column;
        if (src) {
          var e = this.location.end;
          var filler = peg$padEnd("", s22.line.toString().length, " ");
          var line = src[s22.line - 1];
          var last = s22.line === e.line ? e.column : line.length + 1;
          var hatLen = last - s22.column || 1;
          str += "\n --> " + loc + "\n" + filler + " |\n" + s22.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s22.column - 1, " ") + peg$padEnd("", hatLen, "^");
        } else {
          str += "\n at " + loc;
        }
      }
      return str;
    };
    peg$SyntaxError.buildMessage = function(expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        class: function(expectation) {
          var escapedParts = expectation.parts.map(function(part) {
            return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
          });
          return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
        },
        any: function() {
          return "any character";
        },
        end: function() {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        }
      };
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s22) {
        return s22.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function classEscape(s22) {
        return s22.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = expected2.map(describeExpectation);
        var i, j;
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {};
      var peg$source = options.grammarSource;
      var peg$startRuleFunctions = { body: peg$parsebody };
      var peg$startRuleFunction = peg$parsebody;
      var peg$e0 = peg$anyExpectation();
      var peg$f0 = function() {
        return [];
      };
      var peg$f1 = function(rowItems, trailingComment) {
        return {
          itemParts: [],
          ...rowItems,
          trailingComment,
          trailingComma: true
        };
      };
      var peg$f2 = function(rowItems, trailingComment) {
        return { ...rowItems, trailingComment };
      };
      var peg$f3 = function(a, b) {
        return processItem(a, b);
      };
      var peg$f4 = function(b) {
        return processItem(null, b);
      };
      var peg$f5 = function(cell) {
        return { cell };
      };
      var peg$f6 = function() {
        return {};
      };
      var peg$f7 = function(part) {
        return part;
      };
      var peg$f8 = function(x) {
        return x;
      };
      var peg$f9 = function(space, x) {
        return {
          trailingComment: x,
          leadingParbreak: space.parbreak > 0
        };
      };
      var peg$f10 = function(list) {
        return {
          whitespace: list.filter((x) => options.isWhitespace(x)).length,
          parbreak: list.filter((x) => options.isParbreak(x)).length
        };
      };
      var peg$f11 = function() {
        return !options.allowParenGroups;
      };
      var peg$f12 = function(tok) {
        return options.isSameLineComment(tok);
      };
      var peg$f13 = function(tok) {
        return tok;
      };
      var peg$f14 = function(tok) {
        return options.isOwnLineComment(tok);
      };
      var peg$f15 = function(tok) {
        return tok;
      };
      var peg$f16 = function(tok) {
        return options.isWhitespace(tok);
      };
      var peg$f17 = function(tok) {
        return tok;
      };
      var peg$f18 = function(tok) {
        return options.isParbreak(tok);
      };
      var peg$f19 = function(tok) {
        return tok;
      };
      var peg$f20 = function(tok) {
        return options.isComma(tok);
      };
      var peg$f21 = function(tok) {
        return tok;
      };
      var peg$f22 = function(tok) {
        return options.isEquals(tok);
      };
      var peg$f23 = function(tok) {
        return tok;
      };
      var peg$f24 = function(tok) {
        return options.isChar(tok, "(");
      };
      var peg$f25 = function(tok) {
        return tok;
      };
      var peg$f26 = function(tok) {
        return options.isChar(tok, ")");
      };
      var peg$f27 = function(tok) {
        return tok;
      };
      var peg$currPos = 0;
      var peg$savedPos = 0;
      var peg$posDetailsCache = [{ line: 1, column: 1 }];
      var peg$maxFailPos = 0;
      var peg$maxFailExpected = [];
      var peg$silentFails = 0;
      var peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function offset() {
        return peg$savedPos;
      }
      function range() {
        return {
          source: peg$source,
          start: peg$savedPos,
          end: peg$currPos
        };
      }
      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError(
          [peg$otherExpectation(description)],
          input.substring(peg$savedPos, peg$currPos),
          location2
        );
      }
      function error(message, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location2);
      }
      function peg$literalExpectation(text2, ignoreCase) {
        return { type: "literal", text: text2, ignoreCase };
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts, inverted, ignoreCase };
      }
      function peg$anyExpectation() {
        return { type: "any" };
      }
      function peg$endExpectation() {
        return { type: "end" };
      }
      function peg$otherExpectation(description) {
        return { type: "other", description };
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p;
        if (details) {
          return details;
        } else {
          p = pos - 1;
          while (!peg$posDetailsCache[p]) {
            p--;
          }
          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };
          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos);
        var endPosDetails = peg$computePosDetails(endPos);
        return {
          source: peg$source,
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildSimpleError(message, location2) {
        return new peg$SyntaxError(message, null, null, location2);
      }
      function peg$buildStructuredError(expected2, found, location2) {
        return new peg$SyntaxError(
          peg$SyntaxError.buildMessage(expected2, found),
          expected2,
          found,
          location2
        );
      }
      function peg$parsebody() {
        var s0, s1, s22;
        s0 = [];
        s1 = peg$parsecomment_only_line();
        if (s1 === peg$FAILED) {
          s1 = peg$parseitem_with_end();
          if (s1 === peg$FAILED) {
            s1 = peg$parseitem_without_end();
          }
        }
        if (s1 !== peg$FAILED) {
          while (s1 !== peg$FAILED) {
            s0.push(s1);
            s1 = peg$parsecomment_only_line();
            if (s1 === peg$FAILED) {
              s1 = peg$parseitem_with_end();
              if (s1 === peg$FAILED) {
                s1 = peg$parseitem_without_end();
              }
            }
          }
        } else {
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = [];
          s22 = peg$parsewhitespace();
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            s22 = peg$parsewhitespace();
          }
          s22 = peg$parseEOL();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f0();
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        return s0;
      }
      function peg$parseitem_with_end() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8;
        s0 = peg$currPos;
        s1 = peg$parsewhitespace_or_parbreaks();
        s22 = peg$parserow_items();
        if (s22 === peg$FAILED) {
          s22 = null;
        }
        s32 = peg$parsewhitespace_or_parbreaks();
        s42 = peg$parseitem_sep();
        if (s42 !== peg$FAILED) {
          s5 = [];
          s6 = peg$parsewhitespace();
          while (s6 !== peg$FAILED) {
            s5.push(s6);
            s6 = peg$parsewhitespace();
          }
          s6 = peg$parsetrailing_comment();
          if (s6 === peg$FAILED) {
            s6 = null;
          }
          s7 = [];
          s8 = peg$parsewhitespace();
          while (s8 !== peg$FAILED) {
            s7.push(s8);
            s8 = peg$parsewhitespace();
          }
          peg$savedPos = s0;
          s0 = peg$f1(s22, s6);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseitem_without_end() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$parsewhitespace_or_parbreaks();
        s22 = peg$parserow_items();
        if (s22 !== peg$FAILED) {
          s32 = peg$parsetrailing_comment();
          if (s32 === peg$FAILED) {
            s32 = null;
          }
          peg$savedPos = s0;
          s0 = peg$f2(s22, s32);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parserow_items() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$parseitem_part();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$parseseparated_part();
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parseseparated_part();
          }
          peg$savedPos = s0;
          s0 = peg$f3(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = [];
          s22 = peg$parseseparated_part();
          if (s22 !== peg$FAILED) {
            while (s22 !== peg$FAILED) {
              s1.push(s22);
              s22 = peg$parseseparated_part();
            }
          } else {
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f4(s1);
          }
          s0 = s1;
        }
        return s0;
      }
      function peg$parseseparated_part() {
        var s0, s1, s22, s32, s42;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parseparbreak();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parseparbreak();
        }
        s22 = peg$parseequals();
        if (s22 !== peg$FAILED) {
          s32 = [];
          s42 = peg$parseparbreak();
          while (s42 !== peg$FAILED) {
            s32.push(s42);
            s42 = peg$parseparbreak();
          }
          s42 = peg$parseitem_part();
          if (s42 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f5(s42);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = [];
          s22 = peg$parseparbreak();
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            s22 = peg$parseparbreak();
          }
          s22 = peg$parseequals();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f6();
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        return s0;
      }
      function peg$parseitem_part() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8, s9;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsewhitespace();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parsewhitespace();
        }
        s22 = peg$currPos;
        s32 = [];
        s42 = peg$parsenon_whitespace_non_parbreak_token();
        if (s42 === peg$FAILED) {
          s42 = peg$currPos;
          s5 = peg$parsewhitespace();
          if (s5 === peg$FAILED) {
            s5 = peg$parseparbreak();
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$currPos;
            peg$silentFails++;
            s7 = peg$currPos;
            s8 = [];
            s9 = peg$parsewhitespace();
            if (s9 === peg$FAILED) {
              s9 = peg$parseparbreak();
            }
            while (s9 !== peg$FAILED) {
              s8.push(s9);
              s9 = peg$parsewhitespace();
              if (s9 === peg$FAILED) {
                s9 = peg$parseparbreak();
              }
            }
            s9 = peg$parsenon_whitespace_non_parbreak_token();
            if (s9 !== peg$FAILED) {
              s8 = [s8, s9];
              s7 = s8;
            } else {
              peg$currPos = s7;
              s7 = peg$FAILED;
            }
            peg$silentFails--;
            if (s7 !== peg$FAILED) {
              peg$currPos = s6;
              s6 = void 0;
            } else {
              s6 = peg$FAILED;
            }
            if (s6 !== peg$FAILED) {
              s5 = [s5, s6];
              s42 = s5;
            } else {
              peg$currPos = s42;
              s42 = peg$FAILED;
            }
          } else {
            peg$currPos = s42;
            s42 = peg$FAILED;
          }
        }
        if (s42 !== peg$FAILED) {
          while (s42 !== peg$FAILED) {
            s32.push(s42);
            s42 = peg$parsenon_whitespace_non_parbreak_token();
            if (s42 === peg$FAILED) {
              s42 = peg$currPos;
              s5 = peg$parsewhitespace();
              if (s5 === peg$FAILED) {
                s5 = peg$parseparbreak();
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$currPos;
                peg$silentFails++;
                s7 = peg$currPos;
                s8 = [];
                s9 = peg$parsewhitespace();
                if (s9 === peg$FAILED) {
                  s9 = peg$parseparbreak();
                }
                while (s9 !== peg$FAILED) {
                  s8.push(s9);
                  s9 = peg$parsewhitespace();
                  if (s9 === peg$FAILED) {
                    s9 = peg$parseparbreak();
                  }
                }
                s9 = peg$parsenon_whitespace_non_parbreak_token();
                if (s9 !== peg$FAILED) {
                  s8 = [s8, s9];
                  s7 = s8;
                } else {
                  peg$currPos = s7;
                  s7 = peg$FAILED;
                }
                peg$silentFails--;
                if (s7 !== peg$FAILED) {
                  peg$currPos = s6;
                  s6 = void 0;
                } else {
                  s6 = peg$FAILED;
                }
                if (s6 !== peg$FAILED) {
                  s5 = [s5, s6];
                  s42 = s5;
                } else {
                  peg$currPos = s42;
                  s42 = peg$FAILED;
                }
              } else {
                peg$currPos = s42;
                s42 = peg$FAILED;
              }
            }
          }
        } else {
          s32 = peg$FAILED;
        }
        if (s32 !== peg$FAILED) {
          s22 = input.substring(s22, peg$currPos);
        } else {
          s22 = s32;
        }
        if (s22 !== peg$FAILED) {
          s32 = [];
          s42 = peg$parsewhitespace();
          while (s42 !== peg$FAILED) {
            s32.push(s42);
            s42 = peg$parsewhitespace();
          }
          peg$savedPos = s0;
          s0 = peg$f7(s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsetrailing_comment() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsewhitespace();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parsewhitespace();
        }
        s22 = peg$parsesame_line_comment();
        if (s22 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f8(s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecomment_only_line() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parsewhitespace_or_parbreaks();
        s22 = peg$parseown_line_comment();
        if (s22 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f9(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsetoken() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$currPos;
        peg$silentFails++;
        s32 = peg$parsenon_token();
        peg$silentFails--;
        if (s32 === peg$FAILED) {
          s22 = void 0;
        } else {
          peg$currPos = s22;
          s22 = peg$FAILED;
        }
        if (s22 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s32 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s32 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s32 !== peg$FAILED) {
            s22 = [s22, s32];
            s1 = s22;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }
        return s0;
      }
      function peg$parsenon_whitespace_non_parbreak_token() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$currPos;
        peg$silentFails++;
        s32 = peg$parsewhitespace();
        if (s32 === peg$FAILED) {
          s32 = peg$parseparbreak();
        }
        peg$silentFails--;
        if (s32 === peg$FAILED) {
          s22 = void 0;
        } else {
          peg$currPos = s22;
          s22 = peg$FAILED;
        }
        if (s22 !== peg$FAILED) {
          s32 = peg$parseparen_block();
          if (s32 === peg$FAILED) {
            s32 = peg$parsetoken();
          }
          if (s32 !== peg$FAILED) {
            s22 = [s22, s32];
            s1 = s22;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }
        return s0;
      }
      function peg$parsenon_token() {
        var s0;
        s0 = peg$parseitem_sep();
        if (s0 === peg$FAILED) {
          s0 = peg$parseequals();
          if (s0 === peg$FAILED) {
            s0 = peg$parsetrailing_comment();
            if (s0 === peg$FAILED) {
              s0 = peg$parseown_line_comment();
            }
          }
        }
        return s0;
      }
      function peg$parsewhitespace_or_parbreaks() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsewhitespace();
        if (s22 === peg$FAILED) {
          s22 = peg$parseparbreak();
        }
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parsewhitespace();
          if (s22 === peg$FAILED) {
            s22 = peg$parseparbreak();
          }
        }
        peg$savedPos = s0;
        s1 = peg$f10(s1);
        s0 = s1;
        return s0;
      }
      function peg$parseparen_block() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8;
        s0 = peg$currPos;
        peg$savedPos = peg$currPos;
        s1 = peg$f11();
        if (s1) {
          s1 = peg$FAILED;
        } else {
          s1 = void 0;
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$currPos;
          s32 = peg$currPos;
          s42 = peg$parseopen_paren();
          if (s42 !== peg$FAILED) {
            s5 = [];
            s6 = peg$currPos;
            s7 = peg$currPos;
            peg$silentFails++;
            s8 = peg$parseclose_paren();
            peg$silentFails--;
            if (s8 === peg$FAILED) {
              s7 = void 0;
            } else {
              peg$currPos = s7;
              s7 = peg$FAILED;
            }
            if (s7 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s8 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s8 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              if (s8 !== peg$FAILED) {
                s7 = [s7, s8];
                s6 = s7;
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
            } else {
              peg$currPos = s6;
              s6 = peg$FAILED;
            }
            while (s6 !== peg$FAILED) {
              s5.push(s6);
              s6 = peg$currPos;
              s7 = peg$currPos;
              peg$silentFails++;
              s8 = peg$parseclose_paren();
              peg$silentFails--;
              if (s8 === peg$FAILED) {
                s7 = void 0;
              } else {
                peg$currPos = s7;
                s7 = peg$FAILED;
              }
              if (s7 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                  s8 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s8 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e0);
                  }
                }
                if (s8 !== peg$FAILED) {
                  s7 = [s7, s8];
                  s6 = s7;
                } else {
                  peg$currPos = s6;
                  s6 = peg$FAILED;
                }
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
            }
            s6 = peg$parseclose_paren();
            if (s6 !== peg$FAILED) {
              s42 = [s42, s5, s6];
              s32 = s42;
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          } else {
            peg$currPos = s32;
            s32 = peg$FAILED;
          }
          if (s32 !== peg$FAILED) {
            s22 = input.substring(s22, peg$currPos);
          } else {
            s22 = s32;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsesame_line_comment() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f12(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f13(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseown_line_comment() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f14(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f15(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsewhitespace() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f16(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f17(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseparbreak() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f18(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f19(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseitem_sep() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f20(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f21(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseequals() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f22(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f23(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseopen_paren() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f24(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f25(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseclose_paren() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f26(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f27(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseEOL() {
        var s0, s1;
        s0 = peg$currPos;
        peg$silentFails++;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        peg$silentFails--;
        if (s1 === peg$FAILED) {
          s0 = void 0;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function processItem(leadCell, otherCells) {
        const cells = [leadCell || []];
        for (const x of otherCells) {
          cells.push(x.cell || []);
        }
        return { itemParts: cells };
      }
      if (!options.isWhitespace) {
        try {
          Object.assign(options, {
            isChar: (node, char) => node.type === "string" && node.content === char,
            isComma(node) {
              return node.type === "string" && node.content === ",";
            },
            isEquals(node) {
              return node.type === "string" && node.content === "=";
            },
            isParbreak(node) {
              return node.type === "parbreak";
            },
            isWhitespace(node) {
              return node.type === "whitespace";
            },
            isSameLineComment: (node) => node.type === "comment" && node.sameline,
            isOwnLineComment: (node) => node.type === "comment" && !node.sameline,
            isComment: (node) => node.type === "comment",
            allowParenGroups: true
          });
        } catch (e) {
          console.warn("Error when initializing parser", e);
        }
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(
          peg$maxFailExpected,
          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
      }
    }
    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }()
);
var macro_substitutions_default5 = (
  // Generated by Peggy 2.0.1.
  //
  // https://peggyjs.org/
  function() {
    "use strict";
    function peg$subclass(child, parent) {
      function C() {
        this.constructor = child;
      }
      C.prototype = parent.prototype;
      child.prototype = new C();
    }
    function peg$SyntaxError(message, expected, found, location) {
      var self = Error.call(this, message);
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(self, peg$SyntaxError.prototype);
      }
      self.expected = expected;
      self.found = found;
      self.location = location;
      self.name = "SyntaxError";
      return self;
    }
    peg$subclass(peg$SyntaxError, Error);
    function peg$padEnd(str, targetLength, padString) {
      padString = padString || " ";
      if (str.length > targetLength) {
        return str;
      }
      targetLength -= str.length;
      padString += padString.repeat(targetLength);
      return str + padString.slice(0, targetLength);
    }
    peg$SyntaxError.prototype.format = function(sources) {
      var str = "Error: " + this.message;
      if (this.location) {
        var src = null;
        var k;
        for (k = 0; k < sources.length; k++) {
          if (sources[k].source === this.location.source) {
            src = sources[k].text.split(/\r\n|\n|\r/g);
            break;
          }
        }
        var s22 = this.location.start;
        var loc = this.location.source + ":" + s22.line + ":" + s22.column;
        if (src) {
          var e = this.location.end;
          var filler = peg$padEnd("", s22.line.toString().length, " ");
          var line = src[s22.line - 1];
          var last = s22.line === e.line ? e.column : line.length + 1;
          var hatLen = last - s22.column || 1;
          str += "\n --> " + loc + "\n" + filler + " |\n" + s22.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s22.column - 1, " ") + peg$padEnd("", hatLen, "^");
        } else {
          str += "\n at " + loc;
        }
      }
      return str;
    };
    peg$SyntaxError.buildMessage = function(expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        class: function(expectation) {
          var escapedParts = expectation.parts.map(function(part) {
            return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
          });
          return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
        },
        any: function() {
          return "any character";
        },
        end: function() {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        }
      };
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s22) {
        return s22.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function classEscape(s22) {
        return s22.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = expected2.map(describeExpectation);
        var i, j;
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {};
      var peg$source = options.grammarSource;
      var peg$startRuleFunctions = { body: peg$parsebody };
      var peg$startRuleFunction = peg$parsebody;
      var peg$e0 = peg$anyExpectation();
      var peg$f0 = function(e) {
        return [].concat(...e).filter((n) => !!n);
      };
      var peg$f1 = function() {
        return [];
      };
      var peg$f2 = function(tok) {
        return options.isHash(tok);
      };
      var peg$f3 = function(tok) {
        return tok;
      };
      var peg$f4 = function(tok) {
        return options.isNumber(tok);
      };
      var peg$f5 = function(tok) {
        return tok;
      };
      var peg$f6 = function() {
        return { type: "string", content: "#" };
      };
      var peg$f7 = function(num) {
        const split = options.splitNumber(num);
        return [{ type: "hash_number", number: split.number }, split.rest];
      };
      var peg$currPos = 0;
      var peg$savedPos = 0;
      var peg$posDetailsCache = [{ line: 1, column: 1 }];
      var peg$maxFailPos = 0;
      var peg$maxFailExpected = [];
      var peg$silentFails = 0;
      var peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function offset() {
        return peg$savedPos;
      }
      function range() {
        return {
          source: peg$source,
          start: peg$savedPos,
          end: peg$currPos
        };
      }
      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError(
          [peg$otherExpectation(description)],
          input.substring(peg$savedPos, peg$currPos),
          location2
        );
      }
      function error(message, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location2);
      }
      function peg$literalExpectation(text2, ignoreCase) {
        return { type: "literal", text: text2, ignoreCase };
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts, inverted, ignoreCase };
      }
      function peg$anyExpectation() {
        return { type: "any" };
      }
      function peg$endExpectation() {
        return { type: "end" };
      }
      function peg$otherExpectation(description) {
        return { type: "other", description };
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p;
        if (details) {
          return details;
        } else {
          p = pos - 1;
          while (!peg$posDetailsCache[p]) {
            p--;
          }
          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };
          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos);
        var endPosDetails = peg$computePosDetails(endPos);
        return {
          source: peg$source,
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildSimpleError(message, location2) {
        return new peg$SyntaxError(message, null, null, location2);
      }
      function peg$buildStructuredError(expected2, found, location2) {
        return new peg$SyntaxError(
          peg$SyntaxError.buildMessage(expected2, found),
          expected2,
          found,
          location2
        );
      }
      function peg$parsebody() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsedouble_hash();
        if (s22 === peg$FAILED) {
          s22 = peg$parsehash_number();
          if (s22 === peg$FAILED) {
            if (input.length > peg$currPos) {
              s22 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s22 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
          }
        }
        if (s22 !== peg$FAILED) {
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            s22 = peg$parsedouble_hash();
            if (s22 === peg$FAILED) {
              s22 = peg$parsehash_number();
              if (s22 === peg$FAILED) {
                if (input.length > peg$currPos) {
                  s22 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s22 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e0);
                  }
                }
              }
            }
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f0(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseEOL();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f1();
          }
          s0 = s1;
        }
        return s0;
      }
      function peg$parsehash() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f2(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f3(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsenumber() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f4(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f5(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsedouble_hash() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parsehash();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsehash();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f6();
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsehash_number() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parsehash();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsenumber();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f7(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseEOL() {
        var s0, s1;
        s0 = peg$currPos;
        peg$silentFails++;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        peg$silentFails--;
        if (s1 === peg$FAILED) {
          s0 = void 0;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      if (!options.isHash) {
        try {
          Object.assign(options, {
            isHash: (node) => node.type === "string" && node.content === "#",
            isNumber: (node) => node.type === "string" && 0 < +node.content.charAt(0),
            splitNumber: (node) => {
              const number = +node.content.charAt(0);
              if (node.content.length > 1) {
                return {
                  number,
                  rest: {
                    type: "string",
                    content: node.content.slice(1)
                  }
                };
              }
              return { number };
            }
          });
        } catch (e) {
          console.warn("Error when initializing parser", e);
        }
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(
          peg$maxFailExpected,
          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
      }
    }
    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }()
);
var ligatures_default5 = (
  // Generated by Peggy 2.0.1.
  //
  // https://peggyjs.org/
  function() {
    "use strict";
    function peg$subclass(child, parent) {
      function C() {
        this.constructor = child;
      }
      C.prototype = parent.prototype;
      child.prototype = new C();
    }
    function peg$SyntaxError(message, expected, found, location) {
      var self = Error.call(this, message);
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(self, peg$SyntaxError.prototype);
      }
      self.expected = expected;
      self.found = found;
      self.location = location;
      self.name = "SyntaxError";
      return self;
    }
    peg$subclass(peg$SyntaxError, Error);
    function peg$padEnd(str, targetLength, padString) {
      padString = padString || " ";
      if (str.length > targetLength) {
        return str;
      }
      targetLength -= str.length;
      padString += padString.repeat(targetLength);
      return str + padString.slice(0, targetLength);
    }
    peg$SyntaxError.prototype.format = function(sources) {
      var str = "Error: " + this.message;
      if (this.location) {
        var src = null;
        var k;
        for (k = 0; k < sources.length; k++) {
          if (sources[k].source === this.location.source) {
            src = sources[k].text.split(/\r\n|\n|\r/g);
            break;
          }
        }
        var s22 = this.location.start;
        var loc = this.location.source + ":" + s22.line + ":" + s22.column;
        if (src) {
          var e = this.location.end;
          var filler = peg$padEnd("", s22.line.toString().length, " ");
          var line = src[s22.line - 1];
          var last = s22.line === e.line ? e.column : line.length + 1;
          var hatLen = last - s22.column || 1;
          str += "\n --> " + loc + "\n" + filler + " |\n" + s22.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s22.column - 1, " ") + peg$padEnd("", hatLen, "^");
        } else {
          str += "\n at " + loc;
        }
      }
      return str;
    };
    peg$SyntaxError.buildMessage = function(expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        class: function(expectation) {
          var escapedParts = expectation.parts.map(function(part) {
            return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
          });
          return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
        },
        any: function() {
          return "any character";
        },
        end: function() {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        }
      };
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s22) {
        return s22.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function classEscape(s22) {
        return s22.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = expected2.map(describeExpectation);
        var i, j;
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {};
      var peg$source = options.grammarSource;
      var peg$startRuleFunctions = { body: peg$parsebody };
      var peg$startRuleFunction = peg$parsebody;
      var peg$e0 = peg$anyExpectation();
      var peg$f0 = function(e) {
        return [].concat(...e).filter((n) => !!n);
      };
      var peg$f1 = function() {
        return [];
      };
      var peg$f2 = function(toks) {
        return options.isRecognized(toks);
      };
      var peg$f3 = function(toks) {
        return options.isRecognized(toks);
      };
      var peg$f4 = function(tok1, tok2) {
        const split = options.split(tok2);
        return options.isRecognized([tok1, split[0]]);
      };
      var peg$f5 = function(tok1, tok2) {
        const split = options.split(tok2);
        return [options.isRecognized([tok1, split[0]]), split[1]];
      };
      var peg$f6 = function(tok1, tok2) {
        return options.isRecognized([tok1, tok2]);
      };
      var peg$f7 = function(tok1, tok2) {
        return options.isRecognized([tok1, tok2]);
      };
      var peg$f8 = function(toks) {
        return options.isRecognized(toks);
      };
      var peg$f9 = function(toks) {
        return options.isRecognized(toks);
      };
      var peg$f10 = function(tok) {
        return options.isRecognized([tok]);
      };
      var peg$f11 = function(tok) {
        return options.isRecognized([tok]);
      };
      var peg$f12 = function(tok) {
        return options.isMacro(tok);
      };
      var peg$f13 = function(tok) {
        return tok;
      };
      var peg$f14 = function(tok) {
        return options.isWhitespace(tok);
      };
      var peg$f15 = function(tok) {
        return tok;
      };
      var peg$f16 = function(tok) {
        return options.isSplitable(tok);
      };
      var peg$f17 = function(tok) {
        return tok;
      };
      var peg$currPos = 0;
      var peg$savedPos = 0;
      var peg$posDetailsCache = [{ line: 1, column: 1 }];
      var peg$maxFailPos = 0;
      var peg$maxFailExpected = [];
      var peg$silentFails = 0;
      var peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function offset() {
        return peg$savedPos;
      }
      function range() {
        return {
          source: peg$source,
          start: peg$savedPos,
          end: peg$currPos
        };
      }
      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError(
          [peg$otherExpectation(description)],
          input.substring(peg$savedPos, peg$currPos),
          location2
        );
      }
      function error(message, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location2);
      }
      function peg$literalExpectation(text2, ignoreCase) {
        return { type: "literal", text: text2, ignoreCase };
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts, inverted, ignoreCase };
      }
      function peg$anyExpectation() {
        return { type: "any" };
      }
      function peg$endExpectation() {
        return { type: "end" };
      }
      function peg$otherExpectation(description) {
        return { type: "other", description };
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p;
        if (details) {
          return details;
        } else {
          p = pos - 1;
          while (!peg$posDetailsCache[p]) {
            p--;
          }
          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };
          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos);
        var endPosDetails = peg$computePosDetails(endPos);
        return {
          source: peg$source,
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildSimpleError(message, location2) {
        return new peg$SyntaxError(message, null, null, location2);
      }
      function peg$buildStructuredError(expected2, found, location2) {
        return new peg$SyntaxError(
          peg$SyntaxError.buildMessage(expected2, found),
          expected2,
          found,
          location2
        );
      }
      function peg$parsebody() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsetriple_ligature();
        if (s22 === peg$FAILED) {
          s22 = peg$parsedouble_ligature();
          if (s22 === peg$FAILED) {
            s22 = peg$parsemono_ligature();
            if (s22 === peg$FAILED) {
              if (input.length > peg$currPos) {
                s22 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s22 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
            }
          }
        }
        if (s22 !== peg$FAILED) {
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            s22 = peg$parsetriple_ligature();
            if (s22 === peg$FAILED) {
              s22 = peg$parsedouble_ligature();
              if (s22 === peg$FAILED) {
                s22 = peg$parsemono_ligature();
                if (s22 === peg$FAILED) {
                  if (input.length > peg$currPos) {
                    s22 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s22 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e0);
                    }
                  }
                }
              }
            }
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f0(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseEOL();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f1();
          }
          s0 = s1;
        }
        return s0;
      }
      function peg$parsetriple_ligature() {
        var s0, s1, s22, s32, s42;
        s0 = peg$currPos;
        s1 = peg$currPos;
        if (input.length > peg$currPos) {
          s22 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s22 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s22 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s32 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s32 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s32 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s42 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s42 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            if (s42 !== peg$FAILED) {
              s22 = [s22, s32, s42];
              s1 = s22;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f2(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f3(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsedouble_ligature() {
        var s0;
        s0 = peg$parsedouble_macro_ligature();
        if (s0 === peg$FAILED) {
          s0 = peg$parsedouble_macro_ligature_extracted();
          if (s0 === peg$FAILED) {
            s0 = peg$parsedouble_char_ligature();
          }
        }
        return s0;
      }
      function peg$parsedouble_macro_ligature_extracted() {
        var s0, s1, s22, s32, s42;
        s0 = peg$currPos;
        s1 = peg$parsemacro();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$parsewhitespace();
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parsewhitespace();
          }
          s32 = peg$parsesplitable();
          if (s32 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s42 = peg$f4(s1, s32);
            if (s42) {
              s42 = void 0;
            } else {
              s42 = peg$FAILED;
            }
            if (s42 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f5(s1, s32);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsedouble_macro_ligature() {
        var s0, s1, s22, s32, s42;
        s0 = peg$currPos;
        s1 = peg$parsemacro();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$parsewhitespace();
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parsewhitespace();
          }
          if (input.length > peg$currPos) {
            s32 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s32 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s32 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s42 = peg$f6(s1, s32);
            if (s42) {
              s42 = void 0;
            } else {
              s42 = peg$FAILED;
            }
            if (s42 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f7(s1, s32);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsedouble_char_ligature() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$currPos;
        if (input.length > peg$currPos) {
          s22 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s22 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s22 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s32 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s32 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s32 !== peg$FAILED) {
            s22 = [s22, s32];
            s1 = s22;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f8(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f9(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsemono_ligature() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f10(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f11(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsemacro() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f12(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f13(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsewhitespace() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f14(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f15(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsesplitable() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f16(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f17(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseEOL() {
        var s0, s1;
        s0 = peg$currPos;
        peg$silentFails++;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        peg$silentFails--;
        if (s1 === peg$FAILED) {
          s0 = void 0;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      if (!options.isWhitespace) {
        try {
          Object.assign(options, {
            isMacro: (node) => node.type === "macro",
            isWhitespace: (node) => node.type === "whitespace",
            isRecognized: (nodes) => {
              if (nodes.length == 2 && nodes[0].content === "^" && nodes[1].content === "o") {
                return { type: "string", content: "\xF4" };
              }
              return null;
            },
            isSplitable: (node) => node.type === "string" && node.content.length > 1,
            split: (node) => [
              { type: "string", content: node.content.charAt(0) },
              { type: "string", content: node.content.slice(1) }
            ]
          });
        } catch (e) {
          console.warn("Error when initializing parser", e);
        }
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(
          peg$maxFailExpected,
          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
      }
    }
    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }()
);
var xcolor_expressions_default5 = (
  // Generated by Peggy 2.0.1.
  //
  // https://peggyjs.org/
  function() {
    "use strict";
    function peg$subclass(child, parent) {
      function C() {
        this.constructor = child;
      }
      C.prototype = parent.prototype;
      child.prototype = new C();
    }
    function peg$SyntaxError(message, expected, found, location) {
      var self = Error.call(this, message);
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(self, peg$SyntaxError.prototype);
      }
      self.expected = expected;
      self.found = found;
      self.location = location;
      self.name = "SyntaxError";
      return self;
    }
    peg$subclass(peg$SyntaxError, Error);
    function peg$padEnd(str, targetLength, padString) {
      padString = padString || " ";
      if (str.length > targetLength) {
        return str;
      }
      targetLength -= str.length;
      padString += padString.repeat(targetLength);
      return str + padString.slice(0, targetLength);
    }
    peg$SyntaxError.prototype.format = function(sources) {
      var str = "Error: " + this.message;
      if (this.location) {
        var src = null;
        var k;
        for (k = 0; k < sources.length; k++) {
          if (sources[k].source === this.location.source) {
            src = sources[k].text.split(/\r\n|\n|\r/g);
            break;
          }
        }
        var s22 = this.location.start;
        var loc = this.location.source + ":" + s22.line + ":" + s22.column;
        if (src) {
          var e = this.location.end;
          var filler = peg$padEnd("", s22.line.toString().length, " ");
          var line = src[s22.line - 1];
          var last = s22.line === e.line ? e.column : line.length + 1;
          var hatLen = last - s22.column || 1;
          str += "\n --> " + loc + "\n" + filler + " |\n" + s22.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s22.column - 1, " ") + peg$padEnd("", hatLen, "^");
        } else {
          str += "\n at " + loc;
        }
      }
      return str;
    };
    peg$SyntaxError.buildMessage = function(expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        class: function(expectation) {
          var escapedParts = expectation.parts.map(function(part) {
            return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
          });
          return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
        },
        any: function() {
          return "any character";
        },
        end: function() {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        }
      };
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s22) {
        return s22.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function classEscape(s22) {
        return s22.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = expected2.map(describeExpectation);
        var i, j;
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {};
      var peg$source = options.grammarSource;
      var peg$startRuleFunctions = { start: peg$parsestart };
      var peg$startRuleFunction = peg$parsestart;
      var peg$c0 = ";";
      var peg$c1 = ",";
      var peg$c2 = ":";
      var peg$c3 = "/";
      var peg$c4 = ">";
      var peg$c5 = "!";
      var peg$c6 = ".";
      var peg$c7 = "!![";
      var peg$c8 = "]";
      var peg$c9 = "!!";
      var peg$c10 = "+";
      var peg$c11 = "-";
      var peg$r0 = /^[a-zA-Z0-9]/;
      var peg$r1 = /^[0-9]/;
      var peg$r2 = /^[ \t\n\r]/;
      var peg$r3 = /^[0-9a-fA-F]/;
      var peg$e0 = peg$anyExpectation();
      var peg$e1 = peg$literalExpectation(";", false);
      var peg$e2 = peg$literalExpectation(",", false);
      var peg$e3 = peg$otherExpectation("model list");
      var peg$e4 = peg$literalExpectation(":", false);
      var peg$e5 = peg$literalExpectation("/", false);
      var peg$e6 = peg$otherExpectation("model");
      var peg$e7 = peg$otherExpectation("color spec list");
      var peg$e8 = peg$otherExpectation("color spec");
      var peg$e9 = peg$otherExpectation("color");
      var peg$e10 = peg$otherExpectation("function expression");
      var peg$e11 = peg$literalExpectation(">", false);
      var peg$e12 = peg$otherExpectation("function");
      var peg$e13 = peg$otherExpectation("extended expression");
      var peg$e14 = peg$otherExpectation("core model");
      var peg$e15 = peg$otherExpectation("expr");
      var peg$e16 = peg$literalExpectation("!", false);
      var peg$e17 = peg$otherExpectation("mix expr");
      var peg$e18 = peg$otherExpectation("name");
      var peg$e19 = peg$literalExpectation(".", false);
      var peg$e20 = peg$classExpectation([["a", "z"], ["A", "Z"], ["0", "9"]], false, false);
      var peg$e21 = peg$otherExpectation("postfix");
      var peg$e22 = peg$literalExpectation("!![", false);
      var peg$e23 = peg$literalExpectation("]", false);
      var peg$e24 = peg$literalExpectation("!!", false);
      var peg$e25 = peg$otherExpectation("prefix");
      var peg$e26 = peg$otherExpectation("plus");
      var peg$e27 = peg$literalExpectation("+", false);
      var peg$e28 = peg$otherExpectation("minus");
      var peg$e29 = peg$literalExpectation("-", false);
      var peg$e30 = peg$otherExpectation("num");
      var peg$e31 = peg$classExpectation([["0", "9"]], false, false);
      var peg$e32 = peg$otherExpectation("positive float");
      var peg$e33 = peg$otherExpectation("divisor");
      var peg$e34 = peg$otherExpectation("int");
      var peg$e35 = peg$otherExpectation("whitespace");
      var peg$e36 = peg$classExpectation([" ", "	", "\n", "\r"], false, false);
      var peg$e37 = peg$classExpectation([["0", "9"], ["a", "f"], ["A", "F"]], false, false);
      var peg$f0 = function(m) {
        return m;
      };
      var peg$f1 = function(m) {
        return m;
      };
      var peg$f2 = function(m) {
        return m;
      };
      var peg$f3 = function(m) {
        return m;
      };
      var peg$f4 = function(m) {
        return m;
      };
      var peg$f5 = function(a) {
        return { type: "invalid_spec", content: a };
      };
      var peg$f6 = function(f, c) {
        return c;
      };
      var peg$f7 = function(f, r) {
        return { type: "color_set", content: [f].concat(r) };
      };
      var peg$f8 = function(n, s22) {
        return { type: "color_set_item", name: n, spec_list: s22 };
      };
      var peg$f9 = function(c, m) {
        return { type: "model_list", contents: m, core_model: c };
      };
      var peg$f10 = function(m) {
        return { type: "model_list", contents: m, core_model: null };
      };
      var peg$f11 = function(m, a) {
        return a;
      };
      var peg$f12 = function(m, r) {
        return [m].concat(r);
      };
      var peg$f13 = function(s22, a) {
        return a;
      };
      var peg$f14 = function(s22, r) {
        return { type: "spec_list", content: [s22].concat(r) };
      };
      var peg$f15 = function(c) {
        return { type: "hex_spec", content: [c] };
      };
      var peg$f16 = function(c, d) {
        return d;
      };
      var peg$f17 = function(c, d) {
        return d;
      };
      var peg$f18 = function(c, r) {
        return { type: "num_spec", content: r ? [c].concat(r) : [c] };
      };
      var peg$f19 = function(c, fs) {
        return { type: "color", color: c, functions: fs };
      };
      var peg$f20 = function(f, n) {
        return n;
      };
      var peg$f21 = function(f, args) {
        return { type: "function", name: f, args };
      };
      var peg$f22 = function(core, d, e, es) {
        return {
          type: "extended_expr",
          core_model: core,
          div: d,
          expressions: [e].concat(es)
        };
      };
      var peg$f23 = function(core, e, es) {
        return {
          type: "extended_expr",
          core_model: core,
          div: null,
          expressions: [e].concat(es)
        };
      };
      var peg$f24 = function(e, d) {
        return { type: "weighted_expr", color: e, weight: d };
      };
      var peg$f25 = function(e) {
        return e;
      };
      var peg$f26 = function(p, n, e, po) {
        return {
          type: "expr",
          prefix: p,
          name: n,
          mix_expr: e,
          postfix: po
        };
      };
      var peg$f27 = function(p, n) {
        return { type: "complete_mix", mix_percent: p, name: n };
      };
      var peg$f28 = function(p) {
        return { type: "partial_mix", mix_percent: p };
      };
      var peg$f29 = function(c, p) {
        return c.concat(p || []);
      };
      var peg$f30 = function(n) {
        return { type: "postfix", num: n };
      };
      var peg$f31 = function(p) {
        return { type: "postfix", plusses: p };
      };
      var peg$f32 = function(n) {
        return parseInt(n, 10);
      };
      var peg$f33 = function(n) {
        return parseFloat(n);
      };
      var peg$f34 = function(n) {
        return n;
      };
      var peg$f35 = function(n) {
        return -n;
      };
      var peg$f36 = function(m, n) {
        return m ? -n : n;
      };
      var peg$f37 = function(h) {
        return h.toUpperCase();
      };
      var peg$currPos = 0;
      var peg$savedPos = 0;
      var peg$posDetailsCache = [{ line: 1, column: 1 }];
      var peg$maxFailPos = 0;
      var peg$maxFailExpected = [];
      var peg$silentFails = 0;
      var peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function offset() {
        return peg$savedPos;
      }
      function range() {
        return {
          source: peg$source,
          start: peg$savedPos,
          end: peg$currPos
        };
      }
      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError(
          [peg$otherExpectation(description)],
          input.substring(peg$savedPos, peg$currPos),
          location2
        );
      }
      function error(message, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location2);
      }
      function peg$literalExpectation(text2, ignoreCase) {
        return { type: "literal", text: text2, ignoreCase };
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts, inverted, ignoreCase };
      }
      function peg$anyExpectation() {
        return { type: "any" };
      }
      function peg$endExpectation() {
        return { type: "end" };
      }
      function peg$otherExpectation(description) {
        return { type: "other", description };
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p;
        if (details) {
          return details;
        } else {
          p = pos - 1;
          while (!peg$posDetailsCache[p]) {
            p--;
          }
          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };
          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos);
        var endPosDetails = peg$computePosDetails(endPos);
        return {
          source: peg$source,
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildSimpleError(message, location2) {
        return new peg$SyntaxError(message, null, null, location2);
      }
      function peg$buildStructuredError(expected2, found, location2) {
        return new peg$SyntaxError(
          peg$SyntaxError.buildMessage(expected2, found),
          expected2,
          found,
          location2
        );
      }
      function peg$parsestart() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$parsespec();
        if (s1 !== peg$FAILED) {
          s22 = peg$parseEOL();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f0(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsespec_list();
          if (s1 !== peg$FAILED) {
            s22 = peg$parseEOL();
            if (s22 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f1(s1);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsecolor();
            if (s1 !== peg$FAILED) {
              s22 = peg$parseEOL();
              if (s22 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f2(s1);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parsemodel_list();
              if (s1 !== peg$FAILED) {
                s22 = peg$parseEOL();
                if (s22 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s0 = peg$f3(s1);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parsecolor_set_spec();
                if (s1 !== peg$FAILED) {
                  s22 = peg$parseEOL();
                  if (s22 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s0 = peg$f4(s1);
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  s1 = peg$currPos;
                  s22 = [];
                  if (input.length > peg$currPos) {
                    s32 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s32 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e0);
                    }
                  }
                  while (s32 !== peg$FAILED) {
                    s22.push(s32);
                    if (input.length > peg$currPos) {
                      s32 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s32 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e0);
                      }
                    }
                  }
                  s1 = input.substring(s1, peg$currPos);
                  peg$savedPos = s0;
                  s1 = peg$f5(s1);
                  s0 = s1;
                }
              }
            }
          }
        }
        return s0;
      }
      function peg$parsecolor_set_spec() {
        var s0, s1, s22, s32, s42, s5;
        s0 = peg$currPos;
        s1 = peg$parsecolor_set_item();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 59) {
            s42 = peg$c0;
            peg$currPos++;
          } else {
            s42 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e1);
            }
          }
          if (s42 !== peg$FAILED) {
            s5 = peg$parsecolor_set_item();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s32;
              s32 = peg$f6(s1, s5);
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          } else {
            peg$currPos = s32;
            s32 = peg$FAILED;
          }
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 59) {
              s42 = peg$c0;
              peg$currPos++;
            } else {
              s42 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e1);
              }
            }
            if (s42 !== peg$FAILED) {
              s5 = peg$parsecolor_set_item();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s32;
                s32 = peg$f6(s1, s5);
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          }
          peg$savedPos = s0;
          s0 = peg$f7(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecolor_set_item() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$parsename();
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 44) {
            s22 = peg$c1;
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          if (s22 !== peg$FAILED) {
            s32 = peg$parsespec_list();
            if (s32 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f8(s1, s32);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsemodel_list() {
        var s0, s1, s22, s32;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parsecore_model();
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 58) {
            s22 = peg$c2;
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e4);
            }
          }
          if (s22 !== peg$FAILED) {
            s32 = peg$parsemodel_list_tail();
            if (s32 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f9(s1, s32);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsemodel_list_tail();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f10(s1);
          }
          s0 = s1;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        return s0;
      }
      function peg$parsemodel_list_tail() {
        var s0, s1, s22, s32, s42, s5;
        s0 = peg$currPos;
        s1 = peg$parsemodel();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 47) {
            s42 = peg$c3;
            peg$currPos++;
          } else {
            s42 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e5);
            }
          }
          if (s42 !== peg$FAILED) {
            s5 = peg$parsemodel();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s32;
              s32 = peg$f11(s1, s5);
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          } else {
            peg$currPos = s32;
            s32 = peg$FAILED;
          }
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 47) {
              s42 = peg$c3;
              peg$currPos++;
            } else {
              s42 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e5);
              }
            }
            if (s42 !== peg$FAILED) {
              s5 = peg$parsemodel();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s32;
                s32 = peg$f11(s1, s5);
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          }
          peg$savedPos = s0;
          s0 = peg$f12(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsemodel() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parsecore_model();
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e6);
          }
        }
        return s0;
      }
      function peg$parsespec_list() {
        var s0, s1, s22, s32, s42, s5;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parsespec();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 47) {
            s42 = peg$c3;
            peg$currPos++;
          } else {
            s42 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e5);
            }
          }
          if (s42 !== peg$FAILED) {
            s5 = peg$parsespec();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s32;
              s32 = peg$f13(s1, s5);
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          } else {
            peg$currPos = s32;
            s32 = peg$FAILED;
          }
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 47) {
              s42 = peg$c3;
              peg$currPos++;
            } else {
              s42 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e5);
              }
            }
            if (s42 !== peg$FAILED) {
              s5 = peg$parsespec();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s32;
                s32 = peg$f13(s1, s5);
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          }
          peg$savedPos = s0;
          s0 = peg$f14(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e7);
          }
        }
        return s0;
      }
      function peg$parsespec() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$currPos;
        s32 = peg$parsehex();
        if (s32 !== peg$FAILED) {
          s42 = peg$parsehex();
          if (s42 !== peg$FAILED) {
            s5 = peg$parsehex();
            if (s5 !== peg$FAILED) {
              s6 = peg$parsehex();
              if (s6 !== peg$FAILED) {
                s7 = peg$parsehex();
                if (s7 !== peg$FAILED) {
                  s8 = peg$parsehex();
                  if (s8 !== peg$FAILED) {
                    s32 = [s32, s42, s5, s6, s7, s8];
                    s22 = s32;
                  } else {
                    peg$currPos = s22;
                    s22 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s22;
                  s22 = peg$FAILED;
                }
              } else {
                peg$currPos = s22;
                s22 = peg$FAILED;
              }
            } else {
              peg$currPos = s22;
              s22 = peg$FAILED;
            }
          } else {
            peg$currPos = s22;
            s22 = peg$FAILED;
          }
        } else {
          peg$currPos = s22;
          s22 = peg$FAILED;
        }
        if (s22 !== peg$FAILED) {
          s1 = input.substring(s1, peg$currPos);
        } else {
          s1 = s22;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f15(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsedec();
          if (s1 !== peg$FAILED) {
            s22 = [];
            s32 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 44) {
              s42 = peg$c1;
              peg$currPos++;
            } else {
              s42 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e2);
              }
            }
            if (s42 !== peg$FAILED) {
              s5 = peg$parsedec();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s32;
                s32 = peg$f16(s1, s5);
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
            if (s32 !== peg$FAILED) {
              while (s32 !== peg$FAILED) {
                s22.push(s32);
                s32 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 44) {
                  s42 = peg$c1;
                  peg$currPos++;
                } else {
                  s42 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e2);
                  }
                }
                if (s42 !== peg$FAILED) {
                  s5 = peg$parsedec();
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s32;
                    s32 = peg$f16(s1, s5);
                  } else {
                    peg$currPos = s32;
                    s32 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s32;
                  s32 = peg$FAILED;
                }
              }
            } else {
              s22 = peg$FAILED;
            }
            if (s22 === peg$FAILED) {
              s22 = [];
              s32 = peg$currPos;
              s42 = peg$parsesp();
              if (s42 !== peg$FAILED) {
                s5 = peg$parsedec();
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s32;
                  s32 = peg$f17(s1, s5);
                } else {
                  peg$currPos = s32;
                  s32 = peg$FAILED;
                }
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
              if (s32 !== peg$FAILED) {
                while (s32 !== peg$FAILED) {
                  s22.push(s32);
                  s32 = peg$currPos;
                  s42 = peg$parsesp();
                  if (s42 !== peg$FAILED) {
                    s5 = peg$parsedec();
                    if (s5 !== peg$FAILED) {
                      peg$savedPos = s32;
                      s32 = peg$f17(s1, s5);
                    } else {
                      peg$currPos = s32;
                      s32 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s32;
                    s32 = peg$FAILED;
                  }
                }
              } else {
                s22 = peg$FAILED;
              }
            }
            if (s22 === peg$FAILED) {
              s22 = null;
            }
            peg$savedPos = s0;
            s0 = peg$f18(s1, s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e8);
          }
        }
        return s0;
      }
      function peg$parsecolor() {
        var s0, s1, s22, s32;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parsecolor_expr();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$parsefunc_expr();
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parsefunc_expr();
          }
          peg$savedPos = s0;
          s0 = peg$f19(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e9);
          }
        }
        return s0;
      }
      function peg$parsecolor_expr() {
        var s0;
        s0 = peg$parseext_expr();
        if (s0 === peg$FAILED) {
          s0 = peg$parseexpr();
          if (s0 === peg$FAILED) {
            s0 = peg$parsename();
          }
        }
        return s0;
      }
      function peg$parsefunc_expr() {
        var s0, s1, s22, s32, s42, s5, s6;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 62) {
          s1 = peg$c4;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e11);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parsefunction();
          if (s22 !== peg$FAILED) {
            s32 = [];
            s42 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 44) {
              s5 = peg$c1;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e2);
              }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parseint();
              if (s6 !== peg$FAILED) {
                peg$savedPos = s42;
                s42 = peg$f20(s22, s6);
              } else {
                peg$currPos = s42;
                s42 = peg$FAILED;
              }
            } else {
              peg$currPos = s42;
              s42 = peg$FAILED;
            }
            while (s42 !== peg$FAILED) {
              s32.push(s42);
              s42 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 44) {
                s5 = peg$c1;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e2);
                }
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parseint();
                if (s6 !== peg$FAILED) {
                  peg$savedPos = s42;
                  s42 = peg$f20(s22, s6);
                } else {
                  peg$currPos = s42;
                  s42 = peg$FAILED;
                }
              } else {
                peg$currPos = s42;
                s42 = peg$FAILED;
              }
            }
            peg$savedPos = s0;
            s0 = peg$f21(s22, s32);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e10);
          }
        }
        return s0;
      }
      function peg$parsefunction() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parsename();
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e12);
          }
        }
        return s0;
      }
      function peg$parseext_expr() {
        var s0, s1, s22, s32, s42, s5, s6, s7;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parsecore_model();
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 44) {
            s22 = peg$c1;
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          if (s22 !== peg$FAILED) {
            s32 = peg$parsediv();
            if (s32 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 58) {
                s42 = peg$c2;
                peg$currPos++;
              } else {
                s42 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e4);
                }
              }
              if (s42 !== peg$FAILED) {
                s5 = peg$parseweighted_expr();
                if (s5 !== peg$FAILED) {
                  s6 = [];
                  s7 = peg$parseadditional_weighted_expr();
                  while (s7 !== peg$FAILED) {
                    s6.push(s7);
                    s7 = peg$parseadditional_weighted_expr();
                  }
                  peg$savedPos = s0;
                  s0 = peg$f22(s1, s32, s5, s6);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsecore_model();
          if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 58) {
              s22 = peg$c2;
              peg$currPos++;
            } else {
              s22 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e4);
              }
            }
            if (s22 !== peg$FAILED) {
              s32 = peg$parseweighted_expr();
              if (s32 !== peg$FAILED) {
                s42 = [];
                s5 = peg$parseadditional_weighted_expr();
                while (s5 !== peg$FAILED) {
                  s42.push(s5);
                  s5 = peg$parseadditional_weighted_expr();
                }
                peg$savedPos = s0;
                s0 = peg$f23(s1, s32, s42);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e13);
          }
        }
        return s0;
      }
      function peg$parseweighted_expr() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$parseexpr();
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 44) {
            s22 = peg$c1;
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          if (s22 !== peg$FAILED) {
            s32 = peg$parsedec();
            if (s32 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f24(s1, s32);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseadditional_weighted_expr() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 59) {
          s1 = peg$c0;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e1);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parseweighted_expr();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f25(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecore_model() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parsename();
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e14);
          }
        }
        return s0;
      }
      function peg$parseexpr() {
        var s0, s1, s22, s32, s42;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parseprefix();
        s22 = peg$parsename();
        if (s22 !== peg$FAILED) {
          s32 = peg$parsemix_expr();
          s42 = peg$parsepostfix();
          if (s42 === peg$FAILED) {
            s42 = null;
          }
          peg$savedPos = s0;
          s0 = peg$f26(s1, s22, s32, s42);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e15);
          }
        }
        return s0;
      }
      function peg$parsecomplete_mix() {
        var s0, s1, s22, s32, s42;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 33) {
          s1 = peg$c5;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e16);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parsepct();
          if (s22 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 33) {
              s32 = peg$c5;
              peg$currPos++;
            } else {
              s32 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e16);
              }
            }
            if (s32 !== peg$FAILED) {
              s42 = peg$parsename();
              if (s42 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f27(s22, s42);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsepartial_mix() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 33) {
          s1 = peg$c5;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e16);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parsepct();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f28(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsemix_expr() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsecomplete_mix();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parsecomplete_mix();
        }
        s22 = peg$parsepartial_mix();
        if (s22 === peg$FAILED) {
          s22 = null;
        }
        peg$savedPos = s0;
        s0 = peg$f29(s1, s22);
        peg$silentFails--;
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e17);
        }
        return s0;
      }
      function peg$parsename() {
        var s0, s1, s22;
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 46) {
          s0 = peg$c6;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e19);
          }
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = [];
          if (peg$r0.test(input.charAt(peg$currPos))) {
            s22 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e20);
            }
          }
          if (s22 !== peg$FAILED) {
            while (s22 !== peg$FAILED) {
              s1.push(s22);
              if (peg$r0.test(input.charAt(peg$currPos))) {
                s22 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s22 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e20);
                }
              }
            }
          } else {
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            s0 = input.substring(s0, peg$currPos);
          } else {
            s0 = s1;
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e18);
          }
        }
        return s0;
      }
      function peg$parsepostfix() {
        var s0, s1, s22, s32, s42;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 3) === peg$c7) {
          s1 = peg$c7;
          peg$currPos += 3;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e22);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parsenum();
          if (s22 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 93) {
              s32 = peg$c8;
              peg$currPos++;
            } else {
              s32 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e23);
              }
            }
            if (s32 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f30(s22);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c9) {
            s1 = peg$c9;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e24);
            }
          }
          if (s1 !== peg$FAILED) {
            s22 = peg$currPos;
            s32 = [];
            s42 = peg$parseplus();
            if (s42 !== peg$FAILED) {
              while (s42 !== peg$FAILED) {
                s32.push(s42);
                s42 = peg$parseplus();
              }
            } else {
              s32 = peg$FAILED;
            }
            if (s32 !== peg$FAILED) {
              s22 = input.substring(s22, peg$currPos);
            } else {
              s22 = s32;
            }
            if (s22 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f31(s22);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e21);
          }
        }
        return s0;
      }
      function peg$parseprefix() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parseminus();
        if (s0 === peg$FAILED) {
          s0 = null;
        }
        peg$silentFails--;
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e25);
        }
        return s0;
      }
      function peg$parseplus() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        if (input.charCodeAt(peg$currPos) === 43) {
          s22 = peg$c10;
          peg$currPos++;
        } else {
          s22 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e27);
          }
        }
        if (s22 !== peg$FAILED) {
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            if (input.charCodeAt(peg$currPos) === 43) {
              s22 = peg$c10;
              peg$currPos++;
            } else {
              s22 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e27);
              }
            }
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e26);
          }
        }
        return s0;
      }
      function peg$parseminus() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        if (input.charCodeAt(peg$currPos) === 45) {
          s22 = peg$c11;
          peg$currPos++;
        } else {
          s22 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e29);
          }
        }
        if (s22 !== peg$FAILED) {
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            if (input.charCodeAt(peg$currPos) === 45) {
              s22 = peg$c11;
              peg$currPos++;
            } else {
              s22 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e29);
              }
            }
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e28);
          }
        }
        return s0;
      }
      function peg$parsenum() {
        var s0, s1, s22, s32;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = [];
        if (peg$r1.test(input.charAt(peg$currPos))) {
          s32 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s32 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e31);
          }
        }
        if (s32 !== peg$FAILED) {
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            if (peg$r1.test(input.charAt(peg$currPos))) {
              s32 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s32 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e31);
              }
            }
          }
        } else {
          s22 = peg$FAILED;
        }
        if (s22 !== peg$FAILED) {
          s1 = input.substring(s1, peg$currPos);
        } else {
          s1 = s22;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f32(s1);
        }
        s0 = s1;
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e30);
          }
        }
        return s0;
      }
      function peg$parsepct() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8, s9;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$currPos;
        s32 = peg$currPos;
        s42 = [];
        if (peg$r1.test(input.charAt(peg$currPos))) {
          s5 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e31);
          }
        }
        if (s5 !== peg$FAILED) {
          while (s5 !== peg$FAILED) {
            s42.push(s5);
            if (peg$r1.test(input.charAt(peg$currPos))) {
              s5 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e31);
              }
            }
          }
        } else {
          s42 = peg$FAILED;
        }
        if (s42 !== peg$FAILED) {
          s32 = input.substring(s32, peg$currPos);
        } else {
          s32 = s42;
        }
        if (s32 !== peg$FAILED) {
          s42 = peg$currPos;
          s5 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 46) {
            s6 = peg$c6;
            peg$currPos++;
          } else {
            s6 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e19);
            }
          }
          if (s6 !== peg$FAILED) {
            s7 = peg$currPos;
            s8 = [];
            if (peg$r1.test(input.charAt(peg$currPos))) {
              s9 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s9 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e31);
              }
            }
            while (s9 !== peg$FAILED) {
              s8.push(s9);
              if (peg$r1.test(input.charAt(peg$currPos))) {
                s9 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s9 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e31);
                }
              }
            }
            s7 = input.substring(s7, peg$currPos);
            s6 = [s6, s7];
            s5 = s6;
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
          if (s5 === peg$FAILED) {
            s5 = null;
          }
          s42 = input.substring(s42, peg$currPos);
          s32 = [s32, s42];
          s22 = s32;
        } else {
          peg$currPos = s22;
          s22 = peg$FAILED;
        }
        if (s22 !== peg$FAILED) {
          s1 = input.substring(s1, peg$currPos);
        } else {
          s1 = s22;
        }
        if (s1 === peg$FAILED) {
          s1 = peg$currPos;
          s22 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 46) {
            s32 = peg$c6;
            peg$currPos++;
          } else {
            s32 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e19);
            }
          }
          if (s32 !== peg$FAILED) {
            s42 = peg$currPos;
            s5 = [];
            if (peg$r1.test(input.charAt(peg$currPos))) {
              s6 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e31);
              }
            }
            if (s6 !== peg$FAILED) {
              while (s6 !== peg$FAILED) {
                s5.push(s6);
                if (peg$r1.test(input.charAt(peg$currPos))) {
                  s6 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e31);
                  }
                }
              }
            } else {
              s5 = peg$FAILED;
            }
            if (s5 !== peg$FAILED) {
              s42 = input.substring(s42, peg$currPos);
            } else {
              s42 = s5;
            }
            if (s42 !== peg$FAILED) {
              s32 = [s32, s42];
              s22 = s32;
            } else {
              peg$currPos = s22;
              s22 = peg$FAILED;
            }
          } else {
            peg$currPos = s22;
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = input.substring(s1, peg$currPos);
          } else {
            s1 = s22;
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f33(s1);
        }
        s0 = s1;
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e32);
          }
        }
        return s0;
      }
      function peg$parsediv() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parsepct();
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e33);
          }
        }
        return s0;
      }
      function peg$parsedec() {
        var s0, s1, s22;
        s0 = peg$parsepct();
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 43) {
            s1 = peg$c10;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e27);
            }
          }
          if (s1 !== peg$FAILED) {
            s22 = peg$parsepct();
            if (s22 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f34(s22);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 45) {
              s1 = peg$c11;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e29);
              }
            }
            if (s1 !== peg$FAILED) {
              s22 = peg$parsepct();
              if (s22 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f35(s22);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
        }
        return s0;
      }
      function peg$parseint() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parseminus();
        if (s1 === peg$FAILED) {
          s1 = null;
        }
        s22 = peg$parsenum();
        if (s22 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f36(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e34);
          }
        }
        return s0;
      }
      function peg$parse_() {
        var s0, s1;
        peg$silentFails++;
        s0 = [];
        if (peg$r2.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e36);
          }
        }
        while (s1 !== peg$FAILED) {
          s0.push(s1);
          if (peg$r2.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e36);
            }
          }
        }
        peg$silentFails--;
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e35);
        }
        return s0;
      }
      function peg$parsesp() {
        var s0, s1;
        s0 = [];
        if (peg$r2.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e36);
          }
        }
        if (s1 !== peg$FAILED) {
          while (s1 !== peg$FAILED) {
            s0.push(s1);
            if (peg$r2.test(input.charAt(peg$currPos))) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e36);
              }
            }
          }
        } else {
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsehex() {
        var s0, s1;
        s0 = peg$currPos;
        if (peg$r3.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e37);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f37(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parseEOL() {
        var s0, s1;
        s0 = peg$currPos;
        peg$silentFails++;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        peg$silentFails--;
        if (s1 === peg$FAILED) {
          s0 = void 0;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(
          peg$maxFailExpected,
          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
      }
    }
    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }()
);
var tabular_spec_default5 = (
  // Generated by Peggy 2.0.1.
  //
  // https://peggyjs.org/
  function() {
    "use strict";
    function peg$subclass(child, parent) {
      function C() {
        this.constructor = child;
      }
      C.prototype = parent.prototype;
      child.prototype = new C();
    }
    function peg$SyntaxError(message, expected, found, location) {
      var self = Error.call(this, message);
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(self, peg$SyntaxError.prototype);
      }
      self.expected = expected;
      self.found = found;
      self.location = location;
      self.name = "SyntaxError";
      return self;
    }
    peg$subclass(peg$SyntaxError, Error);
    function peg$padEnd(str, targetLength, padString) {
      padString = padString || " ";
      if (str.length > targetLength) {
        return str;
      }
      targetLength -= str.length;
      padString += padString.repeat(targetLength);
      return str + padString.slice(0, targetLength);
    }
    peg$SyntaxError.prototype.format = function(sources) {
      var str = "Error: " + this.message;
      if (this.location) {
        var src = null;
        var k;
        for (k = 0; k < sources.length; k++) {
          if (sources[k].source === this.location.source) {
            src = sources[k].text.split(/\r\n|\n|\r/g);
            break;
          }
        }
        var s22 = this.location.start;
        var loc = this.location.source + ":" + s22.line + ":" + s22.column;
        if (src) {
          var e = this.location.end;
          var filler = peg$padEnd("", s22.line.toString().length, " ");
          var line = src[s22.line - 1];
          var last = s22.line === e.line ? e.column : line.length + 1;
          var hatLen = last - s22.column || 1;
          str += "\n --> " + loc + "\n" + filler + " |\n" + s22.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s22.column - 1, " ") + peg$padEnd("", hatLen, "^");
        } else {
          str += "\n at " + loc;
        }
      }
      return str;
    };
    peg$SyntaxError.buildMessage = function(expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        class: function(expectation) {
          var escapedParts = expectation.parts.map(function(part) {
            return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
          });
          return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
        },
        any: function() {
          return "any character";
        },
        end: function() {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        }
      };
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s22) {
        return s22.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function classEscape(s22) {
        return s22.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = expected2.map(describeExpectation);
        var i, j;
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {};
      var peg$source = options.grammarSource;
      var peg$startRuleFunctions = { body: peg$parsebody };
      var peg$startRuleFunction = peg$parsebody;
      var peg$e0 = peg$otherExpectation("decl_start");
      var peg$e1 = peg$otherExpectation("decl_end");
      var peg$e2 = peg$otherExpectation("vert");
      var peg$e3 = peg$anyExpectation();
      var peg$e4 = peg$otherExpectation("l");
      var peg$e5 = peg$otherExpectation("r");
      var peg$e6 = peg$otherExpectation("c");
      var peg$e7 = peg$otherExpectation("p");
      var peg$e8 = peg$otherExpectation("m");
      var peg$e9 = peg$otherExpectation("b");
      var peg$e10 = peg$otherExpectation("w");
      var peg$e11 = peg$otherExpectation("W");
      var peg$e12 = peg$otherExpectation("X");
      var peg$e13 = peg$otherExpectation("!");
      var peg$e14 = peg$otherExpectation("@");
      var peg$e15 = peg$otherExpectation("<");
      var peg$e16 = peg$otherExpectation(">");
      var peg$e17 = peg$otherExpectation("group");
      var peg$e18 = peg$otherExpectation("whitespace");
      var peg$f0 = function(c) {
        return c;
      };
      var peg$f1 = function(cols) {
        return cols;
      };
      var peg$f2 = function() {
        return [];
      };
      var peg$f3 = function(divs1, start, a, end, divs2) {
        return {
          type: "column",
          pre_dividers: divs1,
          post_dividers: divs2,
          before_start_code: start,
          before_end_code: end,
          alignment: a
        };
      };
      var peg$f4 = function() {
        return {
          type: "vert_divider"
        };
      };
      var peg$f5 = function(b, g) {
        return {
          type: "bang_divider",
          content: g[0].content
        };
      };
      var peg$f6 = function(g) {
        return {
          type: "at_divider",
          content: g[0].content
        };
      };
      var peg$f7 = function(div) {
        return div;
      };
      var peg$f8 = function(g) {
        return { type: "decl_code", code: g[0].content };
      };
      var peg$f9 = function(g) {
        return { type: "decl_code", code: g[0].content };
      };
      var peg$f10 = function() {
        return { type: "alignment", alignment: "left" };
      };
      var peg$f11 = function() {
        return { type: "alignment", alignment: "center" };
      };
      var peg$f12 = function() {
        return { type: "alignment", alignment: "right" };
      };
      var peg$f13 = function() {
        return { type: "alignment", alignment: "X" };
      };
      var peg$f14 = function() {
        return "top";
      };
      var peg$f15 = function() {
        return "default";
      };
      var peg$f16 = function() {
        return "bottom";
      };
      var peg$f17 = function(a, g) {
        return {
          type: "alignment",
          alignment: "parbox",
          baseline: a,
          size: g[0].content
        };
      };
      var peg$f18 = function(g1, g2) {
        return {
          type: "alignment",
          alignment: "parbox",
          baseline: g1[0].content,
          size: g2[0].content
        };
      };
      var peg$f19 = function(tok) {
        return options.matchChar(tok, "|");
      };
      var peg$f20 = function(tok) {
        return options.matchChar(tok, "l");
      };
      var peg$f21 = function(tok) {
        return options.matchChar(tok, "r");
      };
      var peg$f22 = function(tok) {
        return options.matchChar(tok, "c");
      };
      var peg$f23 = function(tok) {
        return options.matchChar(tok, "p");
      };
      var peg$f24 = function(tok) {
        return options.matchChar(tok, "m");
      };
      var peg$f25 = function(tok) {
        return options.matchChar(tok, "b");
      };
      var peg$f26 = function(tok) {
        return options.matchChar(tok, "w");
      };
      var peg$f27 = function(tok) {
        return options.matchChar(tok, "W");
      };
      var peg$f28 = function(tok) {
        return options.matchChar(tok, "X");
      };
      var peg$f29 = function(tok) {
        return options.matchChar(tok, "!");
      };
      var peg$f30 = function(tok) {
        return options.matchChar(tok, "@");
      };
      var peg$f31 = function(tok) {
        return options.matchChar(tok, "<");
      };
      var peg$f32 = function(tok) {
        return options.matchChar(tok, ">");
      };
      var peg$f33 = function(tok) {
        return options.isGroup(tok);
      };
      var peg$f34 = function(tok) {
        return options.isWhitespace(tok);
      };
      var peg$currPos = 0;
      var peg$savedPos = 0;
      var peg$posDetailsCache = [{ line: 1, column: 1 }];
      var peg$maxFailPos = 0;
      var peg$maxFailExpected = [];
      var peg$silentFails = 0;
      var peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function offset() {
        return peg$savedPos;
      }
      function range() {
        return {
          source: peg$source,
          start: peg$savedPos,
          end: peg$currPos
        };
      }
      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError(
          [peg$otherExpectation(description)],
          input.substring(peg$savedPos, peg$currPos),
          location2
        );
      }
      function error(message, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location2);
      }
      function peg$literalExpectation(text2, ignoreCase) {
        return { type: "literal", text: text2, ignoreCase };
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts, inverted, ignoreCase };
      }
      function peg$anyExpectation() {
        return { type: "any" };
      }
      function peg$endExpectation() {
        return { type: "end" };
      }
      function peg$otherExpectation(description) {
        return { type: "other", description };
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p;
        if (details) {
          return details;
        } else {
          p = pos - 1;
          while (!peg$posDetailsCache[p]) {
            p--;
          }
          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };
          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos);
        var endPosDetails = peg$computePosDetails(endPos);
        return {
          source: peg$source,
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildSimpleError(message, location2) {
        return new peg$SyntaxError(message, null, null, location2);
      }
      function peg$buildStructuredError(expected2, found, location2) {
        return new peg$SyntaxError(
          peg$SyntaxError.buildMessage(expected2, found),
          expected2,
          found,
          location2
        );
      }
      function peg$parsebody() {
        var s0, s1, s22, s32, s42, s5;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$currPos;
        s32 = peg$parsecolumn();
        if (s32 !== peg$FAILED) {
          s42 = [];
          s5 = peg$parse_();
          while (s5 !== peg$FAILED) {
            s42.push(s5);
            s5 = peg$parse_();
          }
          peg$savedPos = s22;
          s22 = peg$f0(s32);
        } else {
          peg$currPos = s22;
          s22 = peg$FAILED;
        }
        if (s22 !== peg$FAILED) {
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            s22 = peg$currPos;
            s32 = peg$parsecolumn();
            if (s32 !== peg$FAILED) {
              s42 = [];
              s5 = peg$parse_();
              while (s5 !== peg$FAILED) {
                s42.push(s5);
                s5 = peg$parse_();
              }
              peg$savedPos = s22;
              s22 = peg$f0(s32);
            } else {
              peg$currPos = s22;
              s22 = peg$FAILED;
            }
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f1(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseEOL();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f2();
          }
          s0 = s1;
        }
        return s0;
      }
      function peg$parsecolumn() {
        var s0, s1, s22, s32, s42, s5, s6;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsecolumn_divider();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parsecolumn_divider();
        }
        s22 = peg$parsedecl_start();
        if (s22 === peg$FAILED) {
          s22 = null;
        }
        s32 = peg$parsealignment();
        if (s32 !== peg$FAILED) {
          s42 = peg$parsedecl_end();
          if (s42 === peg$FAILED) {
            s42 = null;
          }
          s5 = [];
          s6 = peg$parsecolumn_divider();
          while (s6 !== peg$FAILED) {
            s5.push(s6);
            s6 = peg$parsecolumn_divider();
          }
          peg$savedPos = s0;
          s0 = peg$f3(s1, s22, s32, s42, s5);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecolumn_divider() {
        var s0, s1, s22, s32, s42;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parse_();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parse_();
        }
        s22 = peg$currPos;
        s32 = peg$parsevert();
        if (s32 !== peg$FAILED) {
          peg$savedPos = s22;
          s32 = peg$f4();
        }
        s22 = s32;
        if (s22 === peg$FAILED) {
          s22 = peg$currPos;
          s32 = peg$parsebang();
          if (s32 !== peg$FAILED) {
            s42 = peg$parsegroup();
            if (s42 !== peg$FAILED) {
              peg$savedPos = s22;
              s22 = peg$f5(s32, s42);
            } else {
              peg$currPos = s22;
              s22 = peg$FAILED;
            }
          } else {
            peg$currPos = s22;
            s22 = peg$FAILED;
          }
          if (s22 === peg$FAILED) {
            s22 = peg$currPos;
            s32 = peg$parseat();
            if (s32 !== peg$FAILED) {
              s42 = peg$parsegroup();
              if (s42 !== peg$FAILED) {
                peg$savedPos = s22;
                s22 = peg$f6(s42);
              } else {
                peg$currPos = s22;
                s22 = peg$FAILED;
              }
            } else {
              peg$currPos = s22;
              s22 = peg$FAILED;
            }
          }
        }
        if (s22 !== peg$FAILED) {
          s32 = [];
          s42 = peg$parse_();
          while (s42 !== peg$FAILED) {
            s32.push(s42);
            s42 = peg$parse_();
          }
          peg$savedPos = s0;
          s0 = peg$f7(s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsedecl_start() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parsegreater();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsegroup();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f8(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        return s0;
      }
      function peg$parsedecl_end() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parseless();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsegroup();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f9(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e1);
          }
        }
        return s0;
      }
      function peg$parsealignment() {
        var s0, s1, s22, s32, s42, s5;
        s0 = peg$currPos;
        s1 = peg$parsel();
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f10();
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsec();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f11();
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parser();
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$f12();
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parseX();
              if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$f13();
              }
              s0 = s1;
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$currPos;
                s22 = peg$parsep();
                if (s22 !== peg$FAILED) {
                  peg$savedPos = s1;
                  s22 = peg$f14();
                }
                s1 = s22;
                if (s1 === peg$FAILED) {
                  s1 = peg$currPos;
                  s22 = peg$parsem();
                  if (s22 !== peg$FAILED) {
                    peg$savedPos = s1;
                    s22 = peg$f15();
                  }
                  s1 = s22;
                  if (s1 === peg$FAILED) {
                    s1 = peg$currPos;
                    s22 = peg$parseb();
                    if (s22 !== peg$FAILED) {
                      peg$savedPos = s1;
                      s22 = peg$f16();
                    }
                    s1 = s22;
                  }
                }
                if (s1 !== peg$FAILED) {
                  s22 = [];
                  s32 = peg$parse_();
                  while (s32 !== peg$FAILED) {
                    s22.push(s32);
                    s32 = peg$parse_();
                  }
                  s32 = peg$parsegroup();
                  if (s32 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s0 = peg$f17(s1, s32);
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  s1 = peg$parsew();
                  if (s1 === peg$FAILED) {
                    s1 = peg$parseW();
                  }
                  if (s1 !== peg$FAILED) {
                    s22 = [];
                    s32 = peg$parse_();
                    while (s32 !== peg$FAILED) {
                      s22.push(s32);
                      s32 = peg$parse_();
                    }
                    s32 = peg$parsegroup();
                    if (s32 !== peg$FAILED) {
                      s42 = [];
                      s5 = peg$parse_();
                      while (s5 !== peg$FAILED) {
                        s42.push(s5);
                        s5 = peg$parse_();
                      }
                      s5 = peg$parsegroup();
                      if (s5 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s0 = peg$f18(s32, s5);
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                }
              }
            }
          }
        }
        return s0;
      }
      function peg$parsevert() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f19(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        return s0;
      }
      function peg$parsel() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f20(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e4);
          }
        }
        return s0;
      }
      function peg$parser() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f21(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e5);
          }
        }
        return s0;
      }
      function peg$parsec() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f22(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e6);
          }
        }
        return s0;
      }
      function peg$parsep() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f23(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e7);
          }
        }
        return s0;
      }
      function peg$parsem() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f24(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e8);
          }
        }
        return s0;
      }
      function peg$parseb() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f25(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e9);
          }
        }
        return s0;
      }
      function peg$parsew() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f26(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e10);
          }
        }
        return s0;
      }
      function peg$parseW() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f27(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e11);
          }
        }
        return s0;
      }
      function peg$parseX() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f28(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e12);
          }
        }
        return s0;
      }
      function peg$parsebang() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f29(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e13);
          }
        }
        return s0;
      }
      function peg$parseat() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f30(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e14);
          }
        }
        return s0;
      }
      function peg$parseless() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f31(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e15);
          }
        }
        return s0;
      }
      function peg$parsegreater() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f32(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e16);
          }
        }
        return s0;
      }
      function peg$parsegroup() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f33(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e17);
          }
        }
        return s0;
      }
      function peg$parse_() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f34(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e18);
          }
        }
        return s0;
      }
      function peg$parseEOL() {
        var s0, s1;
        s0 = peg$currPos;
        peg$silentFails++;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        peg$silentFails--;
        if (s1 === peg$FAILED) {
          s0 = void 0;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      if (!options.isHash) {
        try {
          Object.assign(options, {
            matchChar: (node, char) => node.type === "string" && node.content === char,
            isGroup: (node) => node.type === "group",
            isWhitespace: (node) => node.type === "whitespace"
          });
        } catch (e) {
          console.warn("Error when initializing parser", e);
        }
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(
          peg$maxFailExpected,
          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
      }
    }
    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }()
);
var systeme_environment_default5 = (
  // Generated by Peggy 2.0.1.
  //
  // https://peggyjs.org/
  function() {
    "use strict";
    function peg$subclass(child, parent) {
      function C() {
        this.constructor = child;
      }
      C.prototype = parent.prototype;
      child.prototype = new C();
    }
    function peg$SyntaxError(message, expected, found, location) {
      var self = Error.call(this, message);
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(self, peg$SyntaxError.prototype);
      }
      self.expected = expected;
      self.found = found;
      self.location = location;
      self.name = "SyntaxError";
      return self;
    }
    peg$subclass(peg$SyntaxError, Error);
    function peg$padEnd(str, targetLength, padString) {
      padString = padString || " ";
      if (str.length > targetLength) {
        return str;
      }
      targetLength -= str.length;
      padString += padString.repeat(targetLength);
      return str + padString.slice(0, targetLength);
    }
    peg$SyntaxError.prototype.format = function(sources) {
      var str = "Error: " + this.message;
      if (this.location) {
        var src = null;
        var k;
        for (k = 0; k < sources.length; k++) {
          if (sources[k].source === this.location.source) {
            src = sources[k].text.split(/\r\n|\n|\r/g);
            break;
          }
        }
        var s22 = this.location.start;
        var loc = this.location.source + ":" + s22.line + ":" + s22.column;
        if (src) {
          var e = this.location.end;
          var filler = peg$padEnd("", s22.line.toString().length, " ");
          var line = src[s22.line - 1];
          var last = s22.line === e.line ? e.column : line.length + 1;
          var hatLen = last - s22.column || 1;
          str += "\n --> " + loc + "\n" + filler + " |\n" + s22.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s22.column - 1, " ") + peg$padEnd("", hatLen, "^");
        } else {
          str += "\n at " + loc;
        }
      }
      return str;
    };
    peg$SyntaxError.buildMessage = function(expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        class: function(expectation) {
          var escapedParts = expectation.parts.map(function(part) {
            return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
          });
          return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
        },
        any: function() {
          return "any character";
        },
        end: function() {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        }
      };
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s22) {
        return s22.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function classEscape(s22) {
        return s22.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = expected2.map(describeExpectation);
        var i, j;
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {};
      var peg$source = options.grammarSource;
      var peg$startRuleFunctions = { body: peg$parsebody };
      var peg$startRuleFunction = peg$parsebody;
      var peg$e0 = peg$otherExpectation("partial item");
      var peg$e1 = peg$otherExpectation("item");
      var peg$e2 = peg$anyExpectation();
      var peg$e3 = peg$otherExpectation("equation");
      var peg$e4 = peg$otherExpectation("trailing comment");
      var peg$e5 = peg$otherExpectation("comment only line");
      var peg$e6 = peg$otherExpectation("non-var token");
      var peg$e7 = peg$otherExpectation("token");
      var peg$e8 = peg$otherExpectation("same line comment");
      var peg$e9 = peg$otherExpectation("own line comment");
      var peg$e10 = peg$otherExpectation(",");
      var peg$e11 = peg$otherExpectation("@");
      var peg$e12 = peg$otherExpectation("variable token");
      var peg$e13 = peg$otherExpectation("+/-");
      var peg$e14 = peg$otherExpectation("=");
      var peg$f0 = function(a, b) {
        return a.concat(b ? b : []);
      };
      var peg$f1 = function() {
        return [];
      };
      var peg$f2 = function(a, b, c) {
        return a.concat(b, c);
      };
      var peg$f3 = function(op, a, b, c) {
        return { type: "item", op, variable: b, content: a.concat(b, c) };
      };
      var peg$f4 = function(op, a) {
        return { type: "item", op, variable: null, content: a };
      };
      var peg$f5 = function(line, sep, comment223) {
        return { ...line, sep: [].concat(sep), trailingComment: comment223 };
      };
      var peg$f6 = function(line, comment223) {
        return { ...line, trailingComment: comment223 };
      };
      var peg$f7 = function(eq, ann) {
        return {
          type: "line",
          equation: eq,
          annotation: ann,
          sep: null
        };
      };
      var peg$f8 = function(at, ann) {
        return at ? { type: "annotation", marker: at, content: ann } : null;
      };
      var peg$f9 = function(left, eq, right) {
        return { type: "equation", left, right, equals: eq };
      };
      var peg$f10 = function(x) {
        return x;
      };
      var peg$f11 = function(x) {
        return {
          type: "line",
          trailingComment: x
        };
      };
      var peg$f12 = function(v, s22) {
        return [v].concat(s22 ? s22 : []);
      };
      var peg$f13 = function(t) {
        return t;
      };
      var peg$f14 = function(x) {
        return x;
      };
      var peg$f15 = function(x) {
        return x;
      };
      var peg$f16 = function(tok) {
        return options.isSameLineComment(tok);
      };
      var peg$f17 = function(tok) {
        return tok;
      };
      var peg$f18 = function(tok) {
        return options.isOwnLineComment(tok);
      };
      var peg$f19 = function(tok) {
        return tok;
      };
      var peg$f20 = function(tok) {
        return options.isWhitespace(tok);
      };
      var peg$f21 = function(tok) {
        return tok;
      };
      var peg$f22 = function(tok) {
        return options.isSep(tok);
      };
      var peg$f23 = function(tok) {
        return tok;
      };
      var peg$f24 = function(tok) {
        return options.isAt(tok);
      };
      var peg$f25 = function(tok) {
        return tok;
      };
      var peg$f26 = function(tok) {
        return options.isVar(tok);
      };
      var peg$f27 = function(tok) {
        return tok;
      };
      var peg$f28 = function(tok) {
        return options.isOperation(tok);
      };
      var peg$f29 = function(tok) {
        return tok;
      };
      var peg$f30 = function(tok) {
        return options.isEquals(tok);
      };
      var peg$f31 = function(tok) {
        return tok;
      };
      var peg$f32 = function(tok) {
        return options.isSubscript(tok);
      };
      var peg$f33 = function(tok) {
        return tok;
      };
      var peg$currPos = 0;
      var peg$savedPos = 0;
      var peg$posDetailsCache = [{ line: 1, column: 1 }];
      var peg$maxFailPos = 0;
      var peg$maxFailExpected = [];
      var peg$silentFails = 0;
      var peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function offset() {
        return peg$savedPos;
      }
      function range() {
        return {
          source: peg$source,
          start: peg$savedPos,
          end: peg$currPos
        };
      }
      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError(
          [peg$otherExpectation(description)],
          input.substring(peg$savedPos, peg$currPos),
          location2
        );
      }
      function error(message, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location2);
      }
      function peg$literalExpectation(text2, ignoreCase) {
        return { type: "literal", text: text2, ignoreCase };
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts, inverted, ignoreCase };
      }
      function peg$anyExpectation() {
        return { type: "any" };
      }
      function peg$endExpectation() {
        return { type: "end" };
      }
      function peg$otherExpectation(description) {
        return { type: "other", description };
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p;
        if (details) {
          return details;
        } else {
          p = pos - 1;
          while (!peg$posDetailsCache[p]) {
            p--;
          }
          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };
          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos);
        var endPosDetails = peg$computePosDetails(endPos);
        return {
          source: peg$source,
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildSimpleError(message, location2) {
        return new peg$SyntaxError(message, null, null, location2);
      }
      function peg$buildStructuredError(expected2, found, location2) {
        return new peg$SyntaxError(
          peg$SyntaxError.buildMessage(expected2, found),
          expected2,
          found,
          location2
        );
      }
      function peg$parsebody() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsecomment_only_line();
        if (s22 === peg$FAILED) {
          s22 = peg$parseline_with_sep();
          if (s22 === peg$FAILED) {
            s22 = peg$parsepartial_line_with_comment();
          }
        }
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parsecomment_only_line();
          if (s22 === peg$FAILED) {
            s22 = peg$parseline_with_sep();
            if (s22 === peg$FAILED) {
              s22 = peg$parsepartial_line_with_comment();
            }
          }
        }
        s22 = peg$parseline_without_sep();
        if (s22 === peg$FAILED) {
          s22 = peg$parseEOL();
        }
        if (s22 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f0(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseEOL();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f1();
          }
          s0 = s1;
        }
        return s0;
      }
      function peg$parsepartial_item() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parse_();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parse_();
        }
        s22 = [];
        s32 = peg$parsenon_var_token();
        while (s32 !== peg$FAILED) {
          s22.push(s32);
          s32 = peg$parsenon_var_token();
        }
        s32 = [];
        s42 = peg$parse_();
        while (s42 !== peg$FAILED) {
          s32.push(s42);
          s42 = peg$parse_();
        }
        s42 = peg$parsevar();
        if (s42 !== peg$FAILED) {
          s5 = [];
          s6 = peg$parse_();
          while (s6 !== peg$FAILED) {
            s5.push(s6);
            s6 = peg$parse_();
          }
          s6 = [];
          s7 = peg$parsetoken();
          while (s7 !== peg$FAILED) {
            s6.push(s7);
            s7 = peg$parsetoken();
          }
          s7 = [];
          s8 = peg$parse_();
          while (s8 !== peg$FAILED) {
            s7.push(s8);
            s8 = peg$parse_();
          }
          peg$savedPos = s0;
          s0 = peg$f2(s22, s42, s6);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        return s0;
      }
      function peg$parseitem() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8, s9;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parseoperation();
        if (s1 === peg$FAILED) {
          s1 = null;
        }
        s22 = [];
        s32 = peg$parse_();
        while (s32 !== peg$FAILED) {
          s22.push(s32);
          s32 = peg$parse_();
        }
        s32 = [];
        s42 = peg$parsenon_var_token();
        while (s42 !== peg$FAILED) {
          s32.push(s42);
          s42 = peg$parsenon_var_token();
        }
        s42 = [];
        s5 = peg$parse_();
        while (s5 !== peg$FAILED) {
          s42.push(s5);
          s5 = peg$parse_();
        }
        s5 = peg$parsevar();
        if (s5 !== peg$FAILED) {
          s6 = [];
          s7 = peg$parse_();
          while (s7 !== peg$FAILED) {
            s6.push(s7);
            s7 = peg$parse_();
          }
          s7 = [];
          s8 = peg$parsetoken();
          while (s8 !== peg$FAILED) {
            s7.push(s8);
            s8 = peg$parsetoken();
          }
          s8 = [];
          s9 = peg$parse_();
          while (s9 !== peg$FAILED) {
            s8.push(s9);
            s9 = peg$parse_();
          }
          peg$savedPos = s0;
          s0 = peg$f3(s1, s32, s5, s7);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseoperation();
          if (s1 === peg$FAILED) {
            s1 = null;
          }
          s22 = [];
          s32 = peg$parse_();
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parse_();
          }
          s32 = [];
          s42 = peg$parsenon_var_token();
          if (s42 !== peg$FAILED) {
            while (s42 !== peg$FAILED) {
              s32.push(s42);
              s42 = peg$parsenon_var_token();
            }
          } else {
            s32 = peg$FAILED;
          }
          if (s32 !== peg$FAILED) {
            s42 = [];
            s5 = peg$parse_();
            while (s5 !== peg$FAILED) {
              s42.push(s5);
              s5 = peg$parse_();
            }
            peg$savedPos = s0;
            s0 = peg$f4(s1, s32);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e1);
          }
        }
        return s0;
      }
      function peg$parseline_with_sep() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$parseline_without_sep();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsesep();
          if (s22 !== peg$FAILED) {
            s32 = peg$parsetrailing_comment();
            if (s32 === peg$FAILED) {
              s32 = null;
            }
            peg$savedPos = s0;
            s0 = peg$f5(s1, s22, s32);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsepartial_line_with_comment() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parseline_without_sep();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsetrailing_comment();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f6(s1, s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseline_without_sep() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        if (input.length > peg$currPos) {
          s22 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s22 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        peg$silentFails--;
        if (s22 !== peg$FAILED) {
          peg$currPos = s1;
          s1 = void 0;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parseequation();
          s32 = peg$parseannotation();
          if (s32 === peg$FAILED) {
            s32 = null;
          }
          peg$savedPos = s0;
          s0 = peg$f7(s22, s32);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseannotation() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$parseat();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$parsenon_sep_token();
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parsenon_sep_token();
          }
          peg$savedPos = s0;
          s0 = peg$f8(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseequation() {
        var s0, s1, s22, s32, s42;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parseitem();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parseitem();
        }
        s22 = peg$parseequals();
        if (s22 === peg$FAILED) {
          s22 = null;
        }
        s32 = [];
        s42 = peg$parsetoken();
        if (s42 === peg$FAILED) {
          s42 = peg$parseoperation();
        }
        while (s42 !== peg$FAILED) {
          s32.push(s42);
          s42 = peg$parsetoken();
          if (s42 === peg$FAILED) {
            s42 = peg$parseoperation();
          }
        }
        peg$savedPos = s0;
        s0 = peg$f9(s1, s22, s32);
        peg$silentFails--;
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e3);
        }
        return s0;
      }
      function peg$parsetrailing_comment() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parse_();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parse_();
        }
        s22 = peg$parsesame_line_comment();
        if (s22 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f10(s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e4);
          }
        }
        return s0;
      }
      function peg$parsecomment_only_line() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parse_();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parse_();
        }
        s22 = peg$parseown_line_comment();
        if (s22 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f11(s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e5);
          }
        }
        return s0;
      }
      function peg$parsevar() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$parsevar_token();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$parse_();
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parse_();
          }
          s32 = peg$parsesubscript();
          if (s32 === peg$FAILED) {
            s32 = null;
          }
          peg$savedPos = s0;
          s0 = peg$f12(s1, s32);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsenon_var_token() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        s22 = peg$parsevar();
        peg$silentFails--;
        if (s22 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parsetoken();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f13(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e6);
          }
        }
        return s0;
      }
      function peg$parsenon_sep_token() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        s22 = peg$parsesep();
        if (s22 === peg$FAILED) {
          s22 = peg$parsetrailing_comment();
          if (s22 === peg$FAILED) {
            s22 = peg$parseown_line_comment();
          }
        }
        peg$silentFails--;
        if (s22 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s22 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f14(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsetoken() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        s22 = peg$parsesep();
        if (s22 === peg$FAILED) {
          s22 = peg$parseat();
          if (s22 === peg$FAILED) {
            s22 = peg$parseoperation();
            if (s22 === peg$FAILED) {
              s22 = peg$parseequals();
              if (s22 === peg$FAILED) {
                s22 = peg$parsetrailing_comment();
                if (s22 === peg$FAILED) {
                  s22 = peg$parseown_line_comment();
                }
              }
            }
          }
        }
        peg$silentFails--;
        if (s22 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s22 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f15(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e7);
          }
        }
        return s0;
      }
      function peg$parsesame_line_comment() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f16(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f17(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e8);
          }
        }
        return s0;
      }
      function peg$parseown_line_comment() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f18(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f19(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e9);
          }
        }
        return s0;
      }
      function peg$parse_() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f20(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f21(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsesep() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f22(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f23(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e10);
          }
        }
        return s0;
      }
      function peg$parseat() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f24(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f25(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e11);
          }
        }
        return s0;
      }
      function peg$parsevar_token() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f26(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f27(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e12);
          }
        }
        return s0;
      }
      function peg$parseoperation() {
        var s0, s1, s22, s32, s42;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parse_();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parse_();
        }
        if (input.length > peg$currPos) {
          s22 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s22 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        if (s22 !== peg$FAILED) {
          s32 = [];
          s42 = peg$parse_();
          while (s42 !== peg$FAILED) {
            s32.push(s42);
            s42 = peg$parse_();
          }
          peg$savedPos = peg$currPos;
          s42 = peg$f28(s22);
          if (s42) {
            s42 = void 0;
          } else {
            s42 = peg$FAILED;
          }
          if (s42 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f29(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e13);
          }
        }
        return s0;
      }
      function peg$parseequals() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f30(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f31(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e14);
          }
        }
        return s0;
      }
      function peg$parsesubscript() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f32(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f33(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseEOL() {
        var s0, s1;
        s0 = peg$currPos;
        peg$silentFails++;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        peg$silentFails--;
        if (s1 === peg$FAILED) {
          s0 = void 0;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      if (!options.isWhitespace) {
        try {
          Object.assign(options, {
            isSep: (node) => node.type === "string" && node.content === ",",
            isVar: (node) => node.type === "string" && node.content.match(/[a-zA-Z]/),
            isOperation: (node) => node.type === "string" && node.content.match(/[+-]/),
            isEquals: (node) => node.type === "string" && node.content === "=",
            isAt: (node) => node.type === "string" && node.content === "@",
            isSubscript: (node) => node.content === "_",
            isWhitespace: (node) => node.type === "whitespace",
            isSameLineComment: (node) => node.type === "comment" && node.sameline,
            isOwnLineComment: (node) => node.type === "comment" && !node.sameline
          });
        } catch (e) {
          console.warn("Error when initializing parser", e);
        }
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(
          peg$maxFailExpected,
          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
      }
    }
    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }()
);
var tex_glue_default5 = (
  // Generated by Peggy 2.0.1.
  //
  // https://peggyjs.org/
  function() {
    "use strict";
    function peg$subclass(child, parent) {
      function C() {
        this.constructor = child;
      }
      C.prototype = parent.prototype;
      child.prototype = new C();
    }
    function peg$SyntaxError(message, expected, found, location) {
      var self = Error.call(this, message);
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(self, peg$SyntaxError.prototype);
      }
      self.expected = expected;
      self.found = found;
      self.location = location;
      self.name = "SyntaxError";
      return self;
    }
    peg$subclass(peg$SyntaxError, Error);
    function peg$padEnd(str, targetLength, padString) {
      padString = padString || " ";
      if (str.length > targetLength) {
        return str;
      }
      targetLength -= str.length;
      padString += padString.repeat(targetLength);
      return str + padString.slice(0, targetLength);
    }
    peg$SyntaxError.prototype.format = function(sources) {
      var str = "Error: " + this.message;
      if (this.location) {
        var src = null;
        var k;
        for (k = 0; k < sources.length; k++) {
          if (sources[k].source === this.location.source) {
            src = sources[k].text.split(/\r\n|\n|\r/g);
            break;
          }
        }
        var s22 = this.location.start;
        var loc = this.location.source + ":" + s22.line + ":" + s22.column;
        if (src) {
          var e = this.location.end;
          var filler = peg$padEnd("", s22.line.toString().length, " ");
          var line = src[s22.line - 1];
          var last = s22.line === e.line ? e.column : line.length + 1;
          var hatLen = last - s22.column || 1;
          str += "\n --> " + loc + "\n" + filler + " |\n" + s22.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s22.column - 1, " ") + peg$padEnd("", hatLen, "^");
        } else {
          str += "\n at " + loc;
        }
      }
      return str;
    };
    peg$SyntaxError.buildMessage = function(expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        class: function(expectation) {
          var escapedParts = expectation.parts.map(function(part) {
            return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
          });
          return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
        },
        any: function() {
          return "any character";
        },
        end: function() {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        }
      };
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s22) {
        return s22.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function classEscape(s22) {
        return s22.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = expected2.map(describeExpectation);
        var i, j;
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {};
      var peg$source = options.grammarSource;
      var peg$startRuleFunctions = { root: peg$parseroot };
      var peg$startRuleFunction = peg$parseroot;
      var peg$c0 = "plus";
      var peg$c1 = "minus";
      var peg$c2 = "pt";
      var peg$c3 = "mm";
      var peg$c4 = "cm";
      var peg$c5 = "in";
      var peg$c6 = "ex";
      var peg$c7 = "em";
      var peg$c8 = "bp";
      var peg$c9 = "pc";
      var peg$c10 = "dd";
      var peg$c11 = "cc";
      var peg$c12 = "nd";
      var peg$c13 = "nc";
      var peg$c14 = "sp";
      var peg$c15 = "filll";
      var peg$c16 = "fill";
      var peg$c17 = "fil";
      var peg$c18 = ".";
      var peg$c19 = "+";
      var peg$c20 = "-";
      var peg$r0 = /^[0-9]/;
      var peg$e0 = peg$anyExpectation();
      var peg$e1 = peg$literalExpectation("plus", false);
      var peg$e2 = peg$literalExpectation("minus", false);
      var peg$e3 = peg$literalExpectation("pt", false);
      var peg$e4 = peg$literalExpectation("mm", false);
      var peg$e5 = peg$literalExpectation("cm", false);
      var peg$e6 = peg$literalExpectation("in", false);
      var peg$e7 = peg$literalExpectation("ex", false);
      var peg$e8 = peg$literalExpectation("em", false);
      var peg$e9 = peg$literalExpectation("bp", false);
      var peg$e10 = peg$literalExpectation("pc", false);
      var peg$e11 = peg$literalExpectation("dd", false);
      var peg$e12 = peg$literalExpectation("cc", false);
      var peg$e13 = peg$literalExpectation("nd", false);
      var peg$e14 = peg$literalExpectation("nc", false);
      var peg$e15 = peg$literalExpectation("sp", false);
      var peg$e16 = peg$literalExpectation("filll", false);
      var peg$e17 = peg$literalExpectation("fill", false);
      var peg$e18 = peg$literalExpectation("fil", false);
      var peg$e19 = peg$otherExpectation("number");
      var peg$e20 = peg$classExpectation([["0", "9"]], false, false);
      var peg$e21 = peg$literalExpectation(".", false);
      var peg$e22 = peg$literalExpectation("+", false);
      var peg$e23 = peg$literalExpectation("-", false);
      var peg$f0 = function(b, st, sh) {
        return {
          type: "glue",
          fixed: b,
          stretchable: st,
          shrinkable: sh,
          position: location()
        };
      };
      var peg$f1 = function(glue) {
        return glue;
      };
      var peg$f2 = function(n, u) {
        return { type: "dim", value: n, unit: u };
      };
      var peg$f3 = function(n, u) {
        return { type: "dim", value: n, unit: u };
      };
      var peg$f4 = function(n, u) {
        return { type: "dim", value: n, unit: u };
      };
      var peg$f5 = function(n) {
        return parseFloat(n);
      };
      var peg$currPos = 0;
      var peg$savedPos = 0;
      var peg$posDetailsCache = [{ line: 1, column: 1 }];
      var peg$maxFailPos = 0;
      var peg$maxFailExpected = [];
      var peg$silentFails = 0;
      var peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function offset() {
        return peg$savedPos;
      }
      function range() {
        return {
          source: peg$source,
          start: peg$savedPos,
          end: peg$currPos
        };
      }
      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError(
          [peg$otherExpectation(description)],
          input.substring(peg$savedPos, peg$currPos),
          location2
        );
      }
      function error(message, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location2);
      }
      function peg$literalExpectation(text2, ignoreCase) {
        return { type: "literal", text: text2, ignoreCase };
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts, inverted, ignoreCase };
      }
      function peg$anyExpectation() {
        return { type: "any" };
      }
      function peg$endExpectation() {
        return { type: "end" };
      }
      function peg$otherExpectation(description) {
        return { type: "other", description };
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p;
        if (details) {
          return details;
        } else {
          p = pos - 1;
          while (!peg$posDetailsCache[p]) {
            p--;
          }
          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };
          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos);
        var endPosDetails = peg$computePosDetails(endPos);
        return {
          source: peg$source,
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildSimpleError(message, location2) {
        return new peg$SyntaxError(message, null, null, location2);
      }
      function peg$buildStructuredError(expected2, found, location2) {
        return new peg$SyntaxError(
          peg$SyntaxError.buildMessage(expected2, found),
          expected2,
          found,
          location2
        );
      }
      function peg$parseroot() {
        var s0, s1, s22, s32, s42;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$parsebase();
        if (s22 !== peg$FAILED) {
          s32 = peg$parsestretchable();
          if (s32 === peg$FAILED) {
            s32 = null;
          }
          s42 = peg$parseshrinkable();
          if (s42 === peg$FAILED) {
            s42 = null;
          }
          peg$savedPos = s1;
          s1 = peg$f0(s22, s32, s42);
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s22 = [];
          if (input.length > peg$currPos) {
            s32 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s32 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            if (input.length > peg$currPos) {
              s32 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s32 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
          }
          peg$savedPos = s0;
          s0 = peg$f1(s1);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsebase() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parsenumber();
        if (s1 !== peg$FAILED) {
          s22 = peg$parseunit();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f2(s1, s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsestretchable() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 4) === peg$c0) {
          s1 = peg$c0;
          peg$currPos += 4;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e1);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parsenumber();
          if (s22 !== peg$FAILED) {
            s32 = peg$parserubber_unit();
            if (s32 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f3(s22, s32);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseshrinkable() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 5) === peg$c1) {
          s1 = peg$c1;
          peg$currPos += 5;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parsenumber();
          if (s22 !== peg$FAILED) {
            s32 = peg$parserubber_unit();
            if (s32 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f4(s22, s32);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseunit() {
        var s0;
        if (input.substr(peg$currPos, 2) === peg$c2) {
          s0 = peg$c2;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s0 === peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c3) {
            s0 = peg$c3;
            peg$currPos += 2;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e4);
            }
          }
          if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c4) {
              s0 = peg$c4;
              peg$currPos += 2;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e5);
              }
            }
            if (s0 === peg$FAILED) {
              if (input.substr(peg$currPos, 2) === peg$c5) {
                s0 = peg$c5;
                peg$currPos += 2;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e6);
                }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 2) === peg$c6) {
                  s0 = peg$c6;
                  peg$currPos += 2;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e7);
                  }
                }
                if (s0 === peg$FAILED) {
                  if (input.substr(peg$currPos, 2) === peg$c7) {
                    s0 = peg$c7;
                    peg$currPos += 2;
                  } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e8);
                    }
                  }
                  if (s0 === peg$FAILED) {
                    if (input.substr(peg$currPos, 2) === peg$c8) {
                      s0 = peg$c8;
                      peg$currPos += 2;
                    } else {
                      s0 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e9);
                      }
                    }
                    if (s0 === peg$FAILED) {
                      if (input.substr(peg$currPos, 2) === peg$c9) {
                        s0 = peg$c9;
                        peg$currPos += 2;
                      } else {
                        s0 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$e10);
                        }
                      }
                      if (s0 === peg$FAILED) {
                        if (input.substr(peg$currPos, 2) === peg$c10) {
                          s0 = peg$c10;
                          peg$currPos += 2;
                        } else {
                          s0 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$e11);
                          }
                        }
                        if (s0 === peg$FAILED) {
                          if (input.substr(peg$currPos, 2) === peg$c11) {
                            s0 = peg$c11;
                            peg$currPos += 2;
                          } else {
                            s0 = peg$FAILED;
                            if (peg$silentFails === 0) {
                              peg$fail(peg$e12);
                            }
                          }
                          if (s0 === peg$FAILED) {
                            if (input.substr(peg$currPos, 2) === peg$c12) {
                              s0 = peg$c12;
                              peg$currPos += 2;
                            } else {
                              s0 = peg$FAILED;
                              if (peg$silentFails === 0) {
                                peg$fail(peg$e13);
                              }
                            }
                            if (s0 === peg$FAILED) {
                              if (input.substr(peg$currPos, 2) === peg$c13) {
                                s0 = peg$c13;
                                peg$currPos += 2;
                              } else {
                                s0 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                  peg$fail(peg$e14);
                                }
                              }
                              if (s0 === peg$FAILED) {
                                if (input.substr(peg$currPos, 2) === peg$c14) {
                                  s0 = peg$c14;
                                  peg$currPos += 2;
                                } else {
                                  s0 = peg$FAILED;
                                  if (peg$silentFails === 0) {
                                    peg$fail(peg$e15);
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return s0;
      }
      function peg$parserubber_unit() {
        var s0;
        s0 = peg$parseunit();
        if (s0 === peg$FAILED) {
          if (input.substr(peg$currPos, 5) === peg$c15) {
            s0 = peg$c15;
            peg$currPos += 5;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e16);
            }
          }
          if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 4) === peg$c16) {
              s0 = peg$c16;
              peg$currPos += 4;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e17);
              }
            }
            if (s0 === peg$FAILED) {
              if (input.substr(peg$currPos, 3) === peg$c17) {
                s0 = peg$c17;
                peg$currPos += 3;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e18);
                }
              }
            }
          }
        }
        return s0;
      }
      function peg$parsenumber() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$currPos;
        s32 = peg$parsesign();
        if (s32 === peg$FAILED) {
          s32 = null;
        }
        s42 = peg$currPos;
        s5 = [];
        if (peg$r0.test(input.charAt(peg$currPos))) {
          s6 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s6 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e20);
          }
        }
        while (s6 !== peg$FAILED) {
          s5.push(s6);
          if (peg$r0.test(input.charAt(peg$currPos))) {
            s6 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s6 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e20);
            }
          }
        }
        if (input.charCodeAt(peg$currPos) === 46) {
          s6 = peg$c18;
          peg$currPos++;
        } else {
          s6 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e21);
          }
        }
        if (s6 !== peg$FAILED) {
          s7 = [];
          if (peg$r0.test(input.charAt(peg$currPos))) {
            s8 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s8 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e20);
            }
          }
          if (s8 !== peg$FAILED) {
            while (s8 !== peg$FAILED) {
              s7.push(s8);
              if (peg$r0.test(input.charAt(peg$currPos))) {
                s8 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s8 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e20);
                }
              }
            }
          } else {
            s7 = peg$FAILED;
          }
          if (s7 !== peg$FAILED) {
            s5 = [s5, s6, s7];
            s42 = s5;
          } else {
            peg$currPos = s42;
            s42 = peg$FAILED;
          }
        } else {
          peg$currPos = s42;
          s42 = peg$FAILED;
        }
        if (s42 === peg$FAILED) {
          s42 = [];
          if (peg$r0.test(input.charAt(peg$currPos))) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e20);
            }
          }
          if (s5 !== peg$FAILED) {
            while (s5 !== peg$FAILED) {
              s42.push(s5);
              if (peg$r0.test(input.charAt(peg$currPos))) {
                s5 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e20);
                }
              }
            }
          } else {
            s42 = peg$FAILED;
          }
        }
        if (s42 !== peg$FAILED) {
          s32 = [s32, s42];
          s22 = s32;
        } else {
          peg$currPos = s22;
          s22 = peg$FAILED;
        }
        if (s22 !== peg$FAILED) {
          s1 = input.substring(s1, peg$currPos);
        } else {
          s1 = s22;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f5(s1);
        }
        s0 = s1;
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e19);
          }
        }
        return s0;
      }
      function peg$parsesign() {
        var s0;
        if (input.charCodeAt(peg$currPos) === 43) {
          s0 = peg$c19;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e22);
          }
        }
        if (s0 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 45) {
            s0 = peg$c20;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e23);
            }
          }
        }
        return s0;
      }
      function peg$parseEOL() {
        var s0, s1;
        s0 = peg$currPos;
        peg$silentFails++;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        peg$silentFails--;
        if (s1 === peg$FAILED) {
          s0 = void 0;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(
          peg$maxFailExpected,
          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
      }
    }
    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }()
);
var tikz_default5 = (
  // Generated by Peggy 2.0.1.
  //
  // https://peggyjs.org/
  function() {
    "use strict";
    function peg$subclass(child, parent) {
      function C() {
        this.constructor = child;
      }
      C.prototype = parent.prototype;
      child.prototype = new C();
    }
    function peg$SyntaxError(message, expected, found, location) {
      var self = Error.call(this, message);
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(self, peg$SyntaxError.prototype);
      }
      self.expected = expected;
      self.found = found;
      self.location = location;
      self.name = "SyntaxError";
      return self;
    }
    peg$subclass(peg$SyntaxError, Error);
    function peg$padEnd(str, targetLength, padString) {
      padString = padString || " ";
      if (str.length > targetLength) {
        return str;
      }
      targetLength -= str.length;
      padString += padString.repeat(targetLength);
      return str + padString.slice(0, targetLength);
    }
    peg$SyntaxError.prototype.format = function(sources) {
      var str = "Error: " + this.message;
      if (this.location) {
        var src = null;
        var k;
        for (k = 0; k < sources.length; k++) {
          if (sources[k].source === this.location.source) {
            src = sources[k].text.split(/\r\n|\n|\r/g);
            break;
          }
        }
        var s22 = this.location.start;
        var loc = this.location.source + ":" + s22.line + ":" + s22.column;
        if (src) {
          var e = this.location.end;
          var filler = peg$padEnd("", s22.line.toString().length, " ");
          var line = src[s22.line - 1];
          var last = s22.line === e.line ? e.column : line.length + 1;
          var hatLen = last - s22.column || 1;
          str += "\n --> " + loc + "\n" + filler + " |\n" + s22.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s22.column - 1, " ") + peg$padEnd("", hatLen, "^");
        } else {
          str += "\n at " + loc;
        }
      }
      return str;
    };
    peg$SyntaxError.buildMessage = function(expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        class: function(expectation) {
          var escapedParts = expectation.parts.map(function(part) {
            return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
          });
          return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
        },
        any: function() {
          return "any character";
        },
        end: function() {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        }
      };
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s22) {
        return s22.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function classEscape(s22) {
        return s22.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = expected2.map(describeExpectation);
        var i, j;
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {};
      var peg$source = options.grammarSource;
      var peg$startRuleFunctions = { path_spec: peg$parsepath_spec, foreach_body: peg$parseforeach_body };
      var peg$startRuleFunction = peg$parsepath_spec;
      var peg$e0 = peg$anyExpectation();
      var peg$e1 = peg$otherExpectation("same line comment");
      var peg$e2 = peg$otherExpectation("own line comment");
      var peg$e3 = peg$otherExpectation("comment");
      var peg$e4 = peg$otherExpectation("floating comment");
      var peg$e5 = peg$otherExpectation("operation");
      var peg$e6 = peg$otherExpectation("=");
      var peg$f0 = function(v) {
        return v;
      };
      var peg$f1 = function(ops) {
        return { type: "path_spec", content: ops };
      };
      var peg$f2 = function(c1, op, comment223) {
        return { op, comment: comment223 };
      };
      var peg$f3 = function(c1, ops, c2, body) {
        const comments = [c1, ...ops.map((x) => x.comment), c2].filter(
          (x) => x
        );
        const attribute = ops.map((x) => x.op.content.content).join(" ");
        return {
          type: "animation",
          comments,
          attribute,
          content: body.content
        };
      };
      var peg$f4 = function(start, b) {
        return { ...b, start, type: "foreach" };
      };
      var peg$f5 = function(c1, variables, options2, c2, c3, list, c4, command) {
        const comments = [c1, c2, c3, c4].filter((x) => x);
        return {
          type: "foreach_body",
          variables,
          options: options2 && options2.content,
          list,
          command,
          comments
        };
      };
      var peg$f6 = function(c1, options2, c2, body) {
        const comments = [c1, c2].filter((x) => x);
        return {
          type: "svg_operation",
          options: options2 && options2.content,
          content: body,
          comments
        };
      };
      var peg$f7 = function(c1, c2, coord, c3, c4, x) {
        return { coord: x, comment: c4 };
      };
      var peg$f8 = function(c1, c2, coord, c3, a, c5) {
        const comments = [c1, c2, c3, a && a.comment, c5].filter((x) => x);
        return {
          type: "curve_to",
          controls: a ? [coord, a.coord] : [coord],
          comments
        };
      };
      var peg$f9 = function() {
        return { type: "line_to", command: "|-" };
      };
      var peg$f10 = function() {
        return { type: "line_to", command: "-|" };
      };
      var peg$f11 = function() {
        return { type: "line_to", command: "--" };
      };
      var peg$f12 = function(prefix, content) {
        return { type: "coordinate", content, prefix };
      };
      var peg$f13 = function(content) {
        return { type: "square_brace_group", content };
      };
      var peg$f14 = function(v) {
        return { type: "unknown", content: v };
      };
      var peg$f15 = function(tok) {
        return options.isSameLineComment(tok);
      };
      var peg$f16 = function(tok) {
        return tok;
      };
      var peg$f17 = function(tok) {
        return options.isOwnLineComment(tok);
      };
      var peg$f18 = function(tok) {
        return tok;
      };
      var peg$f19 = function(tok) {
        return options.isComment(tok);
      };
      var peg$f20 = function(tok) {
        return tok;
      };
      var peg$f21 = function(tok) {
        return options.isWhitespace(tok);
      };
      var peg$f22 = function(tok) {
        return tok;
      };
      var peg$f23 = function(c) {
        return c;
      };
      var peg$f24 = function(tok) {
        return options.isOperation(tok);
      };
      var peg$f25 = function(tok) {
        return { type: "operation", content: tok };
      };
      var peg$f26 = function(tok) {
        return options.isChar(tok, "=");
      };
      var peg$f27 = function(tok) {
        return tok;
      };
      var peg$f28 = function(tok) {
        return options.isChar(tok, "[");
      };
      var peg$f29 = function(tok) {
        return tok;
      };
      var peg$f30 = function(tok) {
        return options.isChar(tok, "]");
      };
      var peg$f31 = function(tok) {
        return tok;
      };
      var peg$f32 = function(tok) {
        return options.isChar(tok, "(");
      };
      var peg$f33 = function(tok) {
        return tok;
      };
      var peg$f34 = function(tok) {
        return options.isChar(tok, ")");
      };
      var peg$f35 = function(tok) {
        return tok;
      };
      var peg$f36 = function(tok) {
        return options.isChar(tok, "+");
      };
      var peg$f37 = function(tok) {
        return tok;
      };
      var peg$f38 = function(tok) {
        return options.isChar(tok, "-");
      };
      var peg$f39 = function(tok) {
        return tok;
      };
      var peg$f40 = function(tok) {
        return options.isChar(tok, "|");
      };
      var peg$f41 = function(tok) {
        return tok;
      };
      var peg$f42 = function(tok) {
        return options.isChar(tok, ".");
      };
      var peg$f43 = function(tok) {
        return tok;
      };
      var peg$f44 = function(tok) {
        return options.isChar(tok, "controls");
      };
      var peg$f45 = function(tok) {
        return tok;
      };
      var peg$f46 = function(tok) {
        return options.isChar(tok, "and");
      };
      var peg$f47 = function(tok) {
        return tok;
      };
      var peg$f48 = function(tok) {
        return options.isChar(tok, "svg");
      };
      var peg$f49 = function(tok) {
        return tok;
      };
      var peg$f50 = function(tok) {
        return options.isGroup(tok);
      };
      var peg$f51 = function(tok) {
        return tok;
      };
      var peg$f52 = function(tok) {
        return options.isAnyMacro(tok);
      };
      var peg$f53 = function(tok) {
        return tok;
      };
      var peg$f54 = function(tok) {
        return options.isChar(tok, "foreach");
      };
      var peg$f55 = function(tok) {
        return tok;
      };
      var peg$f56 = function(tok) {
        return options.isMacro(tok, "foreach");
      };
      var peg$f57 = function(tok) {
        return tok;
      };
      var peg$f58 = function(tok) {
        return options.isChar(tok, "in");
      };
      var peg$f59 = function(tok) {
        return tok;
      };
      var peg$f60 = function(tok) {
        return options.isChar(tok, ":");
      };
      var peg$f61 = function(tok) {
        return tok;
      };
      var peg$currPos = 0;
      var peg$savedPos = 0;
      var peg$posDetailsCache = [{ line: 1, column: 1 }];
      var peg$maxFailPos = 0;
      var peg$maxFailExpected = [];
      var peg$silentFails = 0;
      var peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function offset() {
        return peg$savedPos;
      }
      function range() {
        return {
          source: peg$source,
          start: peg$savedPos,
          end: peg$currPos
        };
      }
      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError(
          [peg$otherExpectation(description)],
          input.substring(peg$savedPos, peg$currPos),
          location2
        );
      }
      function error(message, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location2);
      }
      function peg$literalExpectation(text2, ignoreCase) {
        return { type: "literal", text: text2, ignoreCase };
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts, inverted, ignoreCase };
      }
      function peg$anyExpectation() {
        return { type: "any" };
      }
      function peg$endExpectation() {
        return { type: "end" };
      }
      function peg$otherExpectation(description) {
        return { type: "other", description };
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p;
        if (details) {
          return details;
        } else {
          p = pos - 1;
          while (!peg$posDetailsCache[p]) {
            p--;
          }
          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };
          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos);
        var endPosDetails = peg$computePosDetails(endPos);
        return {
          source: peg$source,
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildSimpleError(message, location2) {
        return new peg$SyntaxError(message, null, null, location2);
      }
      function peg$buildStructuredError(expected2, found, location2) {
        return new peg$SyntaxError(
          peg$SyntaxError.buildMessage(expected2, found),
          expected2,
          found,
          location2
        );
      }
      function peg$parsepath_spec() {
        var s0, s1, s22, s32, s42, s5;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$currPos;
        s32 = peg$parsesquare_brace_group();
        if (s32 === peg$FAILED) {
          s32 = peg$parsecoordinate();
          if (s32 === peg$FAILED) {
            s32 = peg$parsecurve_to();
            if (s32 === peg$FAILED) {
              s32 = peg$parseline_to();
              if (s32 === peg$FAILED) {
                s32 = peg$parsesvg();
                if (s32 === peg$FAILED) {
                  s32 = peg$parseforeach();
                  if (s32 === peg$FAILED) {
                    s32 = peg$parseoperation();
                    if (s32 === peg$FAILED) {
                      s32 = peg$parsecomment();
                      if (s32 === peg$FAILED) {
                        s32 = peg$parseanimation();
                        if (s32 === peg$FAILED) {
                          s32 = peg$parseunknown();
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (s32 !== peg$FAILED) {
          s42 = [];
          s5 = peg$parse_();
          while (s5 !== peg$FAILED) {
            s42.push(s5);
            s5 = peg$parse_();
          }
          peg$savedPos = s22;
          s22 = peg$f0(s32);
        } else {
          peg$currPos = s22;
          s22 = peg$FAILED;
        }
        if (s22 !== peg$FAILED) {
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            s22 = peg$currPos;
            s32 = peg$parsesquare_brace_group();
            if (s32 === peg$FAILED) {
              s32 = peg$parsecoordinate();
              if (s32 === peg$FAILED) {
                s32 = peg$parsecurve_to();
                if (s32 === peg$FAILED) {
                  s32 = peg$parseline_to();
                  if (s32 === peg$FAILED) {
                    s32 = peg$parsesvg();
                    if (s32 === peg$FAILED) {
                      s32 = peg$parseforeach();
                      if (s32 === peg$FAILED) {
                        s32 = peg$parseoperation();
                        if (s32 === peg$FAILED) {
                          s32 = peg$parsecomment();
                          if (s32 === peg$FAILED) {
                            s32 = peg$parseanimation();
                            if (s32 === peg$FAILED) {
                              s32 = peg$parseunknown();
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            if (s32 !== peg$FAILED) {
              s42 = [];
              s5 = peg$parse_();
              while (s5 !== peg$FAILED) {
                s42.push(s5);
                s5 = peg$parse_();
              }
              peg$savedPos = s22;
              s22 = peg$f0(s32);
            } else {
              peg$currPos = s22;
              s22 = peg$FAILED;
            }
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f1(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parseanimation() {
        var s0, s1, s22, s32, s42, s5, s6;
        s0 = peg$currPos;
        s1 = peg$parsecolon();
        if (s1 !== peg$FAILED) {
          s22 = peg$parse_comment_();
          s32 = [];
          s42 = peg$currPos;
          s5 = peg$parseoperation();
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_comment_();
            peg$savedPos = s42;
            s42 = peg$f2(s22, s5, s6);
          } else {
            peg$currPos = s42;
            s42 = peg$FAILED;
          }
          if (s42 !== peg$FAILED) {
            while (s42 !== peg$FAILED) {
              s32.push(s42);
              s42 = peg$currPos;
              s5 = peg$parseoperation();
              if (s5 !== peg$FAILED) {
                s6 = peg$parse_comment_();
                peg$savedPos = s42;
                s42 = peg$f2(s22, s5, s6);
              } else {
                peg$currPos = s42;
                s42 = peg$FAILED;
              }
            }
          } else {
            s32 = peg$FAILED;
          }
          if (s32 !== peg$FAILED) {
            s42 = peg$parseequals();
            if (s42 !== peg$FAILED) {
              s5 = peg$parse_comment_();
              s6 = peg$parsegroup();
              if (s6 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f3(s22, s32, s5, s6);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseforeach() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parseforeach_keyword();
        if (s1 === peg$FAILED) {
          s1 = peg$parseforeach_macro();
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parseforeach_body();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f4(s1, s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseforeach_body() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8, s9;
        s0 = peg$currPos;
        s1 = peg$parse_comment_();
        s22 = peg$currPos;
        s32 = [];
        s42 = peg$currPos;
        s5 = peg$currPos;
        peg$silentFails++;
        s6 = peg$parsein_keyword();
        if (s6 === peg$FAILED) {
          s6 = peg$parsesquare_brace_group();
        }
        peg$silentFails--;
        if (s6 === peg$FAILED) {
          s5 = void 0;
        } else {
          peg$currPos = s5;
          s5 = peg$FAILED;
        }
        if (s5 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s6 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s6 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s6 !== peg$FAILED) {
            s5 = [s5, s6];
            s42 = s5;
          } else {
            peg$currPos = s42;
            s42 = peg$FAILED;
          }
        } else {
          peg$currPos = s42;
          s42 = peg$FAILED;
        }
        while (s42 !== peg$FAILED) {
          s32.push(s42);
          s42 = peg$currPos;
          s5 = peg$currPos;
          peg$silentFails++;
          s6 = peg$parsein_keyword();
          if (s6 === peg$FAILED) {
            s6 = peg$parsesquare_brace_group();
          }
          peg$silentFails--;
          if (s6 === peg$FAILED) {
            s5 = void 0;
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
          if (s5 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s6 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            if (s6 !== peg$FAILED) {
              s5 = [s5, s6];
              s42 = s5;
            } else {
              peg$currPos = s42;
              s42 = peg$FAILED;
            }
          } else {
            peg$currPos = s42;
            s42 = peg$FAILED;
          }
        }
        s22 = input.substring(s22, peg$currPos);
        s32 = peg$parsesquare_brace_group();
        if (s32 === peg$FAILED) {
          s32 = null;
        }
        s42 = peg$parse_comment_();
        s5 = peg$parsein_keyword();
        if (s5 !== peg$FAILED) {
          s6 = peg$parse_comment_();
          s7 = peg$parsegroup();
          if (s7 === peg$FAILED) {
            s7 = peg$parsemacro();
          }
          if (s7 !== peg$FAILED) {
            s8 = peg$parse_comment_();
            s9 = peg$parseforeach();
            if (s9 === peg$FAILED) {
              s9 = peg$parsegroup();
              if (s9 === peg$FAILED) {
                s9 = peg$parsemacro();
              }
            }
            if (s9 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f5(s1, s22, s32, s42, s6, s7, s8, s9);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsesvg() {
        var s0, s1, s22, s32, s42, s5;
        s0 = peg$currPos;
        s1 = peg$parsesvg_keyword();
        if (s1 !== peg$FAILED) {
          s22 = peg$parse_comment_();
          s32 = peg$parsesquare_brace_group();
          if (s32 === peg$FAILED) {
            s32 = null;
          }
          s42 = peg$parse_comment_();
          s5 = peg$parsegroup();
          if (s5 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f6(s22, s32, s42, s5);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecurve_to() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8, s9, s10;
        s0 = peg$currPos;
        s1 = peg$parsedotdot();
        if (s1 !== peg$FAILED) {
          s22 = peg$parse_comment_();
          s32 = peg$parsecontrols_keyword();
          if (s32 !== peg$FAILED) {
            s42 = peg$parse_comment_();
            s5 = peg$parsecoordinate();
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_comment_();
              s7 = peg$currPos;
              s8 = peg$parseand_keyword();
              if (s8 !== peg$FAILED) {
                s9 = peg$parse_comment_();
                s10 = peg$parsecoordinate();
                if (s10 !== peg$FAILED) {
                  peg$savedPos = s7;
                  s7 = peg$f7(s22, s42, s5, s6, s9, s10);
                } else {
                  peg$currPos = s7;
                  s7 = peg$FAILED;
                }
              } else {
                peg$currPos = s7;
                s7 = peg$FAILED;
              }
              if (s7 === peg$FAILED) {
                s7 = null;
              }
              s8 = peg$parse_comment_();
              s9 = peg$parsedotdot();
              if (s9 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f8(s22, s42, s5, s6, s7, s8);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseline_to() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parsepipe();
        if (s1 !== peg$FAILED) {
          s22 = peg$parseminus();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f9();
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseminus();
          if (s1 !== peg$FAILED) {
            s22 = peg$parsepipe();
            if (s22 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f10();
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseminus();
            if (s1 !== peg$FAILED) {
              s22 = peg$parseminus();
              if (s22 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f11();
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
        }
        return s0;
      }
      function peg$parsecoordinate() {
        var s0, s1, s22, s32, s42, s5, s6, s7;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$currPos;
        s32 = peg$parseplus();
        if (s32 !== peg$FAILED) {
          s42 = peg$parseplus();
          if (s42 === peg$FAILED) {
            s42 = null;
          }
          s32 = [s32, s42];
          s22 = s32;
        } else {
          peg$currPos = s22;
          s22 = peg$FAILED;
        }
        if (s22 === peg$FAILED) {
          s22 = null;
        }
        s1 = input.substring(s1, peg$currPos);
        s22 = peg$parseopen_paren();
        if (s22 !== peg$FAILED) {
          s32 = peg$currPos;
          s42 = [];
          s5 = peg$currPos;
          s6 = peg$currPos;
          peg$silentFails++;
          s7 = peg$parseclose_paren();
          peg$silentFails--;
          if (s7 === peg$FAILED) {
            s6 = void 0;
          } else {
            peg$currPos = s6;
            s6 = peg$FAILED;
          }
          if (s6 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s7 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s7 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            if (s7 !== peg$FAILED) {
              s6 = [s6, s7];
              s5 = s6;
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
          while (s5 !== peg$FAILED) {
            s42.push(s5);
            s5 = peg$currPos;
            s6 = peg$currPos;
            peg$silentFails++;
            s7 = peg$parseclose_paren();
            peg$silentFails--;
            if (s7 === peg$FAILED) {
              s6 = void 0;
            } else {
              peg$currPos = s6;
              s6 = peg$FAILED;
            }
            if (s6 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s7 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s7 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              if (s7 !== peg$FAILED) {
                s6 = [s6, s7];
                s5 = s6;
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
          }
          s32 = input.substring(s32, peg$currPos);
          s42 = peg$parseclose_paren();
          if (s42 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f12(s1, s32);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsesquare_brace_group() {
        var s0, s1, s22, s32, s42, s5, s6;
        s0 = peg$currPos;
        s1 = peg$parseopen_square_brace();
        if (s1 !== peg$FAILED) {
          s22 = peg$currPos;
          s32 = [];
          s42 = peg$currPos;
          s5 = peg$currPos;
          peg$silentFails++;
          s6 = peg$parseclose_square_brace();
          peg$silentFails--;
          if (s6 === peg$FAILED) {
            s5 = void 0;
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
          if (s5 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s6 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            if (s6 !== peg$FAILED) {
              s5 = [s5, s6];
              s42 = s5;
            } else {
              peg$currPos = s42;
              s42 = peg$FAILED;
            }
          } else {
            peg$currPos = s42;
            s42 = peg$FAILED;
          }
          while (s42 !== peg$FAILED) {
            s32.push(s42);
            s42 = peg$currPos;
            s5 = peg$currPos;
            peg$silentFails++;
            s6 = peg$parseclose_square_brace();
            peg$silentFails--;
            if (s6 === peg$FAILED) {
              s5 = void 0;
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
            if (s5 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s6 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              if (s6 !== peg$FAILED) {
                s5 = [s5, s6];
                s42 = s5;
              } else {
                peg$currPos = s42;
                s42 = peg$FAILED;
              }
            } else {
              peg$currPos = s42;
              s42 = peg$FAILED;
            }
          }
          s22 = input.substring(s22, peg$currPos);
          s32 = peg$parseclose_square_brace();
          if (s32 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f13(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsedotdot() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parsedot();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsedot();
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseunknown() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f14(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parsesame_line_comment() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f15(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f16(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e1);
          }
        }
        return s0;
      }
      function peg$parseown_line_comment() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f17(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f18(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        return s0;
      }
      function peg$parsecomment() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f19(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f20(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        return s0;
      }
      function peg$parse_() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f21(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f22(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parse_comment_() {
        var s0, s1, s22, s32, s42;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parse_();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parse_();
        }
        s22 = peg$parsecomment();
        if (s22 === peg$FAILED) {
          s22 = null;
        }
        s32 = [];
        s42 = peg$parse_();
        while (s42 !== peg$FAILED) {
          s32.push(s42);
          s42 = peg$parse_();
        }
        peg$savedPos = s0;
        s0 = peg$f23(s22);
        peg$silentFails--;
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e4);
        }
        return s0;
      }
      function peg$parseoperation() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f24(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f25(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e5);
          }
        }
        return s0;
      }
      function peg$parseequals() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f26(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f27(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e6);
          }
        }
        return s0;
      }
      function peg$parseopen_square_brace() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f28(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f29(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseclose_square_brace() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f30(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f31(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseopen_paren() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f32(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f33(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseclose_paren() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f34(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f35(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseplus() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f36(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f37(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseminus() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f38(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f39(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsepipe() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f40(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f41(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsedot() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f42(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f43(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecontrols_keyword() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f44(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f45(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseand_keyword() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f46(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f47(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsesvg_keyword() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f48(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f49(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsegroup() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f50(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f51(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsemacro() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f52(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f53(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseforeach_keyword() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f54(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f55(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseforeach_macro() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f56(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f57(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsein_keyword() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f58(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f59(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecolon() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f60(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f61(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseEOL() {
        var s0, s1;
        s0 = peg$currPos;
        peg$silentFails++;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        peg$silentFails--;
        if (s1 === peg$FAILED) {
          s0 = void 0;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      if (!options.isWhitespace) {
        try {
          Object.assign(options, {
            isChar: (node, char) => node.type === "string" && node.content === char,
            isOperation: (node) => node.type === "string" && node.content.match(/[a-zA-Z]/),
            isWhitespace: (node) => node.type === "whitespace" || node.type === "parbreak",
            isSameLineComment: (node) => node.type === "comment" && node.sameline,
            isOwnLineComment: (node) => node.type === "comment" && !node.sameline,
            isComment: (node) => node.type === "comment",
            isGroup: (node) => node.type === "group",
            isMacro: (node, name) => node.type === "macro" && node.content === name,
            isAnyMacro: (node) => node.type === "macro"
          });
        } catch (e) {
          console.warn("Error when initializing parser", e);
        }
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(
          peg$maxFailExpected,
          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
      }
    }
    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }()
);
var ArgSpecPegParser3 = xparse_argspec_default5;
var parseCache3 = {};
function parse2(str = "") {
  parseCache3[str] = parseCache3[str] || ArgSpecPegParser3.parse(str);
  return parseCache3[str];
}
var BRACES_MAP3 = {
  "*": { openMark: "", closeMark: "" },
  "{": { openMark: "{", closeMark: "}" },
  "[": { openMark: "[", closeMark: "]" },
  "(": { openMark: "(", closeMark: ")" },
  "<": { openMark: "<", closeMark: ">" }
};
var CLOSE_BRACES3 = new Set(
  Object.values(BRACES_MAP3).map((x) => x.closeMark).filter((x) => x)
);
function bracesToOpenAndCloseMarks3(braces) {
  const ret = [];
  for (const char of braces.split("")) {
    if (CLOSE_BRACES3.has(char)) {
      continue;
    }
    const braces2 = BRACES_MAP3[char];
    if (braces2 == null) {
      throw new Error(`Unknown open/close mark type "${char}"`);
    }
    braces2;
    ret.push(braces2);
  }
  return ret;
}
function arg3(args2, special) {
  if (args2 == null) {
    return { type: "argument", content: [], openMark: "", closeMark: "" };
  }
  if (typeof args2 === "string") {
    args2 = s3(args2);
  }
  if (!Array.isArray(args2) && args2.type === "argument") {
    return args2;
  }
  let openMark = (special == null ? void 0 : special.openMark) ?? "{";
  let closeMark = (special == null ? void 0 : special.closeMark) ?? "}";
  if (special == null ? void 0 : special.braces) {
    const braces = bracesToOpenAndCloseMarks3(special.braces);
    if (braces[0]) {
      openMark = braces[0].openMark;
      closeMark = braces[0].closeMark;
    }
  }
  if (!Array.isArray(args2)) {
    args2 = [args2];
  }
  return { type: "argument", content: args2, openMark, closeMark };
}
function s3(value) {
  if (typeof value === "string") {
    return { type: "string", content: value };
  }
  return value;
}
var linebreak28 = Symbol("linebreak");
var ESCAPE28 = "\\";
function _printRaw28(node) {
  if (typeof node === "string") {
    return [node];
  }
  if (Array.isArray(node)) {
    return [].concat(
      ...node.map((n) => _printRaw28(n))
    );
  }
  let argsString, escape;
  switch (node.type) {
    case "root":
      return _printRaw28(node.content);
    case "argument":
      return [node.openMark, ..._printRaw28(node.content), node.closeMark];
    case "comment":
      var suffix = node.suffixParbreak ? "" : linebreak28;
      var leadingWhitespace = "";
      if (node.sameline && node.leadingWhitespace) {
        leadingWhitespace = " ";
      }
      if (node.sameline) {
        return [
          leadingWhitespace,
          "%",
          ..._printRaw28(node.content),
          suffix
        ];
      }
      return [linebreak28, "%", ..._printRaw28(node.content), suffix];
    case "environment":
    case "mathenv":
    case "verbatim":
      var env = _printRaw28(node.env);
      var envStart = [ESCAPE28 + "begin{", ...env, "}"];
      var envEnd = [ESCAPE28 + "end{", ...env, "}"];
      argsString = node.args == null ? [] : _printRaw28(node.args);
      return [
        ...envStart,
        ...argsString,
        ..._printRaw28(node.content),
        ...envEnd
      ];
    case "displaymath":
      return [ESCAPE28 + "[", ..._printRaw28(node.content), ESCAPE28 + "]"];
    case "group":
      return ["{", ..._printRaw28(node.content), "}"];
    case "inlinemath":
      return ["$", ..._printRaw28(node.content), "$"];
    case "macro":
      argsString = node.args == null ? [] : _printRaw28(node.args);
      escape = node.escapeToken == null ? ESCAPE28 : node.escapeToken;
      return [escape, ..._printRaw28(node.content), ...argsString];
    case "parbreak":
      return [linebreak28, linebreak28];
    case "string":
      return [node.content];
    case "verb":
      return [
        ESCAPE28,
        node.env,
        node.escape,
        ..._printRaw28(node.content),
        node.escape
      ];
    case "whitespace":
      return [" "];
    default:
      console.warn(
        "Cannot find render for node ",
        node,
        `(of type ${typeof node})`
      );
      return ["" + node];
  }
}
function printRaw28(node, options) {
  const asArray = options != null ? options.asArray : false;
  const printedTokens = _printRaw28(node);
  if (asArray) {
    return printedTokens;
  }
  return printedTokens.map((x) => x === linebreak28 ? "\n" : x).join("");
}
function createMacroMatcher27(macros15) {
  const macrosHash = Array.isArray(macros15) ? macros15.length > 0 ? typeof macros15[0] === "string" ? Object.fromEntries(
    macros15.map((macro223) => {
      if (typeof macro223 !== "string") {
        throw new Error("Wrong branch of map function");
      }
      return [macro223, {}];
    })
  ) : Object.fromEntries(
    macros15.map((macro223) => {
      if (typeof macro223 === "string") {
        throw new Error("Wrong branch of map function");
      }
      if (macro223.escapeToken != null) {
        return [
          macro223.content,
          { escapeToken: macro223.escapeToken }
        ];
      }
      return [macro223.content, {}];
    })
  ) : {} : macros15;
  return function matchAgainstMacros(node) {
    if (node == null || node.type !== "macro") {
      return false;
    }
    const spec = macrosHash[node.content];
    if (!spec) {
      return false;
    }
    if (typeof spec === "object" && "escapeToken" in spec) {
      return spec.escapeToken == null || spec.escapeToken === node.escapeToken;
    }
    return true;
  };
}
function createEnvironmentMatcher27(macros15) {
  const environmentsHash = Array.isArray(macros15) ? Object.fromEntries(
    macros15.map((str) => {
      return [str, {}];
    })
  ) : macros15;
  return function matchAgainstEnvironments(node) {
    if (!match27.anyEnvironment(node)) {
      return false;
    }
    const envName = printRaw28(node.env);
    const spec = environmentsHash[envName];
    if (!spec) {
      return false;
    }
    return true;
  };
}
var match27 = {
  macro(node, macroName) {
    if (node == null) {
      return false;
    }
    return node.type === "macro" && (macroName == null || node.content === macroName);
  },
  anyMacro(node) {
    return match27.macro(node);
  },
  environment(node, envName) {
    if (node == null) {
      return false;
    }
    return (node.type === "environment" || node.type === "mathenv") && (envName == null || printRaw28(node.env) === envName);
  },
  anyEnvironment(node) {
    return match27.environment(node);
  },
  comment(node) {
    if (node == null) {
      return false;
    }
    return node.type === "comment";
  },
  parbreak(node) {
    if (node == null) {
      return false;
    }
    return node.type === "parbreak";
  },
  whitespace(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace";
  },
  /**
   * Matches whitespace or a comment with leading whitespace.
   */
  whitespaceLike(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace" || node.type === "whitespace" && node.leadingWhitespace === true;
  },
  string(node, value) {
    if (node == null) {
      return false;
    }
    return node.type === "string" && (value == null || node.content === value);
  },
  anyString(node) {
    return match27.string(node);
  },
  group(node) {
    if (node == null) {
      return false;
    }
    return node.type === "group";
  },
  argument(node) {
    if (node == null) {
      return false;
    }
    return node.type === "argument";
  },
  blankArgument(node) {
    if (!match27.argument(node)) {
      return false;
    }
    return node.openMark === "" && node.closeMark === "" && node.content.length === 0;
  },
  math(node) {
    if (node == null) {
      return false;
    }
    return node.type === "displaymath" || node.type === "inlinemath";
  },
  createMacroMatcher: createMacroMatcher27,
  createEnvironmentMatcher: createEnvironmentMatcher27
};
var {
  anyEnvironment: anyEnvironment27,
  anyMacro: anyMacro27,
  anyString: anyString27,
  argument: argument27,
  blankArgument: blankArgument27,
  comment: comment27,
  environment: environment27,
  group: group27,
  macro: macro27,
  math: math27,
  parbreak: parbreak27,
  string: string27,
  whitespace: whitespace27
} = match27;
var __create4 = Object.create;
var __defProp4 = Object.defineProperty;
var __getOwnPropDesc4 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames4 = Object.getOwnPropertyNames;
var __getProtoOf4 = Object.getPrototypeOf;
var __hasOwnProp4 = Object.prototype.hasOwnProperty;
var __commonJS4 = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames4(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps4 = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames4(from))
      if (!__hasOwnProp4.call(to, key) && key !== except)
        __defProp4(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc4(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM4 = (mod, isNodeMode, target) => (target = mod != null ? __create4(__getProtoOf4(mod)) : {}, __copyProps4(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp4(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var require_config3 = __commonJS4({
  "../../node_modules/trie-prefix-tree/dist/config.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = {
      END_WORD: "$",
      END_WORD_REPLACER: "9a219a89-91cd-42e2-abd5-eb113af08ca8",
      PERMS_MIN_LEN: 2
    };
    module2.exports = exports["default"];
  }
});
var require_append3 = __commonJS4({
  "../../node_modules/trie-prefix-tree/dist/append.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = append;
    var _config = require_config3();
    var _config2 = _interopRequireDefault(_config);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function append(trie, letter, index2, array) {
      var isEndWordLetter = letter === _config2.default.END_WORD;
      var isLastLetter = index2 === array.length - 1;
      if (isEndWordLetter && !isLastLetter) {
        trie[_config2.default.END_WORD] = 1;
        trie[_config2.default.END_WORD_REPLACER] = {};
        trie = trie[_config2.default.END_WORD_REPLACER];
      } else {
        trie[letter] = trie[letter] || {};
        trie = trie[letter];
      }
      if (isLastLetter) {
        trie[_config2.default.END_WORD] = 1;
      }
      return trie;
    }
    module2.exports = exports["default"];
  }
});
var require_create3 = __commonJS4({
  "../../node_modules/trie-prefix-tree/dist/create.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
      return typeof obj;
    } : function(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    exports.default = create;
    var _append = require_append3();
    var _append2 = _interopRequireDefault(_append);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function create(input) {
      if (!Array.isArray(input)) {
        throw "Expected parameter Array, received " + (typeof input === "undefined" ? "undefined" : _typeof(input));
      }
      var trie = input.reduce(function(accumulator, item) {
        item.toLowerCase().split("").reduce(_append2.default, accumulator);
        return accumulator;
      }, {});
      return trie;
    }
    module2.exports = exports["default"];
  }
});
var require_utils3 = __commonJS4({
  "../../node_modules/trie-prefix-tree/dist/utils.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = {
      objectCopy: function objectCopy(obj) {
        if (typeof obj === "undefined") {
          return {};
        }
        return JSON.parse(JSON.stringify(obj));
      },
      stringify: function stringify(obj) {
        var spacer = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2;
        if (typeof obj === "undefined") {
          return "";
        }
        return JSON.stringify(obj, null, spacer);
      }
    };
    module2.exports = exports["default"];
  }
});
var require_checkPrefix3 = __commonJS4({
  "../../node_modules/trie-prefix-tree/dist/checkPrefix.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = checkPrefix;
    var _utils = require_utils3();
    var _utils2 = _interopRequireDefault(_utils);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function checkPrefix(prefixNode, prefix) {
      var input = prefix.toLowerCase().split("");
      var prefixFound = input.every(function(letter, index2) {
        if (!prefixNode[letter]) {
          return false;
        }
        return prefixNode = prefixNode[letter];
      });
      return {
        prefixFound,
        prefixNode
      };
    }
    module2.exports = exports["default"];
  }
});
var require_recursePrefix3 = __commonJS4({
  "../../node_modules/trie-prefix-tree/dist/recursePrefix.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = recursePrefix;
    var _config = require_config3();
    var _config2 = _interopRequireDefault(_config);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var pushInOrder = function pushInOrder2(word, prefixes) {
      var i = 0;
      while (i < prefixes.length) {
        if (word < prefixes[i]) {
          break;
        }
        i += 1;
      }
      prefixes.splice(i, 0, word);
      return prefixes;
    };
    function recursePrefix(node, prefix, sorted) {
      var prefixes = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [];
      var word = prefix;
      for (var branch in node) {
        var currentLetter = branch;
        if (branch === _config2.default.END_WORD && typeof node[branch] === "number") {
          if (sorted) {
            pushInOrder(word, prefixes);
          } else {
            prefixes.push(word);
          }
          word = "";
        } else if (branch === _config2.default.END_WORD_REPLACER) {
          currentLetter = _config2.default.END_WORD;
        }
        recursePrefix(node[branch], prefix + currentLetter, sorted, prefixes);
      }
      return prefixes;
    }
    module2.exports = exports["default"];
  }
});
var require_recurseRandomWord3 = __commonJS4({
  "../../node_modules/trie-prefix-tree/dist/recurseRandomWord.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = recurseRandomWord;
    var _config = require_config3();
    var _config2 = _interopRequireDefault(_config);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function recurseRandomWord(node, prefix) {
      var word = prefix;
      var branches = Object.keys(node);
      var branch = branches[Math.floor(Math.random() * branches.length)];
      if (branch === _config2.default.END_WORD) {
        return word;
      }
      return recurseRandomWord(node[branch], prefix + branch);
    }
    module2.exports = exports["default"];
  }
});
var require_permutations3 = __commonJS4({
  "../../node_modules/trie-prefix-tree/dist/permutations.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
      return typeof obj;
    } : function(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    exports.default = permutations;
    var _config = require_config3();
    var _config2 = _interopRequireDefault(_config);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function permutations(letters, trie) {
      var opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
        type: "anagram"
      };
      if (typeof letters !== "string") {
        throw "Permutations expects string letters, received " + (typeof letters === "undefined" ? "undefined" : _typeof(letters));
      }
      var words = [];
      var permute = function permute2(word, node) {
        var prefix = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
        var wordIsEmpty = word.length === 0;
        var wordFound = words.indexOf(prefix) !== -1;
        var endWordFound = node[_config2.default.END_WORD] === 1;
        if (wordIsEmpty && endWordFound && !wordFound) {
          words.push(prefix);
        }
        for (var i = 0, len = word.length; i < len; i++) {
          var letter = word[i];
          if (opts.type === "sub-anagram") {
            if (endWordFound && !(words.indexOf(prefix) !== -1)) {
              words.push(prefix);
            }
          }
          if (node[letter]) {
            var remaining = word.substring(0, i) + word.substring(i + 1, len);
            permute2(remaining, node[letter], prefix + letter, words);
          }
        }
        return words.sort();
      };
      return permute(letters, trie);
    }
    module2.exports = exports["default"];
  }
});
var require_dist3 = __commonJS4({
  "../../node_modules/trie-prefix-tree/dist/index.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
      return typeof obj;
    } : function(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    exports.default = function(input) {
      if (!Array.isArray(input)) {
        throw "Expected parameter Array, received " + (typeof input === "undefined" ? "undefined" : _typeof(input));
      }
      var trie = (0, _create2.default)([].concat(_toConsumableArray(input)));
      return {
        /**
         * Get the generated raw trie object
        */
        tree: function tree() {
          return trie;
        },
        /**
         * Get a string representation of the trie
        */
        dump: function dump() {
          var spacer = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
          return _utils2.default.stringify(trie, spacer);
        },
        /**
         * Add a new word to the trie
         */
        addWord: function addWord(word) {
          if (typeof word !== "string" || word === "") {
            throw "Expected parameter string, received " + (typeof word === "undefined" ? "undefined" : _typeof(word));
          }
          var reducer = function reducer2() {
            return _append2.default.apply(void 0, arguments);
          };
          var input2 = word.toLowerCase().split("");
          input2.reduce(reducer, trie);
          return this;
        },
        /**
         * Remove an existing word from the trie
         */
        removeWord: function removeWord(word) {
          if (typeof word !== "string" || word === "") {
            throw "Expected parameter string, received " + (typeof word === "undefined" ? "undefined" : _typeof(word));
          }
          var _checkPrefix = (0, _checkPrefix6.default)(trie, word), prefixFound = _checkPrefix.prefixFound, prefixNode = _checkPrefix.prefixNode;
          if (prefixFound) {
            delete prefixNode[_config2.default.END_WORD];
          }
          return this;
        },
        /**
         * Check a prefix is valid
         * @returns Boolean
        */
        isPrefix: function isPrefix(prefix) {
          if (typeof prefix !== "string") {
            throw "Expected string prefix, received " + (typeof prefix === "undefined" ? "undefined" : _typeof(prefix));
          }
          var _checkPrefix2 = (0, _checkPrefix6.default)(trie, prefix), prefixFound = _checkPrefix2.prefixFound;
          return prefixFound;
        },
        /**
        * Get a list of all words in the trie with the given prefix
        * @returns Array
        */
        getPrefix: function getPrefix(strPrefix) {
          var sorted = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
          if (typeof strPrefix !== "string") {
            throw "Expected string prefix, received " + (typeof strPrefix === "undefined" ? "undefined" : _typeof(strPrefix));
          }
          if (typeof sorted !== "boolean") {
            throw "Expected sort parameter as boolean, received " + (typeof sorted === "undefined" ? "undefined" : _typeof(sorted));
          }
          if (!this.isPrefix(strPrefix)) {
            return [];
          }
          var prefixNode = strPrefix.length ? (0, _checkPrefix6.default)(trie, strPrefix).prefixNode : trie;
          return (0, _recursePrefix2.default)(prefixNode, strPrefix, sorted);
        },
        /**
        * Get a random word in the trie with the given prefix
        * @returns Array
        */
        getRandomWordWithPrefix: function getRandomWordWithPrefix(strPrefix) {
          if (typeof strPrefix !== "string") {
            throw "Expected string prefix, received " + (typeof strPrefix === "undefined" ? "undefined" : _typeof(strPrefix));
          }
          if (!this.isPrefix(strPrefix)) {
            return "";
          }
          var _checkPrefix3 = (0, _checkPrefix6.default)(trie, strPrefix), prefixNode = _checkPrefix3.prefixNode;
          return (0, _recurseRandomWord2.default)(prefixNode, strPrefix);
        },
        /**
        * Count the number of words with the given prefixSearch
        * @returns Number
        */
        countPrefix: function countPrefix(strPrefix) {
          var prefixes = this.getPrefix(strPrefix);
          return prefixes.length;
        },
        /**
        * Get all words in the trie
        * @returns Array
        */
        getWords: function getWords() {
          var sorted = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
          return this.getPrefix("", sorted);
        },
        /**
        * Check the existence of a word in the trie
        * @returns Boolean
        */
        hasWord: function hasWord(word) {
          if (typeof word !== "string") {
            throw "Expected string word, received " + (typeof word === "undefined" ? "undefined" : _typeof(word));
          }
          var _checkPrefix4 = (0, _checkPrefix6.default)(trie, word), prefixFound = _checkPrefix4.prefixFound, prefixNode = _checkPrefix4.prefixNode;
          if (prefixFound) {
            return prefixNode[_config2.default.END_WORD] === 1;
          }
          return false;
        },
        /**
        * Get a list of valid anagrams that can be made from the given letters
        * @returns Array
        */
        getAnagrams: function getAnagrams(letters) {
          if (typeof letters !== "string") {
            throw "Anagrams expected string letters, received " + (typeof letters === "undefined" ? "undefined" : _typeof(letters));
          }
          if (letters.length < PERMS_MIN_LEN) {
            throw "getAnagrams expects at least " + PERMS_MIN_LEN + " letters";
          }
          return (0, _permutations2.default)(letters, trie, {
            type: "anagram"
          });
        },
        /**
        * Get a list of all sub-anagrams that can be made from the given letters
        * @returns Array
        */
        getSubAnagrams: function getSubAnagrams(letters) {
          if (typeof letters !== "string") {
            throw "Expected string letters, received " + (typeof letters === "undefined" ? "undefined" : _typeof(letters));
          }
          if (letters.length < PERMS_MIN_LEN) {
            throw "getSubAnagrams expects at least " + PERMS_MIN_LEN + " letters";
          }
          return (0, _permutations2.default)(letters, trie, {
            type: "sub-anagram"
          });
        }
      };
    };
    var _create = require_create3();
    var _create2 = _interopRequireDefault(_create);
    var _append = require_append3();
    var _append2 = _interopRequireDefault(_append);
    var _checkPrefix5 = require_checkPrefix3();
    var _checkPrefix6 = _interopRequireDefault(_checkPrefix5);
    var _recursePrefix = require_recursePrefix3();
    var _recursePrefix2 = _interopRequireDefault(_recursePrefix);
    var _recurseRandomWord = require_recurseRandomWord3();
    var _recurseRandomWord2 = _interopRequireDefault(_recurseRandomWord);
    var _utils = require_utils3();
    var _utils2 = _interopRequireDefault(_utils);
    var _config = require_config3();
    var _config2 = _interopRequireDefault(_config);
    var _permutations = require_permutations3();
    var _permutations2 = _interopRequireDefault(_permutations);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _toConsumableArray(arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
          arr2[i] = arr[i];
        }
        return arr2;
      } else {
        return Array.from(arr);
      }
    }
    var PERMS_MIN_LEN = _config2.default.PERMS_MIN_LEN;
    module2.exports = exports["default"];
  }
});
var linebreak34 = Symbol("linebreak");
var ESCAPE34 = "\\";
function _printRaw34(node) {
  if (typeof node === "string") {
    return [node];
  }
  if (Array.isArray(node)) {
    return [].concat(
      ...node.map((n) => _printRaw34(n))
    );
  }
  let argsString, escape;
  switch (node.type) {
    case "root":
      return _printRaw34(node.content);
    case "argument":
      return [node.openMark, ..._printRaw34(node.content), node.closeMark];
    case "comment":
      var suffix = node.suffixParbreak ? "" : linebreak34;
      var leadingWhitespace = "";
      if (node.sameline && node.leadingWhitespace) {
        leadingWhitespace = " ";
      }
      if (node.sameline) {
        return [
          leadingWhitespace,
          "%",
          ..._printRaw34(node.content),
          suffix
        ];
      }
      return [linebreak34, "%", ..._printRaw34(node.content), suffix];
    case "environment":
    case "mathenv":
    case "verbatim":
      var env = _printRaw34(node.env);
      var envStart = [ESCAPE34 + "begin{", ...env, "}"];
      var envEnd = [ESCAPE34 + "end{", ...env, "}"];
      argsString = node.args == null ? [] : _printRaw34(node.args);
      return [
        ...envStart,
        ...argsString,
        ..._printRaw34(node.content),
        ...envEnd
      ];
    case "displaymath":
      return [ESCAPE34 + "[", ..._printRaw34(node.content), ESCAPE34 + "]"];
    case "group":
      return ["{", ..._printRaw34(node.content), "}"];
    case "inlinemath":
      return ["$", ..._printRaw34(node.content), "$"];
    case "macro":
      argsString = node.args == null ? [] : _printRaw34(node.args);
      escape = node.escapeToken == null ? ESCAPE34 : node.escapeToken;
      return [escape, ..._printRaw34(node.content), ...argsString];
    case "parbreak":
      return [linebreak34, linebreak34];
    case "string":
      return [node.content];
    case "verb":
      return [
        ESCAPE34,
        node.env,
        node.escape,
        ..._printRaw34(node.content),
        node.escape
      ];
    case "whitespace":
      return [" "];
    default:
      console.warn(
        "Cannot find render for node ",
        node,
        `(of type ${typeof node})`
      );
      return ["" + node];
  }
}
function printRaw34(node, options) {
  const asArray = options != null ? options.asArray : false;
  const printedTokens = _printRaw34(node);
  if (asArray) {
    return printedTokens;
  }
  return printedTokens.map((x) => x === linebreak34 ? "\n" : x).join("");
}
function createMacroMatcher34(macros15) {
  const macrosHash = Array.isArray(macros15) ? macros15.length > 0 ? typeof macros15[0] === "string" ? Object.fromEntries(
    macros15.map((macro223) => {
      if (typeof macro223 !== "string") {
        throw new Error("Wrong branch of map function");
      }
      return [macro223, {}];
    })
  ) : Object.fromEntries(
    macros15.map((macro223) => {
      if (typeof macro223 === "string") {
        throw new Error("Wrong branch of map function");
      }
      if (macro223.escapeToken != null) {
        return [
          macro223.content,
          { escapeToken: macro223.escapeToken }
        ];
      }
      return [macro223.content, {}];
    })
  ) : {} : macros15;
  return function matchAgainstMacros(node) {
    if (node == null || node.type !== "macro") {
      return false;
    }
    const spec = macrosHash[node.content];
    if (!spec) {
      return false;
    }
    if (typeof spec === "object" && "escapeToken" in spec) {
      return spec.escapeToken == null || spec.escapeToken === node.escapeToken;
    }
    return true;
  };
}
function createEnvironmentMatcher34(macros15) {
  const environmentsHash = Array.isArray(macros15) ? Object.fromEntries(
    macros15.map((str) => {
      return [str, {}];
    })
  ) : macros15;
  return function matchAgainstEnvironments(node) {
    if (!match34.anyEnvironment(node)) {
      return false;
    }
    const envName = printRaw34(node.env);
    const spec = environmentsHash[envName];
    if (!spec) {
      return false;
    }
    return true;
  };
}
var match34 = {
  macro(node, macroName) {
    if (node == null) {
      return false;
    }
    return node.type === "macro" && (macroName == null || node.content === macroName);
  },
  anyMacro(node) {
    return match34.macro(node);
  },
  environment(node, envName) {
    if (node == null) {
      return false;
    }
    return (node.type === "environment" || node.type === "mathenv") && (envName == null || printRaw34(node.env) === envName);
  },
  anyEnvironment(node) {
    return match34.environment(node);
  },
  comment(node) {
    if (node == null) {
      return false;
    }
    return node.type === "comment";
  },
  parbreak(node) {
    if (node == null) {
      return false;
    }
    return node.type === "parbreak";
  },
  whitespace(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace";
  },
  /**
   * Matches whitespace or a comment with leading whitespace.
   */
  whitespaceLike(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace" || node.type === "whitespace" && node.leadingWhitespace === true;
  },
  string(node, value) {
    if (node == null) {
      return false;
    }
    return node.type === "string" && (value == null || node.content === value);
  },
  anyString(node) {
    return match34.string(node);
  },
  group(node) {
    if (node == null) {
      return false;
    }
    return node.type === "group";
  },
  argument(node) {
    if (node == null) {
      return false;
    }
    return node.type === "argument";
  },
  blankArgument(node) {
    if (!match34.argument(node)) {
      return false;
    }
    return node.openMark === "" && node.closeMark === "" && node.content.length === 0;
  },
  math(node) {
    if (node == null) {
      return false;
    }
    return node.type === "displaymath" || node.type === "inlinemath";
  },
  createMacroMatcher: createMacroMatcher34,
  createEnvironmentMatcher: createEnvironmentMatcher34
};
var {
  anyEnvironment: anyEnvironment34,
  anyMacro: anyMacro34,
  anyString: anyString34,
  argument: argument34,
  blankArgument: blankArgument34,
  comment: comment34,
  environment: environment34,
  group: group34,
  macro: macro34,
  math: math34,
  parbreak: parbreak34,
  string: string34,
  whitespace: whitespace34
} = match34;
var linebreak223 = Symbol("linebreak");
var ESCAPE223 = "\\";
function _printRaw223(node) {
  if (typeof node === "string") {
    return [node];
  }
  if (Array.isArray(node)) {
    return [].concat(
      ...node.map((n) => _printRaw223(n))
    );
  }
  let argsString, escape;
  switch (node.type) {
    case "root":
      return _printRaw223(node.content);
    case "argument":
      return [node.openMark, ..._printRaw223(node.content), node.closeMark];
    case "comment":
      var suffix = node.suffixParbreak ? "" : linebreak223;
      var leadingWhitespace = "";
      if (node.sameline && node.leadingWhitespace) {
        leadingWhitespace = " ";
      }
      if (node.sameline) {
        return [
          leadingWhitespace,
          "%",
          ..._printRaw223(node.content),
          suffix
        ];
      }
      return [linebreak223, "%", ..._printRaw223(node.content), suffix];
    case "environment":
    case "mathenv":
    case "verbatim":
      var env = _printRaw223(node.env);
      var envStart = [ESCAPE223 + "begin{", ...env, "}"];
      var envEnd = [ESCAPE223 + "end{", ...env, "}"];
      argsString = node.args == null ? [] : _printRaw223(node.args);
      return [
        ...envStart,
        ...argsString,
        ..._printRaw223(node.content),
        ...envEnd
      ];
    case "displaymath":
      return [ESCAPE223 + "[", ..._printRaw223(node.content), ESCAPE223 + "]"];
    case "group":
      return ["{", ..._printRaw223(node.content), "}"];
    case "inlinemath":
      return ["$", ..._printRaw223(node.content), "$"];
    case "macro":
      argsString = node.args == null ? [] : _printRaw223(node.args);
      escape = node.escapeToken == null ? ESCAPE223 : node.escapeToken;
      return [escape, ..._printRaw223(node.content), ...argsString];
    case "parbreak":
      return [linebreak223, linebreak223];
    case "string":
      return [node.content];
    case "verb":
      return [
        ESCAPE223,
        node.env,
        node.escape,
        ..._printRaw223(node.content),
        node.escape
      ];
    case "whitespace":
      return [" "];
    default:
      console.warn(
        "Cannot find render for node ",
        node,
        `(of type ${typeof node})`
      );
      return ["" + node];
  }
}
function printRaw223(node, options) {
  const asArray = options != null ? options.asArray : false;
  const printedTokens = _printRaw223(node);
  if (asArray) {
    return printedTokens;
  }
  return printedTokens.map((x) => x === linebreak223 ? "\n" : x).join("");
}
function scan3(nodes, token, options) {
  const { startIndex, onlySkipWhitespaceAndComments, allowSubstringMatches } = options || {};
  if (typeof token === "string") {
    token = { type: "string", content: token };
  }
  for (let i = startIndex || 0; i < nodes.length; i++) {
    const node = nodes[i];
    if (node.type === token.type) {
      switch (node.type) {
        case "comment":
        case "displaymath":
        case "inlinemath":
        case "root":
        case "parbreak":
        case "whitespace":
        case "verb":
        case "verbatim":
        case "group":
          return i;
        case "macro":
          if (node.content === token.content) {
            return i;
          }
          break;
        case "environment":
        case "mathenv":
          if (printRaw223(node.env) === printRaw223(token.env)) {
            return i;
          }
          break;
        case "string":
          if (node.content === token.content) {
            return i;
          }
          if (allowSubstringMatches && node.content.indexOf(token.content) >= 0) {
            return i;
          }
          break;
      }
    }
    if (onlySkipWhitespaceAndComments && !match34.whitespace(node) && !match34.comment(node)) {
      return null;
    }
  }
  return null;
}
var import_trie_prefix_tree3 = __toESM4(require_dist3(), 1);
var export_Trie3 = import_trie_prefix_tree3.default;
function gobbleSingleArgument2(nodes, argSpec, startPos = 0) {
  if (typeof argSpec === "string" || !argSpec.type) {
    throw new Error(
      `argSpec must be an already-parsed argument specification, not "${JSON.stringify(
        argSpec
      )}"`
    );
  }
  let argument63 = null;
  let currPos = startPos;
  const gobbleWhitespace = argSpec.noLeadingWhitespace ? () => {
  } : () => {
    while (currPos < nodes.length) {
      if (!match27.whitespace(nodes[currPos])) {
        break;
      }
      currPos++;
    }
  };
  const openMark = argSpec.openBrace || "";
  const closeMark = argSpec.closeBrace || "";
  const acceptGroup = (argSpec.type === "mandatory" || argSpec.type === "optional") && openMark === "{" && closeMark === "}";
  function findBracePositions() {
    let openMarkPos = null;
    if (openMark) {
      openMarkPos = nodes.findIndex(
        (node, i) => i >= currPos && match27.string(node, openMark)
      );
      if (openMarkPos < currPos) {
        openMarkPos = null;
      }
    }
    let closeMarkPos = null;
    if (openMarkPos != null) {
      closeMarkPos = nodes.findIndex(
        (node, i) => i >= openMarkPos + 1 && match27.string(node, closeMark)
      );
      if (closeMarkPos < openMarkPos + 1) {
        closeMarkPos = null;
      }
    }
    return [openMarkPos, closeMarkPos];
  }
  gobbleWhitespace();
  const currNode = nodes[currPos];
  if (currNode == null || match27.comment(currNode) || match27.parbreak(currNode)) {
    return { argument: argument63, nodesRemoved: 0 };
  }
  switch (argSpec.type) {
    case "mandatory":
      if (acceptGroup) {
        let content = [currNode];
        if (match27.group(currNode)) {
          content = currNode.content;
        }
        argument63 = arg3(content, {
          openMark,
          closeMark
        });
        currPos++;
        break;
      }
    case "optional":
      if (acceptGroup && match27.group(currNode)) {
        argument63 = arg3(currNode.content, {
          openMark,
          closeMark
        });
        currPos++;
        break;
      }
      if (match27.string(currNode, openMark)) {
        const [openMarkPos, closeMarkPos] = findBracePositions();
        if (openMarkPos != null && closeMarkPos != null) {
          argument63 = arg3(nodes.slice(openMarkPos + 1, closeMarkPos), {
            openMark,
            closeMark
          });
          currPos = closeMarkPos + 1;
          break;
        }
      }
      break;
    case "optionalStar":
    case "optionalToken":
      if (match27.string(
        currNode,
        argSpec.type === "optionalStar" ? "*" : argSpec.token
      )) {
        argument63 = arg3([currNode], { openMark: "", closeMark: "" });
        currPos++;
        break;
      }
      break;
    case "until": {
      if (argSpec.stopTokens.length > 1) {
        console.warn(
          `"until" matches with multi-token stop conditions are not yet implemented`
        );
        break;
      }
      const rawToken = argSpec.stopTokens[0];
      const stopToken = rawToken === " " ? { type: "whitespace" } : { type: "string", content: argSpec.stopTokens[0] };
      let matchPos = scan3(nodes, stopToken, {
        startIndex: startPos,
        allowSubstringMatches: true
      });
      if (matchPos != null && partialStringMatch2(nodes[matchPos], stopToken)) {
        console.warn(
          `"until" arguments that stop at non-punctuation symbols is not yet implemented`
        );
        break;
      }
      if (matchPos == null) {
        break;
      }
      argument63 = arg3(nodes.slice(startPos, matchPos), {
        openMark: "",
        closeMark: rawToken
      });
      currPos = matchPos;
      if (currPos < nodes.length) {
        currPos++;
      }
      break;
    }
    default:
      console.warn(
        `Don't know how to find an argument of argspec type "${argSpec.type}"`
      );
  }
  const nodesRemoved = argument63 ? currPos - startPos : 0;
  nodes.splice(startPos, nodesRemoved);
  return { argument: argument63, nodesRemoved };
}
function partialStringMatch2(node, token) {
  return match27.anyString(node) && match27.anyString(token) && node.content.length > token.content.length;
}
function gobbleArguments2(nodes, argSpec, startPos = 0) {
  if (typeof argSpec === "function") {
    return argSpec(nodes, startPos);
  }
  if (typeof argSpec === "string") {
    argSpec = parse2(argSpec);
  }
  const args = [];
  let nodesRemoved = 0;
  for (const spec of argSpec) {
    const { argument: argument63, nodesRemoved: removed } = gobbleSingleArgument2(
      nodes,
      spec,
      startPos
    );
    if (argument63) {
      args.push(argument63);
      nodesRemoved += removed;
    } else {
      args.push(arg3([], { openMark: "", closeMark: "" }));
    }
  }
  return { args, nodesRemoved };
}
var linebreak43 = Symbol("linebreak");
var ESCAPE43 = "\\";
function _printRaw43(node) {
  if (typeof node === "string") {
    return [node];
  }
  if (Array.isArray(node)) {
    return [].concat(
      ...node.map((n) => _printRaw43(n))
    );
  }
  let argsString, escape;
  switch (node.type) {
    case "root":
      return _printRaw43(node.content);
    case "argument":
      return [node.openMark, ..._printRaw43(node.content), node.closeMark];
    case "comment":
      var suffix = node.suffixParbreak ? "" : linebreak43;
      var leadingWhitespace = "";
      if (node.sameline && node.leadingWhitespace) {
        leadingWhitespace = " ";
      }
      if (node.sameline) {
        return [
          leadingWhitespace,
          "%",
          ..._printRaw43(node.content),
          suffix
        ];
      }
      return [linebreak43, "%", ..._printRaw43(node.content), suffix];
    case "environment":
    case "mathenv":
    case "verbatim":
      var env = _printRaw43(node.env);
      var envStart = [ESCAPE43 + "begin{", ...env, "}"];
      var envEnd = [ESCAPE43 + "end{", ...env, "}"];
      argsString = node.args == null ? [] : _printRaw43(node.args);
      return [
        ...envStart,
        ...argsString,
        ..._printRaw43(node.content),
        ...envEnd
      ];
    case "displaymath":
      return [ESCAPE43 + "[", ..._printRaw43(node.content), ESCAPE43 + "]"];
    case "group":
      return ["{", ..._printRaw43(node.content), "}"];
    case "inlinemath":
      return ["$", ..._printRaw43(node.content), "$"];
    case "macro":
      argsString = node.args == null ? [] : _printRaw43(node.args);
      escape = node.escapeToken == null ? ESCAPE43 : node.escapeToken;
      return [escape, ..._printRaw43(node.content), ...argsString];
    case "parbreak":
      return [linebreak43, linebreak43];
    case "string":
      return [node.content];
    case "verb":
      return [
        ESCAPE43,
        node.env,
        node.escape,
        ..._printRaw43(node.content),
        node.escape
      ];
    case "whitespace":
      return [" "];
    default:
      console.warn(
        "Cannot find render for node ",
        node,
        `(of type ${typeof node})`
      );
      return ["" + node];
  }
}
function printRaw43(node, options) {
  const asArray = options != null ? options.asArray : false;
  const printedTokens = _printRaw43(node);
  if (asArray) {
    return printedTokens;
  }
  return printedTokens.map((x) => x === linebreak43 ? "\n" : x).join("");
}
function createMacroMatcher43(macros15) {
  const macrosHash = Array.isArray(macros15) ? macros15.length > 0 ? typeof macros15[0] === "string" ? Object.fromEntries(
    macros15.map((macro223) => {
      if (typeof macro223 !== "string") {
        throw new Error("Wrong branch of map function");
      }
      return [macro223, {}];
    })
  ) : Object.fromEntries(
    macros15.map((macro223) => {
      if (typeof macro223 === "string") {
        throw new Error("Wrong branch of map function");
      }
      if (macro223.escapeToken != null) {
        return [
          macro223.content,
          { escapeToken: macro223.escapeToken }
        ];
      }
      return [macro223.content, {}];
    })
  ) : {} : macros15;
  return function matchAgainstMacros(node) {
    if (node == null || node.type !== "macro") {
      return false;
    }
    const spec = macrosHash[node.content];
    if (!spec) {
      return false;
    }
    if (typeof spec === "object" && "escapeToken" in spec) {
      return spec.escapeToken == null || spec.escapeToken === node.escapeToken;
    }
    return true;
  };
}
function createEnvironmentMatcher43(macros15) {
  const environmentsHash = Array.isArray(macros15) ? Object.fromEntries(
    macros15.map((str) => {
      return [str, {}];
    })
  ) : macros15;
  return function matchAgainstEnvironments(node) {
    if (!match43.anyEnvironment(node)) {
      return false;
    }
    const envName = printRaw43(node.env);
    const spec = environmentsHash[envName];
    if (!spec) {
      return false;
    }
    return true;
  };
}
var match43 = {
  macro(node, macroName) {
    if (node == null) {
      return false;
    }
    return node.type === "macro" && (macroName == null || node.content === macroName);
  },
  anyMacro(node) {
    return match43.macro(node);
  },
  environment(node, envName) {
    if (node == null) {
      return false;
    }
    return (node.type === "environment" || node.type === "mathenv") && (envName == null || printRaw43(node.env) === envName);
  },
  anyEnvironment(node) {
    return match43.environment(node);
  },
  comment(node) {
    if (node == null) {
      return false;
    }
    return node.type === "comment";
  },
  parbreak(node) {
    if (node == null) {
      return false;
    }
    return node.type === "parbreak";
  },
  whitespace(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace";
  },
  /**
   * Matches whitespace or a comment with leading whitespace.
   */
  whitespaceLike(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace" || node.type === "whitespace" && node.leadingWhitespace === true;
  },
  string(node, value) {
    if (node == null) {
      return false;
    }
    return node.type === "string" && (value == null || node.content === value);
  },
  anyString(node) {
    return match43.string(node);
  },
  group(node) {
    if (node == null) {
      return false;
    }
    return node.type === "group";
  },
  argument(node) {
    if (node == null) {
      return false;
    }
    return node.type === "argument";
  },
  blankArgument(node) {
    if (!match43.argument(node)) {
      return false;
    }
    return node.openMark === "" && node.closeMark === "" && node.content.length === 0;
  },
  math(node) {
    if (node == null) {
      return false;
    }
    return node.type === "displaymath" || node.type === "inlinemath";
  },
  createMacroMatcher: createMacroMatcher43,
  createEnvironmentMatcher: createEnvironmentMatcher43
};
var {
  anyEnvironment: anyEnvironment43,
  anyMacro: anyMacro43,
  anyString: anyString43,
  argument: argument43,
  blankArgument: blankArgument43,
  comment: comment43,
  environment: environment43,
  group: group43,
  macro: macro43,
  math: math43,
  parbreak: parbreak43,
  string: string43,
  whitespace: whitespace43
} = match43;
var CONTINUE9 = Symbol("continue");
var SKIP9 = Symbol("skip");
var EXIT9 = Symbol("exit");
function updateRenderInfo3(node, renderInfo) {
  if (renderInfo != null) {
    node._renderInfo = { ...node._renderInfo || {}, ...renderInfo };
  }
  return node;
}
var linebreak53 = Symbol("linebreak");
var ESCAPE53 = "\\";
function _printRaw53(node) {
  if (typeof node === "string") {
    return [node];
  }
  if (Array.isArray(node)) {
    return [].concat(
      ...node.map((n) => _printRaw53(n))
    );
  }
  let argsString, escape;
  switch (node.type) {
    case "root":
      return _printRaw53(node.content);
    case "argument":
      return [node.openMark, ..._printRaw53(node.content), node.closeMark];
    case "comment":
      var suffix = node.suffixParbreak ? "" : linebreak53;
      var leadingWhitespace = "";
      if (node.sameline && node.leadingWhitespace) {
        leadingWhitespace = " ";
      }
      if (node.sameline) {
        return [
          leadingWhitespace,
          "%",
          ..._printRaw53(node.content),
          suffix
        ];
      }
      return [linebreak53, "%", ..._printRaw53(node.content), suffix];
    case "environment":
    case "mathenv":
    case "verbatim":
      var env = _printRaw53(node.env);
      var envStart = [ESCAPE53 + "begin{", ...env, "}"];
      var envEnd = [ESCAPE53 + "end{", ...env, "}"];
      argsString = node.args == null ? [] : _printRaw53(node.args);
      return [
        ...envStart,
        ...argsString,
        ..._printRaw53(node.content),
        ...envEnd
      ];
    case "displaymath":
      return [ESCAPE53 + "[", ..._printRaw53(node.content), ESCAPE53 + "]"];
    case "group":
      return ["{", ..._printRaw53(node.content), "}"];
    case "inlinemath":
      return ["$", ..._printRaw53(node.content), "$"];
    case "macro":
      argsString = node.args == null ? [] : _printRaw53(node.args);
      escape = node.escapeToken == null ? ESCAPE53 : node.escapeToken;
      return [escape, ..._printRaw53(node.content), ...argsString];
    case "parbreak":
      return [linebreak53, linebreak53];
    case "string":
      return [node.content];
    case "verb":
      return [
        ESCAPE53,
        node.env,
        node.escape,
        ..._printRaw53(node.content),
        node.escape
      ];
    case "whitespace":
      return [" "];
    default:
      console.warn(
        "Cannot find render for node ",
        node,
        `(of type ${typeof node})`
      );
      return ["" + node];
  }
}
function printRaw53(node, options) {
  const asArray = options != null ? options.asArray : false;
  const printedTokens = _printRaw53(node);
  if (asArray) {
    return printedTokens;
  }
  return printedTokens.map((x) => x === linebreak53 ? "\n" : x).join("");
}
function createMacroMatcher53(macros15) {
  const macrosHash = Array.isArray(macros15) ? macros15.length > 0 ? typeof macros15[0] === "string" ? Object.fromEntries(
    macros15.map((macro223) => {
      if (typeof macro223 !== "string") {
        throw new Error("Wrong branch of map function");
      }
      return [macro223, {}];
    })
  ) : Object.fromEntries(
    macros15.map((macro223) => {
      if (typeof macro223 === "string") {
        throw new Error("Wrong branch of map function");
      }
      if (macro223.escapeToken != null) {
        return [
          macro223.content,
          { escapeToken: macro223.escapeToken }
        ];
      }
      return [macro223.content, {}];
    })
  ) : {} : macros15;
  return function matchAgainstMacros(node) {
    if (node == null || node.type !== "macro") {
      return false;
    }
    const spec = macrosHash[node.content];
    if (!spec) {
      return false;
    }
    if (typeof spec === "object" && "escapeToken" in spec) {
      return spec.escapeToken == null || spec.escapeToken === node.escapeToken;
    }
    return true;
  };
}
function createEnvironmentMatcher53(macros15) {
  const environmentsHash = Array.isArray(macros15) ? Object.fromEntries(
    macros15.map((str) => {
      return [str, {}];
    })
  ) : macros15;
  return function matchAgainstEnvironments(node) {
    if (!match53.anyEnvironment(node)) {
      return false;
    }
    const envName = printRaw53(node.env);
    const spec = environmentsHash[envName];
    if (!spec) {
      return false;
    }
    return true;
  };
}
var match53 = {
  macro(node, macroName) {
    if (node == null) {
      return false;
    }
    return node.type === "macro" && (macroName == null || node.content === macroName);
  },
  anyMacro(node) {
    return match53.macro(node);
  },
  environment(node, envName) {
    if (node == null) {
      return false;
    }
    return (node.type === "environment" || node.type === "mathenv") && (envName == null || printRaw53(node.env) === envName);
  },
  anyEnvironment(node) {
    return match53.environment(node);
  },
  comment(node) {
    if (node == null) {
      return false;
    }
    return node.type === "comment";
  },
  parbreak(node) {
    if (node == null) {
      return false;
    }
    return node.type === "parbreak";
  },
  whitespace(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace";
  },
  /**
   * Matches whitespace or a comment with leading whitespace.
   */
  whitespaceLike(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace" || node.type === "whitespace" && node.leadingWhitespace === true;
  },
  string(node, value) {
    if (node == null) {
      return false;
    }
    return node.type === "string" && (value == null || node.content === value);
  },
  anyString(node) {
    return match53.string(node);
  },
  group(node) {
    if (node == null) {
      return false;
    }
    return node.type === "group";
  },
  argument(node) {
    if (node == null) {
      return false;
    }
    return node.type === "argument";
  },
  blankArgument(node) {
    if (!match53.argument(node)) {
      return false;
    }
    return node.openMark === "" && node.closeMark === "" && node.content.length === 0;
  },
  math(node) {
    if (node == null) {
      return false;
    }
    return node.type === "displaymath" || node.type === "inlinemath";
  },
  createMacroMatcher: createMacroMatcher53,
  createEnvironmentMatcher: createEnvironmentMatcher53
};
var {
  anyEnvironment: anyEnvironment53,
  anyMacro: anyMacro53,
  anyString: anyString53,
  argument: argument53,
  blankArgument: blankArgument53,
  comment: comment53,
  environment: environment53,
  group: group53,
  macro: macro53,
  math: math53,
  parbreak: parbreak53,
  string: string53,
  whitespace: whitespace53
} = match53;
var CONTINUE24 = Symbol("continue");
var SKIP24 = Symbol("skip");
var EXIT24 = Symbol("exit");
function attachMacroArgsInArray2(nodes, macros15) {
  let currIndex;
  const isRelevantMacro = match27.createMacroMatcher(macros15);
  function gobbleUntilMacro() {
    while (currIndex >= 0 && !isRelevantMacro(nodes[currIndex])) {
      currIndex--;
    }
  }
  currIndex = nodes.length - 1;
  while (currIndex >= 0) {
    gobbleUntilMacro();
    if (currIndex < 0) {
      return;
    }
    const macroIndex = currIndex;
    const macro63 = nodes[macroIndex];
    const macroName = macro63.content;
    const macroInfo2 = macros15[macroName];
    updateRenderInfo3(macro63, macroInfo2.renderInfo);
    const signatureOrParser = macroInfo2.argumentParser || macroInfo2.signature;
    if (signatureOrParser == null) {
      currIndex--;
      continue;
    }
    if (macro63.args != null) {
      currIndex = macroIndex - 1;
      continue;
    }
    currIndex++;
    const { args } = gobbleArguments2(nodes, signatureOrParser, currIndex);
    macro63.args = args;
    currIndex = macroIndex - 1;
  }
}

// ../unified-latex-util-environments/dist/index.js
var linebreak20 = Symbol("linebreak");
var ESCAPE19 = "\\";
function _printRaw19(node) {
  if (typeof node === "string") {
    return [node];
  }
  if (Array.isArray(node)) {
    return [].concat(
      ...node.map((n) => _printRaw19(n))
    );
  }
  let argsString, escape;
  switch (node.type) {
    case "root":
      return _printRaw19(node.content);
    case "argument":
      return [node.openMark, ..._printRaw19(node.content), node.closeMark];
    case "comment":
      var suffix = node.suffixParbreak ? "" : linebreak20;
      var leadingWhitespace = "";
      if (node.sameline && node.leadingWhitespace) {
        leadingWhitespace = " ";
      }
      if (node.sameline) {
        return [
          leadingWhitespace,
          "%",
          ..._printRaw19(node.content),
          suffix
        ];
      }
      return [linebreak20, "%", ..._printRaw19(node.content), suffix];
    case "environment":
    case "mathenv":
    case "verbatim":
      var env = _printRaw19(node.env);
      var envStart = [ESCAPE19 + "begin{", ...env, "}"];
      var envEnd = [ESCAPE19 + "end{", ...env, "}"];
      argsString = node.args == null ? [] : _printRaw19(node.args);
      return [
        ...envStart,
        ...argsString,
        ..._printRaw19(node.content),
        ...envEnd
      ];
    case "displaymath":
      return [ESCAPE19 + "[", ..._printRaw19(node.content), ESCAPE19 + "]"];
    case "group":
      return ["{", ..._printRaw19(node.content), "}"];
    case "inlinemath":
      return ["$", ..._printRaw19(node.content), "$"];
    case "macro":
      argsString = node.args == null ? [] : _printRaw19(node.args);
      escape = node.escapeToken == null ? ESCAPE19 : node.escapeToken;
      return [escape, ..._printRaw19(node.content), ...argsString];
    case "parbreak":
      return [linebreak20, linebreak20];
    case "string":
      return [node.content];
    case "verb":
      return [
        ESCAPE19,
        node.env,
        node.escape,
        ..._printRaw19(node.content),
        node.escape
      ];
    case "whitespace":
      return [" "];
    default:
      console.warn(
        "Cannot find render for node ",
        node,
        `(of type ${typeof node})`
      );
      return ["" + node];
  }
}
function printRaw19(node, options) {
  const asArray = options != null ? options.asArray : false;
  const printedTokens = _printRaw19(node);
  if (asArray) {
    return printedTokens;
  }
  return printedTokens.map((x) => x === linebreak20 ? "\n" : x).join("");
}
function createMacroMatcher18(macros15) {
  const macrosHash = Array.isArray(macros15) ? macros15.length > 0 ? typeof macros15[0] === "string" ? Object.fromEntries(
    macros15.map((macro232) => {
      if (typeof macro232 !== "string") {
        throw new Error("Wrong branch of map function");
      }
      return [macro232, {}];
    })
  ) : Object.fromEntries(
    macros15.map((macro232) => {
      if (typeof macro232 === "string") {
        throw new Error("Wrong branch of map function");
      }
      if (macro232.escapeToken != null) {
        return [
          macro232.content,
          { escapeToken: macro232.escapeToken }
        ];
      }
      return [macro232.content, {}];
    })
  ) : {} : macros15;
  return function matchAgainstMacros(node) {
    if (node == null || node.type !== "macro") {
      return false;
    }
    const spec = macrosHash[node.content];
    if (!spec) {
      return false;
    }
    if (typeof spec === "object" && "escapeToken" in spec) {
      return spec.escapeToken == null || spec.escapeToken === node.escapeToken;
    }
    return true;
  };
}
function createEnvironmentMatcher18(macros15) {
  const environmentsHash = Array.isArray(macros15) ? Object.fromEntries(
    macros15.map((str) => {
      return [str, {}];
    })
  ) : macros15;
  return function matchAgainstEnvironments(node) {
    if (!match18.anyEnvironment(node)) {
      return false;
    }
    const envName = printRaw19(node.env);
    const spec = environmentsHash[envName];
    if (!spec) {
      return false;
    }
    return true;
  };
}
var match18 = {
  macro(node, macroName) {
    if (node == null) {
      return false;
    }
    return node.type === "macro" && (macroName == null || node.content === macroName);
  },
  anyMacro(node) {
    return match18.macro(node);
  },
  environment(node, envName) {
    if (node == null) {
      return false;
    }
    return (node.type === "environment" || node.type === "mathenv") && (envName == null || printRaw19(node.env) === envName);
  },
  anyEnvironment(node) {
    return match18.environment(node);
  },
  comment(node) {
    if (node == null) {
      return false;
    }
    return node.type === "comment";
  },
  parbreak(node) {
    if (node == null) {
      return false;
    }
    return node.type === "parbreak";
  },
  whitespace(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace";
  },
  /**
   * Matches whitespace or a comment with leading whitespace.
   */
  whitespaceLike(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace" || node.type === "whitespace" && node.leadingWhitespace === true;
  },
  string(node, value) {
    if (node == null) {
      return false;
    }
    return node.type === "string" && (value == null || node.content === value);
  },
  anyString(node) {
    return match18.string(node);
  },
  group(node) {
    if (node == null) {
      return false;
    }
    return node.type === "group";
  },
  argument(node) {
    if (node == null) {
      return false;
    }
    return node.type === "argument";
  },
  blankArgument(node) {
    if (!match18.argument(node)) {
      return false;
    }
    return node.openMark === "" && node.closeMark === "" && node.content.length === 0;
  },
  math(node) {
    if (node == null) {
      return false;
    }
    return node.type === "displaymath" || node.type === "inlinemath";
  },
  createMacroMatcher: createMacroMatcher18,
  createEnvironmentMatcher: createEnvironmentMatcher18
};
var {
  anyEnvironment: anyEnvironment18,
  anyMacro: anyMacro18,
  anyString: anyString18,
  argument: argument18,
  blankArgument: blankArgument18,
  comment: comment18,
  environment: environment18,
  group: group18,
  macro: macro18,
  math: math18,
  parbreak: parbreak18,
  string: string18,
  whitespace: whitespace18
} = match18;
var CONTINUE10 = Symbol("continue");
var SKIP10 = Symbol("skip");
var EXIT10 = Symbol("exit");
function updateRenderInfo4(node, renderInfo) {
  if (renderInfo != null) {
    node._renderInfo = { ...node._renderInfo || {}, ...renderInfo };
  }
  return node;
}
var linebreak29 = Symbol("linebreak");
var ESCAPE29 = "\\";
function _printRaw29(node) {
  if (typeof node === "string") {
    return [node];
  }
  if (Array.isArray(node)) {
    return [].concat(
      ...node.map((n) => _printRaw29(n))
    );
  }
  let argsString, escape;
  switch (node.type) {
    case "root":
      return _printRaw29(node.content);
    case "argument":
      return [node.openMark, ..._printRaw29(node.content), node.closeMark];
    case "comment":
      var suffix = node.suffixParbreak ? "" : linebreak29;
      var leadingWhitespace = "";
      if (node.sameline && node.leadingWhitespace) {
        leadingWhitespace = " ";
      }
      if (node.sameline) {
        return [
          leadingWhitespace,
          "%",
          ..._printRaw29(node.content),
          suffix
        ];
      }
      return [linebreak29, "%", ..._printRaw29(node.content), suffix];
    case "environment":
    case "mathenv":
    case "verbatim":
      var env = _printRaw29(node.env);
      var envStart = [ESCAPE29 + "begin{", ...env, "}"];
      var envEnd = [ESCAPE29 + "end{", ...env, "}"];
      argsString = node.args == null ? [] : _printRaw29(node.args);
      return [
        ...envStart,
        ...argsString,
        ..._printRaw29(node.content),
        ...envEnd
      ];
    case "displaymath":
      return [ESCAPE29 + "[", ..._printRaw29(node.content), ESCAPE29 + "]"];
    case "group":
      return ["{", ..._printRaw29(node.content), "}"];
    case "inlinemath":
      return ["$", ..._printRaw29(node.content), "$"];
    case "macro":
      argsString = node.args == null ? [] : _printRaw29(node.args);
      escape = node.escapeToken == null ? ESCAPE29 : node.escapeToken;
      return [escape, ..._printRaw29(node.content), ...argsString];
    case "parbreak":
      return [linebreak29, linebreak29];
    case "string":
      return [node.content];
    case "verb":
      return [
        ESCAPE29,
        node.env,
        node.escape,
        ..._printRaw29(node.content),
        node.escape
      ];
    case "whitespace":
      return [" "];
    default:
      console.warn(
        "Cannot find render for node ",
        node,
        `(of type ${typeof node})`
      );
      return ["" + node];
  }
}
function printRaw29(node, options) {
  const asArray = options != null ? options.asArray : false;
  const printedTokens = _printRaw29(node);
  if (asArray) {
    return printedTokens;
  }
  return printedTokens.map((x) => x === linebreak29 ? "\n" : x).join("");
}
function createMacroMatcher28(macros15) {
  const macrosHash = Array.isArray(macros15) ? macros15.length > 0 ? typeof macros15[0] === "string" ? Object.fromEntries(
    macros15.map((macro2222) => {
      if (typeof macro2222 !== "string") {
        throw new Error("Wrong branch of map function");
      }
      return [macro2222, {}];
    })
  ) : Object.fromEntries(
    macros15.map((macro2222) => {
      if (typeof macro2222 === "string") {
        throw new Error("Wrong branch of map function");
      }
      if (macro2222.escapeToken != null) {
        return [
          macro2222.content,
          { escapeToken: macro2222.escapeToken }
        ];
      }
      return [macro2222.content, {}];
    })
  ) : {} : macros15;
  return function matchAgainstMacros(node) {
    if (node == null || node.type !== "macro") {
      return false;
    }
    const spec = macrosHash[node.content];
    if (!spec) {
      return false;
    }
    if (typeof spec === "object" && "escapeToken" in spec) {
      return spec.escapeToken == null || spec.escapeToken === node.escapeToken;
    }
    return true;
  };
}
function createEnvironmentMatcher28(macros15) {
  const environmentsHash = Array.isArray(macros15) ? Object.fromEntries(
    macros15.map((str) => {
      return [str, {}];
    })
  ) : macros15;
  return function matchAgainstEnvironments(node) {
    if (!match28.anyEnvironment(node)) {
      return false;
    }
    const envName = printRaw29(node.env);
    const spec = environmentsHash[envName];
    if (!spec) {
      return false;
    }
    return true;
  };
}
var match28 = {
  macro(node, macroName) {
    if (node == null) {
      return false;
    }
    return node.type === "macro" && (macroName == null || node.content === macroName);
  },
  anyMacro(node) {
    return match28.macro(node);
  },
  environment(node, envName) {
    if (node == null) {
      return false;
    }
    return (node.type === "environment" || node.type === "mathenv") && (envName == null || printRaw29(node.env) === envName);
  },
  anyEnvironment(node) {
    return match28.environment(node);
  },
  comment(node) {
    if (node == null) {
      return false;
    }
    return node.type === "comment";
  },
  parbreak(node) {
    if (node == null) {
      return false;
    }
    return node.type === "parbreak";
  },
  whitespace(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace";
  },
  /**
   * Matches whitespace or a comment with leading whitespace.
   */
  whitespaceLike(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace" || node.type === "whitespace" && node.leadingWhitespace === true;
  },
  string(node, value) {
    if (node == null) {
      return false;
    }
    return node.type === "string" && (value == null || node.content === value);
  },
  anyString(node) {
    return match28.string(node);
  },
  group(node) {
    if (node == null) {
      return false;
    }
    return node.type === "group";
  },
  argument(node) {
    if (node == null) {
      return false;
    }
    return node.type === "argument";
  },
  blankArgument(node) {
    if (!match28.argument(node)) {
      return false;
    }
    return node.openMark === "" && node.closeMark === "" && node.content.length === 0;
  },
  math(node) {
    if (node == null) {
      return false;
    }
    return node.type === "displaymath" || node.type === "inlinemath";
  },
  createMacroMatcher: createMacroMatcher28,
  createEnvironmentMatcher: createEnvironmentMatcher28
};
var {
  anyEnvironment: anyEnvironment28,
  anyMacro: anyMacro28,
  anyString: anyString28,
  argument: argument28,
  blankArgument: blankArgument28,
  comment: comment28,
  environment: environment28,
  group: group28,
  macro: macro28,
  math: math28,
  parbreak: parbreak28,
  string: string28,
  whitespace: whitespace28
} = match28;
var latex_default6 = (
  // Generated by Peggy 2.0.1.
  //
  // https://peggyjs.org/
  function() {
    "use strict";
    function peg$subclass(child, parent) {
      function C() {
        this.constructor = child;
      }
      C.prototype = parent.prototype;
      child.prototype = new C();
    }
    function peg$SyntaxError(message, expected, found, location) {
      var self = Error.call(this, message);
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(self, peg$SyntaxError.prototype);
      }
      self.expected = expected;
      self.found = found;
      self.location = location;
      self.name = "SyntaxError";
      return self;
    }
    peg$subclass(peg$SyntaxError, Error);
    function peg$padEnd(str, targetLength, padString) {
      padString = padString || " ";
      if (str.length > targetLength) {
        return str;
      }
      targetLength -= str.length;
      padString += padString.repeat(targetLength);
      return str + padString.slice(0, targetLength);
    }
    peg$SyntaxError.prototype.format = function(sources) {
      var str = "Error: " + this.message;
      if (this.location) {
        var src = null;
        var k;
        for (k = 0; k < sources.length; k++) {
          if (sources[k].source === this.location.source) {
            src = sources[k].text.split(/\r\n|\n|\r/g);
            break;
          }
        }
        var s22 = this.location.start;
        var loc = this.location.source + ":" + s22.line + ":" + s22.column;
        if (src) {
          var e = this.location.end;
          var filler = peg$padEnd("", s22.line.toString().length, " ");
          var line = src[s22.line - 1];
          var last = s22.line === e.line ? e.column : line.length + 1;
          var hatLen = last - s22.column || 1;
          str += "\n --> " + loc + "\n" + filler + " |\n" + s22.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s22.column - 1, " ") + peg$padEnd("", hatLen, "^");
        } else {
          str += "\n at " + loc;
        }
      }
      return str;
    };
    peg$SyntaxError.buildMessage = function(expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        class: function(expectation) {
          var escapedParts = expectation.parts.map(function(part) {
            return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
          });
          return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
        },
        any: function() {
          return "any character";
        },
        end: function() {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        }
      };
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s22) {
        return s22.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function classEscape(s22) {
        return s22.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = expected2.map(describeExpectation);
        var i, j;
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {};
      var peg$source = options.grammarSource;
      var peg$startRuleFunctions = { document: peg$parsedocument, math: peg$parsemath };
      var peg$startRuleFunction = peg$parsedocument;
      var peg$c0 = "%";
      var peg$c1 = ".";
      var peg$c2 = "verb*";
      var peg$c3 = "verb";
      var peg$c4 = "verbatim*";
      var peg$c5 = "verbatim";
      var peg$c6 = "filecontents*";
      var peg$c7 = "filecontents";
      var peg$c8 = "comment";
      var peg$c9 = "lstlisting";
      var peg$c10 = "[";
      var peg$c11 = "]";
      var peg$c12 = "(";
      var peg$c13 = ")";
      var peg$c14 = "begin";
      var peg$c15 = "end";
      var peg$c16 = "equation*";
      var peg$c17 = "equation";
      var peg$c18 = "align*";
      var peg$c19 = "align";
      var peg$c20 = "alignat*";
      var peg$c21 = "alignat";
      var peg$c22 = "gather*";
      var peg$c23 = "gather";
      var peg$c24 = "multline*";
      var peg$c25 = "multline";
      var peg$c26 = "flalign*";
      var peg$c27 = "flalign";
      var peg$c28 = "split";
      var peg$c29 = "math";
      var peg$c30 = "displaymath";
      var peg$c31 = "\\";
      var peg$c32 = "{";
      var peg$c33 = "}";
      var peg$c34 = "$";
      var peg$c35 = "&";
      var peg$c36 = "\r";
      var peg$c37 = "\n";
      var peg$c38 = "\r\n";
      var peg$c39 = "#";
      var peg$c40 = "^";
      var peg$c41 = "_";
      var peg$c42 = "\0";
      var peg$r0 = /^[ \t]/;
      var peg$r1 = /^[a-zA-Z]/;
      var peg$r2 = /^[0-9]/;
      var peg$r3 = /^[.,;:\-*\/()!?=+<>[\]`'"~]/;
      var peg$e0 = peg$otherExpectation("document");
      var peg$e1 = peg$otherExpectation("math");
      var peg$e2 = peg$otherExpectation("token");
      var peg$e3 = peg$anyExpectation();
      var peg$e4 = peg$otherExpectation("parbreak");
      var peg$e5 = peg$otherExpectation("math token");
      var peg$e6 = peg$otherExpectation("nonchar token");
      var peg$e7 = peg$literalExpectation("%", false);
      var peg$e8 = peg$otherExpectation("whitespace");
      var peg$e9 = peg$otherExpectation("number");
      var peg$e10 = peg$literalExpectation(".", false);
      var peg$e11 = peg$otherExpectation("special macro");
      var peg$e12 = peg$literalExpectation("verb*", false);
      var peg$e13 = peg$literalExpectation("verb", false);
      var peg$e14 = peg$otherExpectation("verbatim environment");
      var peg$e15 = peg$literalExpectation("verbatim*", false);
      var peg$e16 = peg$literalExpectation("verbatim", false);
      var peg$e17 = peg$literalExpectation("filecontents*", false);
      var peg$e18 = peg$literalExpectation("filecontents", false);
      var peg$e19 = peg$literalExpectation("comment", false);
      var peg$e20 = peg$literalExpectation("lstlisting", false);
      var peg$e21 = peg$otherExpectation("macro");
      var peg$e22 = peg$otherExpectation("group");
      var peg$e23 = peg$otherExpectation("environment");
      var peg$e24 = peg$otherExpectation("math environment");
      var peg$e25 = peg$otherExpectation("math group");
      var peg$e26 = peg$literalExpectation("[", false);
      var peg$e27 = peg$literalExpectation("]", false);
      var peg$e28 = peg$literalExpectation("(", false);
      var peg$e29 = peg$literalExpectation(")", false);
      var peg$e30 = peg$literalExpectation("begin", false);
      var peg$e31 = peg$literalExpectation("end", false);
      var peg$e32 = peg$literalExpectation("equation*", false);
      var peg$e33 = peg$literalExpectation("equation", false);
      var peg$e34 = peg$literalExpectation("align*", false);
      var peg$e35 = peg$literalExpectation("align", false);
      var peg$e36 = peg$literalExpectation("alignat*", false);
      var peg$e37 = peg$literalExpectation("alignat", false);
      var peg$e38 = peg$literalExpectation("gather*", false);
      var peg$e39 = peg$literalExpectation("gather", false);
      var peg$e40 = peg$literalExpectation("multline*", false);
      var peg$e41 = peg$literalExpectation("multline", false);
      var peg$e42 = peg$literalExpectation("flalign*", false);
      var peg$e43 = peg$literalExpectation("flalign", false);
      var peg$e44 = peg$literalExpectation("split", false);
      var peg$e45 = peg$literalExpectation("math", false);
      var peg$e46 = peg$literalExpectation("displaymath", false);
      var peg$e47 = peg$otherExpectation("escape");
      var peg$e48 = peg$literalExpectation("\\", false);
      var peg$e49 = peg$literalExpectation("{", false);
      var peg$e50 = peg$literalExpectation("}", false);
      var peg$e51 = peg$literalExpectation("$", false);
      var peg$e52 = peg$literalExpectation("&", false);
      var peg$e53 = peg$otherExpectation("newline");
      var peg$e54 = peg$literalExpectation("\r", false);
      var peg$e55 = peg$literalExpectation("\n", false);
      var peg$e56 = peg$literalExpectation("\r\n", false);
      var peg$e57 = peg$literalExpectation("#", false);
      var peg$e58 = peg$literalExpectation("^", false);
      var peg$e59 = peg$literalExpectation("_", false);
      var peg$e60 = peg$literalExpectation("\0", false);
      var peg$e61 = peg$classExpectation([" ", "	"], false, false);
      var peg$e62 = peg$otherExpectation("letter");
      var peg$e63 = peg$classExpectation([["a", "z"], ["A", "Z"]], false, false);
      var peg$e64 = peg$otherExpectation("digit");
      var peg$e65 = peg$classExpectation([["0", "9"]], false, false);
      var peg$e66 = peg$otherExpectation("punctuation");
      var peg$e67 = peg$classExpectation([".", ",", ";", ":", "-", "*", "/", "(", ")", "!", "?", "=", "+", "<", ">", "[", "]", "`", "'", '"', "~"], false, false);
      var peg$e68 = peg$otherExpectation("full comment");
      var peg$e69 = peg$otherExpectation("comment");
      var peg$f0 = function(content) {
        return createNode("root", { content });
      };
      var peg$f1 = function(t) {
        return t;
      };
      var peg$f2 = function(eq) {
        return createNode("inlinemath", { content: eq });
      };
      var peg$f3 = function(s22) {
        return createNode("string", { content: s22 });
      };
      var peg$f4 = function(s22) {
        return createNode("string", { content: s22 });
      };
      var peg$f5 = function() {
        return createNode("parbreak");
      };
      var peg$f6 = function(x) {
        return x;
      };
      var peg$f7 = function(x) {
        return x;
      };
      var peg$f8 = function() {
        return createNode("macro", { content: "^", escapeToken: "" });
      };
      var peg$f9 = function() {
        return createNode("macro", { content: "_", escapeToken: "" });
      };
      var peg$f10 = function(s22) {
        return createNode("string", { content: s22 });
      };
      var peg$f11 = function() {
        return createNode("whitespace");
      };
      var peg$f12 = function(a, b) {
        return a.join("") + "." + b.join("");
      };
      var peg$f13 = function(b) {
        return "." + b.join("");
      };
      var peg$f14 = function(a) {
        return a.join("") + ".";
      };
      var peg$f15 = function(s22) {
        return createNode("string", { content: s22 });
      };
      var peg$f16 = function(env, e, end) {
        return end == e;
      };
      var peg$f17 = function(env, e, x) {
        return x;
      };
      var peg$f18 = function(env, e, x, end) {
        return end == e;
      };
      var peg$f19 = function(env, e, x) {
        return createNode("verb", {
          env,
          escape: e,
          content: x.join("")
        });
      };
      var peg$f20 = function(x) {
        return x;
      };
      var peg$f21 = function(x) {
        return createNode("displaymath", { content: x });
      };
      var peg$f22 = function(x) {
        return x;
      };
      var peg$f23 = function(x) {
        return createNode("inlinemath", { content: x });
      };
      var peg$f24 = function(x) {
        return x;
      };
      var peg$f25 = function(x) {
        return createNode("displaymath", { content: x });
      };
      var peg$f26 = function(env, end_env) {
        return compare_env({ content: [env] }, end_env);
      };
      var peg$f27 = function(env, x) {
        return x;
      };
      var peg$f28 = function(env, body) {
        return createNode("verbatim", {
          env,
          content: body.join("")
        });
      };
      var peg$f29 = function(n) {
        return n.join("");
      };
      var peg$f30 = function(n) {
        return n;
      };
      var peg$f31 = function(m) {
        return createNode("macro", { content: m });
      };
      var peg$f32 = function(c) {
        return c;
      };
      var peg$f33 = function(x) {
        return createNode("group", { content: x });
      };
      var peg$f34 = function(g) {
        return text().slice(1, -1);
      };
      var peg$f35 = function(env, env_comment, end_env) {
        return compare_env(env, end_env);
      };
      var peg$f36 = function(env, env_comment, x) {
        return x;
      };
      var peg$f37 = function(env, env_comment, body) {
        return createNode("environment", {
          env,
          content: env_comment ? [env_comment, ...body] : body
        });
      };
      var peg$f38 = function(env, env_comment, end_env) {
        return compare_env({ content: [env] }, end_env);
      };
      var peg$f39 = function(env, env_comment, x) {
        return x;
      };
      var peg$f40 = function(env, env_comment, body) {
        return createNode("mathenv", {
          env,
          content: env_comment ? [env_comment, ...body] : body
        });
      };
      var peg$f41 = function(c) {
        return c;
      };
      var peg$f42 = function(x) {
        return createNode("group", { content: x });
      };
      var peg$f43 = function(e) {
        return createNode("string", { content: e });
      };
      var peg$f44 = function() {
        return createNode("string", { content: "\\" });
      };
      var peg$f45 = function(s22) {
        return createNode("string", { content: s22 });
      };
      var peg$f46 = function(s22) {
        return createNode("string", { content: s22 });
      };
      var peg$f47 = function(s22) {
        return createNode("string", { content: s22 });
      };
      var peg$f48 = function(s22) {
        return createNode("string", { content: s22 });
      };
      var peg$f49 = function(s22) {
        return createNode("string", { content: s22 });
      };
      var peg$f50 = function(s22) {
        return createNode("string", { content: s22 });
      };
      var peg$f51 = function(s22) {
        return createNode("string", { content: s22 });
      };
      var peg$f52 = function() {
        return " ";
      };
      var peg$f53 = function(p) {
        return createNode("string", { content: p });
      };
      var peg$f54 = function(leading_sp, comment2222) {
        return createNode("comment", {
          ...comment2222,
          sameline: false,
          leadingWhitespace: leading_sp.length > 0
        });
      };
      var peg$f55 = function(spaces, x) {
        return createNode("comment", {
          ...x,
          sameline: true,
          leadingWhitespace: spaces.length > 0
        });
      };
      var peg$f56 = function(c) {
        return c;
      };
      var peg$f57 = function(c) {
        return { content: c.join(""), suffixParbreak: true };
      };
      var peg$f58 = function(c) {
        return c;
      };
      var peg$f59 = function(c) {
        return { content: c.join("") };
      };
      var peg$f60 = function() {
        var loc = location();
        return loc.start.column === 1;
      };
      var peg$currPos = 0;
      var peg$savedPos = 0;
      var peg$posDetailsCache = [{ line: 1, column: 1 }];
      var peg$maxFailPos = 0;
      var peg$maxFailExpected = [];
      var peg$silentFails = 0;
      var peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function offset() {
        return peg$savedPos;
      }
      function range() {
        return {
          source: peg$source,
          start: peg$savedPos,
          end: peg$currPos
        };
      }
      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError(
          [peg$otherExpectation(description)],
          input.substring(peg$savedPos, peg$currPos),
          location2
        );
      }
      function error(message, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location2);
      }
      function peg$literalExpectation(text2, ignoreCase) {
        return { type: "literal", text: text2, ignoreCase };
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts, inverted, ignoreCase };
      }
      function peg$anyExpectation() {
        return { type: "any" };
      }
      function peg$endExpectation() {
        return { type: "end" };
      }
      function peg$otherExpectation(description) {
        return { type: "other", description };
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p;
        if (details) {
          return details;
        } else {
          p = pos - 1;
          while (!peg$posDetailsCache[p]) {
            p--;
          }
          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };
          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos);
        var endPosDetails = peg$computePosDetails(endPos);
        return {
          source: peg$source,
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildSimpleError(message, location2) {
        return new peg$SyntaxError(message, null, null, location2);
      }
      function peg$buildStructuredError(expected2, found, location2) {
        return new peg$SyntaxError(
          peg$SyntaxError.buildMessage(expected2, found),
          expected2,
          found,
          location2
        );
      }
      function peg$parsedocument() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsetoken();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parsetoken();
        }
        peg$savedPos = s0;
        s1 = peg$f0(s1);
        s0 = s1;
        peg$silentFails--;
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e0);
        }
        return s0;
      }
      function peg$parsemath() {
        var s0, s1;
        peg$silentFails++;
        s0 = [];
        s1 = peg$parsemath_token();
        while (s1 !== peg$FAILED) {
          s0.push(s1);
          s1 = peg$parsemath_token();
        }
        peg$silentFails--;
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e1);
        }
        return s0;
      }
      function peg$parsetoken() {
        var s0, s1, s22, s32, s42, s5;
        peg$silentFails++;
        s0 = peg$parsespecial_macro();
        if (s0 === peg$FAILED) {
          s0 = peg$parsemacro();
          if (s0 === peg$FAILED) {
            s0 = peg$parsefull_comment();
            if (s0 === peg$FAILED) {
              s0 = peg$parsegroup();
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parsemath_shift();
                if (s1 !== peg$FAILED) {
                  s22 = [];
                  s32 = peg$currPos;
                  s42 = peg$currPos;
                  peg$silentFails++;
                  s5 = peg$parsemath_shift();
                  peg$silentFails--;
                  if (s5 === peg$FAILED) {
                    s42 = void 0;
                  } else {
                    peg$currPos = s42;
                    s42 = peg$FAILED;
                  }
                  if (s42 !== peg$FAILED) {
                    s5 = peg$parsemath_token();
                    if (s5 !== peg$FAILED) {
                      peg$savedPos = s32;
                      s32 = peg$f1(s5);
                    } else {
                      peg$currPos = s32;
                      s32 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s32;
                    s32 = peg$FAILED;
                  }
                  if (s32 !== peg$FAILED) {
                    while (s32 !== peg$FAILED) {
                      s22.push(s32);
                      s32 = peg$currPos;
                      s42 = peg$currPos;
                      peg$silentFails++;
                      s5 = peg$parsemath_shift();
                      peg$silentFails--;
                      if (s5 === peg$FAILED) {
                        s42 = void 0;
                      } else {
                        peg$currPos = s42;
                        s42 = peg$FAILED;
                      }
                      if (s42 !== peg$FAILED) {
                        s5 = peg$parsemath_token();
                        if (s5 !== peg$FAILED) {
                          peg$savedPos = s32;
                          s32 = peg$f1(s5);
                        } else {
                          peg$currPos = s32;
                          s32 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s32;
                        s32 = peg$FAILED;
                      }
                    }
                  } else {
                    s22 = peg$FAILED;
                  }
                  if (s22 !== peg$FAILED) {
                    s32 = peg$parsemath_shift();
                    if (s32 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s0 = peg$f2(s22);
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
                if (s0 === peg$FAILED) {
                  s0 = peg$parsealignment_tab();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parseparbreak();
                    if (s0 === peg$FAILED) {
                      s0 = peg$parsemacro_parameter();
                      if (s0 === peg$FAILED) {
                        s0 = peg$parseignore();
                        if (s0 === peg$FAILED) {
                          s0 = peg$parsenumber();
                          if (s0 === peg$FAILED) {
                            s0 = peg$parsewhitespace();
                            if (s0 === peg$FAILED) {
                              s0 = peg$parsepunctuation();
                              if (s0 === peg$FAILED) {
                                s0 = peg$currPos;
                                s1 = peg$currPos;
                                s22 = [];
                                s32 = peg$currPos;
                                s42 = peg$currPos;
                                peg$silentFails++;
                                s5 = peg$parsenonchar_token();
                                peg$silentFails--;
                                if (s5 === peg$FAILED) {
                                  s42 = void 0;
                                } else {
                                  peg$currPos = s42;
                                  s42 = peg$FAILED;
                                }
                                if (s42 !== peg$FAILED) {
                                  if (input.length > peg$currPos) {
                                    s5 = input.charAt(peg$currPos);
                                    peg$currPos++;
                                  } else {
                                    s5 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                      peg$fail(peg$e3);
                                    }
                                  }
                                  if (s5 !== peg$FAILED) {
                                    s42 = [s42, s5];
                                    s32 = s42;
                                  } else {
                                    peg$currPos = s32;
                                    s32 = peg$FAILED;
                                  }
                                } else {
                                  peg$currPos = s32;
                                  s32 = peg$FAILED;
                                }
                                if (s32 !== peg$FAILED) {
                                  while (s32 !== peg$FAILED) {
                                    s22.push(s32);
                                    s32 = peg$currPos;
                                    s42 = peg$currPos;
                                    peg$silentFails++;
                                    s5 = peg$parsenonchar_token();
                                    peg$silentFails--;
                                    if (s5 === peg$FAILED) {
                                      s42 = void 0;
                                    } else {
                                      peg$currPos = s42;
                                      s42 = peg$FAILED;
                                    }
                                    if (s42 !== peg$FAILED) {
                                      if (input.length > peg$currPos) {
                                        s5 = input.charAt(peg$currPos);
                                        peg$currPos++;
                                      } else {
                                        s5 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                          peg$fail(peg$e3);
                                        }
                                      }
                                      if (s5 !== peg$FAILED) {
                                        s42 = [s42, s5];
                                        s32 = s42;
                                      } else {
                                        peg$currPos = s32;
                                        s32 = peg$FAILED;
                                      }
                                    } else {
                                      peg$currPos = s32;
                                      s32 = peg$FAILED;
                                    }
                                  }
                                } else {
                                  s22 = peg$FAILED;
                                }
                                if (s22 !== peg$FAILED) {
                                  s1 = input.substring(s1, peg$currPos);
                                } else {
                                  s1 = s22;
                                }
                                if (s1 !== peg$FAILED) {
                                  peg$savedPos = s0;
                                  s1 = peg$f3(s1);
                                }
                                s0 = s1;
                                if (s0 === peg$FAILED) {
                                  s0 = peg$parsebegin_group();
                                  if (s0 === peg$FAILED) {
                                    s0 = peg$parseend_group();
                                    if (s0 === peg$FAILED) {
                                      s0 = peg$parsemath_shift();
                                      if (s0 === peg$FAILED) {
                                        s0 = peg$currPos;
                                        if (input.length > peg$currPos) {
                                          s1 = input.charAt(peg$currPos);
                                          peg$currPos++;
                                        } else {
                                          s1 = peg$FAILED;
                                          if (peg$silentFails === 0) {
                                            peg$fail(peg$e3);
                                          }
                                        }
                                        if (s1 !== peg$FAILED) {
                                          peg$savedPos = s0;
                                          s1 = peg$f4(s1);
                                        }
                                        s0 = s1;
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        return s0;
      }
      function peg$parseparbreak() {
        var s0, s1, s22, s32, s42, s5, s6, s7;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = [];
        s32 = peg$parsesp();
        while (s32 !== peg$FAILED) {
          s22.push(s32);
          s32 = peg$parsesp();
        }
        s32 = peg$parsenl();
        if (s32 !== peg$FAILED) {
          s42 = [];
          s5 = peg$currPos;
          s6 = [];
          s7 = peg$parsesp();
          while (s7 !== peg$FAILED) {
            s6.push(s7);
            s7 = peg$parsesp();
          }
          s7 = peg$parsenl();
          if (s7 !== peg$FAILED) {
            s6 = [s6, s7];
            s5 = s6;
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
          if (s5 !== peg$FAILED) {
            while (s5 !== peg$FAILED) {
              s42.push(s5);
              s5 = peg$currPos;
              s6 = [];
              s7 = peg$parsesp();
              while (s7 !== peg$FAILED) {
                s6.push(s7);
                s7 = peg$parsesp();
              }
              s7 = peg$parsenl();
              if (s7 !== peg$FAILED) {
                s6 = [s6, s7];
                s5 = s6;
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            }
          } else {
            s42 = peg$FAILED;
          }
          if (s42 !== peg$FAILED) {
            s5 = [];
            s6 = peg$parsesp();
            while (s6 !== peg$FAILED) {
              s5.push(s6);
              s6 = peg$parsesp();
            }
            s6 = peg$currPos;
            peg$silentFails++;
            s7 = peg$parsecomment_start();
            peg$silentFails--;
            if (s7 === peg$FAILED) {
              s6 = void 0;
            } else {
              peg$currPos = s6;
              s6 = peg$FAILED;
            }
            if (s6 !== peg$FAILED) {
              s22 = [s22, s32, s42, s5, s6];
              s1 = s22;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
          s1 = peg$currPos;
          s22 = [];
          s32 = peg$parsesp();
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parsesp();
          }
          s32 = peg$parsenl();
          if (s32 !== peg$FAILED) {
            s42 = [];
            s5 = peg$currPos;
            s6 = [];
            s7 = peg$parsesp();
            while (s7 !== peg$FAILED) {
              s6.push(s7);
              s7 = peg$parsesp();
            }
            s7 = peg$parsenl();
            if (s7 !== peg$FAILED) {
              s6 = [s6, s7];
              s5 = s6;
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
            if (s5 !== peg$FAILED) {
              while (s5 !== peg$FAILED) {
                s42.push(s5);
                s5 = peg$currPos;
                s6 = [];
                s7 = peg$parsesp();
                while (s7 !== peg$FAILED) {
                  s6.push(s7);
                  s7 = peg$parsesp();
                }
                s7 = peg$parsenl();
                if (s7 !== peg$FAILED) {
                  s6 = [s6, s7];
                  s5 = s6;
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              }
            } else {
              s42 = peg$FAILED;
            }
            if (s42 !== peg$FAILED) {
              s22 = [s22, s32, s42];
              s1 = s22;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f5();
        }
        s0 = s1;
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e4);
          }
        }
        return s0;
      }
      function peg$parsemath_token() {
        var s0, s1, s22, s32, s42;
        peg$silentFails++;
        s0 = peg$parsespecial_macro();
        if (s0 === peg$FAILED) {
          s0 = peg$parsemacro();
          if (s0 === peg$FAILED) {
            s0 = peg$parsefull_comment();
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = [];
              s22 = peg$parsewhitespace();
              while (s22 !== peg$FAILED) {
                s1.push(s22);
                s22 = peg$parsewhitespace();
              }
              s22 = peg$parsegroup();
              if (s22 !== peg$FAILED) {
                s32 = [];
                s42 = peg$parsewhitespace();
                while (s42 !== peg$FAILED) {
                  s32.push(s42);
                  s42 = peg$parsewhitespace();
                }
                peg$savedPos = s0;
                s0 = peg$f6(s22);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = [];
                s22 = peg$parsewhitespace();
                while (s22 !== peg$FAILED) {
                  s1.push(s22);
                  s22 = peg$parsewhitespace();
                }
                s22 = peg$parsealignment_tab();
                if (s22 !== peg$FAILED) {
                  s32 = [];
                  s42 = peg$parsewhitespace();
                  while (s42 !== peg$FAILED) {
                    s32.push(s42);
                    s42 = peg$parsewhitespace();
                  }
                  peg$savedPos = s0;
                  s0 = peg$f7(s22);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
                if (s0 === peg$FAILED) {
                  s0 = peg$parsemacro_parameter();
                  if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    s1 = [];
                    s22 = peg$parsewhitespace();
                    while (s22 !== peg$FAILED) {
                      s1.push(s22);
                      s22 = peg$parsewhitespace();
                    }
                    s22 = peg$parsesuperscript();
                    if (s22 !== peg$FAILED) {
                      s32 = [];
                      s42 = peg$parsewhitespace();
                      while (s42 !== peg$FAILED) {
                        s32.push(s42);
                        s42 = peg$parsewhitespace();
                      }
                      peg$savedPos = s0;
                      s0 = peg$f8();
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                    if (s0 === peg$FAILED) {
                      s0 = peg$currPos;
                      s1 = [];
                      s22 = peg$parsewhitespace();
                      while (s22 !== peg$FAILED) {
                        s1.push(s22);
                        s22 = peg$parsewhitespace();
                      }
                      s22 = peg$parsesubscript();
                      if (s22 !== peg$FAILED) {
                        s32 = [];
                        s42 = peg$parsewhitespace();
                        while (s42 !== peg$FAILED) {
                          s32.push(s42);
                          s42 = peg$parsewhitespace();
                        }
                        peg$savedPos = s0;
                        s0 = peg$f9();
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                      if (s0 === peg$FAILED) {
                        s0 = peg$parseignore();
                        if (s0 === peg$FAILED) {
                          s0 = peg$parsewhitespace();
                          if (s0 === peg$FAILED) {
                            s0 = peg$currPos;
                            if (input.length > peg$currPos) {
                              s1 = input.charAt(peg$currPos);
                              peg$currPos++;
                            } else {
                              s1 = peg$FAILED;
                              if (peg$silentFails === 0) {
                                peg$fail(peg$e3);
                              }
                            }
                            if (s1 !== peg$FAILED) {
                              peg$savedPos = s0;
                              s1 = peg$f10(s1);
                            }
                            s0 = s1;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e5);
          }
        }
        return s0;
      }
      function peg$parsenonchar_token() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parseescape();
        if (s0 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 37) {
            s0 = peg$c0;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e7);
            }
          }
          if (s0 === peg$FAILED) {
            s0 = peg$parsebegin_group();
            if (s0 === peg$FAILED) {
              s0 = peg$parseend_group();
              if (s0 === peg$FAILED) {
                s0 = peg$parsemath_shift();
                if (s0 === peg$FAILED) {
                  s0 = peg$parsealignment_tab();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parsenl();
                    if (s0 === peg$FAILED) {
                      s0 = peg$parsemacro_parameter();
                      if (s0 === peg$FAILED) {
                        s0 = peg$parseignore();
                        if (s0 === peg$FAILED) {
                          s0 = peg$parsesp();
                          if (s0 === peg$FAILED) {
                            s0 = peg$parsepunctuation();
                            if (s0 === peg$FAILED) {
                              s0 = peg$parseEOF();
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e6);
          }
        }
        return s0;
      }
      function peg$parsewhitespace() {
        var s0, s1, s22, s32, s42, s5, s6, s7;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$parsenl();
        if (s22 !== peg$FAILED) {
          s32 = [];
          s42 = peg$parsesp();
          while (s42 !== peg$FAILED) {
            s32.push(s42);
            s42 = peg$parsesp();
          }
          s22 = [s22, s32];
          s1 = s22;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
          s1 = peg$currPos;
          s22 = [];
          s32 = peg$parsesp();
          if (s32 !== peg$FAILED) {
            while (s32 !== peg$FAILED) {
              s22.push(s32);
              s32 = peg$parsesp();
            }
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s32 = peg$parsenl();
            if (s32 !== peg$FAILED) {
              s42 = peg$currPos;
              peg$silentFails++;
              s5 = peg$parsecomment_start();
              peg$silentFails--;
              if (s5 === peg$FAILED) {
                s42 = void 0;
              } else {
                peg$currPos = s42;
                s42 = peg$FAILED;
              }
              if (s42 !== peg$FAILED) {
                s5 = [];
                s6 = peg$parsesp();
                while (s6 !== peg$FAILED) {
                  s5.push(s6);
                  s6 = peg$parsesp();
                }
                s6 = peg$currPos;
                peg$silentFails++;
                s7 = peg$parsenl();
                peg$silentFails--;
                if (s7 === peg$FAILED) {
                  s6 = void 0;
                } else {
                  peg$currPos = s6;
                  s6 = peg$FAILED;
                }
                if (s6 !== peg$FAILED) {
                  s22 = [s22, s32, s42, s5, s6];
                  s1 = s22;
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 === peg$FAILED) {
            s1 = [];
            s22 = peg$parsesp();
            if (s22 !== peg$FAILED) {
              while (s22 !== peg$FAILED) {
                s1.push(s22);
                s22 = peg$parsesp();
              }
            } else {
              s1 = peg$FAILED;
            }
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f11();
        }
        s0 = s1;
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e8);
          }
        }
        return s0;
      }
      function peg$parsenumber() {
        var s0, s1, s22, s32, s42, s5;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = [];
        s32 = peg$parsenum();
        if (s32 !== peg$FAILED) {
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parsenum();
          }
        } else {
          s22 = peg$FAILED;
        }
        if (s22 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 46) {
            s32 = peg$c1;
            peg$currPos++;
          } else {
            s32 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e10);
            }
          }
          if (s32 !== peg$FAILED) {
            s42 = [];
            s5 = peg$parsenum();
            if (s5 !== peg$FAILED) {
              while (s5 !== peg$FAILED) {
                s42.push(s5);
                s5 = peg$parsenum();
              }
            } else {
              s42 = peg$FAILED;
            }
            if (s42 !== peg$FAILED) {
              peg$savedPos = s1;
              s1 = peg$f12(s22, s42);
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
          s1 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 46) {
            s22 = peg$c1;
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e10);
            }
          }
          if (s22 !== peg$FAILED) {
            s32 = [];
            s42 = peg$parsenum();
            if (s42 !== peg$FAILED) {
              while (s42 !== peg$FAILED) {
                s32.push(s42);
                s42 = peg$parsenum();
              }
            } else {
              s32 = peg$FAILED;
            }
            if (s32 !== peg$FAILED) {
              peg$savedPos = s1;
              s1 = peg$f13(s32);
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 === peg$FAILED) {
            s1 = peg$currPos;
            s22 = [];
            s32 = peg$parsenum();
            if (s32 !== peg$FAILED) {
              while (s32 !== peg$FAILED) {
                s22.push(s32);
                s32 = peg$parsenum();
              }
            } else {
              s22 = peg$FAILED;
            }
            if (s22 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 46) {
                s32 = peg$c1;
                peg$currPos++;
              } else {
                s32 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e10);
                }
              }
              if (s32 !== peg$FAILED) {
                peg$savedPos = s1;
                s1 = peg$f14(s22);
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f15(s1);
        }
        s0 = s1;
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e9);
          }
        }
        return s0;
      }
      function peg$parsespecial_macro() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8, s9;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parseescape();
        if (s1 !== peg$FAILED) {
          if (input.substr(peg$currPos, 5) === peg$c2) {
            s22 = peg$c2;
            peg$currPos += 5;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e12);
            }
          }
          if (s22 === peg$FAILED) {
            if (input.substr(peg$currPos, 4) === peg$c3) {
              s22 = peg$c3;
              peg$currPos += 4;
            } else {
              s22 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e13);
              }
            }
          }
          if (s22 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s32 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s32 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e3);
              }
            }
            if (s32 !== peg$FAILED) {
              s42 = [];
              s5 = peg$currPos;
              s6 = peg$currPos;
              peg$silentFails++;
              s7 = peg$currPos;
              if (input.length > peg$currPos) {
                s8 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s8 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e3);
                }
              }
              if (s8 !== peg$FAILED) {
                peg$savedPos = peg$currPos;
                s9 = peg$f16(s22, s32, s8);
                if (s9) {
                  s9 = void 0;
                } else {
                  s9 = peg$FAILED;
                }
                if (s9 !== peg$FAILED) {
                  s8 = [s8, s9];
                  s7 = s8;
                } else {
                  peg$currPos = s7;
                  s7 = peg$FAILED;
                }
              } else {
                peg$currPos = s7;
                s7 = peg$FAILED;
              }
              peg$silentFails--;
              if (s7 === peg$FAILED) {
                s6 = void 0;
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
              if (s6 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                  s7 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e3);
                  }
                }
                if (s7 !== peg$FAILED) {
                  peg$savedPos = s5;
                  s5 = peg$f17(s22, s32, s7);
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
              while (s5 !== peg$FAILED) {
                s42.push(s5);
                s5 = peg$currPos;
                s6 = peg$currPos;
                peg$silentFails++;
                s7 = peg$currPos;
                if (input.length > peg$currPos) {
                  s8 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s8 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e3);
                  }
                }
                if (s8 !== peg$FAILED) {
                  peg$savedPos = peg$currPos;
                  s9 = peg$f16(s22, s32, s8);
                  if (s9) {
                    s9 = void 0;
                  } else {
                    s9 = peg$FAILED;
                  }
                  if (s9 !== peg$FAILED) {
                    s8 = [s8, s9];
                    s7 = s8;
                  } else {
                    peg$currPos = s7;
                    s7 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s7;
                  s7 = peg$FAILED;
                }
                peg$silentFails--;
                if (s7 === peg$FAILED) {
                  s6 = void 0;
                } else {
                  peg$currPos = s6;
                  s6 = peg$FAILED;
                }
                if (s6 !== peg$FAILED) {
                  if (input.length > peg$currPos) {
                    s7 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e3);
                    }
                  }
                  if (s7 !== peg$FAILED) {
                    peg$savedPos = s5;
                    s5 = peg$f17(s22, s32, s7);
                  } else {
                    peg$currPos = s5;
                    s5 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              }
              s5 = peg$currPos;
              if (input.length > peg$currPos) {
                s6 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e3);
                }
              }
              if (s6 !== peg$FAILED) {
                peg$savedPos = peg$currPos;
                s7 = peg$f18(s22, s32, s42, s6);
                if (s7) {
                  s7 = void 0;
                } else {
                  s7 = peg$FAILED;
                }
                if (s7 !== peg$FAILED) {
                  s6 = [s6, s7];
                  s5 = s6;
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f19(s22, s32, s42);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$parseverbatim_environment();
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsebegin_display_math();
            if (s1 !== peg$FAILED) {
              s22 = [];
              s32 = peg$currPos;
              s42 = peg$currPos;
              peg$silentFails++;
              s5 = peg$parseend_display_math();
              peg$silentFails--;
              if (s5 === peg$FAILED) {
                s42 = void 0;
              } else {
                peg$currPos = s42;
                s42 = peg$FAILED;
              }
              if (s42 !== peg$FAILED) {
                s5 = peg$parsemath_token();
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s32;
                  s32 = peg$f20(s5);
                } else {
                  peg$currPos = s32;
                  s32 = peg$FAILED;
                }
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
              while (s32 !== peg$FAILED) {
                s22.push(s32);
                s32 = peg$currPos;
                s42 = peg$currPos;
                peg$silentFails++;
                s5 = peg$parseend_display_math();
                peg$silentFails--;
                if (s5 === peg$FAILED) {
                  s42 = void 0;
                } else {
                  peg$currPos = s42;
                  s42 = peg$FAILED;
                }
                if (s42 !== peg$FAILED) {
                  s5 = peg$parsemath_token();
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s32;
                    s32 = peg$f20(s5);
                  } else {
                    peg$currPos = s32;
                    s32 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s32;
                  s32 = peg$FAILED;
                }
              }
              s32 = peg$parseend_display_math();
              if (s32 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f21(s22);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parsebegin_inline_math();
              if (s1 !== peg$FAILED) {
                s22 = [];
                s32 = peg$currPos;
                s42 = peg$currPos;
                peg$silentFails++;
                s5 = peg$parseend_inline_math();
                peg$silentFails--;
                if (s5 === peg$FAILED) {
                  s42 = void 0;
                } else {
                  peg$currPos = s42;
                  s42 = peg$FAILED;
                }
                if (s42 !== peg$FAILED) {
                  s5 = peg$parsemath_token();
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s32;
                    s32 = peg$f22(s5);
                  } else {
                    peg$currPos = s32;
                    s32 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s32;
                  s32 = peg$FAILED;
                }
                while (s32 !== peg$FAILED) {
                  s22.push(s32);
                  s32 = peg$currPos;
                  s42 = peg$currPos;
                  peg$silentFails++;
                  s5 = peg$parseend_inline_math();
                  peg$silentFails--;
                  if (s5 === peg$FAILED) {
                    s42 = void 0;
                  } else {
                    peg$currPos = s42;
                    s42 = peg$FAILED;
                  }
                  if (s42 !== peg$FAILED) {
                    s5 = peg$parsemath_token();
                    if (s5 !== peg$FAILED) {
                      peg$savedPos = s32;
                      s32 = peg$f22(s5);
                    } else {
                      peg$currPos = s32;
                      s32 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s32;
                    s32 = peg$FAILED;
                  }
                }
                s32 = peg$parseend_inline_math();
                if (s32 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s0 = peg$f23(s22);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parsemath_shift();
                if (s1 !== peg$FAILED) {
                  s22 = peg$parsemath_shift();
                  if (s22 !== peg$FAILED) {
                    s32 = [];
                    s42 = peg$currPos;
                    s5 = peg$currPos;
                    peg$silentFails++;
                    s6 = peg$currPos;
                    s7 = peg$parsemath_shift();
                    if (s7 !== peg$FAILED) {
                      s8 = peg$parsemath_shift();
                      if (s8 !== peg$FAILED) {
                        s7 = [s7, s8];
                        s6 = s7;
                      } else {
                        peg$currPos = s6;
                        s6 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s6;
                      s6 = peg$FAILED;
                    }
                    peg$silentFails--;
                    if (s6 === peg$FAILED) {
                      s5 = void 0;
                    } else {
                      peg$currPos = s5;
                      s5 = peg$FAILED;
                    }
                    if (s5 !== peg$FAILED) {
                      s6 = peg$parsemath_token();
                      if (s6 !== peg$FAILED) {
                        peg$savedPos = s42;
                        s42 = peg$f24(s6);
                      } else {
                        peg$currPos = s42;
                        s42 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s42;
                      s42 = peg$FAILED;
                    }
                    while (s42 !== peg$FAILED) {
                      s32.push(s42);
                      s42 = peg$currPos;
                      s5 = peg$currPos;
                      peg$silentFails++;
                      s6 = peg$currPos;
                      s7 = peg$parsemath_shift();
                      if (s7 !== peg$FAILED) {
                        s8 = peg$parsemath_shift();
                        if (s8 !== peg$FAILED) {
                          s7 = [s7, s8];
                          s6 = s7;
                        } else {
                          peg$currPos = s6;
                          s6 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s6;
                        s6 = peg$FAILED;
                      }
                      peg$silentFails--;
                      if (s6 === peg$FAILED) {
                        s5 = void 0;
                      } else {
                        peg$currPos = s5;
                        s5 = peg$FAILED;
                      }
                      if (s5 !== peg$FAILED) {
                        s6 = peg$parsemath_token();
                        if (s6 !== peg$FAILED) {
                          peg$savedPos = s42;
                          s42 = peg$f24(s6);
                        } else {
                          peg$currPos = s42;
                          s42 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s42;
                        s42 = peg$FAILED;
                      }
                    }
                    s42 = peg$parsemath_shift();
                    if (s42 !== peg$FAILED) {
                      s5 = peg$parsemath_shift();
                      if (s5 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s0 = peg$f25(s32);
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
                if (s0 === peg$FAILED) {
                  s0 = peg$parsemath_environment();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parseenvironment();
                  }
                }
              }
            }
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e11);
          }
        }
        return s0;
      }
      function peg$parseverbatim_environment() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8, s9, s10, s11;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parsebegin_env();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsebegin_group();
          if (s22 !== peg$FAILED) {
            s32 = peg$parseverbatim_env_name();
            if (s32 !== peg$FAILED) {
              s42 = peg$parseend_group();
              if (s42 !== peg$FAILED) {
                s5 = [];
                s6 = peg$currPos;
                s7 = peg$currPos;
                peg$silentFails++;
                s8 = peg$currPos;
                s9 = peg$parseend_env();
                if (s9 !== peg$FAILED) {
                  s10 = peg$parsegroup();
                  if (s10 !== peg$FAILED) {
                    peg$savedPos = peg$currPos;
                    s11 = peg$f26(s32, s10);
                    if (s11) {
                      s11 = void 0;
                    } else {
                      s11 = peg$FAILED;
                    }
                    if (s11 !== peg$FAILED) {
                      s9 = [s9, s10, s11];
                      s8 = s9;
                    } else {
                      peg$currPos = s8;
                      s8 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s8;
                    s8 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s8;
                  s8 = peg$FAILED;
                }
                peg$silentFails--;
                if (s8 === peg$FAILED) {
                  s7 = void 0;
                } else {
                  peg$currPos = s7;
                  s7 = peg$FAILED;
                }
                if (s7 !== peg$FAILED) {
                  if (input.length > peg$currPos) {
                    s8 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s8 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e3);
                    }
                  }
                  if (s8 !== peg$FAILED) {
                    peg$savedPos = s6;
                    s6 = peg$f27(s32, s8);
                  } else {
                    peg$currPos = s6;
                    s6 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s6;
                  s6 = peg$FAILED;
                }
                while (s6 !== peg$FAILED) {
                  s5.push(s6);
                  s6 = peg$currPos;
                  s7 = peg$currPos;
                  peg$silentFails++;
                  s8 = peg$currPos;
                  s9 = peg$parseend_env();
                  if (s9 !== peg$FAILED) {
                    s10 = peg$parsegroup();
                    if (s10 !== peg$FAILED) {
                      peg$savedPos = peg$currPos;
                      s11 = peg$f26(s32, s10);
                      if (s11) {
                        s11 = void 0;
                      } else {
                        s11 = peg$FAILED;
                      }
                      if (s11 !== peg$FAILED) {
                        s9 = [s9, s10, s11];
                        s8 = s9;
                      } else {
                        peg$currPos = s8;
                        s8 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s8;
                      s8 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s8;
                    s8 = peg$FAILED;
                  }
                  peg$silentFails--;
                  if (s8 === peg$FAILED) {
                    s7 = void 0;
                  } else {
                    peg$currPos = s7;
                    s7 = peg$FAILED;
                  }
                  if (s7 !== peg$FAILED) {
                    if (input.length > peg$currPos) {
                      s8 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s8 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e3);
                      }
                    }
                    if (s8 !== peg$FAILED) {
                      peg$savedPos = s6;
                      s6 = peg$f27(s32, s8);
                    } else {
                      peg$currPos = s6;
                      s6 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s6;
                    s6 = peg$FAILED;
                  }
                }
                s6 = peg$parseend_env();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parsebegin_group();
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parseverbatim_env_name();
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parseend_group();
                      if (s9 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s0 = peg$f28(s32, s5);
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e14);
          }
        }
        return s0;
      }
      function peg$parseverbatim_env_name() {
        var s0;
        if (input.substr(peg$currPos, 9) === peg$c4) {
          s0 = peg$c4;
          peg$currPos += 9;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e15);
          }
        }
        if (s0 === peg$FAILED) {
          if (input.substr(peg$currPos, 8) === peg$c5) {
            s0 = peg$c5;
            peg$currPos += 8;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e16);
            }
          }
          if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 13) === peg$c6) {
              s0 = peg$c6;
              peg$currPos += 13;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e17);
              }
            }
            if (s0 === peg$FAILED) {
              if (input.substr(peg$currPos, 12) === peg$c7) {
                s0 = peg$c7;
                peg$currPos += 12;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e18);
                }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 7) === peg$c8) {
                  s0 = peg$c8;
                  peg$currPos += 7;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e19);
                  }
                }
                if (s0 === peg$FAILED) {
                  if (input.substr(peg$currPos, 10) === peg$c9) {
                    s0 = peg$c9;
                    peg$currPos += 10;
                  } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e20);
                    }
                  }
                }
              }
            }
          }
        }
        return s0;
      }
      function peg$parsemacro() {
        var s0, s1, s22, s32, s42;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$parseescape();
        if (s22 !== peg$FAILED) {
          s32 = [];
          s42 = peg$parsechar();
          if (s42 !== peg$FAILED) {
            while (s42 !== peg$FAILED) {
              s32.push(s42);
              s42 = peg$parsechar();
            }
          } else {
            s32 = peg$FAILED;
          }
          if (s32 !== peg$FAILED) {
            peg$savedPos = s1;
            s1 = peg$f29(s32);
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
          s1 = peg$currPos;
          s22 = peg$parseescape();
          if (s22 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s32 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s32 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e3);
              }
            }
            if (s32 !== peg$FAILED) {
              peg$savedPos = s1;
              s1 = peg$f30(s32);
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f31(s1);
        }
        s0 = s1;
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e21);
          }
        }
        return s0;
      }
      function peg$parsegroup() {
        var s0, s1, s22, s32, s42, s5;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parsebegin_group();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$currPos;
          s42 = peg$currPos;
          peg$silentFails++;
          s5 = peg$parseend_group();
          peg$silentFails--;
          if (s5 === peg$FAILED) {
            s42 = void 0;
          } else {
            peg$currPos = s42;
            s42 = peg$FAILED;
          }
          if (s42 !== peg$FAILED) {
            s5 = peg$parsetoken();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s32;
              s32 = peg$f32(s5);
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          } else {
            peg$currPos = s32;
            s32 = peg$FAILED;
          }
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$currPos;
            s42 = peg$currPos;
            peg$silentFails++;
            s5 = peg$parseend_group();
            peg$silentFails--;
            if (s5 === peg$FAILED) {
              s42 = void 0;
            } else {
              peg$currPos = s42;
              s42 = peg$FAILED;
            }
            if (s42 !== peg$FAILED) {
              s5 = peg$parsetoken();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s32;
                s32 = peg$f32(s5);
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          }
          s32 = peg$parseend_group();
          if (s32 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f33(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e22);
          }
        }
        return s0;
      }
      function peg$parsegroup_contents_as_string() {
        var s0, s1;
        s0 = peg$currPos;
        s1 = peg$parsegroup();
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f34(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parseenvironment() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8, s9, s10;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parsebegin_env();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsegroup_contents_as_string();
          if (s22 !== peg$FAILED) {
            s32 = peg$parsesameline_comment();
            if (s32 === peg$FAILED) {
              s32 = null;
            }
            s42 = [];
            s5 = peg$currPos;
            s6 = peg$currPos;
            peg$silentFails++;
            s7 = peg$currPos;
            s8 = peg$parseend_env();
            if (s8 !== peg$FAILED) {
              s9 = peg$parsegroup_contents_as_string();
              if (s9 !== peg$FAILED) {
                peg$savedPos = peg$currPos;
                s10 = peg$f35(s22, s32, s9);
                if (s10) {
                  s10 = void 0;
                } else {
                  s10 = peg$FAILED;
                }
                if (s10 !== peg$FAILED) {
                  s8 = [s8, s9, s10];
                  s7 = s8;
                } else {
                  peg$currPos = s7;
                  s7 = peg$FAILED;
                }
              } else {
                peg$currPos = s7;
                s7 = peg$FAILED;
              }
            } else {
              peg$currPos = s7;
              s7 = peg$FAILED;
            }
            peg$silentFails--;
            if (s7 === peg$FAILED) {
              s6 = void 0;
            } else {
              peg$currPos = s6;
              s6 = peg$FAILED;
            }
            if (s6 !== peg$FAILED) {
              s7 = peg$parsetoken();
              if (s7 !== peg$FAILED) {
                peg$savedPos = s5;
                s5 = peg$f36(s22, s32, s7);
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
            while (s5 !== peg$FAILED) {
              s42.push(s5);
              s5 = peg$currPos;
              s6 = peg$currPos;
              peg$silentFails++;
              s7 = peg$currPos;
              s8 = peg$parseend_env();
              if (s8 !== peg$FAILED) {
                s9 = peg$parsegroup_contents_as_string();
                if (s9 !== peg$FAILED) {
                  peg$savedPos = peg$currPos;
                  s10 = peg$f35(s22, s32, s9);
                  if (s10) {
                    s10 = void 0;
                  } else {
                    s10 = peg$FAILED;
                  }
                  if (s10 !== peg$FAILED) {
                    s8 = [s8, s9, s10];
                    s7 = s8;
                  } else {
                    peg$currPos = s7;
                    s7 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s7;
                  s7 = peg$FAILED;
                }
              } else {
                peg$currPos = s7;
                s7 = peg$FAILED;
              }
              peg$silentFails--;
              if (s7 === peg$FAILED) {
                s6 = void 0;
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
              if (s6 !== peg$FAILED) {
                s7 = peg$parsetoken();
                if (s7 !== peg$FAILED) {
                  peg$savedPos = s5;
                  s5 = peg$f36(s22, s32, s7);
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            }
            s5 = peg$parseend_env();
            if (s5 !== peg$FAILED) {
              s6 = peg$parsegroup_contents_as_string();
              if (s6 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f37(s22, s32, s42);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e23);
          }
        }
        return s0;
      }
      function peg$parsemath_environment() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8, s9, s10, s11, s12;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parsebegin_env();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsebegin_group();
          if (s22 !== peg$FAILED) {
            s32 = peg$parsemath_env_name();
            if (s32 !== peg$FAILED) {
              s42 = peg$parseend_group();
              if (s42 !== peg$FAILED) {
                s5 = peg$parsesameline_comment();
                if (s5 === peg$FAILED) {
                  s5 = null;
                }
                s6 = [];
                s7 = peg$currPos;
                s8 = peg$currPos;
                peg$silentFails++;
                s9 = peg$currPos;
                s10 = peg$parseend_env();
                if (s10 !== peg$FAILED) {
                  s11 = peg$parsegroup();
                  if (s11 !== peg$FAILED) {
                    peg$savedPos = peg$currPos;
                    s12 = peg$f38(s32, s5, s11);
                    if (s12) {
                      s12 = void 0;
                    } else {
                      s12 = peg$FAILED;
                    }
                    if (s12 !== peg$FAILED) {
                      s10 = [s10, s11, s12];
                      s9 = s10;
                    } else {
                      peg$currPos = s9;
                      s9 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s9;
                    s9 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s9;
                  s9 = peg$FAILED;
                }
                peg$silentFails--;
                if (s9 === peg$FAILED) {
                  s8 = void 0;
                } else {
                  peg$currPos = s8;
                  s8 = peg$FAILED;
                }
                if (s8 !== peg$FAILED) {
                  s9 = peg$parsemath_token();
                  if (s9 !== peg$FAILED) {
                    peg$savedPos = s7;
                    s7 = peg$f39(s32, s5, s9);
                  } else {
                    peg$currPos = s7;
                    s7 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s7;
                  s7 = peg$FAILED;
                }
                while (s7 !== peg$FAILED) {
                  s6.push(s7);
                  s7 = peg$currPos;
                  s8 = peg$currPos;
                  peg$silentFails++;
                  s9 = peg$currPos;
                  s10 = peg$parseend_env();
                  if (s10 !== peg$FAILED) {
                    s11 = peg$parsegroup();
                    if (s11 !== peg$FAILED) {
                      peg$savedPos = peg$currPos;
                      s12 = peg$f38(s32, s5, s11);
                      if (s12) {
                        s12 = void 0;
                      } else {
                        s12 = peg$FAILED;
                      }
                      if (s12 !== peg$FAILED) {
                        s10 = [s10, s11, s12];
                        s9 = s10;
                      } else {
                        peg$currPos = s9;
                        s9 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s9;
                      s9 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s9;
                    s9 = peg$FAILED;
                  }
                  peg$silentFails--;
                  if (s9 === peg$FAILED) {
                    s8 = void 0;
                  } else {
                    peg$currPos = s8;
                    s8 = peg$FAILED;
                  }
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parsemath_token();
                    if (s9 !== peg$FAILED) {
                      peg$savedPos = s7;
                      s7 = peg$f39(s32, s5, s9);
                    } else {
                      peg$currPos = s7;
                      s7 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s7;
                    s7 = peg$FAILED;
                  }
                }
                s7 = peg$parseend_env();
                if (s7 !== peg$FAILED) {
                  s8 = peg$parsebegin_group();
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parsemath_env_name();
                    if (s9 !== peg$FAILED) {
                      s10 = peg$parseend_group();
                      if (s10 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s0 = peg$f40(s32, s5, s6);
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e24);
          }
        }
        return s0;
      }
      function peg$parsemath_group() {
        var s0, s1, s22, s32, s42, s5;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parsebegin_group();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$currPos;
          s42 = peg$currPos;
          peg$silentFails++;
          s5 = peg$parseend_group();
          peg$silentFails--;
          if (s5 === peg$FAILED) {
            s42 = void 0;
          } else {
            peg$currPos = s42;
            s42 = peg$FAILED;
          }
          if (s42 !== peg$FAILED) {
            s5 = peg$parsemath_token();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s32;
              s32 = peg$f41(s5);
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          } else {
            peg$currPos = s32;
            s32 = peg$FAILED;
          }
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$currPos;
            s42 = peg$currPos;
            peg$silentFails++;
            s5 = peg$parseend_group();
            peg$silentFails--;
            if (s5 === peg$FAILED) {
              s42 = void 0;
            } else {
              peg$currPos = s42;
              s42 = peg$FAILED;
            }
            if (s42 !== peg$FAILED) {
              s5 = peg$parsemath_token();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s32;
                s32 = peg$f41(s5);
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          }
          s32 = peg$parseend_group();
          if (s32 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f42(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e25);
          }
        }
        return s0;
      }
      function peg$parsebegin_display_math() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parseescape();
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 91) {
            s22 = peg$c10;
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e26);
            }
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseend_display_math() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parseescape();
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 93) {
            s22 = peg$c11;
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e27);
            }
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsebegin_inline_math() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parseescape();
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 40) {
            s22 = peg$c12;
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e28);
            }
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseend_inline_math() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parseescape();
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 41) {
            s22 = peg$c13;
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e29);
            }
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsebegin_env() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parseescape();
        if (s1 !== peg$FAILED) {
          if (input.substr(peg$currPos, 5) === peg$c14) {
            s22 = peg$c14;
            peg$currPos += 5;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e30);
            }
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseend_env() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parseescape();
        if (s1 !== peg$FAILED) {
          if (input.substr(peg$currPos, 3) === peg$c15) {
            s22 = peg$c15;
            peg$currPos += 3;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e31);
            }
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsemath_env_name() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 9) === peg$c16) {
          s1 = peg$c16;
          peg$currPos += 9;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e32);
          }
        }
        if (s1 === peg$FAILED) {
          if (input.substr(peg$currPos, 8) === peg$c17) {
            s1 = peg$c17;
            peg$currPos += 8;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e33);
            }
          }
          if (s1 === peg$FAILED) {
            if (input.substr(peg$currPos, 6) === peg$c18) {
              s1 = peg$c18;
              peg$currPos += 6;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e34);
              }
            }
            if (s1 === peg$FAILED) {
              if (input.substr(peg$currPos, 5) === peg$c19) {
                s1 = peg$c19;
                peg$currPos += 5;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e35);
                }
              }
              if (s1 === peg$FAILED) {
                if (input.substr(peg$currPos, 8) === peg$c20) {
                  s1 = peg$c20;
                  peg$currPos += 8;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e36);
                  }
                }
                if (s1 === peg$FAILED) {
                  if (input.substr(peg$currPos, 7) === peg$c21) {
                    s1 = peg$c21;
                    peg$currPos += 7;
                  } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e37);
                    }
                  }
                  if (s1 === peg$FAILED) {
                    if (input.substr(peg$currPos, 7) === peg$c22) {
                      s1 = peg$c22;
                      peg$currPos += 7;
                    } else {
                      s1 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e38);
                      }
                    }
                    if (s1 === peg$FAILED) {
                      if (input.substr(peg$currPos, 6) === peg$c23) {
                        s1 = peg$c23;
                        peg$currPos += 6;
                      } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$e39);
                        }
                      }
                      if (s1 === peg$FAILED) {
                        if (input.substr(peg$currPos, 9) === peg$c24) {
                          s1 = peg$c24;
                          peg$currPos += 9;
                        } else {
                          s1 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$e40);
                          }
                        }
                        if (s1 === peg$FAILED) {
                          if (input.substr(peg$currPos, 8) === peg$c25) {
                            s1 = peg$c25;
                            peg$currPos += 8;
                          } else {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) {
                              peg$fail(peg$e41);
                            }
                          }
                          if (s1 === peg$FAILED) {
                            if (input.substr(peg$currPos, 8) === peg$c26) {
                              s1 = peg$c26;
                              peg$currPos += 8;
                            } else {
                              s1 = peg$FAILED;
                              if (peg$silentFails === 0) {
                                peg$fail(peg$e42);
                              }
                            }
                            if (s1 === peg$FAILED) {
                              if (input.substr(peg$currPos, 7) === peg$c27) {
                                s1 = peg$c27;
                                peg$currPos += 7;
                              } else {
                                s1 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                  peg$fail(peg$e43);
                                }
                              }
                              if (s1 === peg$FAILED) {
                                if (input.substr(peg$currPos, 5) === peg$c28) {
                                  s1 = peg$c28;
                                  peg$currPos += 5;
                                } else {
                                  s1 = peg$FAILED;
                                  if (peg$silentFails === 0) {
                                    peg$fail(peg$e44);
                                  }
                                }
                                if (s1 === peg$FAILED) {
                                  if (input.substr(peg$currPos, 4) === peg$c29) {
                                    s1 = peg$c29;
                                    peg$currPos += 4;
                                  } else {
                                    s1 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                      peg$fail(peg$e45);
                                    }
                                  }
                                  if (s1 === peg$FAILED) {
                                    if (input.substr(peg$currPos, 11) === peg$c30) {
                                      s1 = peg$c30;
                                      peg$currPos += 11;
                                    } else {
                                      s1 = peg$FAILED;
                                      if (peg$silentFails === 0) {
                                        peg$fail(peg$e46);
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f43(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parseescape() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 92) {
          s1 = peg$c31;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e48);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f44();
        }
        s0 = s1;
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e47);
          }
        }
        return s0;
      }
      function peg$parsebegin_group() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 123) {
          s1 = peg$c32;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e49);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f45(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parseend_group() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 125) {
          s1 = peg$c33;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e50);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f46(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parsemath_shift() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 36) {
          s1 = peg$c34;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e51);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f47(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parsealignment_tab() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 38) {
          s1 = peg$c35;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e52);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f48(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parsenl() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 13) {
          s22 = peg$c36;
          peg$currPos++;
        } else {
          s22 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e54);
          }
        }
        peg$silentFails--;
        if (s22 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 10) {
            s22 = peg$c37;
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e55);
            }
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 13) {
            s0 = peg$c36;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e54);
            }
          }
          if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c38) {
              s0 = peg$c38;
              peg$currPos += 2;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e56);
              }
            }
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e53);
          }
        }
        return s0;
      }
      function peg$parsemacro_parameter() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 35) {
          s1 = peg$c39;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e57);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f49(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parsesuperscript() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 94) {
          s1 = peg$c40;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e58);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f50(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parsesubscript() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 95) {
          s1 = peg$c41;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e59);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f51(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parseignore() {
        var s0;
        if (input.charCodeAt(peg$currPos) === 0) {
          s0 = peg$c42;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e60);
          }
        }
        return s0;
      }
      function peg$parsesp() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        if (peg$r0.test(input.charAt(peg$currPos))) {
          s22 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s22 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e61);
          }
        }
        if (s22 !== peg$FAILED) {
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            if (peg$r0.test(input.charAt(peg$currPos))) {
              s22 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s22 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e61);
              }
            }
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f52();
        }
        s0 = s1;
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e8);
          }
        }
        return s0;
      }
      function peg$parsechar() {
        var s0, s1;
        peg$silentFails++;
        if (peg$r1.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e63);
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e62);
          }
        }
        return s0;
      }
      function peg$parsenum() {
        var s0, s1;
        peg$silentFails++;
        if (peg$r2.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e65);
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e64);
          }
        }
        return s0;
      }
      function peg$parsepunctuation() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$currPos;
        if (peg$r3.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e67);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f53(s1);
        }
        s0 = s1;
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e66);
          }
        }
        return s0;
      }
      function peg$parsecomment_start() {
        var s0;
        if (input.charCodeAt(peg$currPos) === 37) {
          s0 = peg$c0;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e7);
          }
        }
        return s0;
      }
      function peg$parsefull_comment() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parseownline_comment();
        if (s0 === peg$FAILED) {
          s0 = peg$parsesameline_comment();
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e68);
          }
        }
        return s0;
      }
      function peg$parseownline_comment() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = [];
        s32 = peg$parsesp();
        while (s32 !== peg$FAILED) {
          s22.push(s32);
          s32 = peg$parsesp();
        }
        s32 = peg$parsenl();
        if (s32 !== peg$FAILED) {
          s22 = [s22, s32];
          s1 = s22;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
          s1 = null;
        }
        s22 = peg$parseleading_sp();
        if (s22 !== peg$FAILED) {
          s32 = peg$parsecomment();
          if (s32 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f54(s22, s32);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsesameline_comment() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsesp();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parsesp();
        }
        s22 = peg$parsecomment();
        if (s22 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f55(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecomment() {
        var s0, s1, s22, s32, s42, s5, s6, s7;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parsecomment_start();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$currPos;
          s42 = peg$currPos;
          peg$silentFails++;
          s5 = peg$parsenl();
          peg$silentFails--;
          if (s5 === peg$FAILED) {
            s42 = void 0;
          } else {
            peg$currPos = s42;
            s42 = peg$FAILED;
          }
          if (s42 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s5 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e3);
              }
            }
            if (s5 !== peg$FAILED) {
              peg$savedPos = s32;
              s32 = peg$f56(s5);
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          } else {
            peg$currPos = s32;
            s32 = peg$FAILED;
          }
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$currPos;
            s42 = peg$currPos;
            peg$silentFails++;
            s5 = peg$parsenl();
            peg$silentFails--;
            if (s5 === peg$FAILED) {
              s42 = void 0;
            } else {
              peg$currPos = s42;
              s42 = peg$FAILED;
            }
            if (s42 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s5 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e3);
                }
              }
              if (s5 !== peg$FAILED) {
                peg$savedPos = s32;
                s32 = peg$f56(s5);
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          }
          s32 = peg$currPos;
          peg$silentFails++;
          s42 = peg$parseparbreak();
          peg$silentFails--;
          if (s42 !== peg$FAILED) {
            peg$currPos = s32;
            s32 = void 0;
          } else {
            s32 = peg$FAILED;
          }
          if (s32 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f57(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsecomment_start();
          if (s1 !== peg$FAILED) {
            s22 = [];
            s32 = peg$currPos;
            s42 = peg$currPos;
            peg$silentFails++;
            s5 = peg$parsenl();
            peg$silentFails--;
            if (s5 === peg$FAILED) {
              s42 = void 0;
            } else {
              peg$currPos = s42;
              s42 = peg$FAILED;
            }
            if (s42 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s5 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e3);
                }
              }
              if (s5 !== peg$FAILED) {
                peg$savedPos = s32;
                s32 = peg$f58(s5);
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
            while (s32 !== peg$FAILED) {
              s22.push(s32);
              s32 = peg$currPos;
              s42 = peg$currPos;
              peg$silentFails++;
              s5 = peg$parsenl();
              peg$silentFails--;
              if (s5 === peg$FAILED) {
                s42 = void 0;
              } else {
                peg$currPos = s42;
                s42 = peg$FAILED;
              }
              if (s42 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                  s5 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e3);
                  }
                }
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s32;
                  s32 = peg$f58(s5);
                } else {
                  peg$currPos = s32;
                  s32 = peg$FAILED;
                }
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
            }
            s32 = peg$currPos;
            s42 = peg$parsenl();
            if (s42 !== peg$FAILED) {
              s5 = [];
              s6 = peg$parsesp();
              while (s6 !== peg$FAILED) {
                s5.push(s6);
                s6 = peg$parsesp();
              }
              s6 = peg$currPos;
              peg$silentFails++;
              s7 = peg$parsecomment_start();
              peg$silentFails--;
              if (s7 === peg$FAILED) {
                s6 = void 0;
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
              if (s6 !== peg$FAILED) {
                s42 = [s42, s5, s6];
                s32 = s42;
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
            if (s32 === peg$FAILED) {
              s32 = peg$parsenl();
              if (s32 === peg$FAILED) {
                s32 = peg$parseEOF();
              }
            }
            if (s32 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f59(s22);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e69);
          }
        }
        return s0;
      }
      function peg$parseleading_sp() {
        var s0, s1, s22, s32, s42;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$parsestart_of_line();
        if (s22 !== peg$FAILED) {
          s32 = [];
          s42 = peg$parsesp();
          while (s42 !== peg$FAILED) {
            s32.push(s42);
            s42 = peg$parsesp();
          }
          s22 = [s22, s32];
          s1 = s22;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }
        return s0;
      }
      function peg$parsestart_of_line() {
        var s0;
        peg$savedPos = peg$currPos;
        s0 = peg$f60();
        if (s0) {
          s0 = void 0;
        } else {
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseEOF() {
        var s0, s1;
        s0 = peg$currPos;
        peg$silentFails++;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        peg$silentFails--;
        if (s1 === peg$FAILED) {
          s0 = void 0;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function toString(e) {
        if (typeof e === "string") {
          return e;
        }
        if (typeof e.content === "string") {
          return e.content;
        }
        if (e && e.type === "whitespace") {
          return " ";
        }
        return e;
      }
      function compare_env(g1, g2) {
        const g1Name = typeof g1 === "string" ? g1 : g1.content.map(toString).join("");
        const g2Name = typeof g2 === "string" ? g2 : g2.content.map(toString).join("");
        return g1Name === g2Name;
      }
      function createNode(type, extra = {}) {
        return { type, ...extra, position: location() };
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(
          peg$maxFailExpected,
          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
      }
    }
    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }()
);
var align_environment_default6 = (
  // Generated by Peggy 2.0.1.
  //
  // https://peggyjs.org/
  function() {
    "use strict";
    function peg$subclass(child, parent) {
      function C() {
        this.constructor = child;
      }
      C.prototype = parent.prototype;
      child.prototype = new C();
    }
    function peg$SyntaxError(message, expected, found, location) {
      var self = Error.call(this, message);
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(self, peg$SyntaxError.prototype);
      }
      self.expected = expected;
      self.found = found;
      self.location = location;
      self.name = "SyntaxError";
      return self;
    }
    peg$subclass(peg$SyntaxError, Error);
    function peg$padEnd(str, targetLength, padString) {
      padString = padString || " ";
      if (str.length > targetLength) {
        return str;
      }
      targetLength -= str.length;
      padString += padString.repeat(targetLength);
      return str + padString.slice(0, targetLength);
    }
    peg$SyntaxError.prototype.format = function(sources) {
      var str = "Error: " + this.message;
      if (this.location) {
        var src = null;
        var k;
        for (k = 0; k < sources.length; k++) {
          if (sources[k].source === this.location.source) {
            src = sources[k].text.split(/\r\n|\n|\r/g);
            break;
          }
        }
        var s22 = this.location.start;
        var loc = this.location.source + ":" + s22.line + ":" + s22.column;
        if (src) {
          var e = this.location.end;
          var filler = peg$padEnd("", s22.line.toString().length, " ");
          var line = src[s22.line - 1];
          var last = s22.line === e.line ? e.column : line.length + 1;
          var hatLen = last - s22.column || 1;
          str += "\n --> " + loc + "\n" + filler + " |\n" + s22.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s22.column - 1, " ") + peg$padEnd("", hatLen, "^");
        } else {
          str += "\n at " + loc;
        }
      }
      return str;
    };
    peg$SyntaxError.buildMessage = function(expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        class: function(expectation) {
          var escapedParts = expectation.parts.map(function(part) {
            return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
          });
          return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
        },
        any: function() {
          return "any character";
        },
        end: function() {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        }
      };
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s22) {
        return s22.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function classEscape(s22) {
        return s22.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = expected2.map(describeExpectation);
        var i, j;
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {};
      var peg$source = options.grammarSource;
      var peg$startRuleFunctions = { body: peg$parsebody };
      var peg$startRuleFunction = peg$parsebody;
      var peg$e0 = peg$anyExpectation();
      var peg$f0 = function() {
        return [];
      };
      var peg$f1 = function(x) {
        return { cells: [], colSeps: [], ...x };
      };
      var peg$f2 = function(rowItems, rowSep, trailingComment) {
        return { ...rowItems, rowSep, trailingComment };
      };
      var peg$f3 = function(rowItems, trailingComment) {
        return { ...rowItems, rowSep: null, trailingComment };
      };
      var peg$f4 = function(x) {
        return x;
      };
      var peg$f5 = function(x) {
        return {
          cells: [],
          colSeps: [],
          rowSep: null,
          trailingComment: x
        };
      };
      var peg$f6 = function(x) {
        return x;
      };
      var peg$f7 = function(colSep, cell) {
        return { colSep, cell };
      };
      var peg$f8 = function(colSep) {
        return { colSep };
      };
      var peg$f9 = function(a, b) {
        return processRow(a, b);
      };
      var peg$f10 = function(b) {
        return processRow(null, b);
      };
      var peg$f11 = function(tok) {
        return options.isSameLineComment(tok);
      };
      var peg$f12 = function(tok) {
        return tok;
      };
      var peg$f13 = function(tok) {
        return options.isOwnLineComment(tok);
      };
      var peg$f14 = function(tok) {
        return tok;
      };
      var peg$f15 = function(tok) {
        return options.isWhitespace(tok);
      };
      var peg$f16 = function(tok) {
        return tok;
      };
      var peg$f17 = function(tok) {
        return options.isRowSep(tok);
      };
      var peg$f18 = function(tok) {
        return tok;
      };
      var peg$f19 = function(tok) {
        return options.isColSep(tok);
      };
      var peg$f20 = function(tok) {
        return tok;
      };
      var peg$currPos = 0;
      var peg$savedPos = 0;
      var peg$posDetailsCache = [{ line: 1, column: 1 }];
      var peg$maxFailPos = 0;
      var peg$maxFailExpected = [];
      var peg$silentFails = 0;
      var peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function offset() {
        return peg$savedPos;
      }
      function range() {
        return {
          source: peg$source,
          start: peg$savedPos,
          end: peg$currPos
        };
      }
      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError(
          [peg$otherExpectation(description)],
          input.substring(peg$savedPos, peg$currPos),
          location2
        );
      }
      function error(message, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location2);
      }
      function peg$literalExpectation(text2, ignoreCase) {
        return { type: "literal", text: text2, ignoreCase };
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts, inverted, ignoreCase };
      }
      function peg$anyExpectation() {
        return { type: "any" };
      }
      function peg$endExpectation() {
        return { type: "end" };
      }
      function peg$otherExpectation(description) {
        return { type: "other", description };
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p;
        if (details) {
          return details;
        } else {
          p = pos - 1;
          while (!peg$posDetailsCache[p]) {
            p--;
          }
          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };
          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos);
        var endPosDetails = peg$computePosDetails(endPos);
        return {
          source: peg$source,
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildSimpleError(message, location2) {
        return new peg$SyntaxError(message, null, null, location2);
      }
      function peg$buildStructuredError(expected2, found, location2) {
        return new peg$SyntaxError(
          peg$SyntaxError.buildMessage(expected2, found),
          expected2,
          found,
          location2
        );
      }
      function peg$parsebody() {
        var s0, s1;
        s0 = [];
        s1 = peg$parsecomment_only_line();
        if (s1 === peg$FAILED) {
          s1 = peg$parserow_with_end();
          if (s1 === peg$FAILED) {
            s1 = peg$parserow_without_end();
          }
        }
        if (s1 !== peg$FAILED) {
          while (s1 !== peg$FAILED) {
            s0.push(s1);
            s1 = peg$parsecomment_only_line();
            if (s1 === peg$FAILED) {
              s1 = peg$parserow_with_end();
              if (s1 === peg$FAILED) {
                s1 = peg$parserow_without_end();
              }
            }
          }
        } else {
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseEOL();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f0();
          }
          s0 = s1;
        }
        return s0;
      }
      function peg$parserow_with_end() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$parserow_items();
        if (s22 === peg$FAILED) {
          s22 = null;
        }
        peg$savedPos = s1;
        s22 = peg$f1(s22);
        s1 = s22;
        s22 = peg$parserow_sep();
        if (s22 !== peg$FAILED) {
          s32 = peg$parsetrailing_comment();
          if (s32 === peg$FAILED) {
            s32 = null;
          }
          peg$savedPos = s0;
          s0 = peg$f2(s1, s22, s32);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parserow_without_end() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parserow_items();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsetrailing_comment();
          if (s22 === peg$FAILED) {
            s22 = null;
          }
          peg$savedPos = s0;
          s0 = peg$f3(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsetrailing_comment() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsewhitespace();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parsewhitespace();
        }
        s22 = peg$parsesame_line_comment();
        if (s22 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f4(s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecomment_only_line() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsewhitespace();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parsewhitespace();
        }
        s22 = peg$parseown_line_comment();
        if (s22 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f5(s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsetoken() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        s22 = peg$parserow_sep();
        if (s22 === peg$FAILED) {
          s22 = peg$parsecol_sep();
          if (s22 === peg$FAILED) {
            s22 = peg$parsetrailing_comment();
            if (s22 === peg$FAILED) {
              s22 = peg$parseown_line_comment();
            }
          }
        }
        peg$silentFails--;
        if (s22 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s22 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f6(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecell() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsetoken();
        if (s22 !== peg$FAILED) {
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            s22 = peg$parsetoken();
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }
        return s0;
      }
      function peg$parseseparated_cell() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parsecol_sep();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsecell();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f7(s1, s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsecol_sep();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f8(s1);
          }
          s0 = s1;
        }
        return s0;
      }
      function peg$parserow_items() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$parsecell();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$parseseparated_cell();
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parseseparated_cell();
          }
          peg$savedPos = s0;
          s0 = peg$f9(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = [];
          s22 = peg$parseseparated_cell();
          if (s22 !== peg$FAILED) {
            while (s22 !== peg$FAILED) {
              s1.push(s22);
              s22 = peg$parseseparated_cell();
            }
          } else {
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f10(s1);
          }
          s0 = s1;
        }
        return s0;
      }
      function peg$parsesame_line_comment() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f11(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f12(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseown_line_comment() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f13(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f14(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsewhitespace() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f15(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f16(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parserow_sep() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f17(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f18(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecol_sep() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f19(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f20(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseEOL() {
        var s0, s1;
        s0 = peg$currPos;
        peg$silentFails++;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        peg$silentFails--;
        if (s1 === peg$FAILED) {
          s0 = void 0;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function processRow(leadCell, otherCells) {
        const cells = [leadCell || []];
        const seps = [];
        for (const x of otherCells) {
          cells.push(x.cell || []);
          seps.push(x.colSep);
        }
        return { cells, colSeps: seps };
      }
      if (!options.isWhitespace) {
        try {
          Object.assign(
            options,
            createMatchers(["\\", "hline", "cr"], ["&"])
          );
        } catch (e) {
          console.warn("Error when initializing parser", e);
        }
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(
          peg$maxFailExpected,
          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
      }
    }
    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }()
);
var xparse_argspec_default6 = (
  // Generated by Peggy 2.0.1.
  //
  // https://peggyjs.org/
  function() {
    "use strict";
    function peg$subclass(child, parent) {
      function C() {
        this.constructor = child;
      }
      C.prototype = parent.prototype;
      child.prototype = new C();
    }
    function peg$SyntaxError(message, expected, found, location) {
      var self = Error.call(this, message);
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(self, peg$SyntaxError.prototype);
      }
      self.expected = expected;
      self.found = found;
      self.location = location;
      self.name = "SyntaxError";
      return self;
    }
    peg$subclass(peg$SyntaxError, Error);
    function peg$padEnd(str, targetLength, padString) {
      padString = padString || " ";
      if (str.length > targetLength) {
        return str;
      }
      targetLength -= str.length;
      padString += padString.repeat(targetLength);
      return str + padString.slice(0, targetLength);
    }
    peg$SyntaxError.prototype.format = function(sources) {
      var str = "Error: " + this.message;
      if (this.location) {
        var src = null;
        var k;
        for (k = 0; k < sources.length; k++) {
          if (sources[k].source === this.location.source) {
            src = sources[k].text.split(/\r\n|\n|\r/g);
            break;
          }
        }
        var s22 = this.location.start;
        var loc = this.location.source + ":" + s22.line + ":" + s22.column;
        if (src) {
          var e = this.location.end;
          var filler = peg$padEnd("", s22.line.toString().length, " ");
          var line = src[s22.line - 1];
          var last = s22.line === e.line ? e.column : line.length + 1;
          var hatLen = last - s22.column || 1;
          str += "\n --> " + loc + "\n" + filler + " |\n" + s22.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s22.column - 1, " ") + peg$padEnd("", hatLen, "^");
        } else {
          str += "\n at " + loc;
        }
      }
      return str;
    };
    peg$SyntaxError.buildMessage = function(expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        class: function(expectation) {
          var escapedParts = expectation.parts.map(function(part) {
            return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
          });
          return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
        },
        any: function() {
          return "any character";
        },
        end: function() {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        }
      };
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s22) {
        return s22.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function classEscape(s22) {
        return s22.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = expected2.map(describeExpectation);
        var i, j;
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {};
      var peg$source = options.grammarSource;
      var peg$startRuleFunctions = { args_spec_list: peg$parseargs_spec_list };
      var peg$startRuleFunction = peg$parseargs_spec_list;
      var peg$c0 = "+";
      var peg$c1 = "v";
      var peg$c2 = "b";
      var peg$c3 = "!";
      var peg$c4 = "D";
      var peg$c5 = "d";
      var peg$c6 = "s";
      var peg$c7 = "O";
      var peg$c8 = "o";
      var peg$c9 = "e";
      var peg$c10 = "E";
      var peg$c11 = "t";
      var peg$c12 = "R";
      var peg$c13 = "r";
      var peg$c14 = "u";
      var peg$c15 = "m";
      var peg$c16 = "{";
      var peg$c17 = "}";
      var peg$c18 = " ";
      var peg$c19 = "\n";
      var peg$c20 = "\r";
      var peg$r0 = /^[{ ]/;
      var peg$e0 = peg$literalExpectation("+", false);
      var peg$e1 = peg$literalExpectation("v", false);
      var peg$e2 = peg$anyExpectation();
      var peg$e3 = peg$literalExpectation("b", false);
      var peg$e4 = peg$literalExpectation("!", false);
      var peg$e5 = peg$literalExpectation("D", false);
      var peg$e6 = peg$literalExpectation("d", false);
      var peg$e7 = peg$literalExpectation("s", false);
      var peg$e8 = peg$literalExpectation("O", false);
      var peg$e9 = peg$literalExpectation("o", false);
      var peg$e10 = peg$literalExpectation("e", false);
      var peg$e11 = peg$literalExpectation("E", false);
      var peg$e12 = peg$literalExpectation("t", false);
      var peg$e13 = peg$literalExpectation("R", false);
      var peg$e14 = peg$literalExpectation("r", false);
      var peg$e15 = peg$literalExpectation("u", false);
      var peg$e16 = peg$classExpectation(["{", " "], false, false);
      var peg$e17 = peg$literalExpectation("m", false);
      var peg$e18 = peg$literalExpectation("{", false);
      var peg$e19 = peg$literalExpectation("}", false);
      var peg$e20 = peg$literalExpectation(" ", false);
      var peg$e21 = peg$literalExpectation("\n", false);
      var peg$e22 = peg$literalExpectation("\r", false);
      var peg$f0 = function(x) {
        return x;
      };
      var peg$f1 = function(spec) {
        return spec;
      };
      var peg$f2 = function(spec) {
        return spec;
      };
      var peg$f3 = function(openBrace) {
        return createNode("verbatim", { openBrace, closeBrace: openBrace });
      };
      var peg$f4 = function() {
        return createNode("body");
      };
      var peg$f5 = function(leading_bang, spec) {
        return leading_bang ? { ...spec, noLeadingWhitespace: true } : spec;
      };
      var peg$f6 = function(braceSpec, defaultArg) {
        return createNode("optional", { ...braceSpec, defaultArg });
      };
      var peg$f7 = function(braceSpec) {
        return createNode("optional", braceSpec);
      };
      var peg$f8 = function() {
        return createNode("optionalStar");
      };
      var peg$f9 = function(g) {
        return createNode("optional", { defaultArg: g });
      };
      var peg$f10 = function() {
        return createNode("optional");
      };
      var peg$f11 = function(args) {
        return createNode("embellishment", {
          embellishmentTokens: args.content
        });
      };
      var peg$f12 = function(args, g) {
        return createNode("embellishment", {
          embellishmentTokens: args.content,
          defaultArg: g
        });
      };
      var peg$f13 = function(tok) {
        return createNode("optionalToken", { token: tok });
      };
      var peg$f14 = function(braceSpec, defaultArg) {
        return createNode("mandatory", { ...braceSpec, defaultArg });
      };
      var peg$f15 = function(braceSpec) {
        return createNode("mandatory", braceSpec);
      };
      var peg$f16 = function(stopTokens) {
        return createNode("until", { stopTokens });
      };
      var peg$f17 = function(x) {
        return [x];
      };
      var peg$f18 = function(g) {
        return g.content;
      };
      var peg$f19 = function() {
        return createNode("mandatory");
      };
      var peg$f20 = function(openBrace, closeBrace) {
        return { openBrace, closeBrace };
      };
      var peg$f21 = function(content) {
        return { type: "group", content };
      };
      var peg$f22 = function() {
        return "";
      };
      var peg$currPos = 0;
      var peg$savedPos = 0;
      var peg$posDetailsCache = [{ line: 1, column: 1 }];
      var peg$maxFailPos = 0;
      var peg$maxFailExpected = [];
      var peg$silentFails = 0;
      var peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function offset() {
        return peg$savedPos;
      }
      function range() {
        return {
          source: peg$source,
          start: peg$savedPos,
          end: peg$currPos
        };
      }
      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError(
          [peg$otherExpectation(description)],
          input.substring(peg$savedPos, peg$currPos),
          location2
        );
      }
      function error(message, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location2);
      }
      function peg$literalExpectation(text2, ignoreCase) {
        return { type: "literal", text: text2, ignoreCase };
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts, inverted, ignoreCase };
      }
      function peg$anyExpectation() {
        return { type: "any" };
      }
      function peg$endExpectation() {
        return { type: "end" };
      }
      function peg$otherExpectation(description) {
        return { type: "other", description };
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p;
        if (details) {
          return details;
        } else {
          p = pos - 1;
          while (!peg$posDetailsCache[p]) {
            p--;
          }
          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };
          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos);
        var endPosDetails = peg$computePosDetails(endPos);
        return {
          source: peg$source,
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildSimpleError(message, location2) {
        return new peg$SyntaxError(message, null, null, location2);
      }
      function peg$buildStructuredError(expected2, found, location2) {
        return new peg$SyntaxError(
          peg$SyntaxError.buildMessage(expected2, found),
          expected2,
          found,
          location2
        );
      }
      function peg$parseargs_spec_list() {
        var s0, s1, s22, s32, s42;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$currPos;
        s32 = peg$parsewhitespace();
        s42 = peg$parsearg_spec();
        if (s42 !== peg$FAILED) {
          peg$savedPos = s22;
          s22 = peg$f0(s42);
        } else {
          peg$currPos = s22;
          s22 = peg$FAILED;
        }
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$currPos;
          s32 = peg$parsewhitespace();
          s42 = peg$parsearg_spec();
          if (s42 !== peg$FAILED) {
            peg$savedPos = s22;
            s22 = peg$f0(s42);
          } else {
            peg$currPos = s22;
            s22 = peg$FAILED;
          }
        }
        s22 = peg$parsewhitespace();
        peg$savedPos = s0;
        s0 = peg$f1(s1);
        return s0;
      }
      function peg$parsearg_spec() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 43) {
          s1 = peg$c0;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 === peg$FAILED) {
          s1 = null;
        }
        s22 = peg$parseoptional();
        if (s22 === peg$FAILED) {
          s22 = peg$parsemandatory();
          if (s22 === peg$FAILED) {
            s22 = peg$parseverbatim();
            if (s22 === peg$FAILED) {
              s22 = peg$parserequired();
              if (s22 === peg$FAILED) {
                s22 = peg$parsebody();
                if (s22 === peg$FAILED) {
                  s22 = peg$parseuntil();
                }
              }
            }
          }
        }
        if (s22 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f2(s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseverbatim() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 118) {
          s1 = peg$c1;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e1);
          }
        }
        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s22 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f3(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsebody() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 98) {
          s1 = peg$c2;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f4();
        }
        s0 = s1;
        return s0;
      }
      function peg$parseoptional() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 33) {
          s1 = peg$c3;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e4);
          }
        }
        if (s1 === peg$FAILED) {
          s1 = null;
        }
        s22 = peg$parseoptional_star();
        if (s22 === peg$FAILED) {
          s22 = peg$parseoptional_standard();
          if (s22 === peg$FAILED) {
            s22 = peg$parseoptional_delimited();
            if (s22 === peg$FAILED) {
              s22 = peg$parseoptional_embellishment();
              if (s22 === peg$FAILED) {
                s22 = peg$parseoptional_token();
              }
            }
          }
        }
        if (s22 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f5(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseoptional_delimited() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 68) {
          s1 = peg$c4;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e5);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parsebrace_spec();
          s32 = peg$parsebraced_group();
          if (s32 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f6(s22, s32);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 100) {
            s1 = peg$c5;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e6);
            }
          }
          if (s1 !== peg$FAILED) {
            s22 = peg$parsebrace_spec();
            peg$savedPos = s0;
            s0 = peg$f7(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        return s0;
      }
      function peg$parseoptional_star() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 115) {
          s1 = peg$c6;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e7);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f8();
        }
        s0 = s1;
        return s0;
      }
      function peg$parseoptional_standard() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 79) {
          s1 = peg$c7;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e8);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parsebraced_group();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f9(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 111) {
            s1 = peg$c8;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e9);
            }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f10();
          }
          s0 = s1;
        }
        return s0;
      }
      function peg$parseoptional_embellishment() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 101) {
          s1 = peg$c9;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e10);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parsebraced_group();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f11(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 69) {
            s1 = peg$c10;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e11);
            }
          }
          if (s1 !== peg$FAILED) {
            s22 = peg$parsebraced_group();
            if (s22 !== peg$FAILED) {
              s32 = peg$parsebraced_group();
              if (s32 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f12(s22, s32);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        return s0;
      }
      function peg$parseoptional_token() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 116) {
          s1 = peg$c11;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e12);
          }
        }
        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s22 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f13(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parserequired() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 82) {
          s1 = peg$c12;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e13);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parsebrace_spec();
          s32 = peg$parsebraced_group();
          if (s32 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f14(s22, s32);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 114) {
            s1 = peg$c13;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e14);
            }
          }
          if (s1 !== peg$FAILED) {
            s22 = peg$parsebrace_spec();
            peg$savedPos = s0;
            s0 = peg$f15(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        return s0;
      }
      function peg$parseuntil() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 117) {
          s1 = peg$c14;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e15);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parseuntil_stop_token();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f16(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseuntil_stop_token() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        if (peg$r0.test(input.charAt(peg$currPos))) {
          s22 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s22 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e16);
          }
        }
        peg$silentFails--;
        if (s22 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s22 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f17(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsebraced_group();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f18(s1);
          }
          s0 = s1;
        }
        return s0;
      }
      function peg$parsemandatory() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 109) {
          s1 = peg$c15;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e17);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f19();
        }
        s0 = s1;
        return s0;
      }
      function peg$parsebrace_spec() {
        var s0, s1, s22, s32, s42, s5;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$currPos;
        s32 = peg$currPos;
        peg$silentFails++;
        s42 = peg$parsewhitespace_token();
        peg$silentFails--;
        if (s42 === peg$FAILED) {
          s32 = void 0;
        } else {
          peg$currPos = s32;
          s32 = peg$FAILED;
        }
        if (s32 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s42 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s42 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          if (s42 !== peg$FAILED) {
            s32 = [s32, s42];
            s22 = s32;
          } else {
            peg$currPos = s22;
            s22 = peg$FAILED;
          }
        } else {
          peg$currPos = s22;
          s22 = peg$FAILED;
        }
        if (s22 === peg$FAILED) {
          s22 = null;
        }
        s1 = input.substring(s1, peg$currPos);
        s22 = peg$currPos;
        s32 = peg$currPos;
        s42 = peg$currPos;
        peg$silentFails++;
        s5 = peg$parsewhitespace_token();
        peg$silentFails--;
        if (s5 === peg$FAILED) {
          s42 = void 0;
        } else {
          peg$currPos = s42;
          s42 = peg$FAILED;
        }
        if (s42 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          if (s5 !== peg$FAILED) {
            s42 = [s42, s5];
            s32 = s42;
          } else {
            peg$currPos = s32;
            s32 = peg$FAILED;
          }
        } else {
          peg$currPos = s32;
          s32 = peg$FAILED;
        }
        if (s32 === peg$FAILED) {
          s32 = null;
        }
        s22 = input.substring(s22, peg$currPos);
        peg$savedPos = s0;
        s0 = peg$f20(s1, s22);
        return s0;
      }
      function peg$parsebraced_group() {
        var s0, s1, s22, s32, s42, s5, s6, s7;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 123) {
          s1 = peg$c16;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e18);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$currPos;
          s42 = peg$currPos;
          s5 = peg$currPos;
          peg$silentFails++;
          if (input.charCodeAt(peg$currPos) === 125) {
            s6 = peg$c17;
            peg$currPos++;
          } else {
            s6 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e19);
            }
          }
          peg$silentFails--;
          if (s6 === peg$FAILED) {
            s5 = void 0;
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$currPos;
            peg$silentFails++;
            s7 = peg$parsebraced_group();
            peg$silentFails--;
            if (s7 === peg$FAILED) {
              s6 = void 0;
            } else {
              peg$currPos = s6;
              s6 = peg$FAILED;
            }
            if (s6 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s7 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s7 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e2);
                }
              }
              if (s7 !== peg$FAILED) {
                s5 = [s5, s6, s7];
                s42 = s5;
              } else {
                peg$currPos = s42;
                s42 = peg$FAILED;
              }
            } else {
              peg$currPos = s42;
              s42 = peg$FAILED;
            }
          } else {
            peg$currPos = s42;
            s42 = peg$FAILED;
          }
          if (s42 !== peg$FAILED) {
            s32 = input.substring(s32, peg$currPos);
          } else {
            s32 = s42;
          }
          if (s32 === peg$FAILED) {
            s32 = peg$parsebraced_group();
          }
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$currPos;
            s42 = peg$currPos;
            s5 = peg$currPos;
            peg$silentFails++;
            if (input.charCodeAt(peg$currPos) === 125) {
              s6 = peg$c17;
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e19);
              }
            }
            peg$silentFails--;
            if (s6 === peg$FAILED) {
              s5 = void 0;
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$currPos;
              peg$silentFails++;
              s7 = peg$parsebraced_group();
              peg$silentFails--;
              if (s7 === peg$FAILED) {
                s6 = void 0;
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
              if (s6 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                  s7 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e2);
                  }
                }
                if (s7 !== peg$FAILED) {
                  s5 = [s5, s6, s7];
                  s42 = s5;
                } else {
                  peg$currPos = s42;
                  s42 = peg$FAILED;
                }
              } else {
                peg$currPos = s42;
                s42 = peg$FAILED;
              }
            } else {
              peg$currPos = s42;
              s42 = peg$FAILED;
            }
            if (s42 !== peg$FAILED) {
              s32 = input.substring(s32, peg$currPos);
            } else {
              s32 = s42;
            }
            if (s32 === peg$FAILED) {
              s32 = peg$parsebraced_group();
            }
          }
          if (input.charCodeAt(peg$currPos) === 125) {
            s32 = peg$c17;
            peg$currPos++;
          } else {
            s32 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e19);
            }
          }
          if (s32 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f21(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsewhitespace() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsewhitespace_token();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parsewhitespace_token();
        }
        peg$savedPos = s0;
        s1 = peg$f22();
        s0 = s1;
        return s0;
      }
      function peg$parsewhitespace_token() {
        var s0;
        if (input.charCodeAt(peg$currPos) === 32) {
          s0 = peg$c18;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e20);
          }
        }
        if (s0 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 10) {
            s0 = peg$c19;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e21);
            }
          }
          if (s0 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 13) {
              s0 = peg$c20;
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e22);
              }
            }
          }
        }
        return s0;
      }
      const DEFAULT_OPTIONS = {
        optional: { openBrace: "[", closeBrace: "]" },
        mandatory: { openBrace: "{", closeBrace: "}" }
      };
      function createNode(type, options2) {
        const computedOptions = DEFAULT_OPTIONS[type] || {};
        return { type, ...computedOptions, ...options2 };
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(
          peg$maxFailExpected,
          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
      }
    }
    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }()
);
var pgfkeys_default6 = (
  // Generated by Peggy 2.0.1.
  //
  // https://peggyjs.org/
  function() {
    "use strict";
    function peg$subclass(child, parent) {
      function C() {
        this.constructor = child;
      }
      C.prototype = parent.prototype;
      child.prototype = new C();
    }
    function peg$SyntaxError(message, expected, found, location) {
      var self = Error.call(this, message);
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(self, peg$SyntaxError.prototype);
      }
      self.expected = expected;
      self.found = found;
      self.location = location;
      self.name = "SyntaxError";
      return self;
    }
    peg$subclass(peg$SyntaxError, Error);
    function peg$padEnd(str, targetLength, padString) {
      padString = padString || " ";
      if (str.length > targetLength) {
        return str;
      }
      targetLength -= str.length;
      padString += padString.repeat(targetLength);
      return str + padString.slice(0, targetLength);
    }
    peg$SyntaxError.prototype.format = function(sources) {
      var str = "Error: " + this.message;
      if (this.location) {
        var src = null;
        var k;
        for (k = 0; k < sources.length; k++) {
          if (sources[k].source === this.location.source) {
            src = sources[k].text.split(/\r\n|\n|\r/g);
            break;
          }
        }
        var s22 = this.location.start;
        var loc = this.location.source + ":" + s22.line + ":" + s22.column;
        if (src) {
          var e = this.location.end;
          var filler = peg$padEnd("", s22.line.toString().length, " ");
          var line = src[s22.line - 1];
          var last = s22.line === e.line ? e.column : line.length + 1;
          var hatLen = last - s22.column || 1;
          str += "\n --> " + loc + "\n" + filler + " |\n" + s22.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s22.column - 1, " ") + peg$padEnd("", hatLen, "^");
        } else {
          str += "\n at " + loc;
        }
      }
      return str;
    };
    peg$SyntaxError.buildMessage = function(expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        class: function(expectation) {
          var escapedParts = expectation.parts.map(function(part) {
            return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
          });
          return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
        },
        any: function() {
          return "any character";
        },
        end: function() {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        }
      };
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s22) {
        return s22.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function classEscape(s22) {
        return s22.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = expected2.map(describeExpectation);
        var i, j;
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {};
      var peg$source = options.grammarSource;
      var peg$startRuleFunctions = { body: peg$parsebody };
      var peg$startRuleFunction = peg$parsebody;
      var peg$e0 = peg$anyExpectation();
      var peg$f0 = function() {
        return [];
      };
      var peg$f1 = function(rowItems, trailingComment) {
        return {
          itemParts: [],
          ...rowItems,
          trailingComment,
          trailingComma: true
        };
      };
      var peg$f2 = function(rowItems, trailingComment) {
        return { ...rowItems, trailingComment };
      };
      var peg$f3 = function(a, b) {
        return processItem(a, b);
      };
      var peg$f4 = function(b) {
        return processItem(null, b);
      };
      var peg$f5 = function(cell) {
        return { cell };
      };
      var peg$f6 = function() {
        return {};
      };
      var peg$f7 = function(part) {
        return part;
      };
      var peg$f8 = function(x) {
        return x;
      };
      var peg$f9 = function(space, x) {
        return {
          trailingComment: x,
          leadingParbreak: space.parbreak > 0
        };
      };
      var peg$f10 = function(list) {
        return {
          whitespace: list.filter((x) => options.isWhitespace(x)).length,
          parbreak: list.filter((x) => options.isParbreak(x)).length
        };
      };
      var peg$f11 = function() {
        return !options.allowParenGroups;
      };
      var peg$f12 = function(tok) {
        return options.isSameLineComment(tok);
      };
      var peg$f13 = function(tok) {
        return tok;
      };
      var peg$f14 = function(tok) {
        return options.isOwnLineComment(tok);
      };
      var peg$f15 = function(tok) {
        return tok;
      };
      var peg$f16 = function(tok) {
        return options.isWhitespace(tok);
      };
      var peg$f17 = function(tok) {
        return tok;
      };
      var peg$f18 = function(tok) {
        return options.isParbreak(tok);
      };
      var peg$f19 = function(tok) {
        return tok;
      };
      var peg$f20 = function(tok) {
        return options.isComma(tok);
      };
      var peg$f21 = function(tok) {
        return tok;
      };
      var peg$f22 = function(tok) {
        return options.isEquals(tok);
      };
      var peg$f23 = function(tok) {
        return tok;
      };
      var peg$f24 = function(tok) {
        return options.isChar(tok, "(");
      };
      var peg$f25 = function(tok) {
        return tok;
      };
      var peg$f26 = function(tok) {
        return options.isChar(tok, ")");
      };
      var peg$f27 = function(tok) {
        return tok;
      };
      var peg$currPos = 0;
      var peg$savedPos = 0;
      var peg$posDetailsCache = [{ line: 1, column: 1 }];
      var peg$maxFailPos = 0;
      var peg$maxFailExpected = [];
      var peg$silentFails = 0;
      var peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function offset() {
        return peg$savedPos;
      }
      function range() {
        return {
          source: peg$source,
          start: peg$savedPos,
          end: peg$currPos
        };
      }
      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError(
          [peg$otherExpectation(description)],
          input.substring(peg$savedPos, peg$currPos),
          location2
        );
      }
      function error(message, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location2);
      }
      function peg$literalExpectation(text2, ignoreCase) {
        return { type: "literal", text: text2, ignoreCase };
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts, inverted, ignoreCase };
      }
      function peg$anyExpectation() {
        return { type: "any" };
      }
      function peg$endExpectation() {
        return { type: "end" };
      }
      function peg$otherExpectation(description) {
        return { type: "other", description };
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p;
        if (details) {
          return details;
        } else {
          p = pos - 1;
          while (!peg$posDetailsCache[p]) {
            p--;
          }
          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };
          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos);
        var endPosDetails = peg$computePosDetails(endPos);
        return {
          source: peg$source,
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildSimpleError(message, location2) {
        return new peg$SyntaxError(message, null, null, location2);
      }
      function peg$buildStructuredError(expected2, found, location2) {
        return new peg$SyntaxError(
          peg$SyntaxError.buildMessage(expected2, found),
          expected2,
          found,
          location2
        );
      }
      function peg$parsebody() {
        var s0, s1, s22;
        s0 = [];
        s1 = peg$parsecomment_only_line();
        if (s1 === peg$FAILED) {
          s1 = peg$parseitem_with_end();
          if (s1 === peg$FAILED) {
            s1 = peg$parseitem_without_end();
          }
        }
        if (s1 !== peg$FAILED) {
          while (s1 !== peg$FAILED) {
            s0.push(s1);
            s1 = peg$parsecomment_only_line();
            if (s1 === peg$FAILED) {
              s1 = peg$parseitem_with_end();
              if (s1 === peg$FAILED) {
                s1 = peg$parseitem_without_end();
              }
            }
          }
        } else {
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = [];
          s22 = peg$parsewhitespace();
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            s22 = peg$parsewhitespace();
          }
          s22 = peg$parseEOL();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f0();
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        return s0;
      }
      function peg$parseitem_with_end() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8;
        s0 = peg$currPos;
        s1 = peg$parsewhitespace_or_parbreaks();
        s22 = peg$parserow_items();
        if (s22 === peg$FAILED) {
          s22 = null;
        }
        s32 = peg$parsewhitespace_or_parbreaks();
        s42 = peg$parseitem_sep();
        if (s42 !== peg$FAILED) {
          s5 = [];
          s6 = peg$parsewhitespace();
          while (s6 !== peg$FAILED) {
            s5.push(s6);
            s6 = peg$parsewhitespace();
          }
          s6 = peg$parsetrailing_comment();
          if (s6 === peg$FAILED) {
            s6 = null;
          }
          s7 = [];
          s8 = peg$parsewhitespace();
          while (s8 !== peg$FAILED) {
            s7.push(s8);
            s8 = peg$parsewhitespace();
          }
          peg$savedPos = s0;
          s0 = peg$f1(s22, s6);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseitem_without_end() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$parsewhitespace_or_parbreaks();
        s22 = peg$parserow_items();
        if (s22 !== peg$FAILED) {
          s32 = peg$parsetrailing_comment();
          if (s32 === peg$FAILED) {
            s32 = null;
          }
          peg$savedPos = s0;
          s0 = peg$f2(s22, s32);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parserow_items() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$parseitem_part();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$parseseparated_part();
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parseseparated_part();
          }
          peg$savedPos = s0;
          s0 = peg$f3(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = [];
          s22 = peg$parseseparated_part();
          if (s22 !== peg$FAILED) {
            while (s22 !== peg$FAILED) {
              s1.push(s22);
              s22 = peg$parseseparated_part();
            }
          } else {
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f4(s1);
          }
          s0 = s1;
        }
        return s0;
      }
      function peg$parseseparated_part() {
        var s0, s1, s22, s32, s42;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parseparbreak();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parseparbreak();
        }
        s22 = peg$parseequals();
        if (s22 !== peg$FAILED) {
          s32 = [];
          s42 = peg$parseparbreak();
          while (s42 !== peg$FAILED) {
            s32.push(s42);
            s42 = peg$parseparbreak();
          }
          s42 = peg$parseitem_part();
          if (s42 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f5(s42);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = [];
          s22 = peg$parseparbreak();
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            s22 = peg$parseparbreak();
          }
          s22 = peg$parseequals();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f6();
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        return s0;
      }
      function peg$parseitem_part() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8, s9;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsewhitespace();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parsewhitespace();
        }
        s22 = peg$currPos;
        s32 = [];
        s42 = peg$parsenon_whitespace_non_parbreak_token();
        if (s42 === peg$FAILED) {
          s42 = peg$currPos;
          s5 = peg$parsewhitespace();
          if (s5 === peg$FAILED) {
            s5 = peg$parseparbreak();
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$currPos;
            peg$silentFails++;
            s7 = peg$currPos;
            s8 = [];
            s9 = peg$parsewhitespace();
            if (s9 === peg$FAILED) {
              s9 = peg$parseparbreak();
            }
            while (s9 !== peg$FAILED) {
              s8.push(s9);
              s9 = peg$parsewhitespace();
              if (s9 === peg$FAILED) {
                s9 = peg$parseparbreak();
              }
            }
            s9 = peg$parsenon_whitespace_non_parbreak_token();
            if (s9 !== peg$FAILED) {
              s8 = [s8, s9];
              s7 = s8;
            } else {
              peg$currPos = s7;
              s7 = peg$FAILED;
            }
            peg$silentFails--;
            if (s7 !== peg$FAILED) {
              peg$currPos = s6;
              s6 = void 0;
            } else {
              s6 = peg$FAILED;
            }
            if (s6 !== peg$FAILED) {
              s5 = [s5, s6];
              s42 = s5;
            } else {
              peg$currPos = s42;
              s42 = peg$FAILED;
            }
          } else {
            peg$currPos = s42;
            s42 = peg$FAILED;
          }
        }
        if (s42 !== peg$FAILED) {
          while (s42 !== peg$FAILED) {
            s32.push(s42);
            s42 = peg$parsenon_whitespace_non_parbreak_token();
            if (s42 === peg$FAILED) {
              s42 = peg$currPos;
              s5 = peg$parsewhitespace();
              if (s5 === peg$FAILED) {
                s5 = peg$parseparbreak();
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$currPos;
                peg$silentFails++;
                s7 = peg$currPos;
                s8 = [];
                s9 = peg$parsewhitespace();
                if (s9 === peg$FAILED) {
                  s9 = peg$parseparbreak();
                }
                while (s9 !== peg$FAILED) {
                  s8.push(s9);
                  s9 = peg$parsewhitespace();
                  if (s9 === peg$FAILED) {
                    s9 = peg$parseparbreak();
                  }
                }
                s9 = peg$parsenon_whitespace_non_parbreak_token();
                if (s9 !== peg$FAILED) {
                  s8 = [s8, s9];
                  s7 = s8;
                } else {
                  peg$currPos = s7;
                  s7 = peg$FAILED;
                }
                peg$silentFails--;
                if (s7 !== peg$FAILED) {
                  peg$currPos = s6;
                  s6 = void 0;
                } else {
                  s6 = peg$FAILED;
                }
                if (s6 !== peg$FAILED) {
                  s5 = [s5, s6];
                  s42 = s5;
                } else {
                  peg$currPos = s42;
                  s42 = peg$FAILED;
                }
              } else {
                peg$currPos = s42;
                s42 = peg$FAILED;
              }
            }
          }
        } else {
          s32 = peg$FAILED;
        }
        if (s32 !== peg$FAILED) {
          s22 = input.substring(s22, peg$currPos);
        } else {
          s22 = s32;
        }
        if (s22 !== peg$FAILED) {
          s32 = [];
          s42 = peg$parsewhitespace();
          while (s42 !== peg$FAILED) {
            s32.push(s42);
            s42 = peg$parsewhitespace();
          }
          peg$savedPos = s0;
          s0 = peg$f7(s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsetrailing_comment() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsewhitespace();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parsewhitespace();
        }
        s22 = peg$parsesame_line_comment();
        if (s22 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f8(s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecomment_only_line() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parsewhitespace_or_parbreaks();
        s22 = peg$parseown_line_comment();
        if (s22 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f9(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsetoken() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$currPos;
        peg$silentFails++;
        s32 = peg$parsenon_token();
        peg$silentFails--;
        if (s32 === peg$FAILED) {
          s22 = void 0;
        } else {
          peg$currPos = s22;
          s22 = peg$FAILED;
        }
        if (s22 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s32 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s32 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s32 !== peg$FAILED) {
            s22 = [s22, s32];
            s1 = s22;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }
        return s0;
      }
      function peg$parsenon_whitespace_non_parbreak_token() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$currPos;
        peg$silentFails++;
        s32 = peg$parsewhitespace();
        if (s32 === peg$FAILED) {
          s32 = peg$parseparbreak();
        }
        peg$silentFails--;
        if (s32 === peg$FAILED) {
          s22 = void 0;
        } else {
          peg$currPos = s22;
          s22 = peg$FAILED;
        }
        if (s22 !== peg$FAILED) {
          s32 = peg$parseparen_block();
          if (s32 === peg$FAILED) {
            s32 = peg$parsetoken();
          }
          if (s32 !== peg$FAILED) {
            s22 = [s22, s32];
            s1 = s22;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }
        return s0;
      }
      function peg$parsenon_token() {
        var s0;
        s0 = peg$parseitem_sep();
        if (s0 === peg$FAILED) {
          s0 = peg$parseequals();
          if (s0 === peg$FAILED) {
            s0 = peg$parsetrailing_comment();
            if (s0 === peg$FAILED) {
              s0 = peg$parseown_line_comment();
            }
          }
        }
        return s0;
      }
      function peg$parsewhitespace_or_parbreaks() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsewhitespace();
        if (s22 === peg$FAILED) {
          s22 = peg$parseparbreak();
        }
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parsewhitespace();
          if (s22 === peg$FAILED) {
            s22 = peg$parseparbreak();
          }
        }
        peg$savedPos = s0;
        s1 = peg$f10(s1);
        s0 = s1;
        return s0;
      }
      function peg$parseparen_block() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8;
        s0 = peg$currPos;
        peg$savedPos = peg$currPos;
        s1 = peg$f11();
        if (s1) {
          s1 = peg$FAILED;
        } else {
          s1 = void 0;
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$currPos;
          s32 = peg$currPos;
          s42 = peg$parseopen_paren();
          if (s42 !== peg$FAILED) {
            s5 = [];
            s6 = peg$currPos;
            s7 = peg$currPos;
            peg$silentFails++;
            s8 = peg$parseclose_paren();
            peg$silentFails--;
            if (s8 === peg$FAILED) {
              s7 = void 0;
            } else {
              peg$currPos = s7;
              s7 = peg$FAILED;
            }
            if (s7 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s8 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s8 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              if (s8 !== peg$FAILED) {
                s7 = [s7, s8];
                s6 = s7;
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
            } else {
              peg$currPos = s6;
              s6 = peg$FAILED;
            }
            while (s6 !== peg$FAILED) {
              s5.push(s6);
              s6 = peg$currPos;
              s7 = peg$currPos;
              peg$silentFails++;
              s8 = peg$parseclose_paren();
              peg$silentFails--;
              if (s8 === peg$FAILED) {
                s7 = void 0;
              } else {
                peg$currPos = s7;
                s7 = peg$FAILED;
              }
              if (s7 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                  s8 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s8 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e0);
                  }
                }
                if (s8 !== peg$FAILED) {
                  s7 = [s7, s8];
                  s6 = s7;
                } else {
                  peg$currPos = s6;
                  s6 = peg$FAILED;
                }
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
            }
            s6 = peg$parseclose_paren();
            if (s6 !== peg$FAILED) {
              s42 = [s42, s5, s6];
              s32 = s42;
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          } else {
            peg$currPos = s32;
            s32 = peg$FAILED;
          }
          if (s32 !== peg$FAILED) {
            s22 = input.substring(s22, peg$currPos);
          } else {
            s22 = s32;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsesame_line_comment() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f12(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f13(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseown_line_comment() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f14(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f15(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsewhitespace() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f16(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f17(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseparbreak() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f18(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f19(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseitem_sep() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f20(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f21(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseequals() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f22(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f23(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseopen_paren() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f24(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f25(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseclose_paren() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f26(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f27(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseEOL() {
        var s0, s1;
        s0 = peg$currPos;
        peg$silentFails++;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        peg$silentFails--;
        if (s1 === peg$FAILED) {
          s0 = void 0;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function processItem(leadCell, otherCells) {
        const cells = [leadCell || []];
        for (const x of otherCells) {
          cells.push(x.cell || []);
        }
        return { itemParts: cells };
      }
      if (!options.isWhitespace) {
        try {
          Object.assign(options, {
            isChar: (node, char) => node.type === "string" && node.content === char,
            isComma(node) {
              return node.type === "string" && node.content === ",";
            },
            isEquals(node) {
              return node.type === "string" && node.content === "=";
            },
            isParbreak(node) {
              return node.type === "parbreak";
            },
            isWhitespace(node) {
              return node.type === "whitespace";
            },
            isSameLineComment: (node) => node.type === "comment" && node.sameline,
            isOwnLineComment: (node) => node.type === "comment" && !node.sameline,
            isComment: (node) => node.type === "comment",
            allowParenGroups: true
          });
        } catch (e) {
          console.warn("Error when initializing parser", e);
        }
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(
          peg$maxFailExpected,
          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
      }
    }
    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }()
);
var macro_substitutions_default6 = (
  // Generated by Peggy 2.0.1.
  //
  // https://peggyjs.org/
  function() {
    "use strict";
    function peg$subclass(child, parent) {
      function C() {
        this.constructor = child;
      }
      C.prototype = parent.prototype;
      child.prototype = new C();
    }
    function peg$SyntaxError(message, expected, found, location) {
      var self = Error.call(this, message);
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(self, peg$SyntaxError.prototype);
      }
      self.expected = expected;
      self.found = found;
      self.location = location;
      self.name = "SyntaxError";
      return self;
    }
    peg$subclass(peg$SyntaxError, Error);
    function peg$padEnd(str, targetLength, padString) {
      padString = padString || " ";
      if (str.length > targetLength) {
        return str;
      }
      targetLength -= str.length;
      padString += padString.repeat(targetLength);
      return str + padString.slice(0, targetLength);
    }
    peg$SyntaxError.prototype.format = function(sources) {
      var str = "Error: " + this.message;
      if (this.location) {
        var src = null;
        var k;
        for (k = 0; k < sources.length; k++) {
          if (sources[k].source === this.location.source) {
            src = sources[k].text.split(/\r\n|\n|\r/g);
            break;
          }
        }
        var s22 = this.location.start;
        var loc = this.location.source + ":" + s22.line + ":" + s22.column;
        if (src) {
          var e = this.location.end;
          var filler = peg$padEnd("", s22.line.toString().length, " ");
          var line = src[s22.line - 1];
          var last = s22.line === e.line ? e.column : line.length + 1;
          var hatLen = last - s22.column || 1;
          str += "\n --> " + loc + "\n" + filler + " |\n" + s22.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s22.column - 1, " ") + peg$padEnd("", hatLen, "^");
        } else {
          str += "\n at " + loc;
        }
      }
      return str;
    };
    peg$SyntaxError.buildMessage = function(expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        class: function(expectation) {
          var escapedParts = expectation.parts.map(function(part) {
            return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
          });
          return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
        },
        any: function() {
          return "any character";
        },
        end: function() {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        }
      };
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s22) {
        return s22.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function classEscape(s22) {
        return s22.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = expected2.map(describeExpectation);
        var i, j;
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {};
      var peg$source = options.grammarSource;
      var peg$startRuleFunctions = { body: peg$parsebody };
      var peg$startRuleFunction = peg$parsebody;
      var peg$e0 = peg$anyExpectation();
      var peg$f0 = function(e) {
        return [].concat(...e).filter((n) => !!n);
      };
      var peg$f1 = function() {
        return [];
      };
      var peg$f2 = function(tok) {
        return options.isHash(tok);
      };
      var peg$f3 = function(tok) {
        return tok;
      };
      var peg$f4 = function(tok) {
        return options.isNumber(tok);
      };
      var peg$f5 = function(tok) {
        return tok;
      };
      var peg$f6 = function() {
        return { type: "string", content: "#" };
      };
      var peg$f7 = function(num) {
        const split = options.splitNumber(num);
        return [{ type: "hash_number", number: split.number }, split.rest];
      };
      var peg$currPos = 0;
      var peg$savedPos = 0;
      var peg$posDetailsCache = [{ line: 1, column: 1 }];
      var peg$maxFailPos = 0;
      var peg$maxFailExpected = [];
      var peg$silentFails = 0;
      var peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function offset() {
        return peg$savedPos;
      }
      function range() {
        return {
          source: peg$source,
          start: peg$savedPos,
          end: peg$currPos
        };
      }
      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError(
          [peg$otherExpectation(description)],
          input.substring(peg$savedPos, peg$currPos),
          location2
        );
      }
      function error(message, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location2);
      }
      function peg$literalExpectation(text2, ignoreCase) {
        return { type: "literal", text: text2, ignoreCase };
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts, inverted, ignoreCase };
      }
      function peg$anyExpectation() {
        return { type: "any" };
      }
      function peg$endExpectation() {
        return { type: "end" };
      }
      function peg$otherExpectation(description) {
        return { type: "other", description };
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p;
        if (details) {
          return details;
        } else {
          p = pos - 1;
          while (!peg$posDetailsCache[p]) {
            p--;
          }
          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };
          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos);
        var endPosDetails = peg$computePosDetails(endPos);
        return {
          source: peg$source,
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildSimpleError(message, location2) {
        return new peg$SyntaxError(message, null, null, location2);
      }
      function peg$buildStructuredError(expected2, found, location2) {
        return new peg$SyntaxError(
          peg$SyntaxError.buildMessage(expected2, found),
          expected2,
          found,
          location2
        );
      }
      function peg$parsebody() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsedouble_hash();
        if (s22 === peg$FAILED) {
          s22 = peg$parsehash_number();
          if (s22 === peg$FAILED) {
            if (input.length > peg$currPos) {
              s22 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s22 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
          }
        }
        if (s22 !== peg$FAILED) {
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            s22 = peg$parsedouble_hash();
            if (s22 === peg$FAILED) {
              s22 = peg$parsehash_number();
              if (s22 === peg$FAILED) {
                if (input.length > peg$currPos) {
                  s22 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s22 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e0);
                  }
                }
              }
            }
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f0(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseEOL();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f1();
          }
          s0 = s1;
        }
        return s0;
      }
      function peg$parsehash() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f2(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f3(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsenumber() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f4(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f5(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsedouble_hash() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parsehash();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsehash();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f6();
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsehash_number() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parsehash();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsenumber();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f7(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseEOL() {
        var s0, s1;
        s0 = peg$currPos;
        peg$silentFails++;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        peg$silentFails--;
        if (s1 === peg$FAILED) {
          s0 = void 0;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      if (!options.isHash) {
        try {
          Object.assign(options, {
            isHash: (node) => node.type === "string" && node.content === "#",
            isNumber: (node) => node.type === "string" && 0 < +node.content.charAt(0),
            splitNumber: (node) => {
              const number = +node.content.charAt(0);
              if (node.content.length > 1) {
                return {
                  number,
                  rest: {
                    type: "string",
                    content: node.content.slice(1)
                  }
                };
              }
              return { number };
            }
          });
        } catch (e) {
          console.warn("Error when initializing parser", e);
        }
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(
          peg$maxFailExpected,
          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
      }
    }
    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }()
);
var ligatures_default6 = (
  // Generated by Peggy 2.0.1.
  //
  // https://peggyjs.org/
  function() {
    "use strict";
    function peg$subclass(child, parent) {
      function C() {
        this.constructor = child;
      }
      C.prototype = parent.prototype;
      child.prototype = new C();
    }
    function peg$SyntaxError(message, expected, found, location) {
      var self = Error.call(this, message);
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(self, peg$SyntaxError.prototype);
      }
      self.expected = expected;
      self.found = found;
      self.location = location;
      self.name = "SyntaxError";
      return self;
    }
    peg$subclass(peg$SyntaxError, Error);
    function peg$padEnd(str, targetLength, padString) {
      padString = padString || " ";
      if (str.length > targetLength) {
        return str;
      }
      targetLength -= str.length;
      padString += padString.repeat(targetLength);
      return str + padString.slice(0, targetLength);
    }
    peg$SyntaxError.prototype.format = function(sources) {
      var str = "Error: " + this.message;
      if (this.location) {
        var src = null;
        var k;
        for (k = 0; k < sources.length; k++) {
          if (sources[k].source === this.location.source) {
            src = sources[k].text.split(/\r\n|\n|\r/g);
            break;
          }
        }
        var s22 = this.location.start;
        var loc = this.location.source + ":" + s22.line + ":" + s22.column;
        if (src) {
          var e = this.location.end;
          var filler = peg$padEnd("", s22.line.toString().length, " ");
          var line = src[s22.line - 1];
          var last = s22.line === e.line ? e.column : line.length + 1;
          var hatLen = last - s22.column || 1;
          str += "\n --> " + loc + "\n" + filler + " |\n" + s22.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s22.column - 1, " ") + peg$padEnd("", hatLen, "^");
        } else {
          str += "\n at " + loc;
        }
      }
      return str;
    };
    peg$SyntaxError.buildMessage = function(expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        class: function(expectation) {
          var escapedParts = expectation.parts.map(function(part) {
            return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
          });
          return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
        },
        any: function() {
          return "any character";
        },
        end: function() {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        }
      };
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s22) {
        return s22.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function classEscape(s22) {
        return s22.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = expected2.map(describeExpectation);
        var i, j;
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {};
      var peg$source = options.grammarSource;
      var peg$startRuleFunctions = { body: peg$parsebody };
      var peg$startRuleFunction = peg$parsebody;
      var peg$e0 = peg$anyExpectation();
      var peg$f0 = function(e) {
        return [].concat(...e).filter((n) => !!n);
      };
      var peg$f1 = function() {
        return [];
      };
      var peg$f2 = function(toks) {
        return options.isRecognized(toks);
      };
      var peg$f3 = function(toks) {
        return options.isRecognized(toks);
      };
      var peg$f4 = function(tok1, tok2) {
        const split = options.split(tok2);
        return options.isRecognized([tok1, split[0]]);
      };
      var peg$f5 = function(tok1, tok2) {
        const split = options.split(tok2);
        return [options.isRecognized([tok1, split[0]]), split[1]];
      };
      var peg$f6 = function(tok1, tok2) {
        return options.isRecognized([tok1, tok2]);
      };
      var peg$f7 = function(tok1, tok2) {
        return options.isRecognized([tok1, tok2]);
      };
      var peg$f8 = function(toks) {
        return options.isRecognized(toks);
      };
      var peg$f9 = function(toks) {
        return options.isRecognized(toks);
      };
      var peg$f10 = function(tok) {
        return options.isRecognized([tok]);
      };
      var peg$f11 = function(tok) {
        return options.isRecognized([tok]);
      };
      var peg$f12 = function(tok) {
        return options.isMacro(tok);
      };
      var peg$f13 = function(tok) {
        return tok;
      };
      var peg$f14 = function(tok) {
        return options.isWhitespace(tok);
      };
      var peg$f15 = function(tok) {
        return tok;
      };
      var peg$f16 = function(tok) {
        return options.isSplitable(tok);
      };
      var peg$f17 = function(tok) {
        return tok;
      };
      var peg$currPos = 0;
      var peg$savedPos = 0;
      var peg$posDetailsCache = [{ line: 1, column: 1 }];
      var peg$maxFailPos = 0;
      var peg$maxFailExpected = [];
      var peg$silentFails = 0;
      var peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function offset() {
        return peg$savedPos;
      }
      function range() {
        return {
          source: peg$source,
          start: peg$savedPos,
          end: peg$currPos
        };
      }
      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError(
          [peg$otherExpectation(description)],
          input.substring(peg$savedPos, peg$currPos),
          location2
        );
      }
      function error(message, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location2);
      }
      function peg$literalExpectation(text2, ignoreCase) {
        return { type: "literal", text: text2, ignoreCase };
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts, inverted, ignoreCase };
      }
      function peg$anyExpectation() {
        return { type: "any" };
      }
      function peg$endExpectation() {
        return { type: "end" };
      }
      function peg$otherExpectation(description) {
        return { type: "other", description };
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p;
        if (details) {
          return details;
        } else {
          p = pos - 1;
          while (!peg$posDetailsCache[p]) {
            p--;
          }
          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };
          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos);
        var endPosDetails = peg$computePosDetails(endPos);
        return {
          source: peg$source,
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildSimpleError(message, location2) {
        return new peg$SyntaxError(message, null, null, location2);
      }
      function peg$buildStructuredError(expected2, found, location2) {
        return new peg$SyntaxError(
          peg$SyntaxError.buildMessage(expected2, found),
          expected2,
          found,
          location2
        );
      }
      function peg$parsebody() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsetriple_ligature();
        if (s22 === peg$FAILED) {
          s22 = peg$parsedouble_ligature();
          if (s22 === peg$FAILED) {
            s22 = peg$parsemono_ligature();
            if (s22 === peg$FAILED) {
              if (input.length > peg$currPos) {
                s22 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s22 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
            }
          }
        }
        if (s22 !== peg$FAILED) {
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            s22 = peg$parsetriple_ligature();
            if (s22 === peg$FAILED) {
              s22 = peg$parsedouble_ligature();
              if (s22 === peg$FAILED) {
                s22 = peg$parsemono_ligature();
                if (s22 === peg$FAILED) {
                  if (input.length > peg$currPos) {
                    s22 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s22 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e0);
                    }
                  }
                }
              }
            }
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f0(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseEOL();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f1();
          }
          s0 = s1;
        }
        return s0;
      }
      function peg$parsetriple_ligature() {
        var s0, s1, s22, s32, s42;
        s0 = peg$currPos;
        s1 = peg$currPos;
        if (input.length > peg$currPos) {
          s22 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s22 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s22 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s32 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s32 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s32 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s42 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s42 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            if (s42 !== peg$FAILED) {
              s22 = [s22, s32, s42];
              s1 = s22;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f2(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f3(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsedouble_ligature() {
        var s0;
        s0 = peg$parsedouble_macro_ligature();
        if (s0 === peg$FAILED) {
          s0 = peg$parsedouble_macro_ligature_extracted();
          if (s0 === peg$FAILED) {
            s0 = peg$parsedouble_char_ligature();
          }
        }
        return s0;
      }
      function peg$parsedouble_macro_ligature_extracted() {
        var s0, s1, s22, s32, s42;
        s0 = peg$currPos;
        s1 = peg$parsemacro();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$parsewhitespace();
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parsewhitespace();
          }
          s32 = peg$parsesplitable();
          if (s32 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s42 = peg$f4(s1, s32);
            if (s42) {
              s42 = void 0;
            } else {
              s42 = peg$FAILED;
            }
            if (s42 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f5(s1, s32);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsedouble_macro_ligature() {
        var s0, s1, s22, s32, s42;
        s0 = peg$currPos;
        s1 = peg$parsemacro();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$parsewhitespace();
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parsewhitespace();
          }
          if (input.length > peg$currPos) {
            s32 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s32 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s32 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s42 = peg$f6(s1, s32);
            if (s42) {
              s42 = void 0;
            } else {
              s42 = peg$FAILED;
            }
            if (s42 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f7(s1, s32);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsedouble_char_ligature() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$currPos;
        if (input.length > peg$currPos) {
          s22 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s22 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s22 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s32 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s32 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s32 !== peg$FAILED) {
            s22 = [s22, s32];
            s1 = s22;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f8(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f9(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsemono_ligature() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f10(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f11(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsemacro() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f12(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f13(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsewhitespace() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f14(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f15(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsesplitable() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f16(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f17(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseEOL() {
        var s0, s1;
        s0 = peg$currPos;
        peg$silentFails++;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        peg$silentFails--;
        if (s1 === peg$FAILED) {
          s0 = void 0;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      if (!options.isWhitespace) {
        try {
          Object.assign(options, {
            isMacro: (node) => node.type === "macro",
            isWhitespace: (node) => node.type === "whitespace",
            isRecognized: (nodes) => {
              if (nodes.length == 2 && nodes[0].content === "^" && nodes[1].content === "o") {
                return { type: "string", content: "\xF4" };
              }
              return null;
            },
            isSplitable: (node) => node.type === "string" && node.content.length > 1,
            split: (node) => [
              { type: "string", content: node.content.charAt(0) },
              { type: "string", content: node.content.slice(1) }
            ]
          });
        } catch (e) {
          console.warn("Error when initializing parser", e);
        }
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(
          peg$maxFailExpected,
          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
      }
    }
    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }()
);
var xcolor_expressions_default6 = (
  // Generated by Peggy 2.0.1.
  //
  // https://peggyjs.org/
  function() {
    "use strict";
    function peg$subclass(child, parent) {
      function C() {
        this.constructor = child;
      }
      C.prototype = parent.prototype;
      child.prototype = new C();
    }
    function peg$SyntaxError(message, expected, found, location) {
      var self = Error.call(this, message);
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(self, peg$SyntaxError.prototype);
      }
      self.expected = expected;
      self.found = found;
      self.location = location;
      self.name = "SyntaxError";
      return self;
    }
    peg$subclass(peg$SyntaxError, Error);
    function peg$padEnd(str, targetLength, padString) {
      padString = padString || " ";
      if (str.length > targetLength) {
        return str;
      }
      targetLength -= str.length;
      padString += padString.repeat(targetLength);
      return str + padString.slice(0, targetLength);
    }
    peg$SyntaxError.prototype.format = function(sources) {
      var str = "Error: " + this.message;
      if (this.location) {
        var src = null;
        var k;
        for (k = 0; k < sources.length; k++) {
          if (sources[k].source === this.location.source) {
            src = sources[k].text.split(/\r\n|\n|\r/g);
            break;
          }
        }
        var s22 = this.location.start;
        var loc = this.location.source + ":" + s22.line + ":" + s22.column;
        if (src) {
          var e = this.location.end;
          var filler = peg$padEnd("", s22.line.toString().length, " ");
          var line = src[s22.line - 1];
          var last = s22.line === e.line ? e.column : line.length + 1;
          var hatLen = last - s22.column || 1;
          str += "\n --> " + loc + "\n" + filler + " |\n" + s22.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s22.column - 1, " ") + peg$padEnd("", hatLen, "^");
        } else {
          str += "\n at " + loc;
        }
      }
      return str;
    };
    peg$SyntaxError.buildMessage = function(expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        class: function(expectation) {
          var escapedParts = expectation.parts.map(function(part) {
            return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
          });
          return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
        },
        any: function() {
          return "any character";
        },
        end: function() {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        }
      };
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s22) {
        return s22.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function classEscape(s22) {
        return s22.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = expected2.map(describeExpectation);
        var i, j;
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {};
      var peg$source = options.grammarSource;
      var peg$startRuleFunctions = { start: peg$parsestart };
      var peg$startRuleFunction = peg$parsestart;
      var peg$c0 = ";";
      var peg$c1 = ",";
      var peg$c2 = ":";
      var peg$c3 = "/";
      var peg$c4 = ">";
      var peg$c5 = "!";
      var peg$c6 = ".";
      var peg$c7 = "!![";
      var peg$c8 = "]";
      var peg$c9 = "!!";
      var peg$c10 = "+";
      var peg$c11 = "-";
      var peg$r0 = /^[a-zA-Z0-9]/;
      var peg$r1 = /^[0-9]/;
      var peg$r2 = /^[ \t\n\r]/;
      var peg$r3 = /^[0-9a-fA-F]/;
      var peg$e0 = peg$anyExpectation();
      var peg$e1 = peg$literalExpectation(";", false);
      var peg$e2 = peg$literalExpectation(",", false);
      var peg$e3 = peg$otherExpectation("model list");
      var peg$e4 = peg$literalExpectation(":", false);
      var peg$e5 = peg$literalExpectation("/", false);
      var peg$e6 = peg$otherExpectation("model");
      var peg$e7 = peg$otherExpectation("color spec list");
      var peg$e8 = peg$otherExpectation("color spec");
      var peg$e9 = peg$otherExpectation("color");
      var peg$e10 = peg$otherExpectation("function expression");
      var peg$e11 = peg$literalExpectation(">", false);
      var peg$e12 = peg$otherExpectation("function");
      var peg$e13 = peg$otherExpectation("extended expression");
      var peg$e14 = peg$otherExpectation("core model");
      var peg$e15 = peg$otherExpectation("expr");
      var peg$e16 = peg$literalExpectation("!", false);
      var peg$e17 = peg$otherExpectation("mix expr");
      var peg$e18 = peg$otherExpectation("name");
      var peg$e19 = peg$literalExpectation(".", false);
      var peg$e20 = peg$classExpectation([["a", "z"], ["A", "Z"], ["0", "9"]], false, false);
      var peg$e21 = peg$otherExpectation("postfix");
      var peg$e22 = peg$literalExpectation("!![", false);
      var peg$e23 = peg$literalExpectation("]", false);
      var peg$e24 = peg$literalExpectation("!!", false);
      var peg$e25 = peg$otherExpectation("prefix");
      var peg$e26 = peg$otherExpectation("plus");
      var peg$e27 = peg$literalExpectation("+", false);
      var peg$e28 = peg$otherExpectation("minus");
      var peg$e29 = peg$literalExpectation("-", false);
      var peg$e30 = peg$otherExpectation("num");
      var peg$e31 = peg$classExpectation([["0", "9"]], false, false);
      var peg$e32 = peg$otherExpectation("positive float");
      var peg$e33 = peg$otherExpectation("divisor");
      var peg$e34 = peg$otherExpectation("int");
      var peg$e35 = peg$otherExpectation("whitespace");
      var peg$e36 = peg$classExpectation([" ", "	", "\n", "\r"], false, false);
      var peg$e37 = peg$classExpectation([["0", "9"], ["a", "f"], ["A", "F"]], false, false);
      var peg$f0 = function(m) {
        return m;
      };
      var peg$f1 = function(m) {
        return m;
      };
      var peg$f2 = function(m) {
        return m;
      };
      var peg$f3 = function(m) {
        return m;
      };
      var peg$f4 = function(m) {
        return m;
      };
      var peg$f5 = function(a) {
        return { type: "invalid_spec", content: a };
      };
      var peg$f6 = function(f, c) {
        return c;
      };
      var peg$f7 = function(f, r) {
        return { type: "color_set", content: [f].concat(r) };
      };
      var peg$f8 = function(n, s22) {
        return { type: "color_set_item", name: n, spec_list: s22 };
      };
      var peg$f9 = function(c, m) {
        return { type: "model_list", contents: m, core_model: c };
      };
      var peg$f10 = function(m) {
        return { type: "model_list", contents: m, core_model: null };
      };
      var peg$f11 = function(m, a) {
        return a;
      };
      var peg$f12 = function(m, r) {
        return [m].concat(r);
      };
      var peg$f13 = function(s22, a) {
        return a;
      };
      var peg$f14 = function(s22, r) {
        return { type: "spec_list", content: [s22].concat(r) };
      };
      var peg$f15 = function(c) {
        return { type: "hex_spec", content: [c] };
      };
      var peg$f16 = function(c, d) {
        return d;
      };
      var peg$f17 = function(c, d) {
        return d;
      };
      var peg$f18 = function(c, r) {
        return { type: "num_spec", content: r ? [c].concat(r) : [c] };
      };
      var peg$f19 = function(c, fs) {
        return { type: "color", color: c, functions: fs };
      };
      var peg$f20 = function(f, n) {
        return n;
      };
      var peg$f21 = function(f, args) {
        return { type: "function", name: f, args };
      };
      var peg$f22 = function(core, d, e, es) {
        return {
          type: "extended_expr",
          core_model: core,
          div: d,
          expressions: [e].concat(es)
        };
      };
      var peg$f23 = function(core, e, es) {
        return {
          type: "extended_expr",
          core_model: core,
          div: null,
          expressions: [e].concat(es)
        };
      };
      var peg$f24 = function(e, d) {
        return { type: "weighted_expr", color: e, weight: d };
      };
      var peg$f25 = function(e) {
        return e;
      };
      var peg$f26 = function(p, n, e, po) {
        return {
          type: "expr",
          prefix: p,
          name: n,
          mix_expr: e,
          postfix: po
        };
      };
      var peg$f27 = function(p, n) {
        return { type: "complete_mix", mix_percent: p, name: n };
      };
      var peg$f28 = function(p) {
        return { type: "partial_mix", mix_percent: p };
      };
      var peg$f29 = function(c, p) {
        return c.concat(p || []);
      };
      var peg$f30 = function(n) {
        return { type: "postfix", num: n };
      };
      var peg$f31 = function(p) {
        return { type: "postfix", plusses: p };
      };
      var peg$f32 = function(n) {
        return parseInt(n, 10);
      };
      var peg$f33 = function(n) {
        return parseFloat(n);
      };
      var peg$f34 = function(n) {
        return n;
      };
      var peg$f35 = function(n) {
        return -n;
      };
      var peg$f36 = function(m, n) {
        return m ? -n : n;
      };
      var peg$f37 = function(h) {
        return h.toUpperCase();
      };
      var peg$currPos = 0;
      var peg$savedPos = 0;
      var peg$posDetailsCache = [{ line: 1, column: 1 }];
      var peg$maxFailPos = 0;
      var peg$maxFailExpected = [];
      var peg$silentFails = 0;
      var peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function offset() {
        return peg$savedPos;
      }
      function range() {
        return {
          source: peg$source,
          start: peg$savedPos,
          end: peg$currPos
        };
      }
      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError(
          [peg$otherExpectation(description)],
          input.substring(peg$savedPos, peg$currPos),
          location2
        );
      }
      function error(message, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location2);
      }
      function peg$literalExpectation(text2, ignoreCase) {
        return { type: "literal", text: text2, ignoreCase };
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts, inverted, ignoreCase };
      }
      function peg$anyExpectation() {
        return { type: "any" };
      }
      function peg$endExpectation() {
        return { type: "end" };
      }
      function peg$otherExpectation(description) {
        return { type: "other", description };
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p;
        if (details) {
          return details;
        } else {
          p = pos - 1;
          while (!peg$posDetailsCache[p]) {
            p--;
          }
          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };
          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos);
        var endPosDetails = peg$computePosDetails(endPos);
        return {
          source: peg$source,
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildSimpleError(message, location2) {
        return new peg$SyntaxError(message, null, null, location2);
      }
      function peg$buildStructuredError(expected2, found, location2) {
        return new peg$SyntaxError(
          peg$SyntaxError.buildMessage(expected2, found),
          expected2,
          found,
          location2
        );
      }
      function peg$parsestart() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$parsespec();
        if (s1 !== peg$FAILED) {
          s22 = peg$parseEOL();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f0(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsespec_list();
          if (s1 !== peg$FAILED) {
            s22 = peg$parseEOL();
            if (s22 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f1(s1);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsecolor();
            if (s1 !== peg$FAILED) {
              s22 = peg$parseEOL();
              if (s22 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f2(s1);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parsemodel_list();
              if (s1 !== peg$FAILED) {
                s22 = peg$parseEOL();
                if (s22 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s0 = peg$f3(s1);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parsecolor_set_spec();
                if (s1 !== peg$FAILED) {
                  s22 = peg$parseEOL();
                  if (s22 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s0 = peg$f4(s1);
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  s1 = peg$currPos;
                  s22 = [];
                  if (input.length > peg$currPos) {
                    s32 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s32 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e0);
                    }
                  }
                  while (s32 !== peg$FAILED) {
                    s22.push(s32);
                    if (input.length > peg$currPos) {
                      s32 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s32 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e0);
                      }
                    }
                  }
                  s1 = input.substring(s1, peg$currPos);
                  peg$savedPos = s0;
                  s1 = peg$f5(s1);
                  s0 = s1;
                }
              }
            }
          }
        }
        return s0;
      }
      function peg$parsecolor_set_spec() {
        var s0, s1, s22, s32, s42, s5;
        s0 = peg$currPos;
        s1 = peg$parsecolor_set_item();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 59) {
            s42 = peg$c0;
            peg$currPos++;
          } else {
            s42 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e1);
            }
          }
          if (s42 !== peg$FAILED) {
            s5 = peg$parsecolor_set_item();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s32;
              s32 = peg$f6(s1, s5);
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          } else {
            peg$currPos = s32;
            s32 = peg$FAILED;
          }
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 59) {
              s42 = peg$c0;
              peg$currPos++;
            } else {
              s42 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e1);
              }
            }
            if (s42 !== peg$FAILED) {
              s5 = peg$parsecolor_set_item();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s32;
                s32 = peg$f6(s1, s5);
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          }
          peg$savedPos = s0;
          s0 = peg$f7(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecolor_set_item() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$parsename();
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 44) {
            s22 = peg$c1;
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          if (s22 !== peg$FAILED) {
            s32 = peg$parsespec_list();
            if (s32 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f8(s1, s32);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsemodel_list() {
        var s0, s1, s22, s32;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parsecore_model();
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 58) {
            s22 = peg$c2;
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e4);
            }
          }
          if (s22 !== peg$FAILED) {
            s32 = peg$parsemodel_list_tail();
            if (s32 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f9(s1, s32);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsemodel_list_tail();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f10(s1);
          }
          s0 = s1;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        return s0;
      }
      function peg$parsemodel_list_tail() {
        var s0, s1, s22, s32, s42, s5;
        s0 = peg$currPos;
        s1 = peg$parsemodel();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 47) {
            s42 = peg$c3;
            peg$currPos++;
          } else {
            s42 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e5);
            }
          }
          if (s42 !== peg$FAILED) {
            s5 = peg$parsemodel();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s32;
              s32 = peg$f11(s1, s5);
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          } else {
            peg$currPos = s32;
            s32 = peg$FAILED;
          }
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 47) {
              s42 = peg$c3;
              peg$currPos++;
            } else {
              s42 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e5);
              }
            }
            if (s42 !== peg$FAILED) {
              s5 = peg$parsemodel();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s32;
                s32 = peg$f11(s1, s5);
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          }
          peg$savedPos = s0;
          s0 = peg$f12(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsemodel() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parsecore_model();
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e6);
          }
        }
        return s0;
      }
      function peg$parsespec_list() {
        var s0, s1, s22, s32, s42, s5;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parsespec();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 47) {
            s42 = peg$c3;
            peg$currPos++;
          } else {
            s42 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e5);
            }
          }
          if (s42 !== peg$FAILED) {
            s5 = peg$parsespec();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s32;
              s32 = peg$f13(s1, s5);
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          } else {
            peg$currPos = s32;
            s32 = peg$FAILED;
          }
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 47) {
              s42 = peg$c3;
              peg$currPos++;
            } else {
              s42 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e5);
              }
            }
            if (s42 !== peg$FAILED) {
              s5 = peg$parsespec();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s32;
                s32 = peg$f13(s1, s5);
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          }
          peg$savedPos = s0;
          s0 = peg$f14(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e7);
          }
        }
        return s0;
      }
      function peg$parsespec() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$currPos;
        s32 = peg$parsehex();
        if (s32 !== peg$FAILED) {
          s42 = peg$parsehex();
          if (s42 !== peg$FAILED) {
            s5 = peg$parsehex();
            if (s5 !== peg$FAILED) {
              s6 = peg$parsehex();
              if (s6 !== peg$FAILED) {
                s7 = peg$parsehex();
                if (s7 !== peg$FAILED) {
                  s8 = peg$parsehex();
                  if (s8 !== peg$FAILED) {
                    s32 = [s32, s42, s5, s6, s7, s8];
                    s22 = s32;
                  } else {
                    peg$currPos = s22;
                    s22 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s22;
                  s22 = peg$FAILED;
                }
              } else {
                peg$currPos = s22;
                s22 = peg$FAILED;
              }
            } else {
              peg$currPos = s22;
              s22 = peg$FAILED;
            }
          } else {
            peg$currPos = s22;
            s22 = peg$FAILED;
          }
        } else {
          peg$currPos = s22;
          s22 = peg$FAILED;
        }
        if (s22 !== peg$FAILED) {
          s1 = input.substring(s1, peg$currPos);
        } else {
          s1 = s22;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f15(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsedec();
          if (s1 !== peg$FAILED) {
            s22 = [];
            s32 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 44) {
              s42 = peg$c1;
              peg$currPos++;
            } else {
              s42 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e2);
              }
            }
            if (s42 !== peg$FAILED) {
              s5 = peg$parsedec();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s32;
                s32 = peg$f16(s1, s5);
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
            if (s32 !== peg$FAILED) {
              while (s32 !== peg$FAILED) {
                s22.push(s32);
                s32 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 44) {
                  s42 = peg$c1;
                  peg$currPos++;
                } else {
                  s42 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e2);
                  }
                }
                if (s42 !== peg$FAILED) {
                  s5 = peg$parsedec();
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s32;
                    s32 = peg$f16(s1, s5);
                  } else {
                    peg$currPos = s32;
                    s32 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s32;
                  s32 = peg$FAILED;
                }
              }
            } else {
              s22 = peg$FAILED;
            }
            if (s22 === peg$FAILED) {
              s22 = [];
              s32 = peg$currPos;
              s42 = peg$parsesp();
              if (s42 !== peg$FAILED) {
                s5 = peg$parsedec();
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s32;
                  s32 = peg$f17(s1, s5);
                } else {
                  peg$currPos = s32;
                  s32 = peg$FAILED;
                }
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
              if (s32 !== peg$FAILED) {
                while (s32 !== peg$FAILED) {
                  s22.push(s32);
                  s32 = peg$currPos;
                  s42 = peg$parsesp();
                  if (s42 !== peg$FAILED) {
                    s5 = peg$parsedec();
                    if (s5 !== peg$FAILED) {
                      peg$savedPos = s32;
                      s32 = peg$f17(s1, s5);
                    } else {
                      peg$currPos = s32;
                      s32 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s32;
                    s32 = peg$FAILED;
                  }
                }
              } else {
                s22 = peg$FAILED;
              }
            }
            if (s22 === peg$FAILED) {
              s22 = null;
            }
            peg$savedPos = s0;
            s0 = peg$f18(s1, s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e8);
          }
        }
        return s0;
      }
      function peg$parsecolor() {
        var s0, s1, s22, s32;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parsecolor_expr();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$parsefunc_expr();
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parsefunc_expr();
          }
          peg$savedPos = s0;
          s0 = peg$f19(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e9);
          }
        }
        return s0;
      }
      function peg$parsecolor_expr() {
        var s0;
        s0 = peg$parseext_expr();
        if (s0 === peg$FAILED) {
          s0 = peg$parseexpr();
          if (s0 === peg$FAILED) {
            s0 = peg$parsename();
          }
        }
        return s0;
      }
      function peg$parsefunc_expr() {
        var s0, s1, s22, s32, s42, s5, s6;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 62) {
          s1 = peg$c4;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e11);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parsefunction();
          if (s22 !== peg$FAILED) {
            s32 = [];
            s42 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 44) {
              s5 = peg$c1;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e2);
              }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parseint();
              if (s6 !== peg$FAILED) {
                peg$savedPos = s42;
                s42 = peg$f20(s22, s6);
              } else {
                peg$currPos = s42;
                s42 = peg$FAILED;
              }
            } else {
              peg$currPos = s42;
              s42 = peg$FAILED;
            }
            while (s42 !== peg$FAILED) {
              s32.push(s42);
              s42 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 44) {
                s5 = peg$c1;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e2);
                }
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parseint();
                if (s6 !== peg$FAILED) {
                  peg$savedPos = s42;
                  s42 = peg$f20(s22, s6);
                } else {
                  peg$currPos = s42;
                  s42 = peg$FAILED;
                }
              } else {
                peg$currPos = s42;
                s42 = peg$FAILED;
              }
            }
            peg$savedPos = s0;
            s0 = peg$f21(s22, s32);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e10);
          }
        }
        return s0;
      }
      function peg$parsefunction() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parsename();
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e12);
          }
        }
        return s0;
      }
      function peg$parseext_expr() {
        var s0, s1, s22, s32, s42, s5, s6, s7;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parsecore_model();
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 44) {
            s22 = peg$c1;
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          if (s22 !== peg$FAILED) {
            s32 = peg$parsediv();
            if (s32 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 58) {
                s42 = peg$c2;
                peg$currPos++;
              } else {
                s42 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e4);
                }
              }
              if (s42 !== peg$FAILED) {
                s5 = peg$parseweighted_expr();
                if (s5 !== peg$FAILED) {
                  s6 = [];
                  s7 = peg$parseadditional_weighted_expr();
                  while (s7 !== peg$FAILED) {
                    s6.push(s7);
                    s7 = peg$parseadditional_weighted_expr();
                  }
                  peg$savedPos = s0;
                  s0 = peg$f22(s1, s32, s5, s6);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsecore_model();
          if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 58) {
              s22 = peg$c2;
              peg$currPos++;
            } else {
              s22 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e4);
              }
            }
            if (s22 !== peg$FAILED) {
              s32 = peg$parseweighted_expr();
              if (s32 !== peg$FAILED) {
                s42 = [];
                s5 = peg$parseadditional_weighted_expr();
                while (s5 !== peg$FAILED) {
                  s42.push(s5);
                  s5 = peg$parseadditional_weighted_expr();
                }
                peg$savedPos = s0;
                s0 = peg$f23(s1, s32, s42);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e13);
          }
        }
        return s0;
      }
      function peg$parseweighted_expr() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$parseexpr();
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 44) {
            s22 = peg$c1;
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          if (s22 !== peg$FAILED) {
            s32 = peg$parsedec();
            if (s32 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f24(s1, s32);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseadditional_weighted_expr() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 59) {
          s1 = peg$c0;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e1);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parseweighted_expr();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f25(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecore_model() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parsename();
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e14);
          }
        }
        return s0;
      }
      function peg$parseexpr() {
        var s0, s1, s22, s32, s42;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parseprefix();
        s22 = peg$parsename();
        if (s22 !== peg$FAILED) {
          s32 = peg$parsemix_expr();
          s42 = peg$parsepostfix();
          if (s42 === peg$FAILED) {
            s42 = null;
          }
          peg$savedPos = s0;
          s0 = peg$f26(s1, s22, s32, s42);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e15);
          }
        }
        return s0;
      }
      function peg$parsecomplete_mix() {
        var s0, s1, s22, s32, s42;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 33) {
          s1 = peg$c5;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e16);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parsepct();
          if (s22 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 33) {
              s32 = peg$c5;
              peg$currPos++;
            } else {
              s32 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e16);
              }
            }
            if (s32 !== peg$FAILED) {
              s42 = peg$parsename();
              if (s42 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f27(s22, s42);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsepartial_mix() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 33) {
          s1 = peg$c5;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e16);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parsepct();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f28(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsemix_expr() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsecomplete_mix();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parsecomplete_mix();
        }
        s22 = peg$parsepartial_mix();
        if (s22 === peg$FAILED) {
          s22 = null;
        }
        peg$savedPos = s0;
        s0 = peg$f29(s1, s22);
        peg$silentFails--;
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e17);
        }
        return s0;
      }
      function peg$parsename() {
        var s0, s1, s22;
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 46) {
          s0 = peg$c6;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e19);
          }
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = [];
          if (peg$r0.test(input.charAt(peg$currPos))) {
            s22 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e20);
            }
          }
          if (s22 !== peg$FAILED) {
            while (s22 !== peg$FAILED) {
              s1.push(s22);
              if (peg$r0.test(input.charAt(peg$currPos))) {
                s22 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s22 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e20);
                }
              }
            }
          } else {
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            s0 = input.substring(s0, peg$currPos);
          } else {
            s0 = s1;
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e18);
          }
        }
        return s0;
      }
      function peg$parsepostfix() {
        var s0, s1, s22, s32, s42;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 3) === peg$c7) {
          s1 = peg$c7;
          peg$currPos += 3;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e22);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parsenum();
          if (s22 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 93) {
              s32 = peg$c8;
              peg$currPos++;
            } else {
              s32 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e23);
              }
            }
            if (s32 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f30(s22);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c9) {
            s1 = peg$c9;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e24);
            }
          }
          if (s1 !== peg$FAILED) {
            s22 = peg$currPos;
            s32 = [];
            s42 = peg$parseplus();
            if (s42 !== peg$FAILED) {
              while (s42 !== peg$FAILED) {
                s32.push(s42);
                s42 = peg$parseplus();
              }
            } else {
              s32 = peg$FAILED;
            }
            if (s32 !== peg$FAILED) {
              s22 = input.substring(s22, peg$currPos);
            } else {
              s22 = s32;
            }
            if (s22 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f31(s22);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e21);
          }
        }
        return s0;
      }
      function peg$parseprefix() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parseminus();
        if (s0 === peg$FAILED) {
          s0 = null;
        }
        peg$silentFails--;
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e25);
        }
        return s0;
      }
      function peg$parseplus() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        if (input.charCodeAt(peg$currPos) === 43) {
          s22 = peg$c10;
          peg$currPos++;
        } else {
          s22 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e27);
          }
        }
        if (s22 !== peg$FAILED) {
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            if (input.charCodeAt(peg$currPos) === 43) {
              s22 = peg$c10;
              peg$currPos++;
            } else {
              s22 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e27);
              }
            }
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e26);
          }
        }
        return s0;
      }
      function peg$parseminus() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        if (input.charCodeAt(peg$currPos) === 45) {
          s22 = peg$c11;
          peg$currPos++;
        } else {
          s22 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e29);
          }
        }
        if (s22 !== peg$FAILED) {
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            if (input.charCodeAt(peg$currPos) === 45) {
              s22 = peg$c11;
              peg$currPos++;
            } else {
              s22 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e29);
              }
            }
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e28);
          }
        }
        return s0;
      }
      function peg$parsenum() {
        var s0, s1, s22, s32;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = [];
        if (peg$r1.test(input.charAt(peg$currPos))) {
          s32 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s32 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e31);
          }
        }
        if (s32 !== peg$FAILED) {
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            if (peg$r1.test(input.charAt(peg$currPos))) {
              s32 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s32 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e31);
              }
            }
          }
        } else {
          s22 = peg$FAILED;
        }
        if (s22 !== peg$FAILED) {
          s1 = input.substring(s1, peg$currPos);
        } else {
          s1 = s22;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f32(s1);
        }
        s0 = s1;
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e30);
          }
        }
        return s0;
      }
      function peg$parsepct() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8, s9;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$currPos;
        s32 = peg$currPos;
        s42 = [];
        if (peg$r1.test(input.charAt(peg$currPos))) {
          s5 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e31);
          }
        }
        if (s5 !== peg$FAILED) {
          while (s5 !== peg$FAILED) {
            s42.push(s5);
            if (peg$r1.test(input.charAt(peg$currPos))) {
              s5 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e31);
              }
            }
          }
        } else {
          s42 = peg$FAILED;
        }
        if (s42 !== peg$FAILED) {
          s32 = input.substring(s32, peg$currPos);
        } else {
          s32 = s42;
        }
        if (s32 !== peg$FAILED) {
          s42 = peg$currPos;
          s5 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 46) {
            s6 = peg$c6;
            peg$currPos++;
          } else {
            s6 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e19);
            }
          }
          if (s6 !== peg$FAILED) {
            s7 = peg$currPos;
            s8 = [];
            if (peg$r1.test(input.charAt(peg$currPos))) {
              s9 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s9 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e31);
              }
            }
            while (s9 !== peg$FAILED) {
              s8.push(s9);
              if (peg$r1.test(input.charAt(peg$currPos))) {
                s9 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s9 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e31);
                }
              }
            }
            s7 = input.substring(s7, peg$currPos);
            s6 = [s6, s7];
            s5 = s6;
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
          if (s5 === peg$FAILED) {
            s5 = null;
          }
          s42 = input.substring(s42, peg$currPos);
          s32 = [s32, s42];
          s22 = s32;
        } else {
          peg$currPos = s22;
          s22 = peg$FAILED;
        }
        if (s22 !== peg$FAILED) {
          s1 = input.substring(s1, peg$currPos);
        } else {
          s1 = s22;
        }
        if (s1 === peg$FAILED) {
          s1 = peg$currPos;
          s22 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 46) {
            s32 = peg$c6;
            peg$currPos++;
          } else {
            s32 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e19);
            }
          }
          if (s32 !== peg$FAILED) {
            s42 = peg$currPos;
            s5 = [];
            if (peg$r1.test(input.charAt(peg$currPos))) {
              s6 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e31);
              }
            }
            if (s6 !== peg$FAILED) {
              while (s6 !== peg$FAILED) {
                s5.push(s6);
                if (peg$r1.test(input.charAt(peg$currPos))) {
                  s6 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e31);
                  }
                }
              }
            } else {
              s5 = peg$FAILED;
            }
            if (s5 !== peg$FAILED) {
              s42 = input.substring(s42, peg$currPos);
            } else {
              s42 = s5;
            }
            if (s42 !== peg$FAILED) {
              s32 = [s32, s42];
              s22 = s32;
            } else {
              peg$currPos = s22;
              s22 = peg$FAILED;
            }
          } else {
            peg$currPos = s22;
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = input.substring(s1, peg$currPos);
          } else {
            s1 = s22;
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f33(s1);
        }
        s0 = s1;
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e32);
          }
        }
        return s0;
      }
      function peg$parsediv() {
        var s0, s1;
        peg$silentFails++;
        s0 = peg$parsepct();
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e33);
          }
        }
        return s0;
      }
      function peg$parsedec() {
        var s0, s1, s22;
        s0 = peg$parsepct();
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 43) {
            s1 = peg$c10;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e27);
            }
          }
          if (s1 !== peg$FAILED) {
            s22 = peg$parsepct();
            if (s22 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f34(s22);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 45) {
              s1 = peg$c11;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e29);
              }
            }
            if (s1 !== peg$FAILED) {
              s22 = peg$parsepct();
              if (s22 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f35(s22);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
        }
        return s0;
      }
      function peg$parseint() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parseminus();
        if (s1 === peg$FAILED) {
          s1 = null;
        }
        s22 = peg$parsenum();
        if (s22 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f36(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e34);
          }
        }
        return s0;
      }
      function peg$parse_() {
        var s0, s1;
        peg$silentFails++;
        s0 = [];
        if (peg$r2.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e36);
          }
        }
        while (s1 !== peg$FAILED) {
          s0.push(s1);
          if (peg$r2.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e36);
            }
          }
        }
        peg$silentFails--;
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e35);
        }
        return s0;
      }
      function peg$parsesp() {
        var s0, s1;
        s0 = [];
        if (peg$r2.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e36);
          }
        }
        if (s1 !== peg$FAILED) {
          while (s1 !== peg$FAILED) {
            s0.push(s1);
            if (peg$r2.test(input.charAt(peg$currPos))) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e36);
              }
            }
          }
        } else {
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsehex() {
        var s0, s1;
        s0 = peg$currPos;
        if (peg$r3.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e37);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f37(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parseEOL() {
        var s0, s1;
        s0 = peg$currPos;
        peg$silentFails++;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        peg$silentFails--;
        if (s1 === peg$FAILED) {
          s0 = void 0;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(
          peg$maxFailExpected,
          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
      }
    }
    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }()
);
var tabular_spec_default6 = (
  // Generated by Peggy 2.0.1.
  //
  // https://peggyjs.org/
  function() {
    "use strict";
    function peg$subclass(child, parent) {
      function C() {
        this.constructor = child;
      }
      C.prototype = parent.prototype;
      child.prototype = new C();
    }
    function peg$SyntaxError(message, expected, found, location) {
      var self = Error.call(this, message);
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(self, peg$SyntaxError.prototype);
      }
      self.expected = expected;
      self.found = found;
      self.location = location;
      self.name = "SyntaxError";
      return self;
    }
    peg$subclass(peg$SyntaxError, Error);
    function peg$padEnd(str, targetLength, padString) {
      padString = padString || " ";
      if (str.length > targetLength) {
        return str;
      }
      targetLength -= str.length;
      padString += padString.repeat(targetLength);
      return str + padString.slice(0, targetLength);
    }
    peg$SyntaxError.prototype.format = function(sources) {
      var str = "Error: " + this.message;
      if (this.location) {
        var src = null;
        var k;
        for (k = 0; k < sources.length; k++) {
          if (sources[k].source === this.location.source) {
            src = sources[k].text.split(/\r\n|\n|\r/g);
            break;
          }
        }
        var s22 = this.location.start;
        var loc = this.location.source + ":" + s22.line + ":" + s22.column;
        if (src) {
          var e = this.location.end;
          var filler = peg$padEnd("", s22.line.toString().length, " ");
          var line = src[s22.line - 1];
          var last = s22.line === e.line ? e.column : line.length + 1;
          var hatLen = last - s22.column || 1;
          str += "\n --> " + loc + "\n" + filler + " |\n" + s22.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s22.column - 1, " ") + peg$padEnd("", hatLen, "^");
        } else {
          str += "\n at " + loc;
        }
      }
      return str;
    };
    peg$SyntaxError.buildMessage = function(expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        class: function(expectation) {
          var escapedParts = expectation.parts.map(function(part) {
            return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
          });
          return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
        },
        any: function() {
          return "any character";
        },
        end: function() {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        }
      };
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s22) {
        return s22.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function classEscape(s22) {
        return s22.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = expected2.map(describeExpectation);
        var i, j;
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {};
      var peg$source = options.grammarSource;
      var peg$startRuleFunctions = { body: peg$parsebody };
      var peg$startRuleFunction = peg$parsebody;
      var peg$e0 = peg$otherExpectation("decl_start");
      var peg$e1 = peg$otherExpectation("decl_end");
      var peg$e2 = peg$otherExpectation("vert");
      var peg$e3 = peg$anyExpectation();
      var peg$e4 = peg$otherExpectation("l");
      var peg$e5 = peg$otherExpectation("r");
      var peg$e6 = peg$otherExpectation("c");
      var peg$e7 = peg$otherExpectation("p");
      var peg$e8 = peg$otherExpectation("m");
      var peg$e9 = peg$otherExpectation("b");
      var peg$e10 = peg$otherExpectation("w");
      var peg$e11 = peg$otherExpectation("W");
      var peg$e12 = peg$otherExpectation("X");
      var peg$e13 = peg$otherExpectation("!");
      var peg$e14 = peg$otherExpectation("@");
      var peg$e15 = peg$otherExpectation("<");
      var peg$e16 = peg$otherExpectation(">");
      var peg$e17 = peg$otherExpectation("group");
      var peg$e18 = peg$otherExpectation("whitespace");
      var peg$f0 = function(c) {
        return c;
      };
      var peg$f1 = function(cols) {
        return cols;
      };
      var peg$f2 = function() {
        return [];
      };
      var peg$f3 = function(divs1, start, a, end, divs2) {
        return {
          type: "column",
          pre_dividers: divs1,
          post_dividers: divs2,
          before_start_code: start,
          before_end_code: end,
          alignment: a
        };
      };
      var peg$f4 = function() {
        return {
          type: "vert_divider"
        };
      };
      var peg$f5 = function(b, g) {
        return {
          type: "bang_divider",
          content: g[0].content
        };
      };
      var peg$f6 = function(g) {
        return {
          type: "at_divider",
          content: g[0].content
        };
      };
      var peg$f7 = function(div) {
        return div;
      };
      var peg$f8 = function(g) {
        return { type: "decl_code", code: g[0].content };
      };
      var peg$f9 = function(g) {
        return { type: "decl_code", code: g[0].content };
      };
      var peg$f10 = function() {
        return { type: "alignment", alignment: "left" };
      };
      var peg$f11 = function() {
        return { type: "alignment", alignment: "center" };
      };
      var peg$f12 = function() {
        return { type: "alignment", alignment: "right" };
      };
      var peg$f13 = function() {
        return { type: "alignment", alignment: "X" };
      };
      var peg$f14 = function() {
        return "top";
      };
      var peg$f15 = function() {
        return "default";
      };
      var peg$f16 = function() {
        return "bottom";
      };
      var peg$f17 = function(a, g) {
        return {
          type: "alignment",
          alignment: "parbox",
          baseline: a,
          size: g[0].content
        };
      };
      var peg$f18 = function(g1, g2) {
        return {
          type: "alignment",
          alignment: "parbox",
          baseline: g1[0].content,
          size: g2[0].content
        };
      };
      var peg$f19 = function(tok) {
        return options.matchChar(tok, "|");
      };
      var peg$f20 = function(tok) {
        return options.matchChar(tok, "l");
      };
      var peg$f21 = function(tok) {
        return options.matchChar(tok, "r");
      };
      var peg$f22 = function(tok) {
        return options.matchChar(tok, "c");
      };
      var peg$f23 = function(tok) {
        return options.matchChar(tok, "p");
      };
      var peg$f24 = function(tok) {
        return options.matchChar(tok, "m");
      };
      var peg$f25 = function(tok) {
        return options.matchChar(tok, "b");
      };
      var peg$f26 = function(tok) {
        return options.matchChar(tok, "w");
      };
      var peg$f27 = function(tok) {
        return options.matchChar(tok, "W");
      };
      var peg$f28 = function(tok) {
        return options.matchChar(tok, "X");
      };
      var peg$f29 = function(tok) {
        return options.matchChar(tok, "!");
      };
      var peg$f30 = function(tok) {
        return options.matchChar(tok, "@");
      };
      var peg$f31 = function(tok) {
        return options.matchChar(tok, "<");
      };
      var peg$f32 = function(tok) {
        return options.matchChar(tok, ">");
      };
      var peg$f33 = function(tok) {
        return options.isGroup(tok);
      };
      var peg$f34 = function(tok) {
        return options.isWhitespace(tok);
      };
      var peg$currPos = 0;
      var peg$savedPos = 0;
      var peg$posDetailsCache = [{ line: 1, column: 1 }];
      var peg$maxFailPos = 0;
      var peg$maxFailExpected = [];
      var peg$silentFails = 0;
      var peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function offset() {
        return peg$savedPos;
      }
      function range() {
        return {
          source: peg$source,
          start: peg$savedPos,
          end: peg$currPos
        };
      }
      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError(
          [peg$otherExpectation(description)],
          input.substring(peg$savedPos, peg$currPos),
          location2
        );
      }
      function error(message, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location2);
      }
      function peg$literalExpectation(text2, ignoreCase) {
        return { type: "literal", text: text2, ignoreCase };
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts, inverted, ignoreCase };
      }
      function peg$anyExpectation() {
        return { type: "any" };
      }
      function peg$endExpectation() {
        return { type: "end" };
      }
      function peg$otherExpectation(description) {
        return { type: "other", description };
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p;
        if (details) {
          return details;
        } else {
          p = pos - 1;
          while (!peg$posDetailsCache[p]) {
            p--;
          }
          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };
          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos);
        var endPosDetails = peg$computePosDetails(endPos);
        return {
          source: peg$source,
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildSimpleError(message, location2) {
        return new peg$SyntaxError(message, null, null, location2);
      }
      function peg$buildStructuredError(expected2, found, location2) {
        return new peg$SyntaxError(
          peg$SyntaxError.buildMessage(expected2, found),
          expected2,
          found,
          location2
        );
      }
      function peg$parsebody() {
        var s0, s1, s22, s32, s42, s5;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$currPos;
        s32 = peg$parsecolumn();
        if (s32 !== peg$FAILED) {
          s42 = [];
          s5 = peg$parse_();
          while (s5 !== peg$FAILED) {
            s42.push(s5);
            s5 = peg$parse_();
          }
          peg$savedPos = s22;
          s22 = peg$f0(s32);
        } else {
          peg$currPos = s22;
          s22 = peg$FAILED;
        }
        if (s22 !== peg$FAILED) {
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            s22 = peg$currPos;
            s32 = peg$parsecolumn();
            if (s32 !== peg$FAILED) {
              s42 = [];
              s5 = peg$parse_();
              while (s5 !== peg$FAILED) {
                s42.push(s5);
                s5 = peg$parse_();
              }
              peg$savedPos = s22;
              s22 = peg$f0(s32);
            } else {
              peg$currPos = s22;
              s22 = peg$FAILED;
            }
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f1(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseEOL();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f2();
          }
          s0 = s1;
        }
        return s0;
      }
      function peg$parsecolumn() {
        var s0, s1, s22, s32, s42, s5, s6;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsecolumn_divider();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parsecolumn_divider();
        }
        s22 = peg$parsedecl_start();
        if (s22 === peg$FAILED) {
          s22 = null;
        }
        s32 = peg$parsealignment();
        if (s32 !== peg$FAILED) {
          s42 = peg$parsedecl_end();
          if (s42 === peg$FAILED) {
            s42 = null;
          }
          s5 = [];
          s6 = peg$parsecolumn_divider();
          while (s6 !== peg$FAILED) {
            s5.push(s6);
            s6 = peg$parsecolumn_divider();
          }
          peg$savedPos = s0;
          s0 = peg$f3(s1, s22, s32, s42, s5);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecolumn_divider() {
        var s0, s1, s22, s32, s42;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parse_();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parse_();
        }
        s22 = peg$currPos;
        s32 = peg$parsevert();
        if (s32 !== peg$FAILED) {
          peg$savedPos = s22;
          s32 = peg$f4();
        }
        s22 = s32;
        if (s22 === peg$FAILED) {
          s22 = peg$currPos;
          s32 = peg$parsebang();
          if (s32 !== peg$FAILED) {
            s42 = peg$parsegroup();
            if (s42 !== peg$FAILED) {
              peg$savedPos = s22;
              s22 = peg$f5(s32, s42);
            } else {
              peg$currPos = s22;
              s22 = peg$FAILED;
            }
          } else {
            peg$currPos = s22;
            s22 = peg$FAILED;
          }
          if (s22 === peg$FAILED) {
            s22 = peg$currPos;
            s32 = peg$parseat();
            if (s32 !== peg$FAILED) {
              s42 = peg$parsegroup();
              if (s42 !== peg$FAILED) {
                peg$savedPos = s22;
                s22 = peg$f6(s42);
              } else {
                peg$currPos = s22;
                s22 = peg$FAILED;
              }
            } else {
              peg$currPos = s22;
              s22 = peg$FAILED;
            }
          }
        }
        if (s22 !== peg$FAILED) {
          s32 = [];
          s42 = peg$parse_();
          while (s42 !== peg$FAILED) {
            s32.push(s42);
            s42 = peg$parse_();
          }
          peg$savedPos = s0;
          s0 = peg$f7(s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsedecl_start() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parsegreater();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsegroup();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f8(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        return s0;
      }
      function peg$parsedecl_end() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parseless();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsegroup();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f9(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e1);
          }
        }
        return s0;
      }
      function peg$parsealignment() {
        var s0, s1, s22, s32, s42, s5;
        s0 = peg$currPos;
        s1 = peg$parsel();
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f10();
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsec();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f11();
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parser();
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$f12();
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parseX();
              if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$f13();
              }
              s0 = s1;
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$currPos;
                s22 = peg$parsep();
                if (s22 !== peg$FAILED) {
                  peg$savedPos = s1;
                  s22 = peg$f14();
                }
                s1 = s22;
                if (s1 === peg$FAILED) {
                  s1 = peg$currPos;
                  s22 = peg$parsem();
                  if (s22 !== peg$FAILED) {
                    peg$savedPos = s1;
                    s22 = peg$f15();
                  }
                  s1 = s22;
                  if (s1 === peg$FAILED) {
                    s1 = peg$currPos;
                    s22 = peg$parseb();
                    if (s22 !== peg$FAILED) {
                      peg$savedPos = s1;
                      s22 = peg$f16();
                    }
                    s1 = s22;
                  }
                }
                if (s1 !== peg$FAILED) {
                  s22 = [];
                  s32 = peg$parse_();
                  while (s32 !== peg$FAILED) {
                    s22.push(s32);
                    s32 = peg$parse_();
                  }
                  s32 = peg$parsegroup();
                  if (s32 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s0 = peg$f17(s1, s32);
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  s1 = peg$parsew();
                  if (s1 === peg$FAILED) {
                    s1 = peg$parseW();
                  }
                  if (s1 !== peg$FAILED) {
                    s22 = [];
                    s32 = peg$parse_();
                    while (s32 !== peg$FAILED) {
                      s22.push(s32);
                      s32 = peg$parse_();
                    }
                    s32 = peg$parsegroup();
                    if (s32 !== peg$FAILED) {
                      s42 = [];
                      s5 = peg$parse_();
                      while (s5 !== peg$FAILED) {
                        s42.push(s5);
                        s5 = peg$parse_();
                      }
                      s5 = peg$parsegroup();
                      if (s5 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s0 = peg$f18(s32, s5);
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                }
              }
            }
          }
        }
        return s0;
      }
      function peg$parsevert() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f19(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        return s0;
      }
      function peg$parsel() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f20(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e4);
          }
        }
        return s0;
      }
      function peg$parser() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f21(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e5);
          }
        }
        return s0;
      }
      function peg$parsec() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f22(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e6);
          }
        }
        return s0;
      }
      function peg$parsep() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f23(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e7);
          }
        }
        return s0;
      }
      function peg$parsem() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f24(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e8);
          }
        }
        return s0;
      }
      function peg$parseb() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f25(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e9);
          }
        }
        return s0;
      }
      function peg$parsew() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f26(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e10);
          }
        }
        return s0;
      }
      function peg$parseW() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f27(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e11);
          }
        }
        return s0;
      }
      function peg$parseX() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f28(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e12);
          }
        }
        return s0;
      }
      function peg$parsebang() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f29(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e13);
          }
        }
        return s0;
      }
      function peg$parseat() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f30(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e14);
          }
        }
        return s0;
      }
      function peg$parseless() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f31(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e15);
          }
        }
        return s0;
      }
      function peg$parsegreater() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f32(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e16);
          }
        }
        return s0;
      }
      function peg$parsegroup() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f33(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e17);
          }
        }
        return s0;
      }
      function peg$parse_() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f34(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e18);
          }
        }
        return s0;
      }
      function peg$parseEOL() {
        var s0, s1;
        s0 = peg$currPos;
        peg$silentFails++;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        peg$silentFails--;
        if (s1 === peg$FAILED) {
          s0 = void 0;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      if (!options.isHash) {
        try {
          Object.assign(options, {
            matchChar: (node, char) => node.type === "string" && node.content === char,
            isGroup: (node) => node.type === "group",
            isWhitespace: (node) => node.type === "whitespace"
          });
        } catch (e) {
          console.warn("Error when initializing parser", e);
        }
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(
          peg$maxFailExpected,
          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
      }
    }
    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }()
);
var systeme_environment_default6 = (
  // Generated by Peggy 2.0.1.
  //
  // https://peggyjs.org/
  function() {
    "use strict";
    function peg$subclass(child, parent) {
      function C() {
        this.constructor = child;
      }
      C.prototype = parent.prototype;
      child.prototype = new C();
    }
    function peg$SyntaxError(message, expected, found, location) {
      var self = Error.call(this, message);
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(self, peg$SyntaxError.prototype);
      }
      self.expected = expected;
      self.found = found;
      self.location = location;
      self.name = "SyntaxError";
      return self;
    }
    peg$subclass(peg$SyntaxError, Error);
    function peg$padEnd(str, targetLength, padString) {
      padString = padString || " ";
      if (str.length > targetLength) {
        return str;
      }
      targetLength -= str.length;
      padString += padString.repeat(targetLength);
      return str + padString.slice(0, targetLength);
    }
    peg$SyntaxError.prototype.format = function(sources) {
      var str = "Error: " + this.message;
      if (this.location) {
        var src = null;
        var k;
        for (k = 0; k < sources.length; k++) {
          if (sources[k].source === this.location.source) {
            src = sources[k].text.split(/\r\n|\n|\r/g);
            break;
          }
        }
        var s22 = this.location.start;
        var loc = this.location.source + ":" + s22.line + ":" + s22.column;
        if (src) {
          var e = this.location.end;
          var filler = peg$padEnd("", s22.line.toString().length, " ");
          var line = src[s22.line - 1];
          var last = s22.line === e.line ? e.column : line.length + 1;
          var hatLen = last - s22.column || 1;
          str += "\n --> " + loc + "\n" + filler + " |\n" + s22.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s22.column - 1, " ") + peg$padEnd("", hatLen, "^");
        } else {
          str += "\n at " + loc;
        }
      }
      return str;
    };
    peg$SyntaxError.buildMessage = function(expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        class: function(expectation) {
          var escapedParts = expectation.parts.map(function(part) {
            return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
          });
          return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
        },
        any: function() {
          return "any character";
        },
        end: function() {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        }
      };
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s22) {
        return s22.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function classEscape(s22) {
        return s22.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = expected2.map(describeExpectation);
        var i, j;
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {};
      var peg$source = options.grammarSource;
      var peg$startRuleFunctions = { body: peg$parsebody };
      var peg$startRuleFunction = peg$parsebody;
      var peg$e0 = peg$otherExpectation("partial item");
      var peg$e1 = peg$otherExpectation("item");
      var peg$e2 = peg$anyExpectation();
      var peg$e3 = peg$otherExpectation("equation");
      var peg$e4 = peg$otherExpectation("trailing comment");
      var peg$e5 = peg$otherExpectation("comment only line");
      var peg$e6 = peg$otherExpectation("non-var token");
      var peg$e7 = peg$otherExpectation("token");
      var peg$e8 = peg$otherExpectation("same line comment");
      var peg$e9 = peg$otherExpectation("own line comment");
      var peg$e10 = peg$otherExpectation(",");
      var peg$e11 = peg$otherExpectation("@");
      var peg$e12 = peg$otherExpectation("variable token");
      var peg$e13 = peg$otherExpectation("+/-");
      var peg$e14 = peg$otherExpectation("=");
      var peg$f0 = function(a, b) {
        return a.concat(b ? b : []);
      };
      var peg$f1 = function() {
        return [];
      };
      var peg$f2 = function(a, b, c) {
        return a.concat(b, c);
      };
      var peg$f3 = function(op, a, b, c) {
        return { type: "item", op, variable: b, content: a.concat(b, c) };
      };
      var peg$f4 = function(op, a) {
        return { type: "item", op, variable: null, content: a };
      };
      var peg$f5 = function(line, sep, comment2222) {
        return { ...line, sep: [].concat(sep), trailingComment: comment2222 };
      };
      var peg$f6 = function(line, comment2222) {
        return { ...line, trailingComment: comment2222 };
      };
      var peg$f7 = function(eq, ann) {
        return {
          type: "line",
          equation: eq,
          annotation: ann,
          sep: null
        };
      };
      var peg$f8 = function(at, ann) {
        return at ? { type: "annotation", marker: at, content: ann } : null;
      };
      var peg$f9 = function(left, eq, right) {
        return { type: "equation", left, right, equals: eq };
      };
      var peg$f10 = function(x) {
        return x;
      };
      var peg$f11 = function(x) {
        return {
          type: "line",
          trailingComment: x
        };
      };
      var peg$f12 = function(v, s22) {
        return [v].concat(s22 ? s22 : []);
      };
      var peg$f13 = function(t) {
        return t;
      };
      var peg$f14 = function(x) {
        return x;
      };
      var peg$f15 = function(x) {
        return x;
      };
      var peg$f16 = function(tok) {
        return options.isSameLineComment(tok);
      };
      var peg$f17 = function(tok) {
        return tok;
      };
      var peg$f18 = function(tok) {
        return options.isOwnLineComment(tok);
      };
      var peg$f19 = function(tok) {
        return tok;
      };
      var peg$f20 = function(tok) {
        return options.isWhitespace(tok);
      };
      var peg$f21 = function(tok) {
        return tok;
      };
      var peg$f22 = function(tok) {
        return options.isSep(tok);
      };
      var peg$f23 = function(tok) {
        return tok;
      };
      var peg$f24 = function(tok) {
        return options.isAt(tok);
      };
      var peg$f25 = function(tok) {
        return tok;
      };
      var peg$f26 = function(tok) {
        return options.isVar(tok);
      };
      var peg$f27 = function(tok) {
        return tok;
      };
      var peg$f28 = function(tok) {
        return options.isOperation(tok);
      };
      var peg$f29 = function(tok) {
        return tok;
      };
      var peg$f30 = function(tok) {
        return options.isEquals(tok);
      };
      var peg$f31 = function(tok) {
        return tok;
      };
      var peg$f32 = function(tok) {
        return options.isSubscript(tok);
      };
      var peg$f33 = function(tok) {
        return tok;
      };
      var peg$currPos = 0;
      var peg$savedPos = 0;
      var peg$posDetailsCache = [{ line: 1, column: 1 }];
      var peg$maxFailPos = 0;
      var peg$maxFailExpected = [];
      var peg$silentFails = 0;
      var peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function offset() {
        return peg$savedPos;
      }
      function range() {
        return {
          source: peg$source,
          start: peg$savedPos,
          end: peg$currPos
        };
      }
      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError(
          [peg$otherExpectation(description)],
          input.substring(peg$savedPos, peg$currPos),
          location2
        );
      }
      function error(message, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location2);
      }
      function peg$literalExpectation(text2, ignoreCase) {
        return { type: "literal", text: text2, ignoreCase };
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts, inverted, ignoreCase };
      }
      function peg$anyExpectation() {
        return { type: "any" };
      }
      function peg$endExpectation() {
        return { type: "end" };
      }
      function peg$otherExpectation(description) {
        return { type: "other", description };
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p;
        if (details) {
          return details;
        } else {
          p = pos - 1;
          while (!peg$posDetailsCache[p]) {
            p--;
          }
          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };
          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos);
        var endPosDetails = peg$computePosDetails(endPos);
        return {
          source: peg$source,
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildSimpleError(message, location2) {
        return new peg$SyntaxError(message, null, null, location2);
      }
      function peg$buildStructuredError(expected2, found, location2) {
        return new peg$SyntaxError(
          peg$SyntaxError.buildMessage(expected2, found),
          expected2,
          found,
          location2
        );
      }
      function peg$parsebody() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsecomment_only_line();
        if (s22 === peg$FAILED) {
          s22 = peg$parseline_with_sep();
          if (s22 === peg$FAILED) {
            s22 = peg$parsepartial_line_with_comment();
          }
        }
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parsecomment_only_line();
          if (s22 === peg$FAILED) {
            s22 = peg$parseline_with_sep();
            if (s22 === peg$FAILED) {
              s22 = peg$parsepartial_line_with_comment();
            }
          }
        }
        s22 = peg$parseline_without_sep();
        if (s22 === peg$FAILED) {
          s22 = peg$parseEOL();
        }
        if (s22 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f0(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseEOL();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f1();
          }
          s0 = s1;
        }
        return s0;
      }
      function peg$parsepartial_item() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parse_();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parse_();
        }
        s22 = [];
        s32 = peg$parsenon_var_token();
        while (s32 !== peg$FAILED) {
          s22.push(s32);
          s32 = peg$parsenon_var_token();
        }
        s32 = [];
        s42 = peg$parse_();
        while (s42 !== peg$FAILED) {
          s32.push(s42);
          s42 = peg$parse_();
        }
        s42 = peg$parsevar();
        if (s42 !== peg$FAILED) {
          s5 = [];
          s6 = peg$parse_();
          while (s6 !== peg$FAILED) {
            s5.push(s6);
            s6 = peg$parse_();
          }
          s6 = [];
          s7 = peg$parsetoken();
          while (s7 !== peg$FAILED) {
            s6.push(s7);
            s7 = peg$parsetoken();
          }
          s7 = [];
          s8 = peg$parse_();
          while (s8 !== peg$FAILED) {
            s7.push(s8);
            s8 = peg$parse_();
          }
          peg$savedPos = s0;
          s0 = peg$f2(s22, s42, s6);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        return s0;
      }
      function peg$parseitem() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8, s9;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parseoperation();
        if (s1 === peg$FAILED) {
          s1 = null;
        }
        s22 = [];
        s32 = peg$parse_();
        while (s32 !== peg$FAILED) {
          s22.push(s32);
          s32 = peg$parse_();
        }
        s32 = [];
        s42 = peg$parsenon_var_token();
        while (s42 !== peg$FAILED) {
          s32.push(s42);
          s42 = peg$parsenon_var_token();
        }
        s42 = [];
        s5 = peg$parse_();
        while (s5 !== peg$FAILED) {
          s42.push(s5);
          s5 = peg$parse_();
        }
        s5 = peg$parsevar();
        if (s5 !== peg$FAILED) {
          s6 = [];
          s7 = peg$parse_();
          while (s7 !== peg$FAILED) {
            s6.push(s7);
            s7 = peg$parse_();
          }
          s7 = [];
          s8 = peg$parsetoken();
          while (s8 !== peg$FAILED) {
            s7.push(s8);
            s8 = peg$parsetoken();
          }
          s8 = [];
          s9 = peg$parse_();
          while (s9 !== peg$FAILED) {
            s8.push(s9);
            s9 = peg$parse_();
          }
          peg$savedPos = s0;
          s0 = peg$f3(s1, s32, s5, s7);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseoperation();
          if (s1 === peg$FAILED) {
            s1 = null;
          }
          s22 = [];
          s32 = peg$parse_();
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parse_();
          }
          s32 = [];
          s42 = peg$parsenon_var_token();
          if (s42 !== peg$FAILED) {
            while (s42 !== peg$FAILED) {
              s32.push(s42);
              s42 = peg$parsenon_var_token();
            }
          } else {
            s32 = peg$FAILED;
          }
          if (s32 !== peg$FAILED) {
            s42 = [];
            s5 = peg$parse_();
            while (s5 !== peg$FAILED) {
              s42.push(s5);
              s5 = peg$parse_();
            }
            peg$savedPos = s0;
            s0 = peg$f4(s1, s32);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e1);
          }
        }
        return s0;
      }
      function peg$parseline_with_sep() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$parseline_without_sep();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsesep();
          if (s22 !== peg$FAILED) {
            s32 = peg$parsetrailing_comment();
            if (s32 === peg$FAILED) {
              s32 = null;
            }
            peg$savedPos = s0;
            s0 = peg$f5(s1, s22, s32);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsepartial_line_with_comment() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parseline_without_sep();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsetrailing_comment();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f6(s1, s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseline_without_sep() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        if (input.length > peg$currPos) {
          s22 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s22 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        peg$silentFails--;
        if (s22 !== peg$FAILED) {
          peg$currPos = s1;
          s1 = void 0;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parseequation();
          s32 = peg$parseannotation();
          if (s32 === peg$FAILED) {
            s32 = null;
          }
          peg$savedPos = s0;
          s0 = peg$f7(s22, s32);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseannotation() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$parseat();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$parsenon_sep_token();
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parsenon_sep_token();
          }
          peg$savedPos = s0;
          s0 = peg$f8(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseequation() {
        var s0, s1, s22, s32, s42;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parseitem();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parseitem();
        }
        s22 = peg$parseequals();
        if (s22 === peg$FAILED) {
          s22 = null;
        }
        s32 = [];
        s42 = peg$parsetoken();
        if (s42 === peg$FAILED) {
          s42 = peg$parseoperation();
        }
        while (s42 !== peg$FAILED) {
          s32.push(s42);
          s42 = peg$parsetoken();
          if (s42 === peg$FAILED) {
            s42 = peg$parseoperation();
          }
        }
        peg$savedPos = s0;
        s0 = peg$f9(s1, s22, s32);
        peg$silentFails--;
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e3);
        }
        return s0;
      }
      function peg$parsetrailing_comment() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parse_();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parse_();
        }
        s22 = peg$parsesame_line_comment();
        if (s22 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f10(s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e4);
          }
        }
        return s0;
      }
      function peg$parsecomment_only_line() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parse_();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parse_();
        }
        s22 = peg$parseown_line_comment();
        if (s22 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f11(s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e5);
          }
        }
        return s0;
      }
      function peg$parsevar() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$parsevar_token();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$parse_();
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parse_();
          }
          s32 = peg$parsesubscript();
          if (s32 === peg$FAILED) {
            s32 = null;
          }
          peg$savedPos = s0;
          s0 = peg$f12(s1, s32);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsenon_var_token() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        s22 = peg$parsevar();
        peg$silentFails--;
        if (s22 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parsetoken();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f13(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e6);
          }
        }
        return s0;
      }
      function peg$parsenon_sep_token() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        s22 = peg$parsesep();
        if (s22 === peg$FAILED) {
          s22 = peg$parsetrailing_comment();
          if (s22 === peg$FAILED) {
            s22 = peg$parseown_line_comment();
          }
        }
        peg$silentFails--;
        if (s22 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s22 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f14(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsetoken() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        s22 = peg$parsesep();
        if (s22 === peg$FAILED) {
          s22 = peg$parseat();
          if (s22 === peg$FAILED) {
            s22 = peg$parseoperation();
            if (s22 === peg$FAILED) {
              s22 = peg$parseequals();
              if (s22 === peg$FAILED) {
                s22 = peg$parsetrailing_comment();
                if (s22 === peg$FAILED) {
                  s22 = peg$parseown_line_comment();
                }
              }
            }
          }
        }
        peg$silentFails--;
        if (s22 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s22 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f15(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e7);
          }
        }
        return s0;
      }
      function peg$parsesame_line_comment() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f16(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f17(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e8);
          }
        }
        return s0;
      }
      function peg$parseown_line_comment() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f18(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f19(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e9);
          }
        }
        return s0;
      }
      function peg$parse_() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f20(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f21(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsesep() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f22(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f23(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e10);
          }
        }
        return s0;
      }
      function peg$parseat() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f24(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f25(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e11);
          }
        }
        return s0;
      }
      function peg$parsevar_token() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f26(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f27(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e12);
          }
        }
        return s0;
      }
      function peg$parseoperation() {
        var s0, s1, s22, s32, s42;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parse_();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parse_();
        }
        if (input.length > peg$currPos) {
          s22 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s22 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        if (s22 !== peg$FAILED) {
          s32 = [];
          s42 = peg$parse_();
          while (s42 !== peg$FAILED) {
            s32.push(s42);
            s42 = peg$parse_();
          }
          peg$savedPos = peg$currPos;
          s42 = peg$f28(s22);
          if (s42) {
            s42 = void 0;
          } else {
            s42 = peg$FAILED;
          }
          if (s42 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f29(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e13);
          }
        }
        return s0;
      }
      function peg$parseequals() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f30(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f31(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e14);
          }
        }
        return s0;
      }
      function peg$parsesubscript() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f32(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f33(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseEOL() {
        var s0, s1;
        s0 = peg$currPos;
        peg$silentFails++;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        peg$silentFails--;
        if (s1 === peg$FAILED) {
          s0 = void 0;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      if (!options.isWhitespace) {
        try {
          Object.assign(options, {
            isSep: (node) => node.type === "string" && node.content === ",",
            isVar: (node) => node.type === "string" && node.content.match(/[a-zA-Z]/),
            isOperation: (node) => node.type === "string" && node.content.match(/[+-]/),
            isEquals: (node) => node.type === "string" && node.content === "=",
            isAt: (node) => node.type === "string" && node.content === "@",
            isSubscript: (node) => node.content === "_",
            isWhitespace: (node) => node.type === "whitespace",
            isSameLineComment: (node) => node.type === "comment" && node.sameline,
            isOwnLineComment: (node) => node.type === "comment" && !node.sameline
          });
        } catch (e) {
          console.warn("Error when initializing parser", e);
        }
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(
          peg$maxFailExpected,
          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
      }
    }
    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }()
);
var tex_glue_default6 = (
  // Generated by Peggy 2.0.1.
  //
  // https://peggyjs.org/
  function() {
    "use strict";
    function peg$subclass(child, parent) {
      function C() {
        this.constructor = child;
      }
      C.prototype = parent.prototype;
      child.prototype = new C();
    }
    function peg$SyntaxError(message, expected, found, location) {
      var self = Error.call(this, message);
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(self, peg$SyntaxError.prototype);
      }
      self.expected = expected;
      self.found = found;
      self.location = location;
      self.name = "SyntaxError";
      return self;
    }
    peg$subclass(peg$SyntaxError, Error);
    function peg$padEnd(str, targetLength, padString) {
      padString = padString || " ";
      if (str.length > targetLength) {
        return str;
      }
      targetLength -= str.length;
      padString += padString.repeat(targetLength);
      return str + padString.slice(0, targetLength);
    }
    peg$SyntaxError.prototype.format = function(sources) {
      var str = "Error: " + this.message;
      if (this.location) {
        var src = null;
        var k;
        for (k = 0; k < sources.length; k++) {
          if (sources[k].source === this.location.source) {
            src = sources[k].text.split(/\r\n|\n|\r/g);
            break;
          }
        }
        var s22 = this.location.start;
        var loc = this.location.source + ":" + s22.line + ":" + s22.column;
        if (src) {
          var e = this.location.end;
          var filler = peg$padEnd("", s22.line.toString().length, " ");
          var line = src[s22.line - 1];
          var last = s22.line === e.line ? e.column : line.length + 1;
          var hatLen = last - s22.column || 1;
          str += "\n --> " + loc + "\n" + filler + " |\n" + s22.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s22.column - 1, " ") + peg$padEnd("", hatLen, "^");
        } else {
          str += "\n at " + loc;
        }
      }
      return str;
    };
    peg$SyntaxError.buildMessage = function(expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        class: function(expectation) {
          var escapedParts = expectation.parts.map(function(part) {
            return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
          });
          return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
        },
        any: function() {
          return "any character";
        },
        end: function() {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        }
      };
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s22) {
        return s22.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function classEscape(s22) {
        return s22.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = expected2.map(describeExpectation);
        var i, j;
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {};
      var peg$source = options.grammarSource;
      var peg$startRuleFunctions = { root: peg$parseroot };
      var peg$startRuleFunction = peg$parseroot;
      var peg$c0 = "plus";
      var peg$c1 = "minus";
      var peg$c2 = "pt";
      var peg$c3 = "mm";
      var peg$c4 = "cm";
      var peg$c5 = "in";
      var peg$c6 = "ex";
      var peg$c7 = "em";
      var peg$c8 = "bp";
      var peg$c9 = "pc";
      var peg$c10 = "dd";
      var peg$c11 = "cc";
      var peg$c12 = "nd";
      var peg$c13 = "nc";
      var peg$c14 = "sp";
      var peg$c15 = "filll";
      var peg$c16 = "fill";
      var peg$c17 = "fil";
      var peg$c18 = ".";
      var peg$c19 = "+";
      var peg$c20 = "-";
      var peg$r0 = /^[0-9]/;
      var peg$e0 = peg$anyExpectation();
      var peg$e1 = peg$literalExpectation("plus", false);
      var peg$e2 = peg$literalExpectation("minus", false);
      var peg$e3 = peg$literalExpectation("pt", false);
      var peg$e4 = peg$literalExpectation("mm", false);
      var peg$e5 = peg$literalExpectation("cm", false);
      var peg$e6 = peg$literalExpectation("in", false);
      var peg$e7 = peg$literalExpectation("ex", false);
      var peg$e8 = peg$literalExpectation("em", false);
      var peg$e9 = peg$literalExpectation("bp", false);
      var peg$e10 = peg$literalExpectation("pc", false);
      var peg$e11 = peg$literalExpectation("dd", false);
      var peg$e12 = peg$literalExpectation("cc", false);
      var peg$e13 = peg$literalExpectation("nd", false);
      var peg$e14 = peg$literalExpectation("nc", false);
      var peg$e15 = peg$literalExpectation("sp", false);
      var peg$e16 = peg$literalExpectation("filll", false);
      var peg$e17 = peg$literalExpectation("fill", false);
      var peg$e18 = peg$literalExpectation("fil", false);
      var peg$e19 = peg$otherExpectation("number");
      var peg$e20 = peg$classExpectation([["0", "9"]], false, false);
      var peg$e21 = peg$literalExpectation(".", false);
      var peg$e22 = peg$literalExpectation("+", false);
      var peg$e23 = peg$literalExpectation("-", false);
      var peg$f0 = function(b, st, sh) {
        return {
          type: "glue",
          fixed: b,
          stretchable: st,
          shrinkable: sh,
          position: location()
        };
      };
      var peg$f1 = function(glue) {
        return glue;
      };
      var peg$f2 = function(n, u) {
        return { type: "dim", value: n, unit: u };
      };
      var peg$f3 = function(n, u) {
        return { type: "dim", value: n, unit: u };
      };
      var peg$f4 = function(n, u) {
        return { type: "dim", value: n, unit: u };
      };
      var peg$f5 = function(n) {
        return parseFloat(n);
      };
      var peg$currPos = 0;
      var peg$savedPos = 0;
      var peg$posDetailsCache = [{ line: 1, column: 1 }];
      var peg$maxFailPos = 0;
      var peg$maxFailExpected = [];
      var peg$silentFails = 0;
      var peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function offset() {
        return peg$savedPos;
      }
      function range() {
        return {
          source: peg$source,
          start: peg$savedPos,
          end: peg$currPos
        };
      }
      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError(
          [peg$otherExpectation(description)],
          input.substring(peg$savedPos, peg$currPos),
          location2
        );
      }
      function error(message, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location2);
      }
      function peg$literalExpectation(text2, ignoreCase) {
        return { type: "literal", text: text2, ignoreCase };
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts, inverted, ignoreCase };
      }
      function peg$anyExpectation() {
        return { type: "any" };
      }
      function peg$endExpectation() {
        return { type: "end" };
      }
      function peg$otherExpectation(description) {
        return { type: "other", description };
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p;
        if (details) {
          return details;
        } else {
          p = pos - 1;
          while (!peg$posDetailsCache[p]) {
            p--;
          }
          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };
          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos);
        var endPosDetails = peg$computePosDetails(endPos);
        return {
          source: peg$source,
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildSimpleError(message, location2) {
        return new peg$SyntaxError(message, null, null, location2);
      }
      function peg$buildStructuredError(expected2, found, location2) {
        return new peg$SyntaxError(
          peg$SyntaxError.buildMessage(expected2, found),
          expected2,
          found,
          location2
        );
      }
      function peg$parseroot() {
        var s0, s1, s22, s32, s42;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$parsebase();
        if (s22 !== peg$FAILED) {
          s32 = peg$parsestretchable();
          if (s32 === peg$FAILED) {
            s32 = null;
          }
          s42 = peg$parseshrinkable();
          if (s42 === peg$FAILED) {
            s42 = null;
          }
          peg$savedPos = s1;
          s1 = peg$f0(s22, s32, s42);
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s22 = [];
          if (input.length > peg$currPos) {
            s32 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s32 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            if (input.length > peg$currPos) {
              s32 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s32 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
          }
          peg$savedPos = s0;
          s0 = peg$f1(s1);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsebase() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parsenumber();
        if (s1 !== peg$FAILED) {
          s22 = peg$parseunit();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f2(s1, s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsestretchable() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 4) === peg$c0) {
          s1 = peg$c0;
          peg$currPos += 4;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e1);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parsenumber();
          if (s22 !== peg$FAILED) {
            s32 = peg$parserubber_unit();
            if (s32 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f3(s22, s32);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseshrinkable() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 5) === peg$c1) {
          s1 = peg$c1;
          peg$currPos += 5;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parsenumber();
          if (s22 !== peg$FAILED) {
            s32 = peg$parserubber_unit();
            if (s32 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f4(s22, s32);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseunit() {
        var s0;
        if (input.substr(peg$currPos, 2) === peg$c2) {
          s0 = peg$c2;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s0 === peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c3) {
            s0 = peg$c3;
            peg$currPos += 2;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e4);
            }
          }
          if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c4) {
              s0 = peg$c4;
              peg$currPos += 2;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e5);
              }
            }
            if (s0 === peg$FAILED) {
              if (input.substr(peg$currPos, 2) === peg$c5) {
                s0 = peg$c5;
                peg$currPos += 2;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e6);
                }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 2) === peg$c6) {
                  s0 = peg$c6;
                  peg$currPos += 2;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e7);
                  }
                }
                if (s0 === peg$FAILED) {
                  if (input.substr(peg$currPos, 2) === peg$c7) {
                    s0 = peg$c7;
                    peg$currPos += 2;
                  } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e8);
                    }
                  }
                  if (s0 === peg$FAILED) {
                    if (input.substr(peg$currPos, 2) === peg$c8) {
                      s0 = peg$c8;
                      peg$currPos += 2;
                    } else {
                      s0 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e9);
                      }
                    }
                    if (s0 === peg$FAILED) {
                      if (input.substr(peg$currPos, 2) === peg$c9) {
                        s0 = peg$c9;
                        peg$currPos += 2;
                      } else {
                        s0 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$e10);
                        }
                      }
                      if (s0 === peg$FAILED) {
                        if (input.substr(peg$currPos, 2) === peg$c10) {
                          s0 = peg$c10;
                          peg$currPos += 2;
                        } else {
                          s0 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$e11);
                          }
                        }
                        if (s0 === peg$FAILED) {
                          if (input.substr(peg$currPos, 2) === peg$c11) {
                            s0 = peg$c11;
                            peg$currPos += 2;
                          } else {
                            s0 = peg$FAILED;
                            if (peg$silentFails === 0) {
                              peg$fail(peg$e12);
                            }
                          }
                          if (s0 === peg$FAILED) {
                            if (input.substr(peg$currPos, 2) === peg$c12) {
                              s0 = peg$c12;
                              peg$currPos += 2;
                            } else {
                              s0 = peg$FAILED;
                              if (peg$silentFails === 0) {
                                peg$fail(peg$e13);
                              }
                            }
                            if (s0 === peg$FAILED) {
                              if (input.substr(peg$currPos, 2) === peg$c13) {
                                s0 = peg$c13;
                                peg$currPos += 2;
                              } else {
                                s0 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                  peg$fail(peg$e14);
                                }
                              }
                              if (s0 === peg$FAILED) {
                                if (input.substr(peg$currPos, 2) === peg$c14) {
                                  s0 = peg$c14;
                                  peg$currPos += 2;
                                } else {
                                  s0 = peg$FAILED;
                                  if (peg$silentFails === 0) {
                                    peg$fail(peg$e15);
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return s0;
      }
      function peg$parserubber_unit() {
        var s0;
        s0 = peg$parseunit();
        if (s0 === peg$FAILED) {
          if (input.substr(peg$currPos, 5) === peg$c15) {
            s0 = peg$c15;
            peg$currPos += 5;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e16);
            }
          }
          if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 4) === peg$c16) {
              s0 = peg$c16;
              peg$currPos += 4;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e17);
              }
            }
            if (s0 === peg$FAILED) {
              if (input.substr(peg$currPos, 3) === peg$c17) {
                s0 = peg$c17;
                peg$currPos += 3;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e18);
                }
              }
            }
          }
        }
        return s0;
      }
      function peg$parsenumber() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$currPos;
        s32 = peg$parsesign();
        if (s32 === peg$FAILED) {
          s32 = null;
        }
        s42 = peg$currPos;
        s5 = [];
        if (peg$r0.test(input.charAt(peg$currPos))) {
          s6 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s6 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e20);
          }
        }
        while (s6 !== peg$FAILED) {
          s5.push(s6);
          if (peg$r0.test(input.charAt(peg$currPos))) {
            s6 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s6 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e20);
            }
          }
        }
        if (input.charCodeAt(peg$currPos) === 46) {
          s6 = peg$c18;
          peg$currPos++;
        } else {
          s6 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e21);
          }
        }
        if (s6 !== peg$FAILED) {
          s7 = [];
          if (peg$r0.test(input.charAt(peg$currPos))) {
            s8 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s8 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e20);
            }
          }
          if (s8 !== peg$FAILED) {
            while (s8 !== peg$FAILED) {
              s7.push(s8);
              if (peg$r0.test(input.charAt(peg$currPos))) {
                s8 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s8 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e20);
                }
              }
            }
          } else {
            s7 = peg$FAILED;
          }
          if (s7 !== peg$FAILED) {
            s5 = [s5, s6, s7];
            s42 = s5;
          } else {
            peg$currPos = s42;
            s42 = peg$FAILED;
          }
        } else {
          peg$currPos = s42;
          s42 = peg$FAILED;
        }
        if (s42 === peg$FAILED) {
          s42 = [];
          if (peg$r0.test(input.charAt(peg$currPos))) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e20);
            }
          }
          if (s5 !== peg$FAILED) {
            while (s5 !== peg$FAILED) {
              s42.push(s5);
              if (peg$r0.test(input.charAt(peg$currPos))) {
                s5 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e20);
                }
              }
            }
          } else {
            s42 = peg$FAILED;
          }
        }
        if (s42 !== peg$FAILED) {
          s32 = [s32, s42];
          s22 = s32;
        } else {
          peg$currPos = s22;
          s22 = peg$FAILED;
        }
        if (s22 !== peg$FAILED) {
          s1 = input.substring(s1, peg$currPos);
        } else {
          s1 = s22;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f5(s1);
        }
        s0 = s1;
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e19);
          }
        }
        return s0;
      }
      function peg$parsesign() {
        var s0;
        if (input.charCodeAt(peg$currPos) === 43) {
          s0 = peg$c19;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e22);
          }
        }
        if (s0 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 45) {
            s0 = peg$c20;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e23);
            }
          }
        }
        return s0;
      }
      function peg$parseEOL() {
        var s0, s1;
        s0 = peg$currPos;
        peg$silentFails++;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        peg$silentFails--;
        if (s1 === peg$FAILED) {
          s0 = void 0;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(
          peg$maxFailExpected,
          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
      }
    }
    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }()
);
var tikz_default6 = (
  // Generated by Peggy 2.0.1.
  //
  // https://peggyjs.org/
  function() {
    "use strict";
    function peg$subclass(child, parent) {
      function C() {
        this.constructor = child;
      }
      C.prototype = parent.prototype;
      child.prototype = new C();
    }
    function peg$SyntaxError(message, expected, found, location) {
      var self = Error.call(this, message);
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(self, peg$SyntaxError.prototype);
      }
      self.expected = expected;
      self.found = found;
      self.location = location;
      self.name = "SyntaxError";
      return self;
    }
    peg$subclass(peg$SyntaxError, Error);
    function peg$padEnd(str, targetLength, padString) {
      padString = padString || " ";
      if (str.length > targetLength) {
        return str;
      }
      targetLength -= str.length;
      padString += padString.repeat(targetLength);
      return str + padString.slice(0, targetLength);
    }
    peg$SyntaxError.prototype.format = function(sources) {
      var str = "Error: " + this.message;
      if (this.location) {
        var src = null;
        var k;
        for (k = 0; k < sources.length; k++) {
          if (sources[k].source === this.location.source) {
            src = sources[k].text.split(/\r\n|\n|\r/g);
            break;
          }
        }
        var s22 = this.location.start;
        var loc = this.location.source + ":" + s22.line + ":" + s22.column;
        if (src) {
          var e = this.location.end;
          var filler = peg$padEnd("", s22.line.toString().length, " ");
          var line = src[s22.line - 1];
          var last = s22.line === e.line ? e.column : line.length + 1;
          var hatLen = last - s22.column || 1;
          str += "\n --> " + loc + "\n" + filler + " |\n" + s22.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s22.column - 1, " ") + peg$padEnd("", hatLen, "^");
        } else {
          str += "\n at " + loc;
        }
      }
      return str;
    };
    peg$SyntaxError.buildMessage = function(expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        class: function(expectation) {
          var escapedParts = expectation.parts.map(function(part) {
            return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
          });
          return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
        },
        any: function() {
          return "any character";
        },
        end: function() {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        }
      };
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s22) {
        return s22.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function classEscape(s22) {
        return s22.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = expected2.map(describeExpectation);
        var i, j;
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {};
      var peg$source = options.grammarSource;
      var peg$startRuleFunctions = { path_spec: peg$parsepath_spec, foreach_body: peg$parseforeach_body };
      var peg$startRuleFunction = peg$parsepath_spec;
      var peg$e0 = peg$anyExpectation();
      var peg$e1 = peg$otherExpectation("same line comment");
      var peg$e2 = peg$otherExpectation("own line comment");
      var peg$e3 = peg$otherExpectation("comment");
      var peg$e4 = peg$otherExpectation("floating comment");
      var peg$e5 = peg$otherExpectation("operation");
      var peg$e6 = peg$otherExpectation("=");
      var peg$f0 = function(v) {
        return v;
      };
      var peg$f1 = function(ops) {
        return { type: "path_spec", content: ops };
      };
      var peg$f2 = function(c1, op, comment2222) {
        return { op, comment: comment2222 };
      };
      var peg$f3 = function(c1, ops, c2, body) {
        const comments = [c1, ...ops.map((x) => x.comment), c2].filter(
          (x) => x
        );
        const attribute = ops.map((x) => x.op.content.content).join(" ");
        return {
          type: "animation",
          comments,
          attribute,
          content: body.content
        };
      };
      var peg$f4 = function(start, b) {
        return { ...b, start, type: "foreach" };
      };
      var peg$f5 = function(c1, variables, options2, c2, c3, list, c4, command) {
        const comments = [c1, c2, c3, c4].filter((x) => x);
        return {
          type: "foreach_body",
          variables,
          options: options2 && options2.content,
          list,
          command,
          comments
        };
      };
      var peg$f6 = function(c1, options2, c2, body) {
        const comments = [c1, c2].filter((x) => x);
        return {
          type: "svg_operation",
          options: options2 && options2.content,
          content: body,
          comments
        };
      };
      var peg$f7 = function(c1, c2, coord, c3, c4, x) {
        return { coord: x, comment: c4 };
      };
      var peg$f8 = function(c1, c2, coord, c3, a, c5) {
        const comments = [c1, c2, c3, a && a.comment, c5].filter((x) => x);
        return {
          type: "curve_to",
          controls: a ? [coord, a.coord] : [coord],
          comments
        };
      };
      var peg$f9 = function() {
        return { type: "line_to", command: "|-" };
      };
      var peg$f10 = function() {
        return { type: "line_to", command: "-|" };
      };
      var peg$f11 = function() {
        return { type: "line_to", command: "--" };
      };
      var peg$f12 = function(prefix, content) {
        return { type: "coordinate", content, prefix };
      };
      var peg$f13 = function(content) {
        return { type: "square_brace_group", content };
      };
      var peg$f14 = function(v) {
        return { type: "unknown", content: v };
      };
      var peg$f15 = function(tok) {
        return options.isSameLineComment(tok);
      };
      var peg$f16 = function(tok) {
        return tok;
      };
      var peg$f17 = function(tok) {
        return options.isOwnLineComment(tok);
      };
      var peg$f18 = function(tok) {
        return tok;
      };
      var peg$f19 = function(tok) {
        return options.isComment(tok);
      };
      var peg$f20 = function(tok) {
        return tok;
      };
      var peg$f21 = function(tok) {
        return options.isWhitespace(tok);
      };
      var peg$f22 = function(tok) {
        return tok;
      };
      var peg$f23 = function(c) {
        return c;
      };
      var peg$f24 = function(tok) {
        return options.isOperation(tok);
      };
      var peg$f25 = function(tok) {
        return { type: "operation", content: tok };
      };
      var peg$f26 = function(tok) {
        return options.isChar(tok, "=");
      };
      var peg$f27 = function(tok) {
        return tok;
      };
      var peg$f28 = function(tok) {
        return options.isChar(tok, "[");
      };
      var peg$f29 = function(tok) {
        return tok;
      };
      var peg$f30 = function(tok) {
        return options.isChar(tok, "]");
      };
      var peg$f31 = function(tok) {
        return tok;
      };
      var peg$f32 = function(tok) {
        return options.isChar(tok, "(");
      };
      var peg$f33 = function(tok) {
        return tok;
      };
      var peg$f34 = function(tok) {
        return options.isChar(tok, ")");
      };
      var peg$f35 = function(tok) {
        return tok;
      };
      var peg$f36 = function(tok) {
        return options.isChar(tok, "+");
      };
      var peg$f37 = function(tok) {
        return tok;
      };
      var peg$f38 = function(tok) {
        return options.isChar(tok, "-");
      };
      var peg$f39 = function(tok) {
        return tok;
      };
      var peg$f40 = function(tok) {
        return options.isChar(tok, "|");
      };
      var peg$f41 = function(tok) {
        return tok;
      };
      var peg$f42 = function(tok) {
        return options.isChar(tok, ".");
      };
      var peg$f43 = function(tok) {
        return tok;
      };
      var peg$f44 = function(tok) {
        return options.isChar(tok, "controls");
      };
      var peg$f45 = function(tok) {
        return tok;
      };
      var peg$f46 = function(tok) {
        return options.isChar(tok, "and");
      };
      var peg$f47 = function(tok) {
        return tok;
      };
      var peg$f48 = function(tok) {
        return options.isChar(tok, "svg");
      };
      var peg$f49 = function(tok) {
        return tok;
      };
      var peg$f50 = function(tok) {
        return options.isGroup(tok);
      };
      var peg$f51 = function(tok) {
        return tok;
      };
      var peg$f52 = function(tok) {
        return options.isAnyMacro(tok);
      };
      var peg$f53 = function(tok) {
        return tok;
      };
      var peg$f54 = function(tok) {
        return options.isChar(tok, "foreach");
      };
      var peg$f55 = function(tok) {
        return tok;
      };
      var peg$f56 = function(tok) {
        return options.isMacro(tok, "foreach");
      };
      var peg$f57 = function(tok) {
        return tok;
      };
      var peg$f58 = function(tok) {
        return options.isChar(tok, "in");
      };
      var peg$f59 = function(tok) {
        return tok;
      };
      var peg$f60 = function(tok) {
        return options.isChar(tok, ":");
      };
      var peg$f61 = function(tok) {
        return tok;
      };
      var peg$currPos = 0;
      var peg$savedPos = 0;
      var peg$posDetailsCache = [{ line: 1, column: 1 }];
      var peg$maxFailPos = 0;
      var peg$maxFailExpected = [];
      var peg$silentFails = 0;
      var peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function offset() {
        return peg$savedPos;
      }
      function range() {
        return {
          source: peg$source,
          start: peg$savedPos,
          end: peg$currPos
        };
      }
      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError(
          [peg$otherExpectation(description)],
          input.substring(peg$savedPos, peg$currPos),
          location2
        );
      }
      function error(message, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location2);
      }
      function peg$literalExpectation(text2, ignoreCase) {
        return { type: "literal", text: text2, ignoreCase };
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts, inverted, ignoreCase };
      }
      function peg$anyExpectation() {
        return { type: "any" };
      }
      function peg$endExpectation() {
        return { type: "end" };
      }
      function peg$otherExpectation(description) {
        return { type: "other", description };
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p;
        if (details) {
          return details;
        } else {
          p = pos - 1;
          while (!peg$posDetailsCache[p]) {
            p--;
          }
          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };
          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos);
        var endPosDetails = peg$computePosDetails(endPos);
        return {
          source: peg$source,
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildSimpleError(message, location2) {
        return new peg$SyntaxError(message, null, null, location2);
      }
      function peg$buildStructuredError(expected2, found, location2) {
        return new peg$SyntaxError(
          peg$SyntaxError.buildMessage(expected2, found),
          expected2,
          found,
          location2
        );
      }
      function peg$parsepath_spec() {
        var s0, s1, s22, s32, s42, s5;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$currPos;
        s32 = peg$parsesquare_brace_group();
        if (s32 === peg$FAILED) {
          s32 = peg$parsecoordinate();
          if (s32 === peg$FAILED) {
            s32 = peg$parsecurve_to();
            if (s32 === peg$FAILED) {
              s32 = peg$parseline_to();
              if (s32 === peg$FAILED) {
                s32 = peg$parsesvg();
                if (s32 === peg$FAILED) {
                  s32 = peg$parseforeach();
                  if (s32 === peg$FAILED) {
                    s32 = peg$parseoperation();
                    if (s32 === peg$FAILED) {
                      s32 = peg$parsecomment();
                      if (s32 === peg$FAILED) {
                        s32 = peg$parseanimation();
                        if (s32 === peg$FAILED) {
                          s32 = peg$parseunknown();
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (s32 !== peg$FAILED) {
          s42 = [];
          s5 = peg$parse_();
          while (s5 !== peg$FAILED) {
            s42.push(s5);
            s5 = peg$parse_();
          }
          peg$savedPos = s22;
          s22 = peg$f0(s32);
        } else {
          peg$currPos = s22;
          s22 = peg$FAILED;
        }
        if (s22 !== peg$FAILED) {
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            s22 = peg$currPos;
            s32 = peg$parsesquare_brace_group();
            if (s32 === peg$FAILED) {
              s32 = peg$parsecoordinate();
              if (s32 === peg$FAILED) {
                s32 = peg$parsecurve_to();
                if (s32 === peg$FAILED) {
                  s32 = peg$parseline_to();
                  if (s32 === peg$FAILED) {
                    s32 = peg$parsesvg();
                    if (s32 === peg$FAILED) {
                      s32 = peg$parseforeach();
                      if (s32 === peg$FAILED) {
                        s32 = peg$parseoperation();
                        if (s32 === peg$FAILED) {
                          s32 = peg$parsecomment();
                          if (s32 === peg$FAILED) {
                            s32 = peg$parseanimation();
                            if (s32 === peg$FAILED) {
                              s32 = peg$parseunknown();
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            if (s32 !== peg$FAILED) {
              s42 = [];
              s5 = peg$parse_();
              while (s5 !== peg$FAILED) {
                s42.push(s5);
                s5 = peg$parse_();
              }
              peg$savedPos = s22;
              s22 = peg$f0(s32);
            } else {
              peg$currPos = s22;
              s22 = peg$FAILED;
            }
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f1(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parseanimation() {
        var s0, s1, s22, s32, s42, s5, s6;
        s0 = peg$currPos;
        s1 = peg$parsecolon();
        if (s1 !== peg$FAILED) {
          s22 = peg$parse_comment_();
          s32 = [];
          s42 = peg$currPos;
          s5 = peg$parseoperation();
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_comment_();
            peg$savedPos = s42;
            s42 = peg$f2(s22, s5, s6);
          } else {
            peg$currPos = s42;
            s42 = peg$FAILED;
          }
          if (s42 !== peg$FAILED) {
            while (s42 !== peg$FAILED) {
              s32.push(s42);
              s42 = peg$currPos;
              s5 = peg$parseoperation();
              if (s5 !== peg$FAILED) {
                s6 = peg$parse_comment_();
                peg$savedPos = s42;
                s42 = peg$f2(s22, s5, s6);
              } else {
                peg$currPos = s42;
                s42 = peg$FAILED;
              }
            }
          } else {
            s32 = peg$FAILED;
          }
          if (s32 !== peg$FAILED) {
            s42 = peg$parseequals();
            if (s42 !== peg$FAILED) {
              s5 = peg$parse_comment_();
              s6 = peg$parsegroup();
              if (s6 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f3(s22, s32, s5, s6);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseforeach() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parseforeach_keyword();
        if (s1 === peg$FAILED) {
          s1 = peg$parseforeach_macro();
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parseforeach_body();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f4(s1, s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseforeach_body() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8, s9;
        s0 = peg$currPos;
        s1 = peg$parse_comment_();
        s22 = peg$currPos;
        s32 = [];
        s42 = peg$currPos;
        s5 = peg$currPos;
        peg$silentFails++;
        s6 = peg$parsein_keyword();
        if (s6 === peg$FAILED) {
          s6 = peg$parsesquare_brace_group();
        }
        peg$silentFails--;
        if (s6 === peg$FAILED) {
          s5 = void 0;
        } else {
          peg$currPos = s5;
          s5 = peg$FAILED;
        }
        if (s5 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s6 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s6 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s6 !== peg$FAILED) {
            s5 = [s5, s6];
            s42 = s5;
          } else {
            peg$currPos = s42;
            s42 = peg$FAILED;
          }
        } else {
          peg$currPos = s42;
          s42 = peg$FAILED;
        }
        while (s42 !== peg$FAILED) {
          s32.push(s42);
          s42 = peg$currPos;
          s5 = peg$currPos;
          peg$silentFails++;
          s6 = peg$parsein_keyword();
          if (s6 === peg$FAILED) {
            s6 = peg$parsesquare_brace_group();
          }
          peg$silentFails--;
          if (s6 === peg$FAILED) {
            s5 = void 0;
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
          if (s5 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s6 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            if (s6 !== peg$FAILED) {
              s5 = [s5, s6];
              s42 = s5;
            } else {
              peg$currPos = s42;
              s42 = peg$FAILED;
            }
          } else {
            peg$currPos = s42;
            s42 = peg$FAILED;
          }
        }
        s22 = input.substring(s22, peg$currPos);
        s32 = peg$parsesquare_brace_group();
        if (s32 === peg$FAILED) {
          s32 = null;
        }
        s42 = peg$parse_comment_();
        s5 = peg$parsein_keyword();
        if (s5 !== peg$FAILED) {
          s6 = peg$parse_comment_();
          s7 = peg$parsegroup();
          if (s7 === peg$FAILED) {
            s7 = peg$parsemacro();
          }
          if (s7 !== peg$FAILED) {
            s8 = peg$parse_comment_();
            s9 = peg$parseforeach();
            if (s9 === peg$FAILED) {
              s9 = peg$parsegroup();
              if (s9 === peg$FAILED) {
                s9 = peg$parsemacro();
              }
            }
            if (s9 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f5(s1, s22, s32, s42, s6, s7, s8, s9);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsesvg() {
        var s0, s1, s22, s32, s42, s5;
        s0 = peg$currPos;
        s1 = peg$parsesvg_keyword();
        if (s1 !== peg$FAILED) {
          s22 = peg$parse_comment_();
          s32 = peg$parsesquare_brace_group();
          if (s32 === peg$FAILED) {
            s32 = null;
          }
          s42 = peg$parse_comment_();
          s5 = peg$parsegroup();
          if (s5 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f6(s22, s32, s42, s5);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecurve_to() {
        var s0, s1, s22, s32, s42, s5, s6, s7, s8, s9, s10;
        s0 = peg$currPos;
        s1 = peg$parsedotdot();
        if (s1 !== peg$FAILED) {
          s22 = peg$parse_comment_();
          s32 = peg$parsecontrols_keyword();
          if (s32 !== peg$FAILED) {
            s42 = peg$parse_comment_();
            s5 = peg$parsecoordinate();
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_comment_();
              s7 = peg$currPos;
              s8 = peg$parseand_keyword();
              if (s8 !== peg$FAILED) {
                s9 = peg$parse_comment_();
                s10 = peg$parsecoordinate();
                if (s10 !== peg$FAILED) {
                  peg$savedPos = s7;
                  s7 = peg$f7(s22, s42, s5, s6, s9, s10);
                } else {
                  peg$currPos = s7;
                  s7 = peg$FAILED;
                }
              } else {
                peg$currPos = s7;
                s7 = peg$FAILED;
              }
              if (s7 === peg$FAILED) {
                s7 = null;
              }
              s8 = peg$parse_comment_();
              s9 = peg$parsedotdot();
              if (s9 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f8(s22, s42, s5, s6, s7, s8);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseline_to() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parsepipe();
        if (s1 !== peg$FAILED) {
          s22 = peg$parseminus();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f9();
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseminus();
          if (s1 !== peg$FAILED) {
            s22 = peg$parsepipe();
            if (s22 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f10();
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseminus();
            if (s1 !== peg$FAILED) {
              s22 = peg$parseminus();
              if (s22 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f11();
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
        }
        return s0;
      }
      function peg$parsecoordinate() {
        var s0, s1, s22, s32, s42, s5, s6, s7;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$currPos;
        s32 = peg$parseplus();
        if (s32 !== peg$FAILED) {
          s42 = peg$parseplus();
          if (s42 === peg$FAILED) {
            s42 = null;
          }
          s32 = [s32, s42];
          s22 = s32;
        } else {
          peg$currPos = s22;
          s22 = peg$FAILED;
        }
        if (s22 === peg$FAILED) {
          s22 = null;
        }
        s1 = input.substring(s1, peg$currPos);
        s22 = peg$parseopen_paren();
        if (s22 !== peg$FAILED) {
          s32 = peg$currPos;
          s42 = [];
          s5 = peg$currPos;
          s6 = peg$currPos;
          peg$silentFails++;
          s7 = peg$parseclose_paren();
          peg$silentFails--;
          if (s7 === peg$FAILED) {
            s6 = void 0;
          } else {
            peg$currPos = s6;
            s6 = peg$FAILED;
          }
          if (s6 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s7 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s7 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            if (s7 !== peg$FAILED) {
              s6 = [s6, s7];
              s5 = s6;
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
          while (s5 !== peg$FAILED) {
            s42.push(s5);
            s5 = peg$currPos;
            s6 = peg$currPos;
            peg$silentFails++;
            s7 = peg$parseclose_paren();
            peg$silentFails--;
            if (s7 === peg$FAILED) {
              s6 = void 0;
            } else {
              peg$currPos = s6;
              s6 = peg$FAILED;
            }
            if (s6 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s7 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s7 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              if (s7 !== peg$FAILED) {
                s6 = [s6, s7];
                s5 = s6;
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
          }
          s32 = input.substring(s32, peg$currPos);
          s42 = peg$parseclose_paren();
          if (s42 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f12(s1, s32);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsesquare_brace_group() {
        var s0, s1, s22, s32, s42, s5, s6;
        s0 = peg$currPos;
        s1 = peg$parseopen_square_brace();
        if (s1 !== peg$FAILED) {
          s22 = peg$currPos;
          s32 = [];
          s42 = peg$currPos;
          s5 = peg$currPos;
          peg$silentFails++;
          s6 = peg$parseclose_square_brace();
          peg$silentFails--;
          if (s6 === peg$FAILED) {
            s5 = void 0;
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
          if (s5 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s6 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            if (s6 !== peg$FAILED) {
              s5 = [s5, s6];
              s42 = s5;
            } else {
              peg$currPos = s42;
              s42 = peg$FAILED;
            }
          } else {
            peg$currPos = s42;
            s42 = peg$FAILED;
          }
          while (s42 !== peg$FAILED) {
            s32.push(s42);
            s42 = peg$currPos;
            s5 = peg$currPos;
            peg$silentFails++;
            s6 = peg$parseclose_square_brace();
            peg$silentFails--;
            if (s6 === peg$FAILED) {
              s5 = void 0;
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
            if (s5 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s6 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              if (s6 !== peg$FAILED) {
                s5 = [s5, s6];
                s42 = s5;
              } else {
                peg$currPos = s42;
                s42 = peg$FAILED;
              }
            } else {
              peg$currPos = s42;
              s42 = peg$FAILED;
            }
          }
          s22 = input.substring(s22, peg$currPos);
          s32 = peg$parseclose_square_brace();
          if (s32 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f13(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsedotdot() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = peg$parsedot();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsedot();
          if (s22 !== peg$FAILED) {
            s1 = [s1, s22];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseunknown() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f14(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parsesame_line_comment() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f15(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f16(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e1);
          }
        }
        return s0;
      }
      function peg$parseown_line_comment() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f17(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f18(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        return s0;
      }
      function peg$parsecomment() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f19(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f20(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        return s0;
      }
      function peg$parse_() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f21(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f22(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parse_comment_() {
        var s0, s1, s22, s32, s42;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parse_();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parse_();
        }
        s22 = peg$parsecomment();
        if (s22 === peg$FAILED) {
          s22 = null;
        }
        s32 = [];
        s42 = peg$parse_();
        while (s42 !== peg$FAILED) {
          s32.push(s42);
          s42 = peg$parse_();
        }
        peg$savedPos = s0;
        s0 = peg$f23(s22);
        peg$silentFails--;
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e4);
        }
        return s0;
      }
      function peg$parseoperation() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f24(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f25(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e5);
          }
        }
        return s0;
      }
      function peg$parseequals() {
        var s0, s1, s22;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f26(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f27(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e6);
          }
        }
        return s0;
      }
      function peg$parseopen_square_brace() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f28(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f29(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseclose_square_brace() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f30(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f31(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseopen_paren() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f32(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f33(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseclose_paren() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f34(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f35(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseplus() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f36(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f37(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseminus() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f38(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f39(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsepipe() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f40(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f41(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsedot() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f42(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f43(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecontrols_keyword() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f44(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f45(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseand_keyword() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f46(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f47(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsesvg_keyword() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f48(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f49(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsegroup() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f50(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f51(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsemacro() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f52(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f53(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseforeach_keyword() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f54(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f55(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseforeach_macro() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f56(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f57(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsein_keyword() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f58(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f59(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecolon() {
        var s0, s1, s22;
        s0 = peg$currPos;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s22 = peg$f60(s1);
          if (s22) {
            s22 = void 0;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f61(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseEOL() {
        var s0, s1;
        s0 = peg$currPos;
        peg$silentFails++;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        peg$silentFails--;
        if (s1 === peg$FAILED) {
          s0 = void 0;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      if (!options.isWhitespace) {
        try {
          Object.assign(options, {
            isChar: (node, char) => node.type === "string" && node.content === char,
            isOperation: (node) => node.type === "string" && node.content.match(/[a-zA-Z]/),
            isWhitespace: (node) => node.type === "whitespace" || node.type === "parbreak",
            isSameLineComment: (node) => node.type === "comment" && node.sameline,
            isOwnLineComment: (node) => node.type === "comment" && !node.sameline,
            isComment: (node) => node.type === "comment",
            isGroup: (node) => node.type === "group",
            isMacro: (node, name) => node.type === "macro" && node.content === name,
            isAnyMacro: (node) => node.type === "macro"
          });
        } catch (e) {
          console.warn("Error when initializing parser", e);
        }
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(
          peg$maxFailExpected,
          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
      }
    }
    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }()
);
var ArgSpecPegParser4 = xparse_argspec_default6;
var parseCache4 = {};
function parse4(str = "") {
  parseCache4[str] = parseCache4[str] || ArgSpecPegParser4.parse(str);
  return parseCache4[str];
}
var BRACES_MAP4 = {
  "*": { openMark: "", closeMark: "" },
  "{": { openMark: "{", closeMark: "}" },
  "[": { openMark: "[", closeMark: "]" },
  "(": { openMark: "(", closeMark: ")" },
  "<": { openMark: "<", closeMark: ">" }
};
var CLOSE_BRACES4 = new Set(
  Object.values(BRACES_MAP4).map((x) => x.closeMark).filter((x) => x)
);
function bracesToOpenAndCloseMarks4(braces) {
  const ret = [];
  for (const char of braces.split("")) {
    if (CLOSE_BRACES4.has(char)) {
      continue;
    }
    const braces2 = BRACES_MAP4[char];
    if (braces2 == null) {
      throw new Error(`Unknown open/close mark type "${char}"`);
    }
    braces2;
    ret.push(braces2);
  }
  return ret;
}
function arg4(args2, special) {
  if (args2 == null) {
    return { type: "argument", content: [], openMark: "", closeMark: "" };
  }
  if (typeof args2 === "string") {
    args2 = s4(args2);
  }
  if (!Array.isArray(args2) && args2.type === "argument") {
    return args2;
  }
  let openMark = (special == null ? void 0 : special.openMark) ?? "{";
  let closeMark = (special == null ? void 0 : special.closeMark) ?? "}";
  if (special == null ? void 0 : special.braces) {
    const braces = bracesToOpenAndCloseMarks4(special.braces);
    if (braces[0]) {
      openMark = braces[0].openMark;
      closeMark = braces[0].closeMark;
    }
  }
  if (!Array.isArray(args2)) {
    args2 = [args2];
  }
  return { type: "argument", content: args2, openMark, closeMark };
}
function s4(value) {
  if (typeof value === "string") {
    return { type: "string", content: value };
  }
  return value;
}
var linebreak224 = Symbol("linebreak");
var ESCAPE224 = "\\";
function _printRaw224(node) {
  if (typeof node === "string") {
    return [node];
  }
  if (Array.isArray(node)) {
    return [].concat(
      ...node.map((n) => _printRaw224(n))
    );
  }
  let argsString, escape;
  switch (node.type) {
    case "root":
      return _printRaw224(node.content);
    case "argument":
      return [node.openMark, ..._printRaw224(node.content), node.closeMark];
    case "comment":
      var suffix = node.suffixParbreak ? "" : linebreak224;
      var leadingWhitespace = "";
      if (node.sameline && node.leadingWhitespace) {
        leadingWhitespace = " ";
      }
      if (node.sameline) {
        return [
          leadingWhitespace,
          "%",
          ..._printRaw224(node.content),
          suffix
        ];
      }
      return [linebreak224, "%", ..._printRaw224(node.content), suffix];
    case "environment":
    case "mathenv":
    case "verbatim":
      var env = _printRaw224(node.env);
      var envStart = [ESCAPE224 + "begin{", ...env, "}"];
      var envEnd = [ESCAPE224 + "end{", ...env, "}"];
      argsString = node.args == null ? [] : _printRaw224(node.args);
      return [
        ...envStart,
        ...argsString,
        ..._printRaw224(node.content),
        ...envEnd
      ];
    case "displaymath":
      return [ESCAPE224 + "[", ..._printRaw224(node.content), ESCAPE224 + "]"];
    case "group":
      return ["{", ..._printRaw224(node.content), "}"];
    case "inlinemath":
      return ["$", ..._printRaw224(node.content), "$"];
    case "macro":
      argsString = node.args == null ? [] : _printRaw224(node.args);
      escape = node.escapeToken == null ? ESCAPE224 : node.escapeToken;
      return [escape, ..._printRaw224(node.content), ...argsString];
    case "parbreak":
      return [linebreak224, linebreak224];
    case "string":
      return [node.content];
    case "verb":
      return [
        ESCAPE224,
        node.env,
        node.escape,
        ..._printRaw224(node.content),
        node.escape
      ];
    case "whitespace":
      return [" "];
    default:
      console.warn(
        "Cannot find render for node ",
        node,
        `(of type ${typeof node})`
      );
      return ["" + node];
  }
}
function printRaw224(node, options) {
  const asArray = options != null ? options.asArray : false;
  const printedTokens = _printRaw224(node);
  if (asArray) {
    return printedTokens;
  }
  return printedTokens.map((x) => x === linebreak224 ? "\n" : x).join("");
}
function createMacroMatcher222(macros15) {
  const macrosHash = Array.isArray(macros15) ? macros15.length > 0 ? typeof macros15[0] === "string" ? Object.fromEntries(
    macros15.map((macro2222) => {
      if (typeof macro2222 !== "string") {
        throw new Error("Wrong branch of map function");
      }
      return [macro2222, {}];
    })
  ) : Object.fromEntries(
    macros15.map((macro2222) => {
      if (typeof macro2222 === "string") {
        throw new Error("Wrong branch of map function");
      }
      if (macro2222.escapeToken != null) {
        return [
          macro2222.content,
          { escapeToken: macro2222.escapeToken }
        ];
      }
      return [macro2222.content, {}];
    })
  ) : {} : macros15;
  return function matchAgainstMacros(node) {
    if (node == null || node.type !== "macro") {
      return false;
    }
    const spec = macrosHash[node.content];
    if (!spec) {
      return false;
    }
    if (typeof spec === "object" && "escapeToken" in spec) {
      return spec.escapeToken == null || spec.escapeToken === node.escapeToken;
    }
    return true;
  };
}
function createEnvironmentMatcher222(macros15) {
  const environmentsHash = Array.isArray(macros15) ? Object.fromEntries(
    macros15.map((str) => {
      return [str, {}];
    })
  ) : macros15;
  return function matchAgainstEnvironments(node) {
    if (!match222.anyEnvironment(node)) {
      return false;
    }
    const envName = printRaw224(node.env);
    const spec = environmentsHash[envName];
    if (!spec) {
      return false;
    }
    return true;
  };
}
var match222 = {
  macro(node, macroName) {
    if (node == null) {
      return false;
    }
    return node.type === "macro" && (macroName == null || node.content === macroName);
  },
  anyMacro(node) {
    return match222.macro(node);
  },
  environment(node, envName) {
    if (node == null) {
      return false;
    }
    return (node.type === "environment" || node.type === "mathenv") && (envName == null || printRaw224(node.env) === envName);
  },
  anyEnvironment(node) {
    return match222.environment(node);
  },
  comment(node) {
    if (node == null) {
      return false;
    }
    return node.type === "comment";
  },
  parbreak(node) {
    if (node == null) {
      return false;
    }
    return node.type === "parbreak";
  },
  whitespace(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace";
  },
  /**
   * Matches whitespace or a comment with leading whitespace.
   */
  whitespaceLike(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace" || node.type === "whitespace" && node.leadingWhitespace === true;
  },
  string(node, value) {
    if (node == null) {
      return false;
    }
    return node.type === "string" && (value == null || node.content === value);
  },
  anyString(node) {
    return match222.string(node);
  },
  group(node) {
    if (node == null) {
      return false;
    }
    return node.type === "group";
  },
  argument(node) {
    if (node == null) {
      return false;
    }
    return node.type === "argument";
  },
  blankArgument(node) {
    if (!match222.argument(node)) {
      return false;
    }
    return node.openMark === "" && node.closeMark === "" && node.content.length === 0;
  },
  math(node) {
    if (node == null) {
      return false;
    }
    return node.type === "displaymath" || node.type === "inlinemath";
  },
  createMacroMatcher: createMacroMatcher222,
  createEnvironmentMatcher: createEnvironmentMatcher222
};
var {
  anyEnvironment: anyEnvironment222,
  anyMacro: anyMacro222,
  anyString: anyString222,
  argument: argument222,
  blankArgument: blankArgument222,
  comment: comment222,
  environment: environment222,
  group: group222,
  macro: macro222,
  math: math222,
  parbreak: parbreak222,
  string: string222,
  whitespace: whitespace222
} = match222;
var __create5 = Object.create;
var __defProp5 = Object.defineProperty;
var __getOwnPropDesc5 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames5 = Object.getOwnPropertyNames;
var __getProtoOf5 = Object.getPrototypeOf;
var __hasOwnProp5 = Object.prototype.hasOwnProperty;
var __commonJS5 = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames5(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps5 = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames5(from))
      if (!__hasOwnProp5.call(to, key) && key !== except)
        __defProp5(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc5(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM5 = (mod, isNodeMode, target) => (target = mod != null ? __create5(__getProtoOf5(mod)) : {}, __copyProps5(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp5(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var require_config4 = __commonJS5({
  "../../node_modules/trie-prefix-tree/dist/config.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = {
      END_WORD: "$",
      END_WORD_REPLACER: "9a219a89-91cd-42e2-abd5-eb113af08ca8",
      PERMS_MIN_LEN: 2
    };
    module2.exports = exports["default"];
  }
});
var require_append4 = __commonJS5({
  "../../node_modules/trie-prefix-tree/dist/append.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = append;
    var _config = require_config4();
    var _config2 = _interopRequireDefault(_config);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function append(trie, letter, index2, array) {
      var isEndWordLetter = letter === _config2.default.END_WORD;
      var isLastLetter = index2 === array.length - 1;
      if (isEndWordLetter && !isLastLetter) {
        trie[_config2.default.END_WORD] = 1;
        trie[_config2.default.END_WORD_REPLACER] = {};
        trie = trie[_config2.default.END_WORD_REPLACER];
      } else {
        trie[letter] = trie[letter] || {};
        trie = trie[letter];
      }
      if (isLastLetter) {
        trie[_config2.default.END_WORD] = 1;
      }
      return trie;
    }
    module2.exports = exports["default"];
  }
});
var require_create4 = __commonJS5({
  "../../node_modules/trie-prefix-tree/dist/create.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
      return typeof obj;
    } : function(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    exports.default = create;
    var _append = require_append4();
    var _append2 = _interopRequireDefault(_append);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function create(input) {
      if (!Array.isArray(input)) {
        throw "Expected parameter Array, received " + (typeof input === "undefined" ? "undefined" : _typeof(input));
      }
      var trie = input.reduce(function(accumulator, item) {
        item.toLowerCase().split("").reduce(_append2.default, accumulator);
        return accumulator;
      }, {});
      return trie;
    }
    module2.exports = exports["default"];
  }
});
var require_utils4 = __commonJS5({
  "../../node_modules/trie-prefix-tree/dist/utils.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = {
      objectCopy: function objectCopy(obj) {
        if (typeof obj === "undefined") {
          return {};
        }
        return JSON.parse(JSON.stringify(obj));
      },
      stringify: function stringify(obj) {
        var spacer = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2;
        if (typeof obj === "undefined") {
          return "";
        }
        return JSON.stringify(obj, null, spacer);
      }
    };
    module2.exports = exports["default"];
  }
});
var require_checkPrefix4 = __commonJS5({
  "../../node_modules/trie-prefix-tree/dist/checkPrefix.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = checkPrefix;
    var _utils = require_utils4();
    var _utils2 = _interopRequireDefault(_utils);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function checkPrefix(prefixNode, prefix) {
      var input = prefix.toLowerCase().split("");
      var prefixFound = input.every(function(letter, index2) {
        if (!prefixNode[letter]) {
          return false;
        }
        return prefixNode = prefixNode[letter];
      });
      return {
        prefixFound,
        prefixNode
      };
    }
    module2.exports = exports["default"];
  }
});
var require_recursePrefix4 = __commonJS5({
  "../../node_modules/trie-prefix-tree/dist/recursePrefix.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = recursePrefix;
    var _config = require_config4();
    var _config2 = _interopRequireDefault(_config);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var pushInOrder = function pushInOrder2(word, prefixes) {
      var i = 0;
      while (i < prefixes.length) {
        if (word < prefixes[i]) {
          break;
        }
        i += 1;
      }
      prefixes.splice(i, 0, word);
      return prefixes;
    };
    function recursePrefix(node, prefix, sorted) {
      var prefixes = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [];
      var word = prefix;
      for (var branch in node) {
        var currentLetter = branch;
        if (branch === _config2.default.END_WORD && typeof node[branch] === "number") {
          if (sorted) {
            pushInOrder(word, prefixes);
          } else {
            prefixes.push(word);
          }
          word = "";
        } else if (branch === _config2.default.END_WORD_REPLACER) {
          currentLetter = _config2.default.END_WORD;
        }
        recursePrefix(node[branch], prefix + currentLetter, sorted, prefixes);
      }
      return prefixes;
    }
    module2.exports = exports["default"];
  }
});
var require_recurseRandomWord4 = __commonJS5({
  "../../node_modules/trie-prefix-tree/dist/recurseRandomWord.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = recurseRandomWord;
    var _config = require_config4();
    var _config2 = _interopRequireDefault(_config);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function recurseRandomWord(node, prefix) {
      var word = prefix;
      var branches = Object.keys(node);
      var branch = branches[Math.floor(Math.random() * branches.length)];
      if (branch === _config2.default.END_WORD) {
        return word;
      }
      return recurseRandomWord(node[branch], prefix + branch);
    }
    module2.exports = exports["default"];
  }
});
var require_permutations4 = __commonJS5({
  "../../node_modules/trie-prefix-tree/dist/permutations.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
      return typeof obj;
    } : function(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    exports.default = permutations;
    var _config = require_config4();
    var _config2 = _interopRequireDefault(_config);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function permutations(letters, trie) {
      var opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
        type: "anagram"
      };
      if (typeof letters !== "string") {
        throw "Permutations expects string letters, received " + (typeof letters === "undefined" ? "undefined" : _typeof(letters));
      }
      var words = [];
      var permute = function permute2(word, node) {
        var prefix = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
        var wordIsEmpty = word.length === 0;
        var wordFound = words.indexOf(prefix) !== -1;
        var endWordFound = node[_config2.default.END_WORD] === 1;
        if (wordIsEmpty && endWordFound && !wordFound) {
          words.push(prefix);
        }
        for (var i = 0, len = word.length; i < len; i++) {
          var letter = word[i];
          if (opts.type === "sub-anagram") {
            if (endWordFound && !(words.indexOf(prefix) !== -1)) {
              words.push(prefix);
            }
          }
          if (node[letter]) {
            var remaining = word.substring(0, i) + word.substring(i + 1, len);
            permute2(remaining, node[letter], prefix + letter, words);
          }
        }
        return words.sort();
      };
      return permute(letters, trie);
    }
    module2.exports = exports["default"];
  }
});
var require_dist4 = __commonJS5({
  "../../node_modules/trie-prefix-tree/dist/index.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
      return typeof obj;
    } : function(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    exports.default = function(input) {
      if (!Array.isArray(input)) {
        throw "Expected parameter Array, received " + (typeof input === "undefined" ? "undefined" : _typeof(input));
      }
      var trie = (0, _create2.default)([].concat(_toConsumableArray(input)));
      return {
        /**
         * Get the generated raw trie object
        */
        tree: function tree() {
          return trie;
        },
        /**
         * Get a string representation of the trie
        */
        dump: function dump() {
          var spacer = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
          return _utils2.default.stringify(trie, spacer);
        },
        /**
         * Add a new word to the trie
         */
        addWord: function addWord(word) {
          if (typeof word !== "string" || word === "") {
            throw "Expected parameter string, received " + (typeof word === "undefined" ? "undefined" : _typeof(word));
          }
          var reducer = function reducer2() {
            return _append2.default.apply(void 0, arguments);
          };
          var input2 = word.toLowerCase().split("");
          input2.reduce(reducer, trie);
          return this;
        },
        /**
         * Remove an existing word from the trie
         */
        removeWord: function removeWord(word) {
          if (typeof word !== "string" || word === "") {
            throw "Expected parameter string, received " + (typeof word === "undefined" ? "undefined" : _typeof(word));
          }
          var _checkPrefix = (0, _checkPrefix6.default)(trie, word), prefixFound = _checkPrefix.prefixFound, prefixNode = _checkPrefix.prefixNode;
          if (prefixFound) {
            delete prefixNode[_config2.default.END_WORD];
          }
          return this;
        },
        /**
         * Check a prefix is valid
         * @returns Boolean
        */
        isPrefix: function isPrefix(prefix) {
          if (typeof prefix !== "string") {
            throw "Expected string prefix, received " + (typeof prefix === "undefined" ? "undefined" : _typeof(prefix));
          }
          var _checkPrefix2 = (0, _checkPrefix6.default)(trie, prefix), prefixFound = _checkPrefix2.prefixFound;
          return prefixFound;
        },
        /**
        * Get a list of all words in the trie with the given prefix
        * @returns Array
        */
        getPrefix: function getPrefix(strPrefix) {
          var sorted = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
          if (typeof strPrefix !== "string") {
            throw "Expected string prefix, received " + (typeof strPrefix === "undefined" ? "undefined" : _typeof(strPrefix));
          }
          if (typeof sorted !== "boolean") {
            throw "Expected sort parameter as boolean, received " + (typeof sorted === "undefined" ? "undefined" : _typeof(sorted));
          }
          if (!this.isPrefix(strPrefix)) {
            return [];
          }
          var prefixNode = strPrefix.length ? (0, _checkPrefix6.default)(trie, strPrefix).prefixNode : trie;
          return (0, _recursePrefix2.default)(prefixNode, strPrefix, sorted);
        },
        /**
        * Get a random word in the trie with the given prefix
        * @returns Array
        */
        getRandomWordWithPrefix: function getRandomWordWithPrefix(strPrefix) {
          if (typeof strPrefix !== "string") {
            throw "Expected string prefix, received " + (typeof strPrefix === "undefined" ? "undefined" : _typeof(strPrefix));
          }
          if (!this.isPrefix(strPrefix)) {
            return "";
          }
          var _checkPrefix3 = (0, _checkPrefix6.default)(trie, strPrefix), prefixNode = _checkPrefix3.prefixNode;
          return (0, _recurseRandomWord2.default)(prefixNode, strPrefix);
        },
        /**
        * Count the number of words with the given prefixSearch
        * @returns Number
        */
        countPrefix: function countPrefix(strPrefix) {
          var prefixes = this.getPrefix(strPrefix);
          return prefixes.length;
        },
        /**
        * Get all words in the trie
        * @returns Array
        */
        getWords: function getWords() {
          var sorted = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
          return this.getPrefix("", sorted);
        },
        /**
        * Check the existence of a word in the trie
        * @returns Boolean
        */
        hasWord: function hasWord(word) {
          if (typeof word !== "string") {
            throw "Expected string word, received " + (typeof word === "undefined" ? "undefined" : _typeof(word));
          }
          var _checkPrefix4 = (0, _checkPrefix6.default)(trie, word), prefixFound = _checkPrefix4.prefixFound, prefixNode = _checkPrefix4.prefixNode;
          if (prefixFound) {
            return prefixNode[_config2.default.END_WORD] === 1;
          }
          return false;
        },
        /**
        * Get a list of valid anagrams that can be made from the given letters
        * @returns Array
        */
        getAnagrams: function getAnagrams(letters) {
          if (typeof letters !== "string") {
            throw "Anagrams expected string letters, received " + (typeof letters === "undefined" ? "undefined" : _typeof(letters));
          }
          if (letters.length < PERMS_MIN_LEN) {
            throw "getAnagrams expects at least " + PERMS_MIN_LEN + " letters";
          }
          return (0, _permutations2.default)(letters, trie, {
            type: "anagram"
          });
        },
        /**
        * Get a list of all sub-anagrams that can be made from the given letters
        * @returns Array
        */
        getSubAnagrams: function getSubAnagrams(letters) {
          if (typeof letters !== "string") {
            throw "Expected string letters, received " + (typeof letters === "undefined" ? "undefined" : _typeof(letters));
          }
          if (letters.length < PERMS_MIN_LEN) {
            throw "getSubAnagrams expects at least " + PERMS_MIN_LEN + " letters";
          }
          return (0, _permutations2.default)(letters, trie, {
            type: "sub-anagram"
          });
        }
      };
    };
    var _create = require_create4();
    var _create2 = _interopRequireDefault(_create);
    var _append = require_append4();
    var _append2 = _interopRequireDefault(_append);
    var _checkPrefix5 = require_checkPrefix4();
    var _checkPrefix6 = _interopRequireDefault(_checkPrefix5);
    var _recursePrefix = require_recursePrefix4();
    var _recursePrefix2 = _interopRequireDefault(_recursePrefix);
    var _recurseRandomWord = require_recurseRandomWord4();
    var _recurseRandomWord2 = _interopRequireDefault(_recurseRandomWord);
    var _utils = require_utils4();
    var _utils2 = _interopRequireDefault(_utils);
    var _config = require_config4();
    var _config2 = _interopRequireDefault(_config);
    var _permutations = require_permutations4();
    var _permutations2 = _interopRequireDefault(_permutations);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _toConsumableArray(arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
          arr2[i] = arr[i];
        }
        return arr2;
      } else {
        return Array.from(arr);
      }
    }
    var PERMS_MIN_LEN = _config2.default.PERMS_MIN_LEN;
    module2.exports = exports["default"];
  }
});
var linebreak35 = Symbol("linebreak");
var ESCAPE35 = "\\";
function _printRaw35(node) {
  if (typeof node === "string") {
    return [node];
  }
  if (Array.isArray(node)) {
    return [].concat(
      ...node.map((n) => _printRaw35(n))
    );
  }
  let argsString, escape;
  switch (node.type) {
    case "root":
      return _printRaw35(node.content);
    case "argument":
      return [node.openMark, ..._printRaw35(node.content), node.closeMark];
    case "comment":
      var suffix = node.suffixParbreak ? "" : linebreak35;
      var leadingWhitespace = "";
      if (node.sameline && node.leadingWhitespace) {
        leadingWhitespace = " ";
      }
      if (node.sameline) {
        return [
          leadingWhitespace,
          "%",
          ..._printRaw35(node.content),
          suffix
        ];
      }
      return [linebreak35, "%", ..._printRaw35(node.content), suffix];
    case "environment":
    case "mathenv":
    case "verbatim":
      var env = _printRaw35(node.env);
      var envStart = [ESCAPE35 + "begin{", ...env, "}"];
      var envEnd = [ESCAPE35 + "end{", ...env, "}"];
      argsString = node.args == null ? [] : _printRaw35(node.args);
      return [
        ...envStart,
        ...argsString,
        ..._printRaw35(node.content),
        ...envEnd
      ];
    case "displaymath":
      return [ESCAPE35 + "[", ..._printRaw35(node.content), ESCAPE35 + "]"];
    case "group":
      return ["{", ..._printRaw35(node.content), "}"];
    case "inlinemath":
      return ["$", ..._printRaw35(node.content), "$"];
    case "macro":
      argsString = node.args == null ? [] : _printRaw35(node.args);
      escape = node.escapeToken == null ? ESCAPE35 : node.escapeToken;
      return [escape, ..._printRaw35(node.content), ...argsString];
    case "parbreak":
      return [linebreak35, linebreak35];
    case "string":
      return [node.content];
    case "verb":
      return [
        ESCAPE35,
        node.env,
        node.escape,
        ..._printRaw35(node.content),
        node.escape
      ];
    case "whitespace":
      return [" "];
    default:
      console.warn(
        "Cannot find render for node ",
        node,
        `(of type ${typeof node})`
      );
      return ["" + node];
  }
}
function printRaw35(node, options) {
  const asArray = options != null ? options.asArray : false;
  const printedTokens = _printRaw35(node);
  if (asArray) {
    return printedTokens;
  }
  return printedTokens.map((x) => x === linebreak35 ? "\n" : x).join("");
}
function createMacroMatcher35(macros15) {
  const macrosHash = Array.isArray(macros15) ? macros15.length > 0 ? typeof macros15[0] === "string" ? Object.fromEntries(
    macros15.map((macro2222) => {
      if (typeof macro2222 !== "string") {
        throw new Error("Wrong branch of map function");
      }
      return [macro2222, {}];
    })
  ) : Object.fromEntries(
    macros15.map((macro2222) => {
      if (typeof macro2222 === "string") {
        throw new Error("Wrong branch of map function");
      }
      if (macro2222.escapeToken != null) {
        return [
          macro2222.content,
          { escapeToken: macro2222.escapeToken }
        ];
      }
      return [macro2222.content, {}];
    })
  ) : {} : macros15;
  return function matchAgainstMacros(node) {
    if (node == null || node.type !== "macro") {
      return false;
    }
    const spec = macrosHash[node.content];
    if (!spec) {
      return false;
    }
    if (typeof spec === "object" && "escapeToken" in spec) {
      return spec.escapeToken == null || spec.escapeToken === node.escapeToken;
    }
    return true;
  };
}
function createEnvironmentMatcher35(macros15) {
  const environmentsHash = Array.isArray(macros15) ? Object.fromEntries(
    macros15.map((str) => {
      return [str, {}];
    })
  ) : macros15;
  return function matchAgainstEnvironments(node) {
    if (!match35.anyEnvironment(node)) {
      return false;
    }
    const envName = printRaw35(node.env);
    const spec = environmentsHash[envName];
    if (!spec) {
      return false;
    }
    return true;
  };
}
var match35 = {
  macro(node, macroName) {
    if (node == null) {
      return false;
    }
    return node.type === "macro" && (macroName == null || node.content === macroName);
  },
  anyMacro(node) {
    return match35.macro(node);
  },
  environment(node, envName) {
    if (node == null) {
      return false;
    }
    return (node.type === "environment" || node.type === "mathenv") && (envName == null || printRaw35(node.env) === envName);
  },
  anyEnvironment(node) {
    return match35.environment(node);
  },
  comment(node) {
    if (node == null) {
      return false;
    }
    return node.type === "comment";
  },
  parbreak(node) {
    if (node == null) {
      return false;
    }
    return node.type === "parbreak";
  },
  whitespace(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace";
  },
  /**
   * Matches whitespace or a comment with leading whitespace.
   */
  whitespaceLike(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace" || node.type === "whitespace" && node.leadingWhitespace === true;
  },
  string(node, value) {
    if (node == null) {
      return false;
    }
    return node.type === "string" && (value == null || node.content === value);
  },
  anyString(node) {
    return match35.string(node);
  },
  group(node) {
    if (node == null) {
      return false;
    }
    return node.type === "group";
  },
  argument(node) {
    if (node == null) {
      return false;
    }
    return node.type === "argument";
  },
  blankArgument(node) {
    if (!match35.argument(node)) {
      return false;
    }
    return node.openMark === "" && node.closeMark === "" && node.content.length === 0;
  },
  math(node) {
    if (node == null) {
      return false;
    }
    return node.type === "displaymath" || node.type === "inlinemath";
  },
  createMacroMatcher: createMacroMatcher35,
  createEnvironmentMatcher: createEnvironmentMatcher35
};
var {
  anyEnvironment: anyEnvironment35,
  anyMacro: anyMacro35,
  anyString: anyString35,
  argument: argument35,
  blankArgument: blankArgument35,
  comment: comment35,
  environment: environment35,
  group: group35,
  macro: macro35,
  math: math35,
  parbreak: parbreak35,
  string: string35,
  whitespace: whitespace35
} = match35;
var linebreak2222 = Symbol("linebreak");
var ESCAPE2222 = "\\";
function _printRaw2222(node) {
  if (typeof node === "string") {
    return [node];
  }
  if (Array.isArray(node)) {
    return [].concat(
      ...node.map((n) => _printRaw2222(n))
    );
  }
  let argsString, escape;
  switch (node.type) {
    case "root":
      return _printRaw2222(node.content);
    case "argument":
      return [node.openMark, ..._printRaw2222(node.content), node.closeMark];
    case "comment":
      var suffix = node.suffixParbreak ? "" : linebreak2222;
      var leadingWhitespace = "";
      if (node.sameline && node.leadingWhitespace) {
        leadingWhitespace = " ";
      }
      if (node.sameline) {
        return [
          leadingWhitespace,
          "%",
          ..._printRaw2222(node.content),
          suffix
        ];
      }
      return [linebreak2222, "%", ..._printRaw2222(node.content), suffix];
    case "environment":
    case "mathenv":
    case "verbatim":
      var env = _printRaw2222(node.env);
      var envStart = [ESCAPE2222 + "begin{", ...env, "}"];
      var envEnd = [ESCAPE2222 + "end{", ...env, "}"];
      argsString = node.args == null ? [] : _printRaw2222(node.args);
      return [
        ...envStart,
        ...argsString,
        ..._printRaw2222(node.content),
        ...envEnd
      ];
    case "displaymath":
      return [ESCAPE2222 + "[", ..._printRaw2222(node.content), ESCAPE2222 + "]"];
    case "group":
      return ["{", ..._printRaw2222(node.content), "}"];
    case "inlinemath":
      return ["$", ..._printRaw2222(node.content), "$"];
    case "macro":
      argsString = node.args == null ? [] : _printRaw2222(node.args);
      escape = node.escapeToken == null ? ESCAPE2222 : node.escapeToken;
      return [escape, ..._printRaw2222(node.content), ...argsString];
    case "parbreak":
      return [linebreak2222, linebreak2222];
    case "string":
      return [node.content];
    case "verb":
      return [
        ESCAPE2222,
        node.env,
        node.escape,
        ..._printRaw2222(node.content),
        node.escape
      ];
    case "whitespace":
      return [" "];
    default:
      console.warn(
        "Cannot find render for node ",
        node,
        `(of type ${typeof node})`
      );
      return ["" + node];
  }
}
function printRaw2222(node, options) {
  const asArray = options != null ? options.asArray : false;
  const printedTokens = _printRaw2222(node);
  if (asArray) {
    return printedTokens;
  }
  return printedTokens.map((x) => x === linebreak2222 ? "\n" : x).join("");
}
function scan4(nodes, token, options) {
  const { startIndex, onlySkipWhitespaceAndComments, allowSubstringMatches } = options || {};
  if (typeof token === "string") {
    token = { type: "string", content: token };
  }
  for (let i = startIndex || 0; i < nodes.length; i++) {
    const node = nodes[i];
    if (node.type === token.type) {
      switch (node.type) {
        case "comment":
        case "displaymath":
        case "inlinemath":
        case "root":
        case "parbreak":
        case "whitespace":
        case "verb":
        case "verbatim":
        case "group":
          return i;
        case "macro":
          if (node.content === token.content) {
            return i;
          }
          break;
        case "environment":
        case "mathenv":
          if (printRaw2222(node.env) === printRaw2222(token.env)) {
            return i;
          }
          break;
        case "string":
          if (node.content === token.content) {
            return i;
          }
          if (allowSubstringMatches && node.content.indexOf(token.content) >= 0) {
            return i;
          }
          break;
      }
    }
    if (onlySkipWhitespaceAndComments && !match35.whitespace(node) && !match35.comment(node)) {
      return null;
    }
  }
  return null;
}
var import_trie_prefix_tree4 = __toESM5(require_dist4(), 1);
var export_Trie4 = import_trie_prefix_tree4.default;
function gobbleSingleArgument3(nodes, argSpec, startPos = 0) {
  if (typeof argSpec === "string" || !argSpec.type) {
    throw new Error(
      `argSpec must be an already-parsed argument specification, not "${JSON.stringify(
        argSpec
      )}"`
    );
  }
  let argument622 = null;
  let currPos = startPos;
  const gobbleWhitespace = argSpec.noLeadingWhitespace ? () => {
  } : () => {
    while (currPos < nodes.length) {
      if (!match222.whitespace(nodes[currPos])) {
        break;
      }
      currPos++;
    }
  };
  const openMark = argSpec.openBrace || "";
  const closeMark = argSpec.closeBrace || "";
  const acceptGroup = (argSpec.type === "mandatory" || argSpec.type === "optional") && openMark === "{" && closeMark === "}";
  function findBracePositions() {
    let openMarkPos = null;
    if (openMark) {
      openMarkPos = nodes.findIndex(
        (node, i) => i >= currPos && match222.string(node, openMark)
      );
      if (openMarkPos < currPos) {
        openMarkPos = null;
      }
    }
    let closeMarkPos = null;
    if (openMarkPos != null) {
      closeMarkPos = nodes.findIndex(
        (node, i) => i >= openMarkPos + 1 && match222.string(node, closeMark)
      );
      if (closeMarkPos < openMarkPos + 1) {
        closeMarkPos = null;
      }
    }
    return [openMarkPos, closeMarkPos];
  }
  gobbleWhitespace();
  const currNode = nodes[currPos];
  if (currNode == null || match222.comment(currNode) || match222.parbreak(currNode)) {
    return { argument: argument622, nodesRemoved: 0 };
  }
  switch (argSpec.type) {
    case "mandatory":
      if (acceptGroup) {
        let content = [currNode];
        if (match222.group(currNode)) {
          content = currNode.content;
        }
        argument622 = arg4(content, {
          openMark,
          closeMark
        });
        currPos++;
        break;
      }
    case "optional":
      if (acceptGroup && match222.group(currNode)) {
        argument622 = arg4(currNode.content, {
          openMark,
          closeMark
        });
        currPos++;
        break;
      }
      if (match222.string(currNode, openMark)) {
        const [openMarkPos, closeMarkPos] = findBracePositions();
        if (openMarkPos != null && closeMarkPos != null) {
          argument622 = arg4(nodes.slice(openMarkPos + 1, closeMarkPos), {
            openMark,
            closeMark
          });
          currPos = closeMarkPos + 1;
          break;
        }
      }
      break;
    case "optionalStar":
    case "optionalToken":
      if (match222.string(
        currNode,
        argSpec.type === "optionalStar" ? "*" : argSpec.token
      )) {
        argument622 = arg4([currNode], { openMark: "", closeMark: "" });
        currPos++;
        break;
      }
      break;
    case "until": {
      if (argSpec.stopTokens.length > 1) {
        console.warn(
          `"until" matches with multi-token stop conditions are not yet implemented`
        );
        break;
      }
      const rawToken = argSpec.stopTokens[0];
      const stopToken = rawToken === " " ? { type: "whitespace" } : { type: "string", content: argSpec.stopTokens[0] };
      let matchPos = scan4(nodes, stopToken, {
        startIndex: startPos,
        allowSubstringMatches: true
      });
      if (matchPos != null && partialStringMatch3(nodes[matchPos], stopToken)) {
        console.warn(
          `"until" arguments that stop at non-punctuation symbols is not yet implemented`
        );
        break;
      }
      if (matchPos == null) {
        break;
      }
      argument622 = arg4(nodes.slice(startPos, matchPos), {
        openMark: "",
        closeMark: rawToken
      });
      currPos = matchPos;
      if (currPos < nodes.length) {
        currPos++;
      }
      break;
    }
    default:
      console.warn(
        `Don't know how to find an argument of argspec type "${argSpec.type}"`
      );
  }
  const nodesRemoved = argument622 ? currPos - startPos : 0;
  nodes.splice(startPos, nodesRemoved);
  return { argument: argument622, nodesRemoved };
}
function partialStringMatch3(node, token) {
  return match222.anyString(node) && match222.anyString(token) && node.content.length > token.content.length;
}
function gobbleArguments3(nodes, argSpec, startPos = 0) {
  if (typeof argSpec === "function") {
    return argSpec(nodes, startPos);
  }
  if (typeof argSpec === "string") {
    argSpec = parse4(argSpec);
  }
  const args = [];
  let nodesRemoved = 0;
  for (const spec of argSpec) {
    const { argument: argument622, nodesRemoved: removed } = gobbleSingleArgument3(
      nodes,
      spec,
      startPos
    );
    if (argument622) {
      args.push(argument622);
      nodesRemoved += removed;
    } else {
      args.push(arg4([], { openMark: "", closeMark: "" }));
    }
  }
  return { args, nodesRemoved };
}
var linebreak44 = Symbol("linebreak");
var ESCAPE44 = "\\";
function _printRaw44(node) {
  if (typeof node === "string") {
    return [node];
  }
  if (Array.isArray(node)) {
    return [].concat(
      ...node.map((n) => _printRaw44(n))
    );
  }
  let argsString, escape;
  switch (node.type) {
    case "root":
      return _printRaw44(node.content);
    case "argument":
      return [node.openMark, ..._printRaw44(node.content), node.closeMark];
    case "comment":
      var suffix = node.suffixParbreak ? "" : linebreak44;
      var leadingWhitespace = "";
      if (node.sameline && node.leadingWhitespace) {
        leadingWhitespace = " ";
      }
      if (node.sameline) {
        return [
          leadingWhitespace,
          "%",
          ..._printRaw44(node.content),
          suffix
        ];
      }
      return [linebreak44, "%", ..._printRaw44(node.content), suffix];
    case "environment":
    case "mathenv":
    case "verbatim":
      var env = _printRaw44(node.env);
      var envStart = [ESCAPE44 + "begin{", ...env, "}"];
      var envEnd = [ESCAPE44 + "end{", ...env, "}"];
      argsString = node.args == null ? [] : _printRaw44(node.args);
      return [
        ...envStart,
        ...argsString,
        ..._printRaw44(node.content),
        ...envEnd
      ];
    case "displaymath":
      return [ESCAPE44 + "[", ..._printRaw44(node.content), ESCAPE44 + "]"];
    case "group":
      return ["{", ..._printRaw44(node.content), "}"];
    case "inlinemath":
      return ["$", ..._printRaw44(node.content), "$"];
    case "macro":
      argsString = node.args == null ? [] : _printRaw44(node.args);
      escape = node.escapeToken == null ? ESCAPE44 : node.escapeToken;
      return [escape, ..._printRaw44(node.content), ...argsString];
    case "parbreak":
      return [linebreak44, linebreak44];
    case "string":
      return [node.content];
    case "verb":
      return [
        ESCAPE44,
        node.env,
        node.escape,
        ..._printRaw44(node.content),
        node.escape
      ];
    case "whitespace":
      return [" "];
    default:
      console.warn(
        "Cannot find render for node ",
        node,
        `(of type ${typeof node})`
      );
      return ["" + node];
  }
}
function printRaw44(node, options) {
  const asArray = options != null ? options.asArray : false;
  const printedTokens = _printRaw44(node);
  if (asArray) {
    return printedTokens;
  }
  return printedTokens.map((x) => x === linebreak44 ? "\n" : x).join("");
}
function createMacroMatcher44(macros15) {
  const macrosHash = Array.isArray(macros15) ? macros15.length > 0 ? typeof macros15[0] === "string" ? Object.fromEntries(
    macros15.map((macro2222) => {
      if (typeof macro2222 !== "string") {
        throw new Error("Wrong branch of map function");
      }
      return [macro2222, {}];
    })
  ) : Object.fromEntries(
    macros15.map((macro2222) => {
      if (typeof macro2222 === "string") {
        throw new Error("Wrong branch of map function");
      }
      if (macro2222.escapeToken != null) {
        return [
          macro2222.content,
          { escapeToken: macro2222.escapeToken }
        ];
      }
      return [macro2222.content, {}];
    })
  ) : {} : macros15;
  return function matchAgainstMacros(node) {
    if (node == null || node.type !== "macro") {
      return false;
    }
    const spec = macrosHash[node.content];
    if (!spec) {
      return false;
    }
    if (typeof spec === "object" && "escapeToken" in spec) {
      return spec.escapeToken == null || spec.escapeToken === node.escapeToken;
    }
    return true;
  };
}
function createEnvironmentMatcher44(macros15) {
  const environmentsHash = Array.isArray(macros15) ? Object.fromEntries(
    macros15.map((str) => {
      return [str, {}];
    })
  ) : macros15;
  return function matchAgainstEnvironments(node) {
    if (!match44.anyEnvironment(node)) {
      return false;
    }
    const envName = printRaw44(node.env);
    const spec = environmentsHash[envName];
    if (!spec) {
      return false;
    }
    return true;
  };
}
var match44 = {
  macro(node, macroName) {
    if (node == null) {
      return false;
    }
    return node.type === "macro" && (macroName == null || node.content === macroName);
  },
  anyMacro(node) {
    return match44.macro(node);
  },
  environment(node, envName) {
    if (node == null) {
      return false;
    }
    return (node.type === "environment" || node.type === "mathenv") && (envName == null || printRaw44(node.env) === envName);
  },
  anyEnvironment(node) {
    return match44.environment(node);
  },
  comment(node) {
    if (node == null) {
      return false;
    }
    return node.type === "comment";
  },
  parbreak(node) {
    if (node == null) {
      return false;
    }
    return node.type === "parbreak";
  },
  whitespace(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace";
  },
  /**
   * Matches whitespace or a comment with leading whitespace.
   */
  whitespaceLike(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace" || node.type === "whitespace" && node.leadingWhitespace === true;
  },
  string(node, value) {
    if (node == null) {
      return false;
    }
    return node.type === "string" && (value == null || node.content === value);
  },
  anyString(node) {
    return match44.string(node);
  },
  group(node) {
    if (node == null) {
      return false;
    }
    return node.type === "group";
  },
  argument(node) {
    if (node == null) {
      return false;
    }
    return node.type === "argument";
  },
  blankArgument(node) {
    if (!match44.argument(node)) {
      return false;
    }
    return node.openMark === "" && node.closeMark === "" && node.content.length === 0;
  },
  math(node) {
    if (node == null) {
      return false;
    }
    return node.type === "displaymath" || node.type === "inlinemath";
  },
  createMacroMatcher: createMacroMatcher44,
  createEnvironmentMatcher: createEnvironmentMatcher44
};
var {
  anyEnvironment: anyEnvironment44,
  anyMacro: anyMacro44,
  anyString: anyString44,
  argument: argument44,
  blankArgument: blankArgument44,
  comment: comment44,
  environment: environment44,
  group: group44,
  macro: macro44,
  math: math44,
  parbreak: parbreak44,
  string: string44,
  whitespace: whitespace44
} = match44;
var CONTINUE25 = Symbol("continue");
var SKIP25 = Symbol("skip");
var EXIT25 = Symbol("exit");
var linebreak54 = Symbol("linebreak");
var ESCAPE54 = "\\";
function _printRaw54(node) {
  if (typeof node === "string") {
    return [node];
  }
  if (Array.isArray(node)) {
    return [].concat(
      ...node.map((n) => _printRaw54(n))
    );
  }
  let argsString, escape;
  switch (node.type) {
    case "root":
      return _printRaw54(node.content);
    case "argument":
      return [node.openMark, ..._printRaw54(node.content), node.closeMark];
    case "comment":
      var suffix = node.suffixParbreak ? "" : linebreak54;
      var leadingWhitespace = "";
      if (node.sameline && node.leadingWhitespace) {
        leadingWhitespace = " ";
      }
      if (node.sameline) {
        return [
          leadingWhitespace,
          "%",
          ..._printRaw54(node.content),
          suffix
        ];
      }
      return [linebreak54, "%", ..._printRaw54(node.content), suffix];
    case "environment":
    case "mathenv":
    case "verbatim":
      var env = _printRaw54(node.env);
      var envStart = [ESCAPE54 + "begin{", ...env, "}"];
      var envEnd = [ESCAPE54 + "end{", ...env, "}"];
      argsString = node.args == null ? [] : _printRaw54(node.args);
      return [
        ...envStart,
        ...argsString,
        ..._printRaw54(node.content),
        ...envEnd
      ];
    case "displaymath":
      return [ESCAPE54 + "[", ..._printRaw54(node.content), ESCAPE54 + "]"];
    case "group":
      return ["{", ..._printRaw54(node.content), "}"];
    case "inlinemath":
      return ["$", ..._printRaw54(node.content), "$"];
    case "macro":
      argsString = node.args == null ? [] : _printRaw54(node.args);
      escape = node.escapeToken == null ? ESCAPE54 : node.escapeToken;
      return [escape, ..._printRaw54(node.content), ...argsString];
    case "parbreak":
      return [linebreak54, linebreak54];
    case "string":
      return [node.content];
    case "verb":
      return [
        ESCAPE54,
        node.env,
        node.escape,
        ..._printRaw54(node.content),
        node.escape
      ];
    case "whitespace":
      return [" "];
    default:
      console.warn(
        "Cannot find render for node ",
        node,
        `(of type ${typeof node})`
      );
      return ["" + node];
  }
}
function printRaw54(node, options) {
  const asArray = options != null ? options.asArray : false;
  const printedTokens = _printRaw54(node);
  if (asArray) {
    return printedTokens;
  }
  return printedTokens.map((x) => x === linebreak54 ? "\n" : x).join("");
}
function createMacroMatcher54(macros15) {
  const macrosHash = Array.isArray(macros15) ? macros15.length > 0 ? typeof macros15[0] === "string" ? Object.fromEntries(
    macros15.map((macro2222) => {
      if (typeof macro2222 !== "string") {
        throw new Error("Wrong branch of map function");
      }
      return [macro2222, {}];
    })
  ) : Object.fromEntries(
    macros15.map((macro2222) => {
      if (typeof macro2222 === "string") {
        throw new Error("Wrong branch of map function");
      }
      if (macro2222.escapeToken != null) {
        return [
          macro2222.content,
          { escapeToken: macro2222.escapeToken }
        ];
      }
      return [macro2222.content, {}];
    })
  ) : {} : macros15;
  return function matchAgainstMacros(node) {
    if (node == null || node.type !== "macro") {
      return false;
    }
    const spec = macrosHash[node.content];
    if (!spec) {
      return false;
    }
    if (typeof spec === "object" && "escapeToken" in spec) {
      return spec.escapeToken == null || spec.escapeToken === node.escapeToken;
    }
    return true;
  };
}
function createEnvironmentMatcher54(macros15) {
  const environmentsHash = Array.isArray(macros15) ? Object.fromEntries(
    macros15.map((str) => {
      return [str, {}];
    })
  ) : macros15;
  return function matchAgainstEnvironments(node) {
    if (!match54.anyEnvironment(node)) {
      return false;
    }
    const envName = printRaw54(node.env);
    const spec = environmentsHash[envName];
    if (!spec) {
      return false;
    }
    return true;
  };
}
var match54 = {
  macro(node, macroName) {
    if (node == null) {
      return false;
    }
    return node.type === "macro" && (macroName == null || node.content === macroName);
  },
  anyMacro(node) {
    return match54.macro(node);
  },
  environment(node, envName) {
    if (node == null) {
      return false;
    }
    return (node.type === "environment" || node.type === "mathenv") && (envName == null || printRaw54(node.env) === envName);
  },
  anyEnvironment(node) {
    return match54.environment(node);
  },
  comment(node) {
    if (node == null) {
      return false;
    }
    return node.type === "comment";
  },
  parbreak(node) {
    if (node == null) {
      return false;
    }
    return node.type === "parbreak";
  },
  whitespace(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace";
  },
  /**
   * Matches whitespace or a comment with leading whitespace.
   */
  whitespaceLike(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace" || node.type === "whitespace" && node.leadingWhitespace === true;
  },
  string(node, value) {
    if (node == null) {
      return false;
    }
    return node.type === "string" && (value == null || node.content === value);
  },
  anyString(node) {
    return match54.string(node);
  },
  group(node) {
    if (node == null) {
      return false;
    }
    return node.type === "group";
  },
  argument(node) {
    if (node == null) {
      return false;
    }
    return node.type === "argument";
  },
  blankArgument(node) {
    if (!match54.argument(node)) {
      return false;
    }
    return node.openMark === "" && node.closeMark === "" && node.content.length === 0;
  },
  math(node) {
    if (node == null) {
      return false;
    }
    return node.type === "displaymath" || node.type === "inlinemath";
  },
  createMacroMatcher: createMacroMatcher54,
  createEnvironmentMatcher: createEnvironmentMatcher54
};
var {
  anyEnvironment: anyEnvironment54,
  anyMacro: anyMacro54,
  anyString: anyString54,
  argument: argument54,
  blankArgument: blankArgument54,
  comment: comment54,
  environment: environment54,
  group: group54,
  macro: macro54,
  math: math54,
  parbreak: parbreak54,
  string: string54,
  whitespace: whitespace54
} = match54;
var CONTINUE222 = Symbol("continue");
var SKIP222 = Symbol("skip");
var EXIT222 = Symbol("exit");
var linebreak62 = Symbol("linebreak");
var ESCAPE62 = "\\";
function _printRaw62(node) {
  if (typeof node === "string") {
    return [node];
  }
  if (Array.isArray(node)) {
    return [].concat(
      ...node.map((n) => _printRaw62(n))
    );
  }
  let argsString, escape;
  switch (node.type) {
    case "root":
      return _printRaw62(node.content);
    case "argument":
      return [node.openMark, ..._printRaw62(node.content), node.closeMark];
    case "comment":
      var suffix = node.suffixParbreak ? "" : linebreak62;
      var leadingWhitespace = "";
      if (node.sameline && node.leadingWhitespace) {
        leadingWhitespace = " ";
      }
      if (node.sameline) {
        return [
          leadingWhitespace,
          "%",
          ..._printRaw62(node.content),
          suffix
        ];
      }
      return [linebreak62, "%", ..._printRaw62(node.content), suffix];
    case "environment":
    case "mathenv":
    case "verbatim":
      var env = _printRaw62(node.env);
      var envStart = [ESCAPE62 + "begin{", ...env, "}"];
      var envEnd = [ESCAPE62 + "end{", ...env, "}"];
      argsString = node.args == null ? [] : _printRaw62(node.args);
      return [
        ...envStart,
        ...argsString,
        ..._printRaw62(node.content),
        ...envEnd
      ];
    case "displaymath":
      return [ESCAPE62 + "[", ..._printRaw62(node.content), ESCAPE62 + "]"];
    case "group":
      return ["{", ..._printRaw62(node.content), "}"];
    case "inlinemath":
      return ["$", ..._printRaw62(node.content), "$"];
    case "macro":
      argsString = node.args == null ? [] : _printRaw62(node.args);
      escape = node.escapeToken == null ? ESCAPE62 : node.escapeToken;
      return [escape, ..._printRaw62(node.content), ...argsString];
    case "parbreak":
      return [linebreak62, linebreak62];
    case "string":
      return [node.content];
    case "verb":
      return [
        ESCAPE62,
        node.env,
        node.escape,
        ..._printRaw62(node.content),
        node.escape
      ];
    case "whitespace":
      return [" "];
    default:
      console.warn(
        "Cannot find render for node ",
        node,
        `(of type ${typeof node})`
      );
      return ["" + node];
  }
}
function printRaw62(node, options) {
  const asArray = options != null ? options.asArray : false;
  const printedTokens = _printRaw62(node);
  if (asArray) {
    return printedTokens;
  }
  return printedTokens.map((x) => x === linebreak62 ? "\n" : x).join("");
}
function createMacroMatcher62(macros15) {
  const macrosHash = Array.isArray(macros15) ? macros15.length > 0 ? typeof macros15[0] === "string" ? Object.fromEntries(
    macros15.map((macro232) => {
      if (typeof macro232 !== "string") {
        throw new Error("Wrong branch of map function");
      }
      return [macro232, {}];
    })
  ) : Object.fromEntries(
    macros15.map((macro232) => {
      if (typeof macro232 === "string") {
        throw new Error("Wrong branch of map function");
      }
      if (macro232.escapeToken != null) {
        return [
          macro232.content,
          { escapeToken: macro232.escapeToken }
        ];
      }
      return [macro232.content, {}];
    })
  ) : {} : macros15;
  return function matchAgainstMacros(node) {
    if (node == null || node.type !== "macro") {
      return false;
    }
    const spec = macrosHash[node.content];
    if (!spec) {
      return false;
    }
    if (typeof spec === "object" && "escapeToken" in spec) {
      return spec.escapeToken == null || spec.escapeToken === node.escapeToken;
    }
    return true;
  };
}
function createEnvironmentMatcher62(macros15) {
  const environmentsHash = Array.isArray(macros15) ? Object.fromEntries(
    macros15.map((str) => {
      return [str, {}];
    })
  ) : macros15;
  return function matchAgainstEnvironments(node) {
    if (!match62.anyEnvironment(node)) {
      return false;
    }
    const envName = printRaw62(node.env);
    const spec = environmentsHash[envName];
    if (!spec) {
      return false;
    }
    return true;
  };
}
var match62 = {
  macro(node, macroName) {
    if (node == null) {
      return false;
    }
    return node.type === "macro" && (macroName == null || node.content === macroName);
  },
  anyMacro(node) {
    return match62.macro(node);
  },
  environment(node, envName) {
    if (node == null) {
      return false;
    }
    return (node.type === "environment" || node.type === "mathenv") && (envName == null || printRaw62(node.env) === envName);
  },
  anyEnvironment(node) {
    return match62.environment(node);
  },
  comment(node) {
    if (node == null) {
      return false;
    }
    return node.type === "comment";
  },
  parbreak(node) {
    if (node == null) {
      return false;
    }
    return node.type === "parbreak";
  },
  whitespace(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace";
  },
  /**
   * Matches whitespace or a comment with leading whitespace.
   */
  whitespaceLike(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace" || node.type === "whitespace" && node.leadingWhitespace === true;
  },
  string(node, value) {
    if (node == null) {
      return false;
    }
    return node.type === "string" && (value == null || node.content === value);
  },
  anyString(node) {
    return match62.string(node);
  },
  group(node) {
    if (node == null) {
      return false;
    }
    return node.type === "group";
  },
  argument(node) {
    if (node == null) {
      return false;
    }
    return node.type === "argument";
  },
  blankArgument(node) {
    if (!match62.argument(node)) {
      return false;
    }
    return node.openMark === "" && node.closeMark === "" && node.content.length === 0;
  },
  math(node) {
    if (node == null) {
      return false;
    }
    return node.type === "displaymath" || node.type === "inlinemath";
  },
  createMacroMatcher: createMacroMatcher62,
  createEnvironmentMatcher: createEnvironmentMatcher62
};
var {
  anyEnvironment: anyEnvironment62,
  anyMacro: anyMacro62,
  anyString: anyString62,
  argument: argument62,
  blankArgument: blankArgument62,
  comment: comment62,
  environment: environment62,
  group: group62,
  macro: macro62,
  math: math62,
  parbreak: parbreak62,
  string: string62,
  whitespace: whitespace62
} = match62;
var linebreak72 = Symbol("linebreak");
var ESCAPE72 = "\\";
function _printRaw72(node) {
  if (typeof node === "string") {
    return [node];
  }
  if (Array.isArray(node)) {
    return [].concat(
      ...node.map((n) => _printRaw72(n))
    );
  }
  let argsString, escape;
  switch (node.type) {
    case "root":
      return _printRaw72(node.content);
    case "argument":
      return [node.openMark, ..._printRaw72(node.content), node.closeMark];
    case "comment":
      var suffix = node.suffixParbreak ? "" : linebreak72;
      var leadingWhitespace = "";
      if (node.sameline && node.leadingWhitespace) {
        leadingWhitespace = " ";
      }
      if (node.sameline) {
        return [
          leadingWhitespace,
          "%",
          ..._printRaw72(node.content),
          suffix
        ];
      }
      return [linebreak72, "%", ..._printRaw72(node.content), suffix];
    case "environment":
    case "mathenv":
    case "verbatim":
      var env = _printRaw72(node.env);
      var envStart = [ESCAPE72 + "begin{", ...env, "}"];
      var envEnd = [ESCAPE72 + "end{", ...env, "}"];
      argsString = node.args == null ? [] : _printRaw72(node.args);
      return [
        ...envStart,
        ...argsString,
        ..._printRaw72(node.content),
        ...envEnd
      ];
    case "displaymath":
      return [ESCAPE72 + "[", ..._printRaw72(node.content), ESCAPE72 + "]"];
    case "group":
      return ["{", ..._printRaw72(node.content), "}"];
    case "inlinemath":
      return ["$", ..._printRaw72(node.content), "$"];
    case "macro":
      argsString = node.args == null ? [] : _printRaw72(node.args);
      escape = node.escapeToken == null ? ESCAPE72 : node.escapeToken;
      return [escape, ..._printRaw72(node.content), ...argsString];
    case "parbreak":
      return [linebreak72, linebreak72];
    case "string":
      return [node.content];
    case "verb":
      return [
        ESCAPE72,
        node.env,
        node.escape,
        ..._printRaw72(node.content),
        node.escape
      ];
    case "whitespace":
      return [" "];
    default:
      console.warn(
        "Cannot find render for node ",
        node,
        `(of type ${typeof node})`
      );
      return ["" + node];
  }
}
function printRaw72(node, options) {
  const asArray = options != null ? options.asArray : false;
  const printedTokens = _printRaw72(node);
  if (asArray) {
    return printedTokens;
  }
  return printedTokens.map((x) => x === linebreak72 ? "\n" : x).join("");
}
function createMacroMatcher72(macros15) {
  const macrosHash = Array.isArray(macros15) ? macros15.length > 0 ? typeof macros15[0] === "string" ? Object.fromEntries(
    macros15.map((macro232) => {
      if (typeof macro232 !== "string") {
        throw new Error("Wrong branch of map function");
      }
      return [macro232, {}];
    })
  ) : Object.fromEntries(
    macros15.map((macro232) => {
      if (typeof macro232 === "string") {
        throw new Error("Wrong branch of map function");
      }
      if (macro232.escapeToken != null) {
        return [
          macro232.content,
          { escapeToken: macro232.escapeToken }
        ];
      }
      return [macro232.content, {}];
    })
  ) : {} : macros15;
  return function matchAgainstMacros(node) {
    if (node == null || node.type !== "macro") {
      return false;
    }
    const spec = macrosHash[node.content];
    if (!spec) {
      return false;
    }
    if (typeof spec === "object" && "escapeToken" in spec) {
      return spec.escapeToken == null || spec.escapeToken === node.escapeToken;
    }
    return true;
  };
}
function createEnvironmentMatcher72(macros15) {
  const environmentsHash = Array.isArray(macros15) ? Object.fromEntries(
    macros15.map((str) => {
      return [str, {}];
    })
  ) : macros15;
  return function matchAgainstEnvironments(node) {
    if (!match72.anyEnvironment(node)) {
      return false;
    }
    const envName = printRaw72(node.env);
    const spec = environmentsHash[envName];
    if (!spec) {
      return false;
    }
    return true;
  };
}
var match72 = {
  macro(node, macroName) {
    if (node == null) {
      return false;
    }
    return node.type === "macro" && (macroName == null || node.content === macroName);
  },
  anyMacro(node) {
    return match72.macro(node);
  },
  environment(node, envName) {
    if (node == null) {
      return false;
    }
    return (node.type === "environment" || node.type === "mathenv") && (envName == null || printRaw72(node.env) === envName);
  },
  anyEnvironment(node) {
    return match72.environment(node);
  },
  comment(node) {
    if (node == null) {
      return false;
    }
    return node.type === "comment";
  },
  parbreak(node) {
    if (node == null) {
      return false;
    }
    return node.type === "parbreak";
  },
  whitespace(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace";
  },
  /**
   * Matches whitespace or a comment with leading whitespace.
   */
  whitespaceLike(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace" || node.type === "whitespace" && node.leadingWhitespace === true;
  },
  string(node, value) {
    if (node == null) {
      return false;
    }
    return node.type === "string" && (value == null || node.content === value);
  },
  anyString(node) {
    return match72.string(node);
  },
  group(node) {
    if (node == null) {
      return false;
    }
    return node.type === "group";
  },
  argument(node) {
    if (node == null) {
      return false;
    }
    return node.type === "argument";
  },
  blankArgument(node) {
    if (!match72.argument(node)) {
      return false;
    }
    return node.openMark === "" && node.closeMark === "" && node.content.length === 0;
  },
  math(node) {
    if (node == null) {
      return false;
    }
    return node.type === "displaymath" || node.type === "inlinemath";
  },
  createMacroMatcher: createMacroMatcher72,
  createEnvironmentMatcher: createEnvironmentMatcher72
};
var {
  anyEnvironment: anyEnvironment72,
  anyMacro: anyMacro72,
  anyString: anyString72,
  argument: argument72,
  blankArgument: blankArgument72,
  comment: comment72,
  environment: environment72,
  group: group72,
  macro: macro72,
  math: math72,
  parbreak: parbreak72,
  string: string72,
  whitespace: whitespace72
} = match72;
var CONTINUE32 = Symbol("continue");
var SKIP32 = Symbol("skip");
var EXIT32 = Symbol("exit");
var linebreak82 = Symbol("linebreak");
function processEnvironment(envNode, envInfo) {
  if (envInfo.signature && envNode.args == null) {
    const { args } = gobbleArguments3(envNode.content, envInfo.signature);
    envNode.args = args;
  }
  updateRenderInfo4(envNode, envInfo.renderInfo);
  if (typeof envInfo.processContent === "function") {
    envNode.content = envInfo.processContent(envNode.content);
  }
}

// libs/process-macros-and-environments.ts
var unifiedLatexProcessMacrosAndEnvironmentsWithMathReparse = function unifiedLatexProcessMacrosAndEnvironmentsWithMathReparse2(options) {
  const { environments: environments15 = {}, macros: macros15 = {} } = options || {};
  const mathMacros = Object.fromEntries(
    Object.entries(macros15).filter(
      ([_, info]) => {
        var _a;
        return ((_a = info.renderInfo) == null ? void 0 : _a.inMathMode) === true;
      }
    )
  );
  const mathEnvs = Object.fromEntries(
    Object.entries(environments15).filter(
      ([_, info]) => {
        var _a;
        return ((_a = info.renderInfo) == null ? void 0 : _a.inMathMode) === true;
      }
    )
  );
  const mathReparser = unifiedLatexReparseMathConstructPlugin({
    mathEnvs: Object.keys(mathEnvs),
    mathMacros: Object.keys(mathMacros)
  });
  const isRelevantEnvironment = match16.createEnvironmentMatcher(environments15);
  const isRelevantMathEnvironment = match16.createEnvironmentMatcher(mathEnvs);
  return (tree) => {
    visit2(
      tree,
      {
        enter: (nodes) => {
          if (!Array.isArray(nodes)) {
            return;
          }
          attachMacroArgsInArray2(nodes, mathMacros);
        },
        leave: (node) => {
          if (!isRelevantMathEnvironment(node)) {
            return;
          }
          const envName = printRaw17(node.env);
          const envInfo = environments15[envName];
          if (!envInfo) {
            throw new Error(
              `Could not find environment info for environment "${envName}"`
            );
          }
          processEnvironment(node, envInfo);
        }
      },
      { includeArrays: true }
    );
    mathReparser(tree);
    visit2(
      tree,
      {
        enter: (nodes) => {
          if (!Array.isArray(nodes)) {
            return;
          }
          attachMacroArgsInArray2(nodes, macros15);
        },
        leave: (node) => {
          if (!isRelevantEnvironment(node)) {
            return;
          }
          const envName = printRaw17(node.env);
          const envInfo = environments15[envName];
          if (!envInfo) {
            throw new Error(
              `Could not find environment info for environment "${envName}"`
            );
          }
          processEnvironment(node, envInfo);
        }
      },
      { includeArrays: true }
    );
  };
};

// ../unified-latex-util-catcode/dist/index.js
function findRegionInArray(tree, start, end) {
  const ret = [];
  let currRegion = { start: void 0, end: tree.length };
  for (let i = 0; i < tree.length; i++) {
    const node = tree[i];
    if (start(node)) {
      currRegion.start = i;
    }
    if (end(node)) {
      currRegion.end = i + 1;
      ret.push(currRegion);
      currRegion = { start: void 0, end: tree.length };
    }
  }
  if (currRegion.start != null) {
    ret.push(currRegion);
  }
  return ret;
}
var linebreak21 = Symbol("linebreak");
var ESCAPE20 = "\\";
function _printRaw20(node) {
  if (typeof node === "string") {
    return [node];
  }
  if (Array.isArray(node)) {
    return [].concat(
      ...node.map((n) => _printRaw20(n))
    );
  }
  let argsString, escape;
  switch (node.type) {
    case "root":
      return _printRaw20(node.content);
    case "argument":
      return [node.openMark, ..._printRaw20(node.content), node.closeMark];
    case "comment":
      var suffix = node.suffixParbreak ? "" : linebreak21;
      var leadingWhitespace = "";
      if (node.sameline && node.leadingWhitespace) {
        leadingWhitespace = " ";
      }
      if (node.sameline) {
        return [
          leadingWhitespace,
          "%",
          ..._printRaw20(node.content),
          suffix
        ];
      }
      return [linebreak21, "%", ..._printRaw20(node.content), suffix];
    case "environment":
    case "mathenv":
    case "verbatim":
      var env = _printRaw20(node.env);
      var envStart = [ESCAPE20 + "begin{", ...env, "}"];
      var envEnd = [ESCAPE20 + "end{", ...env, "}"];
      argsString = node.args == null ? [] : _printRaw20(node.args);
      return [
        ...envStart,
        ...argsString,
        ..._printRaw20(node.content),
        ...envEnd
      ];
    case "displaymath":
      return [ESCAPE20 + "[", ..._printRaw20(node.content), ESCAPE20 + "]"];
    case "group":
      return ["{", ..._printRaw20(node.content), "}"];
    case "inlinemath":
      return ["$", ..._printRaw20(node.content), "$"];
    case "macro":
      argsString = node.args == null ? [] : _printRaw20(node.args);
      escape = node.escapeToken == null ? ESCAPE20 : node.escapeToken;
      return [escape, ..._printRaw20(node.content), ...argsString];
    case "parbreak":
      return [linebreak21, linebreak21];
    case "string":
      return [node.content];
    case "verb":
      return [
        ESCAPE20,
        node.env,
        node.escape,
        ..._printRaw20(node.content),
        node.escape
      ];
    case "whitespace":
      return [" "];
    default:
      console.warn(
        "Cannot find render for node ",
        node,
        `(of type ${typeof node})`
      );
      return ["" + node];
  }
}
function printRaw20(node, options) {
  const asArray = options != null ? options.asArray : false;
  const printedTokens = _printRaw20(node);
  if (asArray) {
    return printedTokens;
  }
  return printedTokens.map((x) => x === linebreak21 ? "\n" : x).join("");
}
function createMacroMatcher19(macros15) {
  const macrosHash = Array.isArray(macros15) ? macros15.length > 0 ? typeof macros15[0] === "string" ? Object.fromEntries(
    macros15.map((macro223) => {
      if (typeof macro223 !== "string") {
        throw new Error("Wrong branch of map function");
      }
      return [macro223, {}];
    })
  ) : Object.fromEntries(
    macros15.map((macro223) => {
      if (typeof macro223 === "string") {
        throw new Error("Wrong branch of map function");
      }
      if (macro223.escapeToken != null) {
        return [
          macro223.content,
          { escapeToken: macro223.escapeToken }
        ];
      }
      return [macro223.content, {}];
    })
  ) : {} : macros15;
  return function matchAgainstMacros(node) {
    if (node == null || node.type !== "macro") {
      return false;
    }
    const spec = macrosHash[node.content];
    if (!spec) {
      return false;
    }
    if (typeof spec === "object" && "escapeToken" in spec) {
      return spec.escapeToken == null || spec.escapeToken === node.escapeToken;
    }
    return true;
  };
}
function createEnvironmentMatcher19(macros15) {
  const environmentsHash = Array.isArray(macros15) ? Object.fromEntries(
    macros15.map((str) => {
      return [str, {}];
    })
  ) : macros15;
  return function matchAgainstEnvironments(node) {
    if (!match19.anyEnvironment(node)) {
      return false;
    }
    const envName = printRaw20(node.env);
    const spec = environmentsHash[envName];
    if (!spec) {
      return false;
    }
    return true;
  };
}
var match19 = {
  macro(node, macroName) {
    if (node == null) {
      return false;
    }
    return node.type === "macro" && (macroName == null || node.content === macroName);
  },
  anyMacro(node) {
    return match19.macro(node);
  },
  environment(node, envName) {
    if (node == null) {
      return false;
    }
    return (node.type === "environment" || node.type === "mathenv") && (envName == null || printRaw20(node.env) === envName);
  },
  anyEnvironment(node) {
    return match19.environment(node);
  },
  comment(node) {
    if (node == null) {
      return false;
    }
    return node.type === "comment";
  },
  parbreak(node) {
    if (node == null) {
      return false;
    }
    return node.type === "parbreak";
  },
  whitespace(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace";
  },
  /**
   * Matches whitespace or a comment with leading whitespace.
   */
  whitespaceLike(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace" || node.type === "whitespace" && node.leadingWhitespace === true;
  },
  string(node, value) {
    if (node == null) {
      return false;
    }
    return node.type === "string" && (value == null || node.content === value);
  },
  anyString(node) {
    return match19.string(node);
  },
  group(node) {
    if (node == null) {
      return false;
    }
    return node.type === "group";
  },
  argument(node) {
    if (node == null) {
      return false;
    }
    return node.type === "argument";
  },
  blankArgument(node) {
    if (!match19.argument(node)) {
      return false;
    }
    return node.openMark === "" && node.closeMark === "" && node.content.length === 0;
  },
  math(node) {
    if (node == null) {
      return false;
    }
    return node.type === "displaymath" || node.type === "inlinemath";
  },
  createMacroMatcher: createMacroMatcher19,
  createEnvironmentMatcher: createEnvironmentMatcher19
};
var {
  anyEnvironment: anyEnvironment19,
  anyMacro: anyMacro19,
  anyString: anyString19,
  argument: argument19,
  blankArgument: blankArgument19,
  comment: comment19,
  environment: environment19,
  group: group19,
  macro: macro19,
  math: math19,
  parbreak: parbreak19,
  string: string19,
  whitespace: whitespace19
} = match19;
function refineRegions(regions) {
  const _regions = [...regions];
  _regions.sort((a, b) => a.start - b.start);
  const cutPointsSet = new Set(_regions.flatMap((r) => [r.start, r.end]));
  const cutPoints = Array.from(cutPointsSet);
  cutPoints.sort((a, b) => a - b);
  const retRegions = [];
  const retRegionsContainedIn = [];
  let seekIndex = 0;
  for (let i = 0; i < cutPoints.length - 1; i++) {
    const start = cutPoints[i];
    const end = cutPoints[i + 1];
    const region = { start, end };
    const regionContainedIn = /* @__PURE__ */ new Set();
    let encounteredEndPastStart = false;
    for (let j = seekIndex; j < _regions.length; j++) {
      const superRegion = _regions[j];
      if (superRegion.end >= region.start) {
        encounteredEndPastStart = true;
      }
      if (!encounteredEndPastStart && superRegion.end < region.start) {
        seekIndex = j + 1;
        continue;
      }
      if (superRegion.start > end) {
        break;
      }
      if (superRegion.start <= region.start && superRegion.end >= region.end) {
        encounteredEndPastStart = true;
        regionContainedIn.add(superRegion);
      }
    }
    if (regionContainedIn.size > 0) {
      retRegions.push(region);
      retRegionsContainedIn.push(regionContainedIn);
    }
  }
  return { regions: retRegions, regionsContainedIn: retRegionsContainedIn };
}
function splitByRegions(array, regionsRecord) {
  const ret = [];
  const indices = [0, array.length];
  const reverseMap = {};
  for (const [key, records] of Object.entries(regionsRecord)) {
    indices.push(
      ...records.flatMap((r) => {
        reverseMap["" + [r.start, r.end]] = key;
        return [r.start, r.end];
      })
    );
  }
  indices.sort((a, b) => a - b);
  for (let i = 0; i < indices.length - 1; i++) {
    const start = indices[i];
    const end = indices[i + 1];
    if (start === end) {
      continue;
    }
    const regionKey = reverseMap["" + [start, end]];
    ret.push([regionKey || null, array.slice(start, end)]);
  }
  return ret;
}
var linebreak210 = Symbol("linebreak");
var ESCAPE210 = "\\";
function _printRaw210(node) {
  if (typeof node === "string") {
    return [node];
  }
  if (Array.isArray(node)) {
    return [].concat(
      ...node.map((n) => _printRaw210(n))
    );
  }
  let argsString, escape;
  switch (node.type) {
    case "root":
      return _printRaw210(node.content);
    case "argument":
      return [node.openMark, ..._printRaw210(node.content), node.closeMark];
    case "comment":
      var suffix = node.suffixParbreak ? "" : linebreak210;
      var leadingWhitespace = "";
      if (node.sameline && node.leadingWhitespace) {
        leadingWhitespace = " ";
      }
      if (node.sameline) {
        return [
          leadingWhitespace,
          "%",
          ..._printRaw210(node.content),
          suffix
        ];
      }
      return [linebreak210, "%", ..._printRaw210(node.content), suffix];
    case "environment":
    case "mathenv":
    case "verbatim":
      var env = _printRaw210(node.env);
      var envStart = [ESCAPE210 + "begin{", ...env, "}"];
      var envEnd = [ESCAPE210 + "end{", ...env, "}"];
      argsString = node.args == null ? [] : _printRaw210(node.args);
      return [
        ...envStart,
        ...argsString,
        ..._printRaw210(node.content),
        ...envEnd
      ];
    case "displaymath":
      return [ESCAPE210 + "[", ..._printRaw210(node.content), ESCAPE210 + "]"];
    case "group":
      return ["{", ..._printRaw210(node.content), "}"];
    case "inlinemath":
      return ["$", ..._printRaw210(node.content), "$"];
    case "macro":
      argsString = node.args == null ? [] : _printRaw210(node.args);
      escape = node.escapeToken == null ? ESCAPE210 : node.escapeToken;
      return [escape, ..._printRaw210(node.content), ...argsString];
    case "parbreak":
      return [linebreak210, linebreak210];
    case "string":
      return [node.content];
    case "verb":
      return [
        ESCAPE210,
        node.env,
        node.escape,
        ..._printRaw210(node.content),
        node.escape
      ];
    case "whitespace":
      return [" "];
    default:
      console.warn(
        "Cannot find render for node ",
        node,
        `(of type ${typeof node})`
      );
      return ["" + node];
  }
}
function printRaw210(node, options) {
  const asArray = options != null ? options.asArray : false;
  const printedTokens = _printRaw210(node);
  if (asArray) {
    return printedTokens;
  }
  return printedTokens.map((x) => x === linebreak210 ? "\n" : x).join("");
}
function createMacroMatcher29(macros15) {
  const macrosHash = Array.isArray(macros15) ? macros15.length > 0 ? typeof macros15[0] === "string" ? Object.fromEntries(
    macros15.map((macro223) => {
      if (typeof macro223 !== "string") {
        throw new Error("Wrong branch of map function");
      }
      return [macro223, {}];
    })
  ) : Object.fromEntries(
    macros15.map((macro223) => {
      if (typeof macro223 === "string") {
        throw new Error("Wrong branch of map function");
      }
      if (macro223.escapeToken != null) {
        return [
          macro223.content,
          { escapeToken: macro223.escapeToken }
        ];
      }
      return [macro223.content, {}];
    })
  ) : {} : macros15;
  return function matchAgainstMacros(node) {
    if (node == null || node.type !== "macro") {
      return false;
    }
    const spec = macrosHash[node.content];
    if (!spec) {
      return false;
    }
    if (typeof spec === "object" && "escapeToken" in spec) {
      return spec.escapeToken == null || spec.escapeToken === node.escapeToken;
    }
    return true;
  };
}
function createEnvironmentMatcher29(macros15) {
  const environmentsHash = Array.isArray(macros15) ? Object.fromEntries(
    macros15.map((str) => {
      return [str, {}];
    })
  ) : macros15;
  return function matchAgainstEnvironments(node) {
    if (!match29.anyEnvironment(node)) {
      return false;
    }
    const envName = printRaw210(node.env);
    const spec = environmentsHash[envName];
    if (!spec) {
      return false;
    }
    return true;
  };
}
var match29 = {
  macro(node, macroName) {
    if (node == null) {
      return false;
    }
    return node.type === "macro" && (macroName == null || node.content === macroName);
  },
  anyMacro(node) {
    return match29.macro(node);
  },
  environment(node, envName) {
    if (node == null) {
      return false;
    }
    return (node.type === "environment" || node.type === "mathenv") && (envName == null || printRaw210(node.env) === envName);
  },
  anyEnvironment(node) {
    return match29.environment(node);
  },
  comment(node) {
    if (node == null) {
      return false;
    }
    return node.type === "comment";
  },
  parbreak(node) {
    if (node == null) {
      return false;
    }
    return node.type === "parbreak";
  },
  whitespace(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace";
  },
  /**
   * Matches whitespace or a comment with leading whitespace.
   */
  whitespaceLike(node) {
    if (node == null) {
      return false;
    }
    return node.type === "whitespace" || node.type === "whitespace" && node.leadingWhitespace === true;
  },
  string(node, value) {
    if (node == null) {
      return false;
    }
    return node.type === "string" && (value == null || node.content === value);
  },
  anyString(node) {
    return match29.string(node);
  },
  group(node) {
    if (node == null) {
      return false;
    }
    return node.type === "group";
  },
  argument(node) {
    if (node == null) {
      return false;
    }
    return node.type === "argument";
  },
  blankArgument(node) {
    if (!match29.argument(node)) {
      return false;
    }
    return node.openMark === "" && node.closeMark === "" && node.content.length === 0;
  },
  math(node) {
    if (node == null) {
      return false;
    }
    return node.type === "displaymath" || node.type === "inlinemath";
  },
  createMacroMatcher: createMacroMatcher29,
  createEnvironmentMatcher: createEnvironmentMatcher29
};
var {
  anyEnvironment: anyEnvironment29,
  anyMacro: anyMacro29,
  anyString: anyString29,
  argument: argument29,
  blankArgument: blankArgument29,
  comment: comment29,
  environment: environment29,
  group: group29,
  macro: macro29,
  math: math29,
  parbreak: parbreak29,
  string: string29,
  whitespace: whitespace29
} = match29;
function listMathChildren3(node) {
  const NULL_RETURN = { enter: [], leave: [] };
  if (Array.isArray(node)) {
    return NULL_RETURN;
  }
  if (match29.math(node)) {
    return { enter: ["content"], leave: [] };
  }
  const renderInfo = node._renderInfo || {};
  if (renderInfo.inMathMode == null) {
    return NULL_RETURN;
  }
  if (match29.macro(node)) {
    if (renderInfo.inMathMode === true) {
      return { enter: ["args"], leave: [] };
    } else if (renderInfo.inMathMode === false) {
      return { enter: [], leave: ["args"] };
    }
  }
  if (match29.environment(node)) {
    if (renderInfo.inMathMode === true) {
      return { enter: ["content"], leave: [] };
    } else {
      return { enter: [], leave: ["content"] };
    }
  }
  return NULL_RETURN;
}
var CONTINUE11 = Symbol("continue");
var SKIP11 = Symbol("skip");
var EXIT11 = Symbol("exit");
var DEFAULT_CONTEXT3 = {
  inMathMode: false,
  hasMathModeAncestor: false
};
function visit3(tree, visitor, options) {
  const {
    startingContext = DEFAULT_CONTEXT3,
    test = () => true,
    includeArrays = false
  } = options || {};
  let enter;
  let leave;
  if (typeof visitor === "function") {
    enter = visitor;
  } else if (visitor && typeof visitor === "object") {
    enter = visitor.enter;
    leave = visitor.leave;
  }
  walk(tree, {
    key: void 0,
    index: void 0,
    parents: [],
    containingArray: void 0,
    context: { ...startingContext }
  });
  function walk(node, { key, index: index2, parents, context, containingArray }) {
    const nodePassesTest = includeArrays ? test(node, { key, index: index2, parents, context, containingArray }) : !Array.isArray(node) && test(node, { key, index: index2, parents, context, containingArray });
    const result = enter && nodePassesTest ? toResult3(
      enter(node, {
        key,
        index: index2,
        parents,
        context,
        containingArray
      })
    ) : [CONTINUE11];
    if (result[0] === EXIT11) {
      return result;
    }
    if (result[0] === SKIP11) {
      return leave && nodePassesTest ? toResult3(
        leave(node, {
          key,
          index: index2,
          parents,
          context,
          containingArray
        })
      ) : result;
    }
    if (Array.isArray(node)) {
      for (let index22 = 0; index22 > -1 && index22 < node.length; index22++) {
        const item = node[index22];
        const result2 = walk(item, {
          key,
          index: index22,
          parents,
          context,
          containingArray: node
        });
        if (result2[0] === EXIT11) {
          return result2;
        }
        if (typeof result2[1] === "number") {
          index22 = result2[1] - 1;
        }
      }
    } else {
      let childProps = ["content", "args"];
      switch (node.type) {
        case "macro":
          childProps = ["args"];
          break;
        case "comment":
        case "string":
        case "verb":
        case "verbatim":
          childProps = [];
          break;
        default:
          break;
      }
      const mathModeProps = listMathChildren3(node);
      for (const key2 of childProps) {
        const value = node[key2];
        const grandparents = [node].concat(parents);
        if (value == null) {
          continue;
        }
        const newContext = { ...context };
        if (mathModeProps.enter.includes(key2)) {
          newContext.inMathMode = true;
          newContext.hasMathModeAncestor = true;
        } else if (mathModeProps.leave.includes(key2)) {
          newContext.inMathMode = false;
        }
        const result2 = walk(value, {
          key: key2,
          index: void 0,
          parents: grandparents,
          context: newContext,
          containingArray: void 0
        });
        if (result2[0] === EXIT11) {
          return result2;
        }
      }
    }
    return leave && nodePassesTest ? toResult3(
      leave(node, {
        key,
        index: index2,
        parents,
        context,
        containingArray
      })
    ) : result;
  }
}
function toResult3(value) {
  if (value == null) {
    return [CONTINUE11];
  }
  if (Array.isArray(value)) {
    return value;
  }
  if (typeof value === "number") {
    return [CONTINUE11, value];
  }
  return [value];
}
function escapeRegExp(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function buildWordRegex(allowedSet) {
  const regexpStr = `^(${["\\p{L}"].concat(Array.from(allowedSet).map(escapeRegExp)).join("|")})*`;
  return new RegExp(regexpStr, "u");
}
function hasReparsableMacroNamesInArray(tree, allowedTokens) {
  for (let i = 0; i < tree.length; i++) {
    const macro36 = tree[i];
    const string36 = tree[i + 1];
    if (match19.anyMacro(macro36) && match19.anyString(string36)) {
      if (allowedTokens.has(
        macro36.content.charAt(macro36.content.length - 1)
      ) || allowedTokens.has(string36.content.charAt(0))) {
        return true;
      }
    }
  }
  return false;
}
function hasReparsableMacroNames(tree, allowedTokens) {
  if (typeof allowedTokens === "string") {
    allowedTokens = new Set(allowedTokens.split(""));
  }
  const _allowedTokens = allowedTokens;
  for (const v of _allowedTokens) {
    if (v.length > 1) {
      throw new Error(
        `Only single characters are allowed as \`allowedTokens\` when reparsing macro names, not \`${v}\`.`
      );
    }
  }
  let ret = false;
  visit3(
    tree,
    (nodes) => {
      if (hasReparsableMacroNamesInArray(nodes, _allowedTokens)) {
        ret = true;
        return EXIT11;
      }
    },
    { includeArrays: true, test: Array.isArray }
  );
  return ret;
}
function reparseMacroNamesInArray(tree, allowedTokens) {
  var _a, _b, _c;
  const regex = buildWordRegex(allowedTokens);
  let i = 0;
  while (i < tree.length) {
    const macro36 = tree[i];
    const string36 = tree[i + 1];
    if (match19.anyMacro(macro36) && // The _^ macros in math mode should not be extended no-matter what;
    // So we check to make sure that the macro we're dealing with has the default escape token.
    (macro36.escapeToken == null || macro36.escapeToken === "\\") && match19.anyString(string36) && // There are two options. Either the macro ends with the special character,
    // e.g. `\@foo` or the special character starts the next string, e.g. `\foo@`.
    (allowedTokens.has(
      macro36.content.charAt(macro36.content.length - 1)
    ) || allowedTokens.has(string36.content.charAt(0)))) {
      const match36 = string36.content.match(regex);
      const takeable = match36 ? match36[0] : "";
      if (takeable.length > 0) {
        if (takeable.length === string36.content.length) {
          macro36.content += string36.content;
          tree.splice(i + 1, 1);
          if (macro36.position && ((_a = string36.position) == null ? void 0 : _a.end)) {
            macro36.position.end = string36.position.end;
          }
        } else {
          macro36.content += takeable;
          string36.content = string36.content.slice(takeable.length);
          if ((_b = macro36.position) == null ? void 0 : _b.end) {
            macro36.position.end.offset += takeable.length;
            macro36.position.end.column += takeable.length;
          }
          if ((_c = string36.position) == null ? void 0 : _c.start) {
            string36.position.start.offset += takeable.length;
            string36.position.start.column += takeable.length;
          }
        }
      } else {
        i++;
      }
    } else {
      ++i;
    }
  }
}
function reparseMacroNames(tree, allowedTokens) {
  if (typeof allowedTokens === "string") {
    allowedTokens = new Set(allowedTokens.split(""));
  }
  const _allowedTokens = allowedTokens;
  for (const v of _allowedTokens) {
    if (v.length > 1) {
      throw new Error(
        `Only single characters are allowed as \`allowedTokens\` when reparsing macro names, not \`${v}\`.`
      );
    }
  }
  visit3(
    tree,
    (nodes) => {
      reparseMacroNamesInArray(nodes, _allowedTokens);
    },
    { includeArrays: true, test: Array.isArray }
  );
}
var expl3Find = {
  start: match19.createMacroMatcher(["ExplSyntaxOn"]),
  end: match19.createMacroMatcher(["ExplSyntaxOff"])
};
var atLetterFind = {
  start: match19.createMacroMatcher(["makeatletter"]),
  end: match19.createMacroMatcher(["makeatother"])
};
function findExpl3AndAtLetterRegionsInArray(tree) {
  const expl3 = findRegionInArray(tree, expl3Find.start, expl3Find.end);
  const atLetter = findRegionInArray(
    tree,
    atLetterFind.start,
    atLetterFind.end
  );
  const regionMap = new Map([
    ...expl3.map((x) => [x, "expl"]),
    ...atLetter.map((x) => [x, "atLetter"])
  ]);
  const all = refineRegions([...expl3, ...atLetter]);
  const ret = {
    explOnly: [],
    atLetterOnly: [],
    both: []
  };
  for (let i = 0; i < all.regions.length; i++) {
    const region = all.regions[i];
    const containedIn = all.regionsContainedIn[i];
    if (containedIn.size === 2) {
      ret.both.push(region);
      continue;
    }
    for (const v of containedIn.values()) {
      if (regionMap.get(v) === "expl") {
        ret.explOnly.push(region);
      }
      if (regionMap.get(v) === "atLetter") {
        ret.atLetterOnly.push(region);
      }
    }
  }
  ret.explOnly = ret.explOnly.filter((r) => r.end - r.start > 1);
  ret.atLetterOnly = ret.atLetterOnly.filter((r) => r.end - r.start > 1);
  ret.both = ret.both.filter((r) => r.end - r.start > 1);
  return ret;
}
var atLetterSet = /* @__PURE__ */ new Set(["@"]);
var explSet = /* @__PURE__ */ new Set(["_", ":"]);
var bothSet = /* @__PURE__ */ new Set(["_", ":", "@"]);
function reparseExpl3AndAtLetterRegions(tree) {
  visit3(
    tree,
    {
      leave: (nodes) => {
        const regions = findExpl3AndAtLetterRegionsInArray(nodes);
        const totalNumRegions = regions.both.length + regions.atLetterOnly.length + regions.explOnly.length;
        if (totalNumRegions === 0) {
          return;
        }
        const splits = splitByRegions(nodes, regions);
        const processed = [];
        for (const [key, slice] of splits) {
          switch (key) {
            case null:
              processed.push(...slice);
              continue;
            case "atLetterOnly":
              reparseMacroNames(slice, atLetterSet);
              processed.push(...slice);
              continue;
            case "explOnly":
              reparseMacroNames(slice, explSet);
              processed.push(...slice);
              continue;
            case "both":
              reparseMacroNames(slice, bothSet);
              processed.push(...slice);
              continue;
            default:
              throw new Error(
                `Unexpected case when splitting ${key}`
              );
          }
        }
        nodes.length = 0;
        nodes.push(...processed);
        return SKIP11;
      }
    },
    { includeArrays: true, test: Array.isArray }
  );
}

// libs/process-at-letter-and-expl-macros.ts
var unifiedLatexProcessAtLetterAndExplMacros = function unifiedLatexProcessAtLetterAndExplMacros2(options) {
  let {
    atLetter = false,
    expl3 = false,
    autodetectExpl3AndAtLetter = false
  } = options || {};
  return (tree) => {
    reparseExpl3AndAtLetterRegions(tree);
    if (atLetter || expl3) {
      autodetectExpl3AndAtLetter = false;
    }
    if (autodetectExpl3AndAtLetter) {
      atLetter = hasReparsableMacroNames(tree, "@");
      expl3 = hasReparsableMacroNames(tree, "_");
    }
    const charSet = /* @__PURE__ */ new Set();
    if (atLetter) {
      charSet.add("@");
    }
    if (expl3) {
      charSet.add(":");
      charSet.add("_");
    }
    if (charSet.size > 0) {
      reparseMacroNames(tree, charSet);
    }
  };
};

// libs/plugin-from-string.ts
var unifiedLatexFromString = function unifiedLatexFromString2(options) {
  const {
    mode = "regular",
    macros: macros15 = {},
    environments: environments15 = {},
    flags: {
      atLetter = false,
      expl3 = false,
      autodetectExpl3AndAtLetter = false
    } = {}
  } = options || {};
  const allMacroInfo = Object.assign(
    {},
    ...Object.values(macroInfo),
    macros15
  );
  const allEnvInfo = Object.assign(
    {},
    ...Object.values(environmentInfo),
    environments15
  );
  const fullParser = unified().use(unifiedLatexFromStringMinimal, { mode }).use(unifiedLatexProcessAtLetterAndExplMacros, {
    atLetter,
    expl3,
    autodetectExpl3AndAtLetter
  }).use(unifiedLatexProcessMacrosAndEnvironmentsWithMathReparse, {
    macros: allMacroInfo,
    environments: allEnvInfo
  }).use(unifiedLatexTrimEnvironmentContents).use(unifiedLatexTrimRoot).use(unifiedLatexAstComplier);
  const parser2 = (str) => {
    const file = fullParser.processSync({ value: str });
    return file.result;
  };
  Object.assign(this, { Parser: parser2 });
};

// libs/parse.ts
var parser = unified().use(unifiedLatexFromString).freeze();
function parse5(str) {
  return parser.parse(str);
}
function getParser(options) {
  return unified().use(unifiedLatexFromString, options).freeze();
}

// libs/parse-math.ts
function parseMath(str) {
  if (typeof str !== "string") {
    str = printRaw17(str);
  }
  const file = unified().use(unifiedLatexFromString, { mode: "math" }).use(unifiedLatexAstComplier).processSync({ value: str });
  return file.result.content;
}
/*! Bundled license information:

is-buffer/index.js:
  (*!
   * Determine if an object is a Buffer
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)
*/
//# sourceMappingURL=index.cjs.map
